<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01-Django入门-web应用</title>
    <url>/posts/10425.html</url>
    <content><![CDATA[<p>web应用</p>
<a id="more"></a>



<h2 id="一-Web应用程序是什么"><a href="#一-Web应用程序是什么" class="headerlink" title="一 Web应用程序是什么"></a>一 Web应用程序是什么</h2><p>Web应用程序是一种可以通过Web访问的应用程序，程序的最大好处是用户很容易访问应用程序，用户只需要有浏览器即可，不需要再安装其他软件</p>
<p>应用程序有两种模式C/S、B/S。C/S是客户端/服务器端程序，也就是说这类程序一般独立运行。而B/S就是浏览器端/服务器端应用程序，这类应用程序一般借助IE等浏览器来运行。WEB应用程序一般是B/S模式。Web应用程序首先是“应用程序”，和用标准的程序语言，如C、C++等编写出来的程序没有什么本质上的不同。然而Web应用程序又有自己独特的地方，就是它是基于Web的，而不是采用传统方法运行的。换句话说，它是典型的浏览器/服务器架构的产物。</p>
<h3 id="1-1-Web应用程序的优点"><a href="#1-1-Web应用程序的优点" class="headerlink" title="1.1 Web应用程序的优点"></a>1.1 Web应用程序的优点</h3><ul>
<li>网络应用程序不需要任何复杂的“展开”过程，你所需要的只是一个适用的浏览器；</li>
<li>网络应用程序通常耗费很少的用户硬盘空间，或者一点都不耗费；</li>
<li>它们不需要更新，因为所有新的特性都在服务器上执行，从而自动传达到用户端；</li>
<li>网络应用程序和服务器端的网络产品都很容易结合，如email功能和搜索功能；</li>
<li>因为它们在网络浏览器窗口中运行，所以大多数情况下它们是通过跨平台使用的 (例如Windows，Mac，Linux等等)</li>
</ul>
<h3 id="1-2-Web应用程序的缺点"><a href="#1-2-Web应用程序的缺点" class="headerlink" title="1.2 Web应用程序的缺点"></a>1.2 Web应用程序的缺点</h3><ul>
<li>网络应用程序强调浏览器的适用性。如果浏览器方没有提供特定的功能，或者弃用特定的平台或操作系统版本（导致不适用），就会影响大量用户；</li>
<li>网络应用依靠互联网远程服务器端的应用文件。因此，当连接出问题时，应用将不能正常使用。</li>
<li>许多网络应用程序不是开源的，只能依赖第三方提供的服务，因此不能针对用户定制化、个性化，而且大多数情况下用户不能离线使用，因而损失了很多灵活性；</li>
<li>它们完全依赖应用服务商的可及性。如果公司倒闭，服务器停止使用，用户也无法追索以前的资料。对比而看，即使软件制造商倒闭了，传统的安装软件也可以继续运行，尽管不能再更新或有其他用户服务；</li>
<li>相似地，提供方公司对软件和其功能有了更大的控制权。只要他们愿意就能为软件添加新特性，即使用户想等bugs先被解决再更新。跳过较差的软件版本也不可能了。公司可以强加不受欢迎的特性给用户，也可以随意减少带宽来削减开支。</li>
<li>公司理论上可以检索任何的用户行为。这有可能引起隐私安全问题。</li>
</ul>
<h3 id="1-3-B-S架构优点"><a href="#1-3-B-S架构优点" class="headerlink" title="1.3 B/S架构优点"></a>1.3 B/S架构优点</h3><p>浏览器/服务器架构（Browser/Server,简称B/S）能够很好地应用在广域网上，成为越来越多的企业的选择。浏览器/服务器架构相对于其他几种应用程序体系结构，有如下3方面的优点：</p>
<ul>
<li>这种架构采用Internet上标准的通信协议（通常是TCP/IP协议）作为客户机同服务器通信的协议。这样可以使位于Internet任意位置的人都能够正常访问服务器。对于服务器来说，通过相应的Web服务和数据库服务可以对数据进行处理。对外采用标准的通信协议，以便共享数据。</li>
<li>在服务器上对数据进行处理，就处理的结果生成网页，以方便客户端直接下载。</li>
<li>在客户机上对数据的处理被进一步简化，将浏览器作为客户端的应用程序，以实现对数据的显示。不再需要为客户端单独编写和安装其他类型的应用程序。这样，在客户端只需要安装一套内置浏览器的操作系统，直接安装一套浏览器，就可以实现服务器上数据的访问。而浏览器是计算机的标准设备</li>
</ul>
<p><strong>总结一下，本质上：浏览器是一个socket客户端，服务器是一个socket服务端</strong></p>
<h2 id="二-基于SOCKET写一个web应用"><a href="#二-基于SOCKET写一个web应用" class="headerlink" title="二 基于SOCKET写一个web应用"></a>二 基于SOCKET写一个web应用</h2><h3 id="2-1-main-py"><a href="#2-1-main-py" class="headerlink" title="2.1 main.py"></a>2.1 main.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_run</span>():</span></span><br><span class="line">    soc = socket.socket()</span><br><span class="line">    soc.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8008</span>))</span><br><span class="line">    soc.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn, addr = soc.accept()</span><br><span class="line">        recv_data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">        print(recv_data)</span><br><span class="line">        <span class="comment"># 1 直接在send里写，发送给客户端</span></span><br><span class="line">        <span class="comment"># conn.send(b&#x27;HTTP/1.1 200 OK\r\n\r\n&lt;h1&gt;hello web&lt;/h1&gt;&lt;img src=&quot;https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=5e3814acf9edab64607f4592965fc4a6/14ce36d3d539b600c0c465d0eb50352ac65cb74b.jpg&quot;&gt;&lt;/img&gt;&#x27;)</span></span><br><span class="line">        <span class="comment">#2 打开一个html文件，发送给客户端</span></span><br><span class="line">        <span class="comment"># with open(&#x27;index.html&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;) as f:</span></span><br><span class="line">        <span class="comment">#     data=f.read()</span></span><br><span class="line">        <span class="comment"># conn.send((&#x27;HTTP/1.1 200 OK\r\n\r\n%s&#x27;%data).encode(&#x27;utf-8&#x27;))</span></span><br><span class="line">        <span class="comment"># 3 动态网页，字符串替换</span></span><br><span class="line">        <span class="keyword">import</span> time</span><br><span class="line">        now=time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime())</span><br><span class="line">        print(now)</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">&#x27;index.html&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            data=f.read()</span><br><span class="line">        data=data.replace(<span class="string">&#x27;@@@&#x27;</span>,now)</span><br><span class="line">        conn.send((<span class="string">&#x27;HTTP/1.1 200 OK\r\n\r\n%s&#x27;</span>%data).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    server_run()</span><br></pre></td></tr></table></figure>

<h3 id="2-2-index-html"><a href="#2-2-index-html" class="headerlink" title="2.2 index.html"></a>2.2 index.html</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>@@@<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=5e3814acf9edab64607f4592965fc4a6/14ce36d3d539b600c0c465d0eb50352ac65cb74b.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="三-手撸简单web框架"><a href="#三-手撸简单web框架" class="headerlink" title="三 手撸简单web框架"></a>三 手撸简单web框架</h2><h3 id="3-1-main-py"><a href="#3-1-main-py" class="headerlink" title="3.1 main.py"></a>3.1 main.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&lt;img src=&quot;https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=5e3814acf9edab64607f4592965fc4a6/14ce36d3d539b600c0c465d0eb50352ac65cb74b.jpg&quot;&gt;&lt;/img&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;login.html&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f :</span><br><span class="line">        data=f.read()</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">import</span> datetime</span><br><span class="line">    now=datetime.datetime.now().strftime(<span class="string">&#x27;%Y-%m-%d %X&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;time.html&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f :</span><br><span class="line">        data=f.read()</span><br><span class="line">    data=data.replace(<span class="string">&#x27;@@time@@&#x27;</span>,now)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_list</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 创建连接</span></span><br><span class="line">    conn = pymysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, passwd=<span class="string">&#x27;123456&#x27;</span>, db=<span class="string">&#x27;lqz&#x27;</span>)</span><br><span class="line">    cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)</span><br><span class="line">    cursor.execute(<span class="string">&quot;select id,name,password from user&quot;</span>)</span><br><span class="line">    user_list = cursor.fetchall()</span><br><span class="line">    cursor.close()</span><br><span class="line">    conn.close()</span><br><span class="line">    tr_list=[]</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> user_list:</span><br><span class="line">        tr=<span class="string">&#x27;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&#x27;</span>%(row[<span class="string">&#x27;id&#x27;</span>],row[<span class="string">&#x27;name&#x27;</span>],row[<span class="string">&#x27;password&#x27;</span>])</span><br><span class="line">        tr_list.append(tr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;user_list.html&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data=f.read()</span><br><span class="line">    data=data.replace(<span class="string">&#x27;@@body@@&#x27;</span>,<span class="string">&#x27;&#x27;</span>.join(tr_list))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_list_new</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 创建连接</span></span><br><span class="line">    conn = pymysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, passwd=<span class="string">&#x27;123456&#x27;</span>, db=<span class="string">&#x27;lqz&#x27;</span>)</span><br><span class="line">    cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)</span><br><span class="line">    cursor.execute(<span class="string">&quot;select id,name,password from user&quot;</span>)</span><br><span class="line">    user_list = cursor.fetchall()</span><br><span class="line">    cursor.close()</span><br><span class="line">    conn.close()</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;user_list_new.html&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data=f.read()</span><br><span class="line">    <span class="keyword">from</span> jinja2 <span class="keyword">import</span> Template</span><br><span class="line">    template=Template(data)</span><br><span class="line">    response=template.render(user_list=user_list)</span><br><span class="line">    <span class="comment"># response=template.render(&#123;&#x27;user_list&#x27;:user_list&#125;)</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">urls = [</span><br><span class="line">    (<span class="string">&#x27;/index&#x27;</span>, index),</span><br><span class="line">    (<span class="string">&#x27;/login&#x27;</span>, login),</span><br><span class="line">    (<span class="string">&#x27;/time&#x27;</span>, time),</span><br><span class="line">    (<span class="string">&#x27;/user_list&#x27;</span>, user_list),</span><br><span class="line">    (<span class="string">&#x27;/user_list_new&#x27;</span>, user_list_new),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    soc = socket.socket()</span><br><span class="line">    soc.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8006</span>))</span><br><span class="line">    soc.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn, port = soc.accept()</span><br><span class="line">        data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="comment"># data=data.decode(&#x27;utf-8&#x27;)</span></span><br><span class="line">        print(data)</span><br><span class="line">        data = str(data, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        request_list = data.split(<span class="string">&#x27;\r\n\r\n&#x27;</span>)</span><br><span class="line">        head_list = request_list[<span class="number">0</span>].split(<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">        method, url, htt = head_list[<span class="number">0</span>].split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="comment"># conn.send(b&#x27;hello web&#x27;)</span></span><br><span class="line">        conn.send(<span class="string">b&#x27;HTTP/1.1 200 OK \r\n\r\n&#x27;</span>)</span><br><span class="line">        print(url)</span><br><span class="line">        func_name = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> urls:</span><br><span class="line">            <span class="keyword">if</span> url == u[<span class="number">0</span>]:</span><br><span class="line">                func_name = u[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> func_name:</span><br><span class="line">            response = func_name(data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            response = <span class="string">&#x27;404 not found&#x27;</span></span><br><span class="line"></span><br><span class="line">        conn.send(response.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>

<h3 id="3-2-login-html"><a href="#3-2-login-html" class="headerlink" title="3.2 login.html"></a>3.2 login.html</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-time-html"><a href="#3-3-time-html" class="headerlink" title="3.3 time.html"></a>3.3 time.html</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@@time@@</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-user-list-html"><a href="#3-4-user-list-html" class="headerlink" title="3.4 user_list.html"></a>3.4 user_list.html</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        @@body@@</span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5-user-list-new"><a href="#3-5-user-list-new" class="headerlink" title="3.5 user_list_new"></a>3.5 user_list_new</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>name<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>password<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    &#123;% for user in user_list%&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;user.id&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;user.name&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;user.password&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    &#123;%endfor%&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>02-Django入门-HTTP协议</title>
    <url>/posts/39766.html</url>
    <content><![CDATA[<p>HTTP 协议</p>
<a id="more"></a>



<h2 id="0-动态网页-静态网页-伪静态"><a href="#0-动态网页-静态网页-伪静态" class="headerlink" title="0. 动态网页 静态网页 伪静态"></a>0. 动态网页 静态网页 伪静态</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">静态网页</span><br><span class="line">    页面上的数据是直接写死的 永远不变</span><br><span class="line">动态网页</span><br><span class="line">    数据是实时获取的</span><br><span class="line">  eg:</span><br><span class="line">    <span class="number">1.</span>后端获取当前时间展示到html页面上</span><br><span class="line">    <span class="number">2.</span>数据是从数据数据库中获取的展示到html页面上</span><br><span class="line"></span><br><span class="line">伪静态网页</span><br><span class="line">    伪装的目的在于增大网站的seo查询力度</span><br><span class="line">  并且增加搜索引擎的收藏概率</span><br><span class="line">  (搜索引擎本质上就是一个巨大的爬虫程序)</span><br><span class="line">总结:</span><br><span class="line">  无论你怎么优化，处理，不如RMB玩家</span><br><span class="line">urlpartterns = [</span><br><span class="line">  re_path(<span class="string">r&#x27;^reg.html&#x27;</span>,views.reg,name=<span class="string">&#x27;app02.reg&#x27;</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="0-JinJa2-模块"><a href="#0-JinJa2-模块" class="headerlink" title="0. JinJa2 模块"></a>0. JinJa2 模块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install jinja2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模板语法</span></span><br><span class="line">&#123;&#123; user &#125;&#125;</span><br><span class="line">&#123;&#123; user.get(<span class="string">&#x27;username&#x27;</span>) &#125;&#125;</span><br><span class="line">&#123;&#123; user.age &#125;&#125;</span><br><span class="line">&#123;&#123; user[<span class="string">&#x27;hobby&#x27;</span>] &#125;&#125;</span><br></pre></td></tr></table></figure>





<h2 id="一-http协议简介"><a href="#一-http协议简介" class="headerlink" title="一 http协议简介"></a>一 http协议简介</h2><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于万维网（WWW:World Wide Web ）服务器与本地浏览器之间传输超文本的传送协议。</p>
<p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gj1v3zrxr6j30t008gn1y.jpg" alt="image-20200924172049937"></p>
<h2 id="二-http协议特性"><a href="#二-http协议特性" class="headerlink" title="二 http协议特性"></a>二 http协议特性</h2><h3 id="2-1-基于TCP-IP协议之上的应用层协议"><a href="#2-1-基于TCP-IP协议之上的应用层协议" class="headerlink" title="2.1 基于TCP/IP协议之上的应用层协议"></a>2.1 基于TCP/IP协议之上的应用层协议</h3><h3 id="2-2-基于请求－响应模式"><a href="#2-2-基于请求－响应模式" class="headerlink" title="2.2 基于请求－响应模式"></a>2.2 基于请求－响应模式</h3><p>HTTP协议规定,请求从客户端发出,最后服务器端响应该请求并 返回。换句话说,肯定是先从客户端开始建立通信的,服务器端在没有 接收到请求之前不会发送响应</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gj1v4exupzj30t00a6af1.jpg" alt="image-20200924172118199"></p>
<h3 id="2-3-无状态保存"><a href="#2-3-无状态保存" class="headerlink" title="2.3 无状态保存"></a>2.3 无状态保存</h3><p>HTTP是一种不保存状态,即无状态(stateless)协议。HTTP协议 自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个 级别,协议对于发送过的请求或响应都不做持久化处理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gj1v4yobhaj30s00e4q9r.jpg" alt="image-20200924172149501"></p>
<p>使用HTTP协议,每当有新的请求发送时,就会有对应的新响应产 生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务,确保协议的可伸缩性,而特意把HTTP协议设计成 如此简单的。可是,随着Web的不断发展,因无状态而导致业务处理变得棘手 的情况增多了。比如,用户登录到一家购物网站,即使他跳转到该站的 其他页面后,也需要能继续保持登录状态。针对这个实例,网站为了能 够掌握是谁送出的请求,需要保存用户的状态。HTTP/1.1虽然是无状态协议,但为了实现期望的保持状态功能, 于是引入了Cookie技术。有了Cookie再用HTTP协议通信,就可以管 理状态了。有关Cookie的详细内容稍后讲解</p>
<h3 id="2-4-无连接"><a href="#2-4-无连接" class="headerlink" title="2.4 无连接"></a>2.4 无连接</h3><p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
<h2 id="三-http请求协议与响应协议"><a href="#三-http请求协议与响应协议" class="headerlink" title="三 http请求协议与响应协议"></a>三 http请求协议与响应协议</h2><p>http协议包含由浏览器发送数据到服务器需要遵循的请求协议与服务器发送数据到浏览器需要遵循的请求协议。用于HTTP协议交互的信被为HTTP报文。请求端(客户端)的HTTP报文 做请求报文,响应端(服务器端)的 做响应报文。HTTP报文本身是由多行数据构成的字 文本。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gj1v5jenz5j30tq0eq7aa.jpg" alt="image-20200924172222493"></p>
<h3 id="3-1-请求协议"><a href="#3-1-请求协议" class="headerlink" title="3.1 请求协议"></a>3.1 请求协议</h3><h4 id="请求格式"><a href="#请求格式" class="headerlink" title="请求格式"></a>请求格式</h4><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gj1v6d9oftj30vi0d2gpn.jpg" alt="image-20200924172250257"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gj1v6jblf2j30tw0caacp.jpg" alt="image-20200924172316497"></p>
<h4 id="请求方式-get与post请求"><a href="#请求方式-get与post请求" class="headerlink" title="请求方式: get与post请求"></a>请求方式: get与post请求</h4><ul>
<li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditBook?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的请求体中.</li>
<li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</li>
<li>GET与POST请求在服务端获取请求数据方式不同。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;&#39;&#39;</span><br><span class="line">    GET请求</span><br><span class="line">    # 请求首行</span><br><span class="line">    GET &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">    # get请求后面的参数</span><br><span class="line">    GET &#x2F;?name&#x3D;lqz&amp;age&#x3D;18 HTTP&#x2F;1.1\r\n</span><br><span class="line">    # 请求头</span><br><span class="line">    Host: 127.0.0.1:8008\r\n</span><br><span class="line">    Connection: keep-alive\r\n</span><br><span class="line">    Cache-Control: max-age&#x3D;0\r\n</span><br><span class="line">    Upgrade-Insecure-Requests: 1\r\n</span><br><span class="line">    User-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;65.0.3325.181 Safari&#x2F;537.36\r\n</span><br><span class="line">    Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8\r\nAccept-Encoding: gzip, deflate, br\r\n</span><br><span class="line">    Accept-Language: zh-CN,zh;q&#x3D;0.9\r\n</span><br><span class="line">    Cookie: csrftoken&#x3D;7xx6BxQDJ6KB0PM7qS8uTA892ACtooNbnnF4LDwlYk1Y7S7nTS81FBqwruizHsxF\r\n\r\n&#39;</span><br><span class="line">    # 请求体（get请求，请求体为空）    </span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    POST请求</span><br><span class="line">    # 请求首行</span><br><span class="line">    POST &#x2F;?name&#x3D;lqz&amp;age&#x3D;18 HTTP&#x2F;1.1\r\n</span><br><span class="line">    # 请求头</span><br><span class="line">    Host: 127.0.0.1:8008\r\nConnection: keep-alive\r\nContent-Length: 21\r\nCache-Control: max-age&#x3D;0\r\nOrigin: http:&#x2F;&#x2F;127.0.0.1:8008\r\nUpgrade-Insecure-Requests: 1\r\nContent-Type: application&#x2F;x-www-form-urlencoded\r\nUser-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;65.0.3325.181 Safari&#x2F;537.36\r\nAccept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8\r\nReferer: http:&#x2F;&#x2F;127.0.0.1:8008&#x2F;?name&#x3D;lqz&amp;age&#x3D;18\r\nAccept-Encoding: gzip, deflate, br\r\nAccept-Language: zh-CN,zh;q&#x3D;0.9\r\nCookie: csrftoken&#x3D;7xx6BxQDJ6KB0PM7qS8uTA892ACtooNbnnF4LDwlYk1Y7S7nTS81FBqwruizHsxF\r\n\r\n</span><br><span class="line">    # 请求体</span><br><span class="line">    name&#x3D;lqz&amp;password&#x3D;123&#39;</span><br><span class="line">    </span><br><span class="line">    &#39;&#39;&#39;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-响应协议"><a href="#3-2-响应协议" class="headerlink" title="3.2 响应协议"></a>3.2 响应协议</h3><h3 id="响应格式"><a href="#响应格式" class="headerlink" title="响应格式"></a>响应格式</h3><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gj1v7q07r9j30xi0cyaei.jpg" alt="image-20200924172428894"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gj1v87pnwrj30ro0bcwho.jpg" alt="image-20200924172443165"></p>
<h3 id="3-3-响应状态码"><a href="#3-3-响应状态码" class="headerlink" title="3.3 响应状态码"></a>3.3 响应状态码</h3><p>状态码的职 是当客户端向服务器端发送请求时, 返回的请求 结果。借助状态码,用户可以知道服务器端是正常 理了请求,还是出 现了 。状态码如200 OK,以3位数字和原因 成。数字中的 一位指定了响应 别,后两位无分 。响应 别有以5种。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gj1v8s70a5j314m0e8tix.jpg" alt="image-20200924172516228"></p>
<h2 id="四-URL简介"><a href="#四-URL简介" class="headerlink" title="四 URL简介"></a>四 URL简介</h2><p>统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它</p>
<p>格式：</p>
<blockquote>
<p>协议：//IP:端口(80)/路径?name=lqz&amp;age=18</p>
<p>？之前的是请求路径，？之后的是请求数据部分</p>
</blockquote>
<p>演示示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">sock=socket.socket()</span><br><span class="line">sock.bind((&quot;127.0.0.1&quot;,8808))</span><br><span class="line">sock.listen(5)</span><br><span class="line"></span><br><span class="line">while 1:</span><br><span class="line">    print(&quot;server waiting.....&quot;)</span><br><span class="line">    conn,addr=sock.accept()</span><br><span class="line">    data=conn.recv(1024)</span><br><span class="line">    print(&quot;data&quot;, data)</span><br><span class="line"></span><br><span class="line">    # 读取html文件</span><br><span class="line">    with open(&quot;login.html&quot;,&quot;rb&quot;) as f:</span><br><span class="line">        data=f.read()</span><br><span class="line"></span><br><span class="line">    conn.send((b&quot;HTTP/1.1 200 OK\r\nContent-type:text/html\r\n\r\n%s&quot;%data))</span><br><span class="line">    conn.close()</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    密码 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>03-Django入门-web框架</title>
    <url>/posts/25526.html</url>
    <content><![CDATA[<p>Web 框架初识</p>
<a id="more"></a>

<h2 id="一-web框架"><a href="#一-web框架" class="headerlink" title="一 web框架"></a>一 web框架</h2><p>Web框架（Web framework）是一种开发框架，用来支持动态网站、网络应用和网络服务的开发。这大多数的web框架提供了一套开发和部署网站的方式，也为web行为提供了一套通用的方法。web框架已经实现了很多功能，开发人员使用框架提供的方法并且完成自己的业务逻辑，就能快速开发web应用了。浏览器和服务器的是基于HTTP协议进行通信的。也可以说web框架就是在以上十几行代码基础张扩展出来的，有很多简单方便使用的方法，大大提高了开发的效率。</p>
<h3 id="1-1-wsgiref模块"><a href="#1-1-wsgiref模块" class="headerlink" title="1.1 wsgiref模块"></a>1.1 wsgiref模块</h3><p>最简单的Web应用就是先把HTML用文件保存好，用一个现成的HTTP服务器软件，接收用户请求，从文件中读取HTML，返回。</p>
<p>如果要动态生成HTML，就需要把上述步骤自己来实现。不过，接受HTTP请求、解析HTTP请求、发送HTTP响应都是苦力活，如果我们自己来写这些底层代码，还没开始写动态HTML呢，就得花个把月去读HTTP规范。</p>
<p>正确的做法是底层代码由专门的服务器软件实现，我们用Python专注于生成HTML文档。因为我们不希望接触到TCP连接、HTTP原始请求和响应格式，所以，需要一个统一的接口协议来实现这样的服务器软件，让我们专心用Python编写Web业务。这个接口就是WSGI：Web Server Gateway Interface。而wsgiref模块就是python基于wsgi协议开发的服务模块。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mya</span>(<span class="params">environ, start_response</span>):</span></span><br><span class="line">    print(environ)</span><br><span class="line">    start_response(<span class="string">&#x27;200 OK&#x27;</span>, [(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html&#x27;</span>)])</span><br><span class="line">    <span class="keyword">if</span> environ.get(<span class="string">&#x27;PATH_INFO&#x27;</span>) == <span class="string">&#x27;/index&#x27;</span>:</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">&#x27;index.html&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            data=f.read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> environ.get(<span class="string">&#x27;PATH_INFO&#x27;</span>) == <span class="string">&#x27;/login&#x27;</span>:</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">&#x27;login.html&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            data = f.read()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data=<span class="string">b&#x27;&lt;h1&gt;Hello, web!&lt;/h1&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> [data]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    myserver = make_server(<span class="string">&#x27;&#x27;</span>, <span class="number">8011</span>, mya)</span><br><span class="line">    print(<span class="string">&#x27;监听8010&#x27;</span>)</span><br><span class="line">    myserver.serve_forever()</span><br></pre></td></tr></table></figure>

<h2 id="二-手撸自己的Web框架"><a href="#二-手撸自己的Web框架" class="headerlink" title="二 手撸自己的Web框架"></a>二 手撸自己的Web框架</h2><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gj1vegl3a2j308q088q2w.jpg" alt="img"></p>
<h3 id="2-1-models-py"><a href="#2-1-models-py" class="headerlink" title="2.1 models.py"></a>2.1 models.py</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;&#39;&#39;</span><br><span class="line">链接数据库返回字典格式：</span><br><span class="line">cursor&#x3D;pymysql.cursors.DictCursor</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">import pymysql</span><br><span class="line">#连接数据库</span><br><span class="line">conn &#x3D; pymysql.connect(host&#x3D;&#39;127.0.0.1&#39;,port&#x3D; 3306,user &#x3D; &#39;root&#39;,passwd&#x3D;&#39;123456&#39;,db&#x3D;&#39;web&#39;) #db：库名</span><br><span class="line">#创建游标</span><br><span class="line">cur &#x3D; conn.cursor()</span><br><span class="line"></span><br><span class="line">sql&#x3D;&#39;&#39;&#39;</span><br><span class="line">create table userinfo(</span><br><span class="line">        id INT PRIMARY KEY ,</span><br><span class="line">        name VARCHAR(32) ,</span><br><span class="line">        password VARCHAR(32)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">cur.execute(sql)</span><br><span class="line"></span><br><span class="line">#提交</span><br><span class="line">conn.commit()</span><br><span class="line">#关闭指针对象</span><br><span class="line">cur.close()</span><br><span class="line">#关闭连接对象</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<h3 id="2-2-myserver-py"><a href="#2-2-myserver-py" class="headerlink" title="2.2 myserver.py"></a>2.2 myserver.py</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from wsgiref.simple_server import make_server</span><br><span class="line"></span><br><span class="line">from urls import url_patters</span><br><span class="line"></span><br><span class="line">def mya(environ, start_response):</span><br><span class="line">    # print(environ)</span><br><span class="line">    start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text&#x2F;html&#39;)])</span><br><span class="line">    func &#x3D; None</span><br><span class="line">    for item in url_patters:</span><br><span class="line">        if item[0] &#x3D;&#x3D; environ.get(&#39;PATH_INFO&#39;):</span><br><span class="line">            func &#x3D; item[1]</span><br><span class="line">            break</span><br><span class="line">    if func:</span><br><span class="line">        data &#x3D; func(environ)</span><br><span class="line">        return [data]</span><br><span class="line">    else:</span><br><span class="line">        return [b&#39;404&#39;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    myserver &#x3D; make_server(&#39;&#39;, 8011, mya)</span><br><span class="line">    print(&#39;监听8010&#39;)</span><br><span class="line">    myserver.serve_forever()</span><br></pre></td></tr></table></figure>

<h3 id="2-3-urls-py"><a href="#2-3-urls-py" class="headerlink" title="2.3 urls.py"></a>2.3 urls.py</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from views import *</span><br><span class="line">url_patters &#x3D; [</span><br><span class="line">    (&#39;&#x2F;login&#39;, login),</span><br><span class="line">    (&#39;&#x2F;index&#39;, index),</span><br><span class="line">    (&#39;&#x2F;time&#39;, time),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="2-4-views-py"><a href="#2-4-views-py" class="headerlink" title="2.4 views.py"></a>2.4 views.py</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def index(environ):</span><br><span class="line">    with open(&#39;templates&#x2F;index.html&#39;, &#39;rb&#39;) as f:</span><br><span class="line">        data &#x3D; f.read()</span><br><span class="line">    return data</span><br><span class="line">def time(environ):</span><br><span class="line">    import datetime</span><br><span class="line">    now&#x3D;datetime.datetime.now().strftime(&#39;%y-%m-%d %X&#39;)</span><br><span class="line">    print(now)</span><br><span class="line">    return now.encode(&#39;utf-8&#39;)</span><br><span class="line">from urllib.parse import parse_qs</span><br><span class="line">import pymysql</span><br><span class="line">def login(request):</span><br><span class="line">    if request.get(&quot;REQUEST_METHOD&quot;) &#x3D;&#x3D; &quot;POST&quot;:</span><br><span class="line">        try:</span><br><span class="line">            request_body_size &#x3D; int(request.get(&#39;CONTENT_LENGTH&#39;, 0))</span><br><span class="line">        except (ValueError):</span><br><span class="line">            request_body_size &#x3D; 0</span><br><span class="line"></span><br><span class="line">        request_body &#x3D; request[&#39;wsgi.input&#39;].read(request_body_size)</span><br><span class="line">        data &#x3D; parse_qs(request_body)</span><br><span class="line"></span><br><span class="line">        user &#x3D; data.get(b&quot;user&quot;)[0].decode(&quot;utf8&quot;)</span><br><span class="line">        pwd &#x3D; data.get(b&quot;pwd&quot;)[0].decode(&quot;utf8&quot;)</span><br><span class="line"></span><br><span class="line">        # 连接数据库</span><br><span class="line">        conn &#x3D; pymysql.connect(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;3306, user&#x3D;&#39;root&#39;, passwd&#x3D;&#39;123456&#39;, db&#x3D;&#39;web&#39;)  # db：库名</span><br><span class="line">        # 创建游标</span><br><span class="line">        cur &#x3D; conn.cursor()</span><br><span class="line">        SQL &#x3D; &quot;select * from userinfo WHERE NAME &#x3D;&#39;%s&#39; AND PASSWORD &#x3D;&#39;%s&#39;&quot; % (user, pwd)</span><br><span class="line">        cur.execute(SQL)</span><br><span class="line"></span><br><span class="line">        if cur.fetchone():</span><br><span class="line"></span><br><span class="line">            f &#x3D; open(&quot;templates&#x2F;backend.html&quot;, &quot;rb&quot;)</span><br><span class="line">            data &#x3D; f.read()</span><br><span class="line">            data &#x3D; data.decode(&quot;utf8&quot;)</span><br><span class="line">            return data.encode(&quot;utf8&quot;)</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line">            print(&quot;OK456&quot;)</span><br><span class="line">            return b&quot;user or pwd is wrong&quot;</span><br><span class="line"></span><br><span class="line">    else:</span><br><span class="line">        f &#x3D; open(&quot;templates&#x2F;login.html&quot;, &quot;rb&quot;)</span><br><span class="line">        data &#x3D; f.read()</span><br><span class="line">        f.close()</span><br><span class="line">        return data</span><br></pre></td></tr></table></figure>

<h3 id="2-5-tempaltes下backend-html"><a href="#2-5-tempaltes下backend-html" class="headerlink" title="2.5 tempaltes下backend.html"></a>2.5 tempaltes下backend.html</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">登录成功</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-tempaltes下index-html"><a href="#2-5-tempaltes下index-html" class="headerlink" title="2.5 tempaltes下index.html"></a>2.5 tempaltes下index.html</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">index</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-tempaltes下login-html"><a href="#2-5-tempaltes下login-html" class="headerlink" title="2.5 tempaltes下login.html"></a>2.5 tempaltes下login.html</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h4&gt;登录页面&lt;&#x2F;h4&gt;</span><br><span class="line">&lt;form action&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:8011&#x2F;login&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">     用户名 &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;user&quot;&gt;</span><br><span class="line">     密码 &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;pwd&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="三-其它socket服务端"><a href="#三-其它socket服务端" class="headerlink" title="三 其它socket服务端"></a>三 其它socket服务端</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;cgi&#39;: CGIServer,</span><br><span class="line">&#39;flup&#39;: FlupFCGIServer,</span><br><span class="line">&#39;wsgiref&#39;: WSGIRefServer,</span><br><span class="line">&#39;waitress&#39;: WaitressServer,</span><br><span class="line">&#39;cherrypy&#39;: CherryPyServer,</span><br><span class="line">&#39;paste&#39;: PasteServer,</span><br><span class="line">&#39;fapws3&#39;: FapwsServer,</span><br><span class="line">&#39;tornado&#39;: TornadoServer,</span><br><span class="line">&#39;gae&#39;: AppEngineServer,</span><br><span class="line">&#39;twisted&#39;: TwistedServer,</span><br><span class="line">&#39;diesel&#39;: DieselServer,</span><br><span class="line">&#39;meinheld&#39;: MeinheldServer,</span><br><span class="line">&#39;gunicorn&#39;: GunicornServer,</span><br><span class="line">&#39;eventlet&#39;: EventletServer,</span><br><span class="line">&#39;gevent&#39;: GeventServer,</span><br><span class="line">&#39;geventSocketIO&#39;:GeventSocketIOServer,</span><br><span class="line">&#39;rocket&#39;: RocketServer,</span><br><span class="line">&#39;bjoern&#39; : BjoernServer,</span><br><span class="line">&#39;auto&#39;: AutoServer,</span><br></pre></td></tr></table></figure>

<p>都遵循一个协议wsgi（Web Server Gateway Interface web服务网关接口）</p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>04-Django入门-简介</title>
    <url>/posts/33743.html</url>
    <content><![CDATA[<p>Django 简介</p>
<a id="more"></a>

<h2 id="一-MVC与MTV模型"><a href="#一-MVC与MTV模型" class="headerlink" title="一 MVC与MTV模型"></a>一 MVC与MTV模型</h2><h3 id="1-1-MVC"><a href="#1-1-MVC" class="headerlink" title="1.1 MVC"></a>1.1 MVC</h3><p>Web服务器开发领域里著名的MVC模式，所谓MVC就是把Web应用分为模型(M)，控制器(C)和视图(V)三层，他们之间以一种插件式的、松耦合的方式连接在一起，模型负责业务对象与数据库的映射(ORM)，视图负责与用户的交互(页面)，控制器接受用户的输入调用模型和视图完成用户的请求，其示意图如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gj1vz7cqdej30rm0i078f.jpg" alt="image-20200924175052910"></p>
<h3 id="1-2-MTV"><a href="#1-2-MTV" class="headerlink" title="1.2 MTV"></a>1.2 MTV</h3><p>Django的MTV模式本质上和MVC是一样的，也是为了各组件间保持松耦合关系，只是定义上有些许不同，Django的MTV分别是值：</p>
<ul>
<li>M 代表模型（Model）： 负责业务对象和数据库的关系映射(ORM)。</li>
<li>T 代表模板 (Template)：负责如何把页面展示给用户(html)。</li>
<li>V 代表视图（View）： 负责业务逻辑，并在适当时候调用Model和Template。</li>
</ul>
<p>除了以上三层之外，还需要一个URL分发器，它的作用是将一个个URL的页面请求分发给不同的View处理，View再调用相应的Model和Template，MTV的响应模式如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gj1w0gl8cmj314c0gegrv.jpg" alt="image-20200924175204537"></p>
<p>一般是用户通过浏览器向我们的服务器发起一个请求(request)，这个请求回去访问视图函数，（如果不涉及到数据调用，那么这个时候视图函数返回一个模板也就是一个网页给用户），视图函数调用模型，模型去数据库查找数据，然后逐级返回，视图函数把返回的数据填充到模板中空格中，最后返回网页给用户。</p>
<h2 id="二-Django的下载与基本命令"><a href="#二-Django的下载与基本命令" class="headerlink" title="二 Django的下载与基本命令"></a>二 Django的下载与基本命令</h2><h3 id="2-1-下载Django"><a href="#2-1-下载Django" class="headerlink" title="2.1 下载Django"></a>2.1 下载Django</h3><p>　　方式一：在命令行输入：pip3 install django</p>
<p>　　　　pip install django==1.11.9 -i <a href="http://pypi.hustunique.org/simple">http://pypi.hustunique.org/simple</a> 指定版本号，指定国内镜像</p>
<p>　　方式二：用pycharm安装</p>
<p>　　方式三：用pycharm的Terminal的命令行安装</p>
<h3 id="2-2-创建一个django-project"><a href="#2-2-创建一个django-project" class="headerlink" title="2.2 创建一个django project"></a>2.2 创建一个django project</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">django-admin.py startproject mysite</span><br></pre></td></tr></table></figure>

<p>当前目录下会生成mysite的工程，目录结构如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gj1w18rsraj30he0cy0uk.jpg" alt="image-20200924175250501"></p>
<ul>
<li>manage.py —– Django项目里面的工具，通过它可以调用django shell和数据库等。</li>
<li>settings.py —- 包含了项目的默认设置，包括数据库信息，调试标志以及其他一些工作的变量。</li>
<li>urls.py —– 负责把URL模式映射到应用程序。</li>
</ul>
<h3 id="2-3-在mysite目录下创建应用"><a href="#2-3-在mysite目录下创建应用" class="headerlink" title="2.3 在mysite目录下创建应用"></a>2.3 在mysite目录下创建应用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py startapp blog</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gj1w2o9s2hj30ew0eet9f.jpg" alt="image-20200924175406936"></p>
<h3 id="2-4-启动django项目"><a href="#2-4-启动django项目" class="headerlink" title="2.4 启动django项目"></a>2.4 启动django项目</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py runserver 8001</span><br></pre></td></tr></table></figure>

<p>这样我们的django就启动起来了！当我们访问：<a href="http://127.0.0.1:8080/%E6%97%B6%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%EF%BC%9A">http://127.0.0.1:8080/时就可以看到：</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gj1w38w557j30ru04m0ue.jpg" alt="image-20200924175446249"></p>
<h2 id="三-基于Django实现的一个简单示例"><a href="#三-基于Django实现的一个简单示例" class="headerlink" title="三 基于Django实现的一个简单示例"></a>三 基于Django实现的一个简单示例</h2><h3 id="3-1-URL控制器"><a href="#3-1-URL控制器" class="headerlink" title="3.1 URL控制器"></a>3.1 URL控制器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import path</span><br><span class="line"></span><br><span class="line">from app01 import views</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    path(&#39;admin&#x2F;&#39;, admin.site.urls),</span><br><span class="line">    path(&#39;index&#x2F;&#39;,views.index),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="3-2-视图"><a href="#3-2-视图" class="headerlink" title="3.2 视图"></a>3.2 视图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line"></span><br><span class="line">    import datetime</span><br><span class="line">    now&#x3D;datetime.datetime.now()</span><br><span class="line">    ctime&#x3D;now.strftime(&quot;%Y-%m-%d %X&quot;)</span><br><span class="line"></span><br><span class="line">    return render(request,&quot;index.html&quot;,&#123;&quot;ctime&quot;:ctime&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-3-模版"><a href="#3-3-模版" class="headerlink" title="3.3 模版"></a>3.3 模版</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h4&gt;当前时间:&#123;&#123; ctime &#125;&#125;&lt;&#x2F;h4&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="四-Django静态文件配置"><a href="#四-Django静态文件配置" class="headerlink" title="四 Django静态文件配置"></a>四 Django静态文件配置</h2><h3 id="4-1-static"><a href="#4-1-static" class="headerlink" title="4.1 static"></a>4.1 static</h3><p>新建一个目录叫：static，我们的css文件，js文件，图片文件都放在这下面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">STATIC_URL = &#x27;/static/&#x27;  # HTML中使用的静态文件夹前缀;也是访问的时候，url带的名称； 相当于访问静态文件的令牌</span><br><span class="line">STATICFILES_DIRS = [</span><br><span class="line">    os.path.join(BASE_DIR, &#x27;static&#x27;), # 静态文件存放位置</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">#STATIC_URL = &#x27;/static/&#x27;就是为静态文件的绝对路径起了一个别名，以后我们只需要用路径/static/即可；相当于一个令牌，找静态文件以后会遍历STATICFILES_DIRS去找</span><br><span class="line"></span><br><span class="line">-- 注意：</span><br><span class="line">页面中 需要静态文件动态解析</span><br><span class="line">&#123;% load static %&#125;  这里只能是static</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/867021-20180110190001816-1349372864.png" alt="img"></p>
<h3 id="4-2-mycss-css"><a href="#4-2-mycss-css" class="headerlink" title="4.2 mycss.css"></a>4.2 mycss.css</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h4&#123;</span><br><span class="line">    color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-myjs-js"><a href="#4-3-myjs-js" class="headerlink" title="4.3 myjs.js"></a>4.3 myjs.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&#39;h4&#39;).click(function () &#123;</span><br><span class="line">    $(this).css(&quot;color&quot;,&quot;green&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="4-4-insex-html"><a href="#4-4-insex-html" class="headerlink" title="4.4 insex.html"></a>4.4 insex.html</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;&#x2F;static&#x2F;mycss.css&quot;&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;&#x2F;static&#x2F;jquery-3.3.1.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h4&gt;我是红色，点击变绿&lt;&#x2F;h4&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;&#x2F;static&#x2F;myjs.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="五-Django请求生命周期"><a href="#五-Django请求生命周期" class="headerlink" title="五 Django请求生命周期"></a>五 Django请求生命周期</h2><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/DJango%E8%AF%B7%E6%B1%82%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="image-20210520034434563"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WSGI: 协议；Web服务器网关接口</span><br><span class="line">1.请求来的时候解析封装</span><br><span class="line">2.响应走的时候打包处理</span><br><span class="line"></span><br><span class="line">wsgiref：Django自带的模块，支持并发量很小，1000左右</span><br><span class="line">上线后会换成uwsgi</span><br><span class="line"></span><br><span class="line">WSGI wsgiref uwsgi是什么关系？</span><br><span class="line">WSGI是协议，wsgiref uwsgi是实现该协议的模块。</span><br></pre></td></tr></table></figure>



<h2 id="六-Django与其他web框架"><a href="#六-Django与其他web框架" class="headerlink" title="六 Django与其他web框架"></a>六 Django与其他web框架</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;&#39;&#39;</span><br><span class="line">a socket服务端</span><br><span class="line">b 根据url不同返回不同的内容</span><br><span class="line">    url---视图函数</span><br><span class="line">c 字符串返回给用户</span><br><span class="line">    特殊字符替换</span><br><span class="line"></span><br><span class="line">Web框架种类：</span><br><span class="line">a         b   c     Tornado</span><br><span class="line">别人的a   b    c     django（a用的wsgiref）</span><br><span class="line">别人a     b   别人c  flask（c用的jinja2）</span><br><span class="line">另一种分类：</span><br><span class="line">Django和其它</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">三板斧</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">HttpResponse: 返回字符串类型的数据</span><br><span class="line">render: 返回HTML文件</span><br><span class="line">        # 第一种传值方式：更加精确，节省资源</span><br><span class="line">    # return render(request, &#39;03 ab_render.html&#39;, &#123;&#39;data&#39;:user_dict,&#39;date&#39;:123&#125;)</span><br><span class="line">    # 第二种传值方式:当要传的数据特别多的时候</span><br><span class="line">    &quot;&quot;&quot;locals会将所在的名称空间中所有的名字全部传给html页面&quot;&quot;&quot;</span><br><span class="line">    # return render(request, &#39;03 ab_render.html&#39;, locals())</span><br><span class="line">redirect: 重定向</span><br><span class="line">      return redirect(&#39;https:&#x2F;&#x2F;www.sina.com.cn&#39;)</span><br><span class="line">    return redirect(&#39;&#x2F;home&#x2F;&#39;)</span><br><span class="line">request: 请求相关的所有数据对象 比env更牛逼</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>05-Django进阶-路由</title>
    <url>/posts/5607.html</url>
    <content><![CDATA[<p>Django 路由</p>
<a id="more"></a>

<h2 id="底层是for循环"><a href="#底层是for循环" class="headerlink" title="### 底层是for循环"></a>### 底层是for循环</h2><h1 id="Django之路由层"><a href="#Django之路由层" class="headerlink" title="Django之路由层"></a>Django之路由层</h1><h2 id="一-路由的作用"><a href="#一-路由的作用" class="headerlink" title="一 路由的作用"></a>一 路由的作用</h2><p>路由即请求地址与视图函数的映射关系，如果把网站比喻为一本书，那路由就好比是这本书的目录，在Django中路由默认配置在urls.py中，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1825659-20191011222443889-1706228438..png" alt="urls"></p>
<h2 id="二-简单的路由配置"><a href="#二-简单的路由配置" class="headerlink" title="二 简单的路由配置"></a>二 简单的路由配置</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># urls.py </span></span><br><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由一条条映射关系组成的urlpatterns这个列表称之为路由表</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">     url(regex, view, kwargs=<span class="literal">None</span>, name=<span class="literal">None</span>), <span class="comment"># url本质就是一个函数</span></span><br><span class="line">]</span><br><span class="line"><span class="comment">#函数url关键参数介绍</span></span><br><span class="line"><span class="comment"># regex：正则表达式,用来匹配url地址的路径部分，</span></span><br><span class="line">        <span class="comment"># 例如url地址为：http://127.0.0.1:8001/index/，正则表达式要匹配的部分是index/</span></span><br><span class="line"><span class="comment"># view：通常为一个视图函数，用来处理业务逻辑</span></span><br><span class="line"><span class="comment"># kwargs：略（用法详见有名分组）</span></span><br><span class="line"><span class="comment"># name：略（用法详见反向解析）</span></span><br></pre></td></tr></table></figure>

<p>案例：</p>
<p>urls.py文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views <span class="comment"># 导入模块views.py</span></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r&#x27;^admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    </span><br><span class="line">    url(<span class="string">r&#x27;^index/$&#x27;</span>,views.index), <span class="comment"># 新增一条</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="admin路由分发本质（include）-可以无限制的嵌套N多层"><a href="#admin路由分发本质（include）-可以无限制的嵌套N多层" class="headerlink" title="admin路由分发本质（include） 可以无限制的嵌套N多层"></a>admin路由分发本质（include） 可以无限制的嵌套N多层</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">               既可以函数.view,也可以类名.as_view(),也可以放个元祖</span><br><span class="line">url(r^index&#x2F;, (元祖三个参数))</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20210526101335503.png" alt="image-20210526101335503"></p>
<p>views.py文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponse <span class="comment"># 导入HttpResponse，用来生成响应信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增视图函数index</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;index page...&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python manage.py runserver <span class="number">8001</span> # 在浏览器输入：http://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8001</span>/index/ 会看到 index page...</span><br></pre></td></tr></table></figure>

<p>注意一：</p>
<p>斜杠是Django加的，不是浏览器加的，浏览器会重新发起请求，这个浏览器行为。</p>
<p>刚刚我们在浏览器输入：<a href="http://127.0.0.1:8001/index/%EF%BC%8CDjango%E4%BC%9A%E6%8B%BF%E7%9D%80%E8%B7%AF%E5%BE%84%E9%83%A8%E5%88%86index/%E5%8E%BB%E8%B7%AF%E7%94%B1%E8%A1%A8%E4%B8%AD%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E5%8C%B9%E9%85%8D%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E4%B8%80%E6%97%A6%E5%8C%B9%E9%85%8D%E6%88%90%E5%8A%9F%EF%BC%8C%E5%88%99%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%85%B6%E5%90%8E%E7%9A%84%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B8%8D%E4%BC%9A%E7%BB%A7%E7%BB%AD%E5%BE%80%E4%B8%8B%E5%8C%B9%E9%85%8D%EF%BC%8C%E6%AD%A4%E5%A4%84%E5%8C%B9%E9%85%8D%E6%88%90%E5%8A%9F%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%98%AF">http://127.0.0.1:8001/index/，Django会拿着路径部分index/去路由表中自上而下匹配正则表达式，一旦匹配成功，则立即执行其后的视图函数，不会继续往下匹配，此处匹配成功的正则表达式是</a> r’^index/$’。</p>
<p>注意二：</p>
<p>但是我们在浏览器输入：<a href="http://127.0.0.1:8001/index%EF%BC%8CDjango%E5%90%8C%E6%A0%B7%E4%BC%9A%E6%8B%BF%E7%9D%80%E8%B7%AF%E5%BE%84%E9%83%A8%E5%88%86index%E5%8E%BB%E8%B7%AF%E7%94%B1%E8%A1%A8%E4%B8%AD%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E5%8C%B9%E9%85%8D%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E8%B2%8C%E4%BC%BC%E5%B9%B6%E4%B8%8D%E4%BC%9A%E5%8C%B9%E9%85%8D%E6%88%90%E5%8A%9F%E4%BB%BB%E4%BD%95%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88">http://127.0.0.1:8001/index，Django同样会拿着路径部分index去路由表中自上而下匹配正则表达式，貌似并不会匹配成功任何正则表达式（</a> r’^index/$’匹配的是必须以 / 结尾，所以不会匹配成功index），但实际上仍然会看到结果 index page…，原因如下：</p>
<p>在配置文件settings.py中有一个参数<strong>APPEND_SLASH</strong>，该参数有两个值True或False</p>
<p>这个东西是在中间件里面明确写了的配置**<font color=red>‘django.middleware.common.CommonMiddleware’</font>**</p>
<p>当<strong>APPEND_SLASH=True（</strong>如果配置文件中没有该配置，APPEND_SLASH的默认值为True），并且用户请求的url地址的路径部分不是以 / 结尾，例如请求的url地址是 <a href="http://127.0.0.1:8001/index%EF%BC%8CDjango%E4%BC%9A%E6%8B%BF%E7%9D%80%E8%B7%AF%E5%BE%84%E9%83%A8%E5%88%86%EF%BC%88%E5%8D%B3index%EF%BC%89%E5%8E%BB%E8%B7%AF%E7%94%B1%E8%A1%A8%E4%B8%AD%E5%8C%B9%E9%85%8D%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E5%8F%91%E7%8E%B0%E5%8C%B9%E9%85%8D%E4%B8%8D%E6%88%90%E5%8A%9F%EF%BC%8C**%E9%82%A3%E4%B9%88Django%E4%BC%9A%E5%9C%A8%E8%B7%AF%E5%BE%84%E5%90%8E%E5%8A%A0">http://127.0.0.1:8001/index，Django会拿着路径部分（即index）去路由表中匹配正则表达式，发现匹配不成功，**那么Django会在路径后加</a> /** （即index/）再去路由表中匹配，如果匹配失败则会返回路径未找到，如果匹配成功，则会返回重定向信息给浏览器，要求浏览器重新向 <a href="http://127.0.0.1:8001/index/%E5%9C%B0%E5%9D%80%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E3%80%82">http://127.0.0.1:8001/index/地址发送请求。</a></p>
<p>当APPEND_SLASH=False时，则不会执行上述过程，即一旦url地址的路径部分匹配失败就立即返回路径未找到，不会做任何的附加操作<br>ps：注意！！！在末尾加/然后重新发起请求，这是浏览器的功能，如果是在终端直接执行curl <a href="http://127.0.0.1:8901/index%EF%BC%8C%E5%88%99%E6%B2%A1%E6%9C%89%E8%AF%A5%E5%8A%9F%E8%83%BD">http://127.0.0.1:8901/index，则没有该功能</a></p>
<h2 id="三-分组"><a href="#三-分组" class="headerlink" title="三 分组"></a>三 分组</h2><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1825659-20191011222444233-977445247.gif" alt="img"></p>
<p>简而言之: <strong>就是给某一段正则表达式用小括号括起来</strong></p>
<p>什么是分组、为何要分组呢？比如我们开发了一个博客系统，当我们需要根据文章的id查看指定文章时，浏览器在发送请求时需要向后台传递参数（文章的id号），可以使用 <a href="http://127.0.0.1:8001/article/?id=3%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%B0%86%E5%8F%82%E6%95%B0%E6%94%BE%E5%88%B0%E8%B7%AF%E5%BE%84%E4%B8%ADhttp://127.0.0.1:8001/article/3/">http://127.0.0.1:8001/article/?id=3，也可以直接将参数放到路径中http://127.0.0.1:8001/article/3/</a></p>
<p>针对后一种方式Django就需要直接从路径中取出参数，这就用到了正则表达式的分组功能了，分组分为两种：无名分组与有名分组</p>
<p>[<img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1825659-20191011222444524-429200914..png" alt="1554196523649"></p>
<h4 id="3-1-无名分组"><a href="#3-1-无名分组" class="headerlink" title="3.1 无名分组"></a>3.1 无名分组</h4><p><code>无名分组就是将括号内正则表达式匹配到的内容当做位置参数传递给后面的视图函数</code></p>
<p>urls.py文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r&#x27;^admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 下述正则表达式会匹配url地址的路径部分为:article/数字/，匹配成功的分组部分会以位置参数的形式传给视图函数，有几个分组就传几个位置参数</span></span><br><span class="line">    url(<span class="string">r&#x27;^aritcle/(\d+)/$&#x27;</span>,views.article), </span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>views.py文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要额外增加一个形参用于接收传递过来的分组数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">article</span>(<span class="params">request,article_id</span>):</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;id为 %s 的文章内容...&#x27;</span> %article_id)</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python manage.py runserver <span class="number">8001</span> # 在浏览器输入：http://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8001</span>/article/<span class="number">3</span>/ 会看到: id为 <span class="number">3</span> 的文章内容...</span><br></pre></td></tr></table></figure>



<h4 id="3-2-有名分组"><a href="#3-2-有名分组" class="headerlink" title="3.2 有名分组"></a>3.2 有名分组</h4><p><code>有名分组就是将括号内正则表达式匹配到的内容当做关键字参数传递给后面的视图函数</code></p>
<p>urls.py文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r&#x27;^admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 该正则会匹配url地址的路径部分为:article/数字/，匹配成功的分组部分会以关键字参数（article_id=匹配成功的数字）的形式传给视图函数，有几个有名分组就会传几个关键字参数</span></span><br><span class="line">    url(<span class="string">r&#x27;^aritcle/(?P&lt;article_id&gt;\d+)/$&#x27;</span>,views.article), </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.0版本</span></span><br><span class="line">path(<span class="string">&#x27;articles/&lt;int:year&gt;/&#x27;</span>, views.year_archive),</span><br></pre></td></tr></table></figure>

<p>views.py文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要额外增加一个形参，形参名必须为article_id</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">article</span>(<span class="params">request,article_id</span>):</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;id为 %s 的文章内容...&#x27;</span> %article_id)</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python manage.py runserver <span class="number">8001</span> # 在浏览器输入：http://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8001</span>/article/<span class="number">3</span>/ 会看到: id为 <span class="number">3</span> 的文章内容...</span><br></pre></td></tr></table></figure>

<p>总结：有名分组和无名分组都是为了获取路径中的参数，并传递给视图函数，区别在于无名分组是以位置参数的形式传递，有名分组是以关键字参数的形式传递。</p>
<p><font color=red>强调：无名分组和有名分组不能混合使用；但是单个分组可以使用多次</font></p>
<h2 id="四-路由分发"><a href="#四-路由分发" class="headerlink" title="四 路由分发"></a>四 路由分发</h2><p>[<img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1825659-20191011222445154-1444675186.gif" alt="img"></p>
<p>随着项目功能的增加，app会越来越多，路由也越来越多，每个app都会有属于自己的路由，如果再将所有的路由都放到一张路由表中，会导致结构不清晰，不便于管理，所以我们应该将app自己的路由交由自己管理，然后在总路由表中做分发，具体做法如下</p>
<p>1 创建两个app</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建项目mystie2</span></span><br><span class="line">E:\git&gt;django-admin startproject mysite2</span><br><span class="line"><span class="comment"># 切换到项目目录下</span></span><br><span class="line">E:\git&gt;cd mysite2</span><br><span class="line"><span class="comment"># 创建app01和app02</span></span><br><span class="line">E:\git\mysite2&gt;python3 manage.py startapp app01</span><br><span class="line">E:\git\mysite2&gt;python3 manage.py startapp app02</span><br></pre></td></tr></table></figure>

<p>2 在每个app下手动创建urls.py来存放自己的路由，如下：</p>
<p>app01下的urls.py文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="comment"># 导入app01的views</span></span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r&#x27;^index/$&#x27;</span>,views.index), </span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>app01下的views.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;我是app01的index页面...&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>app02下的urls.py文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="comment"># 导入app02的views</span></span><br><span class="line"><span class="keyword">from</span> app02 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r&#x27;^index/$&#x27;</span>,views.index), </span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>app02下的views.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;我是app02的index页面...&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>3 在总的urls.py文件中（mysite2文件夹下的urls.py）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url,include</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总路由表</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r&#x27;^admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 新增两条路由，注意不能以$结尾</span></span><br><span class="line">    <span class="comment"># include函数就是做分发操作的，当在浏览器输入http://127.0.0.1:8001/app01/index/时，会先进入到总路由表中进行匹配，正则表达式r&#x27;^app01/&#x27;会先匹配成功路径app01/，然后include功能会去app01下的urls.py中继续匹配剩余的路径部分</span></span><br><span class="line">    url(<span class="string">r&#x27;^app01/&#x27;</span>, include(<span class="string">&#x27;app01.urls&#x27;</span>)),</span><br><span class="line">    url(<span class="string">r&#x27;^app02/&#x27;</span>, include(<span class="string">&#x27;app02.urls&#x27;</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python manage.py runserver <span class="number">8001</span>  </span><br><span class="line"># 在浏览器输入：http://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8001</span>/app01/index/ 会看到:我是app01的index页面...</span><br><span class="line"># 在浏览器输入：http://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8001</span>/app02/index/ 会看到:我是app02的index页面...</span><br></pre></td></tr></table></figure>



<h2 id="五-反向解析"><a href="#五-反向解析" class="headerlink" title="五 反向解析"></a>五 反向解析</h2><p>简单理解: 通过方法得到一个结果，该结果可以直接访问对应的url触发视图函数。通过参数name为url地址的路径部分起一个别名，项目中就可以通过别名来获取这个路径。</p>
<p>在软件开发初期，url地址的路径设计可能并不完美，后期需要进行调整，如果项目中很多地方使用了该路径，一旦该路径发生变化，就意味着所有使用该路径的地方都需要进行修改，这是一个非常繁琐的操作。</p>
<p>解决方案就是在编写一条url(regex, view, kwargs=None, name=None)时，可以通过参数name为url地址的路径部分起一个别名，项目中就可以通过别名来获取这个路径。以后无论路径如何变化别名与路径始终保持一致。</p>
<p>上述方案中通过别名获取路径的过程称为反向解析</p>
<p>案例：登录成功跳转到index.html页面</p>
<p>在urls.py文件中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r&#x27;^admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    </span><br><span class="line">    url(<span class="string">r&#x27;^login/$&#x27;</span>, views.login,name=<span class="string">&#x27;login_page&#x27;</span>), <span class="comment"># 路径login/的别名为login_page</span></span><br><span class="line">    url(<span class="string">r&#x27;^index/$&#x27;</span>, views.index,name=<span class="string">&#x27;index_page&#x27;</span>), <span class="comment"># 路径index/的别名为index_page</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>在views.py中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render </span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> reverse <span class="comment"># 用于反向解析</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> redirect <span class="comment">#用于重定向页面</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        <span class="comment"># 当为get请求时，返回login.html页面,页面中的&#123;% url &#x27;login_page&#x27; %&#125;会被反向解析成路径：/login/</span></span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&#x27;login.html&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 当为post请求时，可以从request.POST中取出请求体的数据</span></span><br><span class="line">    name = request.POST.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    pwd = request.POST.get(<span class="string">&#x27;pwd&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&#x27;kevin&#x27;</span> <span class="keyword">and</span> pwd == <span class="string">&#x27;123&#x27;</span>:</span><br><span class="line">        url = reverse(<span class="string">&#x27;index_page&#x27;</span>)  <span class="comment"># reverse会将别名&#x27;index_page&#x27;反向解析成路径：/index/       </span></span><br><span class="line">        <span class="keyword">return</span> redirect(url) <span class="comment"># 重定向到/index/</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;用户名或密码错误&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;index.html&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>补充: redirect相关</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ps : redirect</span></span><br><span class="line">         redirect括号内可以直接写url，也可以直接写别名</span><br><span class="line">       但是如果别名带额外参数的话，那么就必须用reverse解析了。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>







<p>login.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--强调：login_page必须加引号--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&#123;% url &#x27;login_page&#x27; %&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125; <span class="comment">&lt;!--强调：必须加上这一行，后续我们会详细介绍--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是index页面...<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py runserver <span class="number">8001</span>  </span><br><span class="line"><span class="comment"># 在浏览器输入：http://127.0.0.1:8001/login/ 会看到登录页面，输入正确的用户名密码会跳转到index.html</span></span><br><span class="line"><span class="comment"># 当我们修改路由表中匹配路径的正则表达式时，程序其余部分均无需修改</span></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">在views.py中，后端反向解析的使用：</span><br><span class="line">    url = reverse(<span class="string">&#x27;index_page&#x27;</span>)</span><br><span class="line">在模版login.html文件中，前端反向解析的使用</span><br><span class="line">    &#123;% url <span class="string">&#x27;login_page&#x27;</span> %&#125;</span><br></pre></td></tr></table></figure>



<p>拓展阅读：</p>
<p>如果路径存在分组的反向解析使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r&#x27;^admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    </span><br><span class="line">    url(<span class="string">r&#x27;^aritcle/(\d+)/$&#x27;</span>,views.article,name=<span class="string">&#x27;article_page&#x27;</span>), <span class="comment">#　无名分组</span></span><br><span class="line">    url(<span class="string">r&#x27;^user/(?P&lt;uid&gt;\d+)/$&#x27;</span>,views.article,name=<span class="string">&#x27;user_page&#x27;</span>), <span class="comment"># 有名分组</span></span><br><span class="line">]</span><br><span class="line"><span class="comment"># 1 针对无名分组，比如我们要反向解析出：/aritcle/1/ 这种路径，写法如下</span></span><br><span class="line">在views.py中，反向解析的使用：</span><br><span class="line">    url = reverse(<span class="string">&#x27;article_page&#x27;</span>,args=(<span class="number">1</span>,)) </span><br><span class="line">在模版login.html文件中，反向解析的使用；参数必须是分组所能识别的\d+</span><br><span class="line">    &#123;% url <span class="string">&#x27;article_page&#x27;</span> <span class="number">1</span> %&#125;</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这个数字写代码的时候一般情况下：</span></span><br><span class="line"><span class="string">   前端渲染的时候，放的是数据的主键值  数据的编辑和删除</span></span><br><span class="line"><span class="string">   url(r&#x27;^edit/(\d+)/$&#x27;,views.edit,name=&#x27;xxx&#x27;), #　无名分组</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">   def edit(request, edit_id):</span></span><br><span class="line"><span class="string">          reverse(&#x27;xxx&#x27;,args=(edit_id,))</span></span><br><span class="line"><span class="string">   &#123;% for user_obj in user_queryset %&#125;</span></span><br><span class="line"><span class="string">           &lt;a href=&quot;&#123;% url &#x27;xxx&#x27; user_obj.id %&#125;&quot;&gt;编辑&lt;/a&gt;</span></span><br><span class="line"><span class="string">   &#123;% endfor %&#125;</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 2 针对有名分组，比如我们要反向解析出：/user/1/ 这种路径，写法如下</span></span><br><span class="line">在views.py中，反向解析的使用：</span><br><span class="line">  掌握</span><br><span class="line">  url = reverse(<span class="string">&#x27;user_page&#x27;</span>,args=(<span class="number">1</span>,)) </span><br><span class="line">  了解</span><br><span class="line">    url = reverse(<span class="string">&#x27;user_page&#x27;</span>,kwargs=&#123;<span class="string">&#x27;uid&#x27;</span>:<span class="number">1</span>&#125;) </span><br><span class="line">在模版login.html文件中，反向解析的使用</span><br><span class="line">  掌握</span><br><span class="line">  &#123;% url <span class="string">&#x27;user_page&#x27;</span> <span class="number">1</span> %&#125;</span><br><span class="line">  了解</span><br><span class="line">    &#123;% url <span class="string">&#x27;user_page&#x27;</span> uid=<span class="number">1</span> %&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结-模板：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 在html代码里</span><br><span class="line">&#123;% url &quot;别名&quot; 参数 参数%&#125;</span><br><span class="line"></span><br><span class="line">2 在视图函数中：</span><br><span class="line">　　2.1 url&#x3D;reverse(&#39;test&#39;)</span><br><span class="line">　　2.2 url&#x3D;reverse(&#39;test&#39;,args&#x3D;(10,20))</span><br></pre></td></tr></table></figure>





<h2 id="六-名称空间"><a href="#六-名称空间" class="headerlink" title="六 名称空间"></a>六 名称空间</h2><p>当我们的项目下创建了多个app，并且每个app下都针对匹配的路径起了别名，如果别名存在重复，那么在反向解析时则会出现覆盖，如下</p>
<p>1 创建两个app</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建项目mystie2</span></span><br><span class="line">E:\git&gt;django-admin startproject mysite2</span><br><span class="line"><span class="comment"># 切换到项目目录下</span></span><br><span class="line">E:\git&gt;cd mysite2</span><br><span class="line"><span class="comment"># 创建app01和app02</span></span><br><span class="line">E:\git\mysite2&gt;python3 manage.py startapp app01</span><br><span class="line">E:\git\mysite2&gt;python3 manage.py startapp app02</span><br></pre></td></tr></table></figure>

<p>2 在每个app下手动创建urls.py来存放自己的路由，并且为匹配的路径起别名</p>
<p>app01下的urls.py文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># 为匹配的路径app01/index/起别名&#x27;index_page&#x27;</span></span><br><span class="line">    url(<span class="string">r&#x27;^index/$&#x27;</span>,views.index,name=<span class="string">&#x27;index_page&#x27;</span>), </span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>app02下的urls.py文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="keyword">from</span> app02 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># 为匹配的路径app02/index/起别名&#x27;index_page&#x27;,与app01中的别名相同</span></span><br><span class="line">    url(<span class="string">r&#x27;^index/$&#x27;</span>,views.index,name=<span class="string">&#x27;index_page&#x27;</span>), </span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>3 在每个app下的view.py中编写视图函数，在视图函数中针对别名’index_page’做反向解析</p>
<p>app01下的views.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> reverse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    url=reverse(<span class="string">&#x27;index_page&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;app01的index页面，反向解析结果为%s&#x27;</span> %url)</span><br></pre></td></tr></table></figure>

<p>app02下的views.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> reverse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    url=reverse(<span class="string">&#x27;index_page&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;app02的index页面，反向解析结果为%s&#x27;</span> %url)</span><br></pre></td></tr></table></figure>

<p>3 在总的urls.py文件中（mysite2文件夹下的urls.py）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url,include</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总路由表</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r&#x27;^admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 新增两条路由，注意不能以$结尾</span></span><br><span class="line">    url(<span class="string">r&#x27;^app01/&#x27;</span>, include(<span class="string">&#x27;app01.urls&#x27;</span>)),</span><br><span class="line">    url(<span class="string">r&#x27;^app02/&#x27;</span>, include(<span class="string">&#x27;app02.urls&#x27;</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>4、测试：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python manage.py runserver <span class="number">8001</span>  </span><br></pre></td></tr></table></figure>

<p>在测试时，无论在浏览器输入：<a href="http://127.0.0.1:8001/app01/index/%E8%BF%98%E6%98%AF%E8%BE%93%E5%85%A5http://127.0.0.1:8001/app02/index/">http://127.0.0.1:8001/app01/index/还是输入http://127.0.0.1:8001/app02/index/</a> 针对别名’index_page’反向解析的结果都是/app02/index/，覆盖了app01下别名的解析。</p>
<p>解决这个问题的方法之一就是避免使用相同的别名，如果就想使用相同的别名，那就需要用到django中名称空间的概念，将别名放到不同的名称空间中，这样即便是出现重复，彼此也不会冲突，具体做法如下</p>
<p>1、总urls.py在路由分发时，指定名称空间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url, include</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总路由表</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r&#x27;^admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 传给include功能一个元组，元组的第一个值是路由分发的地址，第二个值则是我们为名称空间起的名字</span></span><br><span class="line">    url(<span class="string">r&#x27;^app01/&#x27;</span>, include((<span class="string">&#x27;app01.urls&#x27;</span>,<span class="string">&#x27;app01&#x27;</span>))),</span><br><span class="line">    url(<span class="string">r&#x27;^app02/&#x27;</span>, include((<span class="string">&#x27;app02.urls&#x27;</span>,<span class="string">&#x27;app02&#x27;</span>))),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>2、修改每个app下的view.py中视图函数，针对不同名称空间中的别名’index_page’做反向解析</p>
<p>app01下的views.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> reverse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    url=reverse(<span class="string">&#x27;app01:index_page&#x27;</span>) <span class="comment"># 解析的是名称空间app01下的别名&#x27;index_page&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;app01的index页面，反向解析结果为%s&#x27;</span> %url)</span><br></pre></td></tr></table></figure>

<p>app02下的views.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> reverse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    url=reverse(<span class="string">&#x27;app02:index_page&#x27;</span>) <span class="comment"># 解析的是名称空间app02下的别名&#x27;index_page&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;app02的index页面，反向解析结果为%s&#x27;</span> %url)</span><br></pre></td></tr></table></figure>

<p>3、测试：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python manage.py runserver <span class="number">8001</span>  </span><br></pre></td></tr></table></figure>

<p>浏览器输入：<a href="http://127.0.0.1:8001/app01/index/%E5%8F%8D%E5%90%91%E8%A7%A3%E6%9E%90%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF/app01/index/">http://127.0.0.1:8001/app01/index/反向解析的结果是/app01/index/</a></p>
<p>在浏览器输入<a href="http://127.0.0.1:8001/app02/index/">http://127.0.0.1:8001/app02/index/</a> 反向解析的结果是/app02/index/</p>
<p>总结:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、在视图函数中基于名称空间的反向解析，用法如下</span><br><span class="line">url=reverse(<span class="string">&#x27;名称空间的名字:待解析的别名&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、在模版里基于名称空间的反向解析，用法如下</span><br><span class="line">&lt;a href=&quot;&#123;% url &#x27;名称空间的名字:待解析的别名&#x27;%&#125;&quot;&gt;哈哈&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p><strong>补充</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 路由正常分发</span><br><span class="line">re_path(r&#39;^app01&#x2F;&#39;, include(&#39;app01.urls&#39;)),</span><br><span class="line">re_path(r&#39;^app02&#x2F;&#39;, include(&#39;app02.urls&#39;)),</span><br><span class="line"></span><br><span class="line"># app01 和 app02 的urls</span><br><span class="line">re_path(r&#39;reg&#x2F;&#39;, views.reg, name&#x3D;&#39;app01_reg&#39;)</span><br><span class="line">re_path(r&#39;reg&#x2F;&#39;, views.reg, name&#x3D;&#39;app02_reg&#39;)</span><br><span class="line"></span><br><span class="line"># 后端</span><br><span class="line">url &#x3D; reverse(&#39;app01_reg&#39;)</span><br><span class="line">    return HttpResponse(&#39;from app01 reg, url是: %s&#39; %url)</span><br><span class="line">url &#x3D; reverse(&#39;app02_reg&#39;)</span><br><span class="line">    return HttpResponse(&#39;from app02 reg, url是: %s&#39; %url)</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h2 id="七-django2-0版的re-path与path"><a href="#七-django2-0版的re-path与path" class="headerlink" title="七 django2.0版的re_path与path"></a>七 django2.0版的re_path与path</h2><h4 id="7-1-re-path"><a href="#7-1-re-path" class="headerlink" title="7.1 re_path"></a>7.1 re_path</h4><p>Django2.0中的re_path与django1.0的url一样，传入的第一个参数都是正则表达式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> re_path <span class="comment"># django2.0中的re_path</span></span><br><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url <span class="comment"># 在django2.0中同样可以导入1.0中的url</span></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># 用法完全一致</span></span><br><span class="line">    url(<span class="string">r&#x27;^app01/&#x27;</span>, include((<span class="string">&#x27;app01.urls&#x27;</span>,nanespace=<span class="string">&#x27;app01&#x27;</span>))),</span><br><span class="line">    re_path(<span class="string">r&#x27;^app02/&#x27;</span>, include((<span class="string">&#x27;app02.urls&#x27;</span>,nanespace=<span class="string">&#x27;app02&#x27;</span>))),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="7-2-path"><a href="#7-2-path" class="headerlink" title="7.2 path"></a>7.2 path</h4><p>在Django2.0中新增了一个path功能，用来解决：数据类型转换问题与正则表达式冗余问题，如下</p>
<p>urls.py文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> re_path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># 问题一：数据类型转换</span></span><br><span class="line">    <span class="comment"># 正则表达式会将请求路径中的年份匹配成功然后以str类型传递函数year_archive，在函数year_archive中如果想以int类型的格式处理年份，则必须进行数据类型转换</span></span><br><span class="line">    re_path(<span class="string">r&#x27;^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/$&#x27;</span>, views.year_archive),</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 问题二：正则表达式冗余</span></span><br><span class="line">    <span class="comment"># 下述三个路由中匹配article_id采用了同样的正则表达式，重复编写了三遍，存在冗余问题，并且极不容易管理，因为一旦article_id规则需要改变，则必须同时修改三处代码</span></span><br><span class="line">    </span><br><span class="line">    re_path(<span class="string">r&#x27;^article/(?P&lt;article_id&gt;[a-zA-Z0-9]+)/detail/$&#x27;</span>, views.detail_view),</span><br><span class="line">    re_path(<span class="string">r&#x27;^articles/(?P&lt;article_id&gt;[a-zA-Z0-9]+)/edit/$&#x27;</span>, views.edit_view),</span><br><span class="line">    re_path(<span class="string">r&#x27;^articles/(?P&lt;article_id&gt;[a-zA-Z0-9]+)/delete/$&#x27;</span>, views.delete_view),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>views.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">year_archive</span>(<span class="params">request,year</span>):</span></span><br><span class="line">    print(year,type(year))</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;year_archive page&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail_view</span>(<span class="params">request,article_id</span>):</span></span><br><span class="line">    print(article_id, type(article_id))</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;detail_view page&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_view</span>(<span class="params">request,article_id</span>):</span></span><br><span class="line">    print(article_id, type(article_id))</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;edit_view page&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_view</span>(<span class="params">request,article_id</span>):</span></span><br><span class="line">    print(article_id, type(article_id))</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;delete_view page&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>Django2.0中的path如何解决上述两个问题的呢？请看示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,re_path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># 问题一的解决方案：</span></span><br><span class="line">    path(<span class="string">&#x27;articles/&lt;int:year&gt;/&#x27;</span>, views.year_archive), <span class="comment"># &lt;int:year&gt;相当于一个有名分组，其中int是django提供的转换器，相当于正则表达式，专门用于匹配数字类型，而year则是我们为有名分组命的名，并且int会将匹配成功的结果转换成整型后按照格式（year=整型值）传给函数year_archive</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 问题二解决方法：用一个int转换器可以替代多处正则表达式</span></span><br><span class="line">    path(<span class="string">&#x27;articles/&lt;int:article_id&gt;/detail/&#x27;</span>, views.detail_view), </span><br><span class="line">    path(<span class="string">&#x27;articles/&lt;int:article_id&gt;/edit/&#x27;</span>, views.edit_view),</span><br><span class="line">    path(<span class="string">&#x27;articles/&lt;int:article_id&gt;/delete/&#x27;</span>, views.delete_view),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>强调：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、path与re_path或者1.0中的url的不同之处是，传给path的第一个参数不再是正则表达式，而是一个完全匹配的路径，相同之处是第一个参数中的匹配字符均无需加前导斜杠</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2、使用尖括号(&lt;&gt;)从url中捕获值，相当于有名分组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3、&lt;&gt;中可以包含一个转化器类型（converter type），比如使用 &lt;int:name&gt; 使用了转换器int。若果没有转化器，将匹配任何字符串，当然也包括了 / 字符</span></span><br></pre></td></tr></table></figure>

<p>[<img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1825659-20191011222449112-578457427.gif" alt="img"></p>
<p>django默认支持一下5种转换器（Path converters）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str,匹配除了路径分隔符（/）之外的非空字符串，这是默认的形式</span><br><span class="line">int,匹配正整数，包含<span class="number">0</span>。</span><br><span class="line">slug,匹配字母、数字以及横杠、下划线组成的字符串。</span><br><span class="line">uuid,匹配格式化的uuid，如 <span class="number">075194</span>d3<span class="number">-6885</span><span class="number">-417</span>e-a8a8<span class="number">-6</span>c931e272f00。</span><br><span class="line">path,匹配任何非空字符串，包含了路径分隔符（/）（不能用？）</span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path(<span class="string">&#x27;articles/&lt;int:year&gt;/&lt;int:month&gt;/&lt;slug:other&gt;/&#x27;</span>, views.article_detail) </span><br><span class="line"><span class="comment"># 针对路径http://127.0.0.1:8000/articles/2009/123/hello/，path会匹配出参数year=2009,month=123,other=&#x27;hello&#x27;传递给函数article_detail</span></span><br></pre></td></tr></table></figure>

<p>很明显针对月份month，转换器int是无法精准匹配的，如果我们只想匹配两个字符，那么转换器slug也无法满足需求，针对等等这一系列复杂的需要，我们可以定义自己的转化器。转化器是一个类或接口，它的要求有三点：</p>
<ul>
<li><code>regex</code> 类属性，字符串类型</li>
<li><code>to_python(self, value)</code> 方法，value是由类属性 <code>regex</code> 所匹配到的字符串，返回具体的Python变量值，以供Django传递到对应的视图函数中。</li>
<li><code>to_url(self, value)</code> 方法，和 <code>to_python</code> 相反，value是一个具体的Python变量值，返回其字符串，通常用于url反向引用。</li>
</ul>
<p>自定义转换器示例：</p>
<ol>
<li><p>在app01下新建文件path_ converters.py,文件名可以随意命名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonthConverter</span>:</span></span><br><span class="line">    regex=<span class="string">&#x27;\d&#123;2&#125;&#x27;</span> <span class="comment"># 属性名必须为regex</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_python</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">return</span> int(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_url</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">return</span> value <span class="comment"># 匹配的regex是两个数字，返回的结果也必须是两个数字</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在urls.py中，使用<code>register_converter</code> 将其注册到URL配置中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,register_converter</span><br><span class="line"><span class="keyword">from</span> app01.path_converts <span class="keyword">import</span> MonthConverter</span><br><span class="line"></span><br><span class="line">register_converter(MonthConverter,<span class="string">&#x27;mon&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;articles/&lt;int:year&gt;/&lt;mon:month&gt;/&lt;slug:other&gt;/&#x27;</span>, views.article_detail, name=<span class="string">&#x27;aaa&#x27;</span>),</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>views.py中的视图函数article_detail</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,HttpResponse,reverse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">article_detail</span>(<span class="params">request,year,month,other</span>):</span></span><br><span class="line">    print(year,type(year))</span><br><span class="line">    print(month,type(month))</span><br><span class="line">    print(other,type(other))</span><br><span class="line">    print(reverse(<span class="string">&#x27;xxx&#x27;</span>,args=(<span class="number">1988</span>,<span class="number">12</span>,<span class="string">&#x27;hello&#x27;</span>))) <span class="comment"># 反向解析结果/articles/1988/12/hello/</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;xxxx&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># <span class="number">1</span>、在浏览器输入http://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8000</span>/articles/<span class="number">2009</span>/<span class="number">12</span>/hello/，<span class="built_in">path</span>会成功匹配出参数year=<span class="number">2009</span>,month=<span class="number">12</span>,other=&#x27;hello&#x27;传递给函数article_detail</span><br><span class="line"># <span class="number">2</span>、在浏览器输入http://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8000</span>/articles/<span class="number">2009</span>/<span class="number">123</span>/hello/，<span class="built_in">path</span>会匹配失败，因为我们自定义的转换器mon只匹配两位数字，而对应位置的<span class="number">123</span>超过了<span class="number">2</span>位</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="model层区别"><a href="#model层区别" class="headerlink" title="model层区别"></a>model层区别</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.x 里面外键默认都是级联更新删除的</span><br><span class="line">但是到了2.x和3.x 中需要你自己手动配置参数</span><br><span class="line"></span><br><span class="line"> models.ForeignKey(to&#x3D;&#39;Publish&#39;)</span><br><span class="line"> models.ForeignKey(to&#x3D;&#39;Publish&#39;,on_delete&#x3D;models.CASCADE)</span><br></pre></td></tr></table></figure>



<h2 id="补充：-自定义暴露后端资源"><a href="#补充：-自定义暴露后端资源" class="headerlink" title="补充： 自定义暴露后端资源"></a>补充： 自定义暴露后端资源</h2><p>MEDIA_ROOT 代表着　要上传的路径会和你在ｍｏｄｅｌｓ中写的上传的路径进行拼节形成最终文件上传的路径　<br>MEDIA_URL　主要就是映射了　在前端使用media_url　当你的media_root　发生改变的时候不用去更改前端模板中的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在settings 中配置路径</span></span><br><span class="line">MEDIA_URL = <span class="string">&#x27;/media/&#x27;</span>  <span class="comment"># 可以在模板语法中使用</span></span><br><span class="line">MEDIA_ROOT = os.path.join(BASE_DIR, <span class="string">&#x27;media&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在urls 中引入serve 模块 和settings 配置</span></span><br><span class="line"><span class="keyword">from</span> django.views.static <span class="keyword">import</span> serve</span><br><span class="line"><span class="keyword">from</span> 项目名 <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露后端指定文件夹资源(MEDIA_ROOT的路径)</span></span><br><span class="line"><span class="comment">##media配置——配合settings中的MEDIA_ROOT的配置，就可以在浏览器的地址栏访问media文件夹及里面的文件了</span></span><br><span class="line">re_path(<span class="string">&#x27;^media/(?P&lt;path&gt;.*)&#x27;</span>, serve, &#123;<span class="string">&#x27;document_root&#x27;</span>:settings.MEDIA_ROOT&#125;),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># models</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    nid = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment">##头像是一个FileField——注意这里必须是“相对路径”，不能是/avatars/这样的绝对路径</span></span><br><span class="line">    avatar = models.FileField(upload_to=<span class="string">&#x27;avatars/&#x27;</span>,default=<span class="string">&#x27;avatars/default.jpg&#x27;</span>)</span><br><span class="line"><span class="comment">## 我们上传的文件会保存在 /media/avatars目录</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#### MEDIA_URL 需要配合中间件使用，</span></span><br><span class="line">在使用MEDIA_URL之前我们需要新增一条中间件，在settings.py文件的TEMPLATES参数中加入中间件：</span><br><span class="line">django.template.context_processors.media</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">然后我们在settings.py中加入MEDIA_URL的参数：</span><br><span class="line"></span><br><span class="line">MEDIA_URL = <span class="string">&#x27;/media/&#x27;</span></span><br><span class="line">接着我们再新增一条测试路由：</span><br><span class="line"></span><br><span class="line"><span class="comment">##测试</span></span><br><span class="line">path(<span class="string">&#x27;aa/bb&#x27;</span>,views.aa),</span><br><span class="line">视图也比较简单：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aa</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span>  render(request,<span class="string">&#x27;aa.html&#x27;</span>)</span><br><span class="line">然后模板文件中我们做相应的功能：</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a href=&quot;&#123;&#123; MEDIA_URL &#125;&#125;avatars/222.jpg&quot;&gt;查看media目录下的一张图片&lt;/a&gt;</span><br><span class="line">&lt;p&gt;MEDIA_URL: &#123;&#123; MEDIA_URL &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">假如我们想实现点击a标签的文字出来<span class="number">222.j</span>pg图片，可以在href加上图片的路径，这里大家看到了，我们用模板语言&#123;&#123; MEDIA_URL &#125;&#125;进行渲染，这里模板语言渲染出来的值其实就是我们在settings中设置的<span class="string">&#x27;/media/&#x27;</span>。我们可以看一下演示效果：</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>06-Django进阶-视图</title>
    <url>/posts/36345.html</url>
    <content><![CDATA[<p>Django 视图</p>
<a id="more"></a>



<h2 id="0-HttpResponse-render-redirect"><a href="#0-HttpResponse-render-redirect" class="headerlink" title="0. HttpResponse, render, redirect"></a>0. HttpResponse, render, redirect</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">HttpResponse</span><br><span class="line">   返回字符类型</span><br><span class="line">render</span><br><span class="line">   返回html页面 并且在返回给浏览器之前还可以给html文件传值</span><br><span class="line">redirect</span><br><span class="line">   重定向</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># 视图函数必须要返回一个HttpResponse对象，  研究源码即可得出结论</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># render内部原理</span></span><br><span class="line"><span class="string">from django.template import Template, Context</span></span><br><span class="line"><span class="string">  res = Template(&#x27;&lt;h1&gt;&#123;&#123; user &#125;&#125;&lt;/h1&gt;&#x27;)</span></span><br><span class="line"><span class="string">  con = Context(&#123;&#x27;user&#x27;:&#123;&#x27;username&#x27;:&#x27;jason&#x27;,&#x27;password&#x27;:123&#125;&#125;)</span></span><br><span class="line"><span class="string">  ret = res.render(con)</span></span><br><span class="line"><span class="string">  print(ret)</span></span><br><span class="line"><span class="string">  return HttpResponse(ret)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="一-视图函数"><a href="#一-视图函数" class="headerlink" title="一 视图函数"></a>一 视图函数</h2><p>视图函数，简称视图，属于Django的视图层，默认定义在views.py文件中，是用来处理web请求信息以及返回响应信息的函数，所以研究视图函数只需熟练掌握两个对象即可：请求对象(HttpRequest)和响应对象(HttpResponse)</p>
<p>[<img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1825659-20191011222544245-79299495..png" alt="1554198422515"></p>
<h3 id="二-请求对象-HttpRequest"><a href="#二-请求对象-HttpRequest" class="headerlink" title="二 请求对象(HttpRequest)"></a>二 请求对象(HttpRequest)</h3><p>django将http协议请求报文中的请求行、首部信息、内容主体封装到了HttpRequest对象中（类似于我们自定义框架的environ参数）。 django会将HttpRequest对象当做参数传给视图函数的第一个参数request，在视图函数中，通过访问该对象的属性便可以提取http协议的请求数据</p>
<h4 id="2-1、HttpRequest对象常用属性part1"><a href="#2-1、HttpRequest对象常用属性part1" class="headerlink" title="2.1、HttpRequest对象常用属性part1"></a>2.1、HttpRequest对象常用属性part1</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">一.HttpRequest.method</span><br><span class="line">　　获取请求使用的方法（值为纯大写的字符串格式）。例如：<span class="string">&quot;GET&quot;</span>、<span class="string">&quot;POST&quot;</span></span><br><span class="line">   应该通过该属性的值来判断请求方法</span><br><span class="line"></span><br><span class="line">二.HttpRequest.GET</span><br><span class="line">　　值为一个类似于字典的QueryDict对象，封装了GET请求的所有参数，可通过HttpRequest.GET.get(<span class="string">&#x27;键&#x27;</span>)获取相对应的值</span><br><span class="line">   </span><br><span class="line">  </span><br><span class="line">三.HttpRequest.POST</span><br><span class="line">   值为一个类似于字典的QueryDict对象，封装了POST请求所包含的表单数据，可通过HttpRequest.POST.get(<span class="string">&#x27;键&#x27;</span>)获取相对应的值</span><br><span class="line">   注意：get只会获取列表最后一个元素</span><br><span class="line">   针对表单中checkbox类型的input标签、select标签提交的数据，键对应的值为多个，需要用：HttpRequest.POST.getlist(<span class="string">&quot;hobbies&quot;</span>)获取存有多个值的列表,同理也有HttpRequest.GET.getlist(<span class="string">&quot;键&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>案例：</p>
<p>urls.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> re_path</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r&#x27;^login/$&#x27;</span>,views.login),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>Views.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        <span class="comment"># 当请求url为：http://127.0.0.1:8001/login/?a=1&amp;b=2&amp;c=3&amp;c=4&amp;c=5</span></span><br><span class="line">        <span class="comment"># 请求方法是GET，?后的请求参数都存放于request.GET中</span></span><br><span class="line">        print(request.GET)</span><br><span class="line">        <span class="comment"># 输出&lt;QueryDict: &#123;&#x27;a&#x27;: [&#x27;1&#x27;], &#x27;b&#x27;: [&#x27;2&#x27;], &#x27;c&#x27;: [&#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;]&#125;&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取？后参数的方式为</span></span><br><span class="line">        a=request.GET.get(<span class="string">&#x27;a&#x27;</span>) <span class="comment"># 1</span></span><br><span class="line">        b=request.GET.get(<span class="string">&#x27;b&#x27;</span>) <span class="comment"># 2</span></span><br><span class="line">        c=request.GET.getlist(<span class="string">&#x27;c&#x27;</span>) <span class="comment"># [&#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;login.html&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        <span class="comment"># 在输入框内输入用户名egon、年龄18，选择爱好，点击提交</span></span><br><span class="line">        <span class="comment"># 请求方法为POST，表单内的数据都会存放于request.POST中</span></span><br><span class="line">        print(request.POST) </span><br><span class="line">        <span class="comment"># 输出&lt;QueryDict: &#123;..., &#x27;name&#x27;: [&#x27;egon&#x27;], &#x27;age&#x27;: [&#x27;18&#x27;], &#x27;hobbies&#x27;: [&#x27;music&#x27;, &#x27;read&#x27;]&#125;&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取表单中数据的方式为</span></span><br><span class="line">        name=request.POST.get(<span class="string">&#x27;name&#x27;</span>) <span class="comment"># egon</span></span><br><span class="line">        age=request.POST.get(<span class="string">&#x27;age&#x27;</span>) <span class="comment"># 18</span></span><br><span class="line">        hobbies=request.POST.getlist(<span class="string">&#x27;hobbies&#x27;</span>) <span class="comment"># [&#x27;music&#x27;, &#x27;read&#x27;]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;提交成功&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在templates目录下新建login.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">method=&quot;post&quot;代表在提交表单时会以POST方法提交表单数据</span></span><br><span class="line"><span class="comment">action=&quot;/login/&quot; 代表表单数据的提交地址为http://127.0.0.1:8001/login/,可以简写为action=&quot;/login/&quot;,或者action=&quot;&quot;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://127.0.0.1:8001/login/&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125; <span class="comment">&lt;!--强调：必须加上这一行，后续我们会详细介绍--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        爱好：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobbies&quot;</span> <span class="attr">value</span>=<span class="string">&quot;music&quot;</span>&gt;</span>音乐</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobbies&quot;</span> <span class="attr">value</span>=<span class="string">&quot;read&quot;</span>&gt;</span>阅读</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobbies&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dancing&quot;</span>&gt;</span>跳舞</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2、HttpRequest对象常用属性part2"><a href="#2-2、HttpRequest对象常用属性part2" class="headerlink" title="2.2、HttpRequest对象常用属性part2"></a>2.2、HttpRequest对象常用属性part2</h4><p><strong>form表单上传文件及后端如何操作:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">form 表单上传文件类型的数据</span><br><span class="line">    1. method 必须指定成post</span><br><span class="line">    2. enctype必须换成formdata</span><br><span class="line">    3. form表单是无法发送json格式数据的</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">一.HttpRequest.body</span><br><span class="line">   当浏览器基于http协议的POST方法提交数据时，数据会被放到请求体中发送给django，django会将接收到的请求体数据存放于HttpRequest.body属性中，因为该属性的值为Bytes类型，所以通常情况下直接处理Bytes、并从中提取有用数据的操作是复杂而繁琐的，好在django会对它做进一步的处理与封装以便我们更为方便地提取数据，比如</span><br><span class="line">   对于form表单来说，提交数据的常用方法为GET与POST</span><br><span class="line">   <span class="number">1</span>：如果表单属性method=<span class="string">&#x27;GET&#x27;</span>,那么在提交表单时，表单内数据不会存放于请求体中，而是会将表单数据按照k1=v1&amp;k2=v2&amp;k3=v3的格式放到url中，然后发送给django，django会将这些数据封装到request.GET中，注意此时的request.body为空、无用</span><br><span class="line">   <span class="number">2</span>：如果表单属性method=<span class="string">&#x27;POST&#x27;</span>，那么在提交表单时，表单内的所有数据都会存放于请求体中，在发送给django后会封装到request.body里，此时django为了方便我们提取数据，会request.body的数据进行进一步的处理，具体如何处理呢，需要从form表单提交数据的编码格式说起：</span><br><span class="line">    form表单对提交的表单数据有两种常用的编码格式，可以通过属性enctype进行设置，如下</span><br><span class="line">    编码格式<span class="number">1</span>(默认的编码格式):enctype=<span class="string">&quot;application/x-www-form-urlencoded&quot;</span> </span><br><span class="line">    编码格式<span class="number">2</span>(使用form表单上传文件时只能用该编码):enctype=<span class="string">&quot;multipart/form-data&quot;</span> </span><br><span class="line">    如果form表单提交数据是按照编码格式<span class="number">1</span>,那么request.body中数据的格式类似于GET方法的数据格式，如k1=v1&amp;k2=v2，此时django会将request.body中的数据提取出来封装到request.POST中方便我们提取</span><br><span class="line">    如果form表单提交数据是按照编码格式<span class="number">2</span>,那么request.body中数据的格式为<span class="string">b&#x27;------WebKitFormBoundaryKtcwuksQltpNprep\r\nContent-Disposition: form-data;......&#x27;</span>,，此时django会将request.body中的数据提取出来封装到request.POST中，将上传的文件数据专门提取出来封装到request.FILES属性中</span><br><span class="line">    强调：毫无疑问，编码格式<span class="number">2</span>的数据量要大于编码格式<span class="number">1</span>，如果无需上传文件，还是推荐使用更为精简的编码格式<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    我们除了可以采用form表单向django提交数据外，还可以采用ajax技术，ajax可以提交的数据格式有：<span class="number">1</span>、编码格式<span class="number">1</span> <span class="number">2</span>、编码格式<span class="number">2</span> <span class="number">3</span>、json，当ajax采用POST方法提交前两种格式的数据时，django的处理方案同上，但是当ajax采用POST方法提交json格式的数据时，django会将接收到的数据存放于HttpRequest.body，此时需要我们自己对HttpRequest.body属性值做反序列化操作，</span><br><span class="line">具体的，我们在讲解ajax时再做具体介绍</span><br><span class="line">    </span><br><span class="line">二.HttpRequest.FILES</span><br><span class="line">   如果使用form表单POST上传文件的话，文件数据将包含在HttpRequest.FILES属性中。</span><br><span class="line"></span><br><span class="line">　　该属性值为一个类似于字典的对象，可以包含多组key:value（对应多个上传的文件），其中每个key为&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;&quot;</span> /&gt; 中name属性的值，而value则为对应的文件数据</span><br><span class="line">　　强调：HttpRequest.FILES 只有在请求的方法为POST 且提交的&lt;form&gt; 带有enctype=<span class="string">&quot;multipart/form-data&quot;</span> 的情况下才会包含数据。否则，FILES 将为一个空的类似于字典的对象。</span><br></pre></td></tr></table></figure>



<p>案例：form表单上传文件</p>
<p>urls.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,register_converter,re_path</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r&#x27;^register/$&#x27;</span>,views.register),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>views.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;register.html&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        print(request.body)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从request.POST中获取用户名</span></span><br><span class="line">        name=request.POST.get(<span class="string">&#x27;name&#x27;</span>) </span><br><span class="line">        <span class="comment"># 从request.FILES获取文件对象</span></span><br><span class="line">        file_obj=request.FILES.get(<span class="string">&#x27;header_img&#x27;</span>) </span><br><span class="line">        name = file_obj.name <span class="comment"># 获取文件名字</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 上传的文件存放于templates文件夹下</span></span><br><span class="line">        <span class="keyword">with</span> open(name,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f: </span><br><span class="line">            <span class="keyword">for</span> chunk <span class="keyword">in</span> file_obj.chunks():</span><br><span class="line">                f.write(chunk)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;注册成功&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在templates目录下新建register.html</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;注册页面&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=<span class="string">&quot;&quot;</span> method=<span class="string">&quot;POST&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span> &gt;</span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        用户名:&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        头像:&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;header_img&quot;</span>&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-3、HttpRequest对象常用属性part3"><a href="#2-3、HttpRequest对象常用属性part3" class="headerlink" title="2.3、HttpRequest对象常用属性part3"></a>2.3、HttpRequest对象常用属性part3</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">一.HttpRequest.path</span><br><span class="line">   HttpRequest.path_info</span><br><span class="line">　　获取url地址的路径部分，只包含路径部分</span><br><span class="line"></span><br><span class="line">二.HttpRequest.get_full_path()</span><br><span class="line">　　获取url地址的完整path，既包含路径又包含参数部分</span><br><span class="line"></span><br><span class="line">如果请求地址是http://127.0.0.1:8001/order/?name=egon&amp;age=10#_label3，</span><br><span class="line">HttpRequest.path的值为<span class="string">&quot;/order/&quot;</span></span><br><span class="line">HttpRequest.get_full_path()的值为<span class="string">&quot;/order/?name=egon&amp;age=10&quot;</span></span><br></pre></td></tr></table></figure>

<p>案例：</p>
<p>urls.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,register_converter,re_path</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r&#x27;^order&#x27;</span>,views.order),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>views.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对请求的url地址：http://127.0.0.1:8001/order/?name=egon&amp;age=10#_label3</span></span><br><span class="line"><span class="comment"># 从域名后的最后一个“/”开始到“？”为止是路径部分，即/order/</span></span><br><span class="line"><span class="comment"># 从“？”开始到“#”为止之间的部分为参数部分,即name=egon&amp;age=10</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">order</span>(<span class="params">request</span>):</span></span><br><span class="line">    print(request.path) <span class="comment"># 结果为“/order/”</span></span><br><span class="line">    print(request.get_full_path()) <span class="comment"># 结果为&quot;/order/?name=egon&amp;age=10&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;order page&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-4、HttpRequest对象常用属性part4"><a href="#2-4、HttpRequest对象常用属性part4" class="headerlink" title="2.4、HttpRequest对象常用属性part4"></a>2.4、HttpRequest对象常用属性part4</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">一.HttpRequest.META</span><br><span class="line"> 　 值为包含了HTTP协议的请求头数据的Python字典，字典中的key及期对应值的解释如下</span><br><span class="line">    CONTENT_LENGTH —— 请求的正文的长度（是一个字符串）。</span><br><span class="line">    CONTENT_TYPE —— 请求的正文的MIME类型。</span><br><span class="line">    HTTP_ACCEPT —— 响应可接收的Content-Type。</span><br><span class="line">    HTTP_ACCEPT_ENCODING —— 响应可接收的编码。</span><br><span class="line">    HTTP_ACCEPT_LANGUAGE —— 响应可接收的语言。</span><br><span class="line">    HTTP_HOST —— 客服端发送数据的目标主机与端口</span><br><span class="line">    HTTP_REFERER —— Referring 页面。</span><br><span class="line">    HTTP_USER_AGENT —— 客户端使用的软件版本信息</span><br><span class="line">    QUERY_STRING —— 单个字符串形式的查询字符串（未解析过的形式）。</span><br><span class="line">    REMOTE_ADDR —— 客户端的IP地址。</span><br><span class="line">    REMOTE_HOST —— 客户端的主机名。</span><br><span class="line">    REMOTE_USER —— 服务器认证后的用户。</span><br><span class="line">    REQUEST_METHOD —— 一个字符串，例如<span class="string">&quot;GET&quot;</span> 或<span class="string">&quot;POST&quot;</span>。</span><br><span class="line">    SERVER_NAME —— 服务器的主机名。</span><br><span class="line">    SERVER_PORT —— 服务器的端口（是一个字符串）。</span><br><span class="line"> 　　从上面可以看到，除 CONTENT_LENGTH 和 CONTENT_TYPE 之外，HTTP协议的请求头数据转换为 META 的键时，</span><br><span class="line">    都会</span><br><span class="line">    <span class="number">1</span>、将所有字母大写</span><br><span class="line">    <span class="number">2</span>、将单词的连接符替换为下划线</span><br><span class="line">    <span class="number">3</span>、加上前缀HTTP_。</span><br><span class="line">    所以，一个叫做 X-Bender 的头部将转换成 META 中的 HTTP_X_BENDER 键。</span><br><span class="line">   </span><br><span class="line">注意：下述常用属性暂且了解即可，待我们讲到专门的知识点时再专门详细讲解</span><br><span class="line">二.HttpRequest.COOKIES</span><br><span class="line">　　一个标准的Python 字典，包含所有的cookie。键和值都为字符串。</span><br><span class="line"></span><br><span class="line">三.HttpRequest.session</span><br><span class="line"> 　一个既可读又可写的类似于字典的对象，表示当前的会话。只有当Django 启用会话的支持时才可用。</span><br><span class="line"></span><br><span class="line"><span class="number">11.</span>HttpRequest.user(用户认证组件下使用)</span><br><span class="line"></span><br><span class="line">　　一个 AUTH_USER_MODEL 类型的对象，表示当前登录的用户。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>HttpRequest.is_ajax()</span><br><span class="line"></span><br><span class="line">　　如果请求是通过XMLHttpRequest 发起的，则返回<span class="literal">True</span>，方法是检查 HTTP_X_REQUESTED_WITH 相应的首部是否是字符串<span class="string">&#x27;XMLHttpRequest&#x27;</span>。</span><br><span class="line"></span><br><span class="line">　　大部分现代的 JavaScript 库都会发送这个头部。如果你编写自己的 XMLHttpRequest 调用（在浏览器端），你必须手工设置这个值来让 is_ajax() 可以工作。</span><br><span class="line"></span><br><span class="line">　　如果一个响应需要根据请求是否是通过AJAX 发起的，并且你正在使用某种形式的缓存例如Django 的 cache middleware，</span><br><span class="line">   你应该使用 vary_on_headers(<span class="string">&#x27;HTTP_X_REQUESTED_WITH&#x27;</span>) 装饰你的视图以让响应能够正确地缓存。</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">request.method <span class="comment"># 返回请求方式  并且是全大写的字符串形式 &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line">对于Form表单来说: </span><br><span class="line">    &#x27;GET&#x27; : 数据格式k1=v1&amp;k2=v2&amp;k3=v3 的格式放入url中，数据经过Django封装到--&gt; request.GET中，此时request.body为空。</span><br><span class="line">    <span class="string">&#x27;POST&#x27;</span>: (<span class="number">1</span>) urlencoded</span><br><span class="line">             数据格式为k1=v1&amp;k2=v2&amp;k3=v3 ---&gt; 从body封装到request.POST种</span><br><span class="line">            (<span class="number">2</span>) form-data</span><br><span class="line">            数据格式为<span class="string">b&#x27;WebKitFormBoundaryKtcwuksQltpNprep\r\nContent-Disposition: form-data;......&#x27;</span>,<span class="string">&#x27;  </span></span><br><span class="line"><span class="string">            此时Django会把数据从request.body 中 封装到---&gt; request.POST中,文件---&gt; request.FILES</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">request.POST  # 获取用户提交的POST请求普通数据（不包含文件）</span></span><br><span class="line"><span class="string">    request.POST.get()  # 只获取列表最后一个元素</span></span><br><span class="line"><span class="string">    request.POST.getlist() # 直接将列表取出</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Ajax提交数据: 方式除urlencoded和form-data外，还有json。</span></span><br><span class="line"><span class="string">             前两种与form表单无差异，如果是json，则会将数据封装在---&gt; request.body中、</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">get请求携带的数据大小是有限制的 4KB</span></span><br><span class="line"><span class="string">post没有限制</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="二-QueryDict对象"><a href="#二-QueryDict对象" class="headerlink" title="二. QueryDict对象"></a>二. QueryDict对象</h3><p>参考博客：<a href="https://www.liujiangblog.com/course/django/139">https://www.liujiangblog.com/course/django/139</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一定要初一区分QueryDict和QuerySet，前者是对HTTP请求数据包中携带的数据的封装，后者是对从数据库中查询出来的数据进行的封装。</span><br><span class="line"></span><br><span class="line">在HttpRequest对象中，GET和POST属性都是一个django.http.QueryDict的实例。也就是说你可以按本文下面提供的方法操作request.POST和request.GET。</span><br><span class="line"></span><br><span class="line">request.POST或request.GET的QueryDict都是不可变，只读的。如果要修改它，需要使用QueryDict.copy()方法，获取它的一个拷贝，然后在这个拷贝上进行修改操作。</span><br></pre></td></tr></table></figure>

<ul>
<li>重点</li>
</ul>
<p>QueryDict.get()， 返回键的对应的值，如果是有多个值（序列），只返回最后一个值 </p>
<p>QueryDict.getlist()，返回键对应的值列表</p>
<h3 id="三-响应对象-HttpResponse"><a href="#三-响应对象-HttpResponse" class="headerlink" title="三 响应对象(HttpResponse)"></a>三 响应对象(HttpResponse)</h3><p>响应可以是任何形式的内容，比如一个HTML文件的内容，一个重定向，一个404错误，一个XML文档，或者一张图片等。总之，无论视图本身包含什么逻辑，都要返回响应，具体的说，响应对象主要有三种形式:HttpResponse,render,redirect</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponse,render,redirect</span><br></pre></td></tr></table></figure>

<h3 id="3-1、HttpResponse"><a href="#3-1、HttpResponse" class="headerlink" title="3.1、HttpResponse()"></a>3.1、HttpResponse()</h3><p>括号内直接跟一个具体的字符串作为响应体，比较直接很简单，所以这里主要介绍后面两种形式。</p>
<h4 id="3-2、render"><a href="#3-2、render" class="headerlink" title="3.2、render()"></a>3.2、render()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">render(request, template_name[, context]）</span><br><span class="line">参数：</span><br><span class="line">    <span class="number">1</span>、request：用于生成响应的请求对象，固定必须传入的第一个参数</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span>、template_name：要使用的模板的完整名称，必须传入，render默认会去templates目录下查找模板文件</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span>、context：可选参数，可以传入一个字典用来替换模块文件中的变量</span><br><span class="line"></span><br><span class="line">综上，render的功能可以总结为：根据给定字典渲染模板文件，并返回一个渲染后的 HttpResponse对象。</span><br></pre></td></tr></table></figure>

<h4 id="3-3、redirect"><a href="#3-3、redirect" class="headerlink" title="3.3、redirect()"></a>3.3、redirect()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回重定向信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span>(<span class="params">request</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;/some/url/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重定向的地址也可以是一个完整的URL：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span>(<span class="params">request</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;http://www.baidu.com/&#x27;</span>)　</span><br></pre></td></tr></table></figure>

<p>[<img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1825659-20191011222545525-832902557.gif" alt="img"></p>
<p>重定向转态码301与302的区别（了解）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">一、<span class="number">301</span>和<span class="number">302</span>的异同。</span><br><span class="line">   <span class="number">1</span>、相同之处：</span><br><span class="line">   <span class="number">301</span>和<span class="number">302</span>状态码都表示重定向，具体点说就是浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址（浏览器会从响应头Location中获取新地址），用户看到的效果都是输入地址A后瞬间跳转到了另一个地址B</span><br><span class="line">   </span><br><span class="line">   <span class="number">2</span>、不同之处：</span><br><span class="line">　　<span class="number">301</span>表示旧地址A的资源已经被永久地移除了，即这个资源不可访问了。搜索引擎在抓取新内容的同时也将旧的网址转换为重定向之后的地址；</span><br><span class="line">　　<span class="number">302</span>表示旧地址A的资源还在，即这个资源仍然可以访问，这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容、并且会保存旧的网址。 从SEO层面考虑，<span class="number">302</span>要好于<span class="number">301</span></span><br><span class="line"></span><br><span class="line">二、重定向原因：</span><br><span class="line">   <span class="number">1</span>、网站调整（如改变网页目录结构）；</span><br><span class="line">   <span class="number">2</span>、网页被移到一个新地址；</span><br><span class="line">   <span class="number">3</span>、网页扩展名改变(如应用需要把.php改成.Html或.shtml)。</span><br><span class="line">      这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个<span class="number">404</span>页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。</span><br></pre></td></tr></table></figure>

<p>[<img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1825659-20191011222545750-1325469848..png" alt="1554198744154"></p>
<h3 id="四-JsonResponse"><a href="#四-JsonResponse" class="headerlink" title="四 JsonResponse"></a>四 JsonResponse</h3><p>向前端返回一个json格式字符串的两种方式</p>
<p>方式一：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span>(<span class="params">request</span>):</span></span><br><span class="line">    data=[<span class="string">&#x27;egon&#x27;</span>,<span class="string">&#x27;kevin&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(json.dumps(data) )</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>方式二：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span>(<span class="params">request</span>):</span></span><br><span class="line">    data=[<span class="string">&#x27;egon&#x27;</span>,<span class="string">&#x27;kevin&#x27;</span>]</span><br><span class="line">    <span class="comment">## 如果有中文</span></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(data,json_dumps_params=&#123;<span class="string">&#x27;ensure&#x27;</span>:<span class="string">&#x27;false&#x27;</span>&#125;,safe=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(data,safe=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment">#默认safe=True代表只能序列化字典对象，safe=False代表可以序列化字典以外的对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">####Json格式化时间字符串</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyJSONEncoder</span>(<span class="params">json.JSONEncoder</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(obj, datetime.datetime):</span><br><span class="line">            <span class="keyword">return</span> obj.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(obj, datetime.date):</span><br><span class="line">            <span class="keyword">return</span> obj.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> json.JSONEncoder.default(self, obj)</span><br></pre></td></tr></table></figure>

<h3 id="六-FBV和CBV"><a href="#六-FBV和CBV" class="headerlink" title="六 FBV和CBV"></a>六 FBV和CBV</h3><p>django的视图层由两种形式构成：FBV和CBV</p>
<p>1、FBV基于函数的视图（Function base view），我们之前一直介绍的都是FBV</p>
<p>2、CBV基于类的视图(Class base view)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">CBV特点</span></span><br><span class="line"><span class="string">    能够直接根据请求方式的不同直接匹配到对应的方法执行</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<p>案例：</p>
<p>urls.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,register_converter,re_path</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r&#x27;^login/&#x27;</span>,views.LoginView.as_view()), <span class="comment"># 必须调用类下的方法as_view</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>views.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,HttpResponse,redirect</span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginView</span>(<span class="params">View</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span>(<span class="params">self, request, *args, **kwargs</span>):</span> <span class="comment"># 可在该方法内做一些预处理操作</span></span><br><span class="line">        <span class="comment"># 当请求url为：http://127.0.0.1:8008/login/会先触发dispatch的执行</span></span><br><span class="line">        <span class="comment"># 如果http协议的请求方法为GET，则调用下述get方法</span></span><br><span class="line">        <span class="comment"># 如果http协议的请求方法为POST，则调用下述post方法</span></span><br><span class="line">        obj=super().dispatch(request, *args, **kwargs) <span class="comment"># 必须继承父类的dispatch功能</span></span><br><span class="line">        <span class="keyword">return</span> obj <span class="comment"># 必须返回obj</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;login.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        name=request.POST.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        pwd=request.POST.get(<span class="string">&#x27;pwd&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> name  == <span class="string">&#x27;egon&#x27;</span> <span class="keyword">and</span> pwd == <span class="string">&#x27;123&#x27;</span>:</span><br><span class="line">            res=<span class="string">&#x27;登录成功&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res=<span class="string">&#x27;用户名或密码错误&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(res)</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py runserver <span class="number">8001</span> </span><br><span class="line"><span class="comment"># 验证GET请求：在浏览器输入：http://127.0.0.1:8001/login/</span></span><br><span class="line"><span class="comment"># 验证POST请求：在表单内输入数据然后提交</span></span><br></pre></td></tr></table></figure>

<p>采用CBV可以引入面向对象的思想对数据进行更高程度的封装，此处简单了解即可，我们将在后续的项目中详细介绍它的应用于强大之处</p>
<h3 id="七-CBV源码剖析-要求不看源码也能描述出CBV的内部执行流程"><a href="#七-CBV源码剖析-要求不看源码也能描述出CBV的内部执行流程" class="headerlink" title="七. CBV源码剖析(要求不看源码也能描述出CBV的内部执行流程)"></a>七. CBV源码剖析(要求不看源码也能描述出CBV的内部执行流程)</h3><p>在看Python源码时，一定要时刻提醒自己面向对象属性方法查找顺序：<br>先从对象自己找，再去产生对象的类里面找，之后再去父类找。<br><strong>源码中只要看到了self.一定要弄清楚当前self是谁，才能明确关系。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. views 能够根据请求方式的不同自动匹配触发对应方法的执行(只要是视图层看书都应该有一个形参request)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. url  CBV与FBV在路由匹配上本质是一样的，都是路由 对应 函数内存地址</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    <span class="comment"># CBV</span></span><br><span class="line">    re_path(<span class="string">r&#x27;^login/&#x27;</span>,views.MyLogin.as_view())</span><br><span class="line">    <span class="comment"># 上述代码在启动的django的时候就会立刻执行as_view方法</span></span><br><span class="line">    <span class="comment"># url(r&#x27;login/&#x27;,views.view)  FBV一模一样</span></span><br><span class="line">    <span class="comment"># CBV与FBV在路由匹配上本质是一样的，都是路由 对应 函数内存地址</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 源码</span></span><br><span class="line"><span class="meta">@classonlymethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">as_view</span>(<span class="params">cls, **initkwargs</span>):</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">view</span>(<span class="params">request, *args, **kwargs</span>):</span></span><br><span class="line">      self = cls(**initkwargs) <span class="comment"># cls是我们自己写的类</span></span><br><span class="line">      <span class="comment"># self = MyLogin(**initkwargs) 产生一个我们自己写的类的对象</span></span><br><span class="line">      ...</span><br><span class="line">       <span class="comment"># 这个self 就是上面我们自己类产生的对象。找dispatch，先从对象自己本身去找，再去产生对象的类里面MyLogin去找，也没有，就去MyLogin的父类去找，View</span></span><br><span class="line">      <span class="keyword">return</span> self.dispatch(*args, **kwargs)</span><br><span class="line">   <span class="keyword">return</span> view</span><br><span class="line"></span><br><span class="line"><span class="comment"># CBV精髓</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> self.dispatch(request, *args, **kwargs)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">时刻提醒自己面向对象属性方法的查找顺序</span></span><br><span class="line"><span class="string">    先从对象自己找</span></span><br><span class="line"><span class="string">    再去产生对象的类里面找</span></span><br><span class="line"><span class="string">    之后再去父类找</span></span><br><span class="line"><span class="string">总结: 只要看到self点，就要问自己当前的这个self是谁</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># CBV精髓</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dispatch</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">    <span class="comment"># 获取当前请求方式的小写格式，然后比对当前请求方式是否合法</span></span><br><span class="line">    <span class="comment"># get请求为例</span></span><br><span class="line">    <span class="keyword">if</span> request.method.lower() <span class="keyword">in</span> self.http_method_names:</span><br><span class="line">        handler = getattr(self, request.method.lower(), self.http_method_not_allowed)</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        反射: 通过字符串来操作对象的属性或者方法</span></span><br><span class="line"><span class="string">            handler = getattr(自己写的类产生的对象，&#x27;get&#x27;，当找不到get属性或者方法的时候就会用第三个参数)</span></span><br><span class="line"><span class="string">            handler = 我们自己写的类里面的get方法</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        handler = self.http_method_not_allowed <span class="comment"># 报错提示方法</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> handler(request, *args, **kwargs)</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    自动调用get方法</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>07-Django进阶-模板</title>
    <url>/posts/42884.html</url>
    <content><![CDATA[<p>Django 模板</p>
<a id="more"></a>

<h2 id="一-模板简介"><a href="#一-模板简介" class="headerlink" title="一 模板简介"></a>一 模板简介</h2><p>在刚刚介绍完的视图层中我们提到，浏览器发送的请求信息会转发给视图函数进行处理，而视图函数在经过一系列处理后必须要有返回信息给浏览器。如果我们要返回html标签、css等数据给浏览器进行渲染，我们可以在视图函数中这么做</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">current_datetime</span>(<span class="params">request</span>):</span></span><br><span class="line">    now = datetime.datetime.now()</span><br><span class="line">    html = <span class="string">&quot;&lt;html&gt;&lt;body&gt;It is now %s.&lt;/body&gt;&lt;/html&gt;&quot;</span> % now</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(html)</span><br></pre></td></tr></table></figure>

<p>上例所示，我们直接将HTML代码放到视图函数里，然后进行返回，这可以使我们很直观地看清楚浏览器从发送请求到看到前端界面内容的这个过程中视图函数的基本工作原理，但是这种将前端代码与后端代码耦合到了一起开发方式，会存在以下问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、程序的可维护性与可扩展性问题</span><br><span class="line">前端界面一旦需要重新设计、修改，则必须对后端的Python代码进行相应的修改。 然而前端界面的修改往往比后端 Python 代码的修改要频繁得多，因此如果可以在不进行 Python 代码修改的情况下变更前端界面的设计，那将会方便得多。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、开发效率问题</span><br><span class="line">Python 代码编写和 HTML 设计是两项不同的工作，大多数专业的网站开发环境都将它们分配给不同的人员（甚至不同部门）来完成。 专门的程序员去编写 Python代码、专门的设计人员去制作模板，这两项工作同时进行，效率才是最高的。</span><br></pre></td></tr></table></figure>

<p>基于上述原因，将前端页面和Python的代码分离是一种不错的开发模式。 为此 Django专门提供了模板系统 (Template System，即模板层)来实现这种模式，这就是本章要具体讨论的问题。</p>
<p>[<img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1825659-20191011222641249-610103613.gif" alt="img"></p>
<p><strong>django的模板=HTML代码+模板语法</strong></p>
<p>存放于templates目录下的html文件称之为模板文件，如果我们想要返回的html页面中的数据是动态的，那么必须在html页面中嵌入变量，这便用到了django的模板语法，具体来说，django的模板语法有以下重点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">一、变量：&#123;&#123; 变量名 &#125;&#125;</span><br><span class="line">    <span class="number">1.1</span> 深度查询：句点符的应用</span><br><span class="line">    <span class="number">1.2</span> 过滤器</span><br><span class="line">二、标签：&#123;% 标签名 %&#125;</span><br><span class="line">三、自定义标签和过滤器</span><br><span class="line">四、模板的导入和继承</span><br></pre></td></tr></table></figure>

<p>下面就让我们来一一介绍它们</p>
<h2 id="二-模板语法之变量"><a href="#二-模板语法之变量" class="headerlink" title="二 模板语法之变量"></a>二 模板语法之变量</h2><p><strong>两种传值方式：</strong><br><code>&#123;&#123;&#125;&#125;：变量相关`
`&#123;%%&#125;：逻辑相关`

#### 2.0 模板语法传值

须知：

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">模板语法传值</span><br><span class="line"><span class="comment"># 要知道render支持两种给html文件传值的方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python所有的基本数据类型 函数名 类名 对象都可以被传到html上</span></span><br><span class="line"><span class="comment"># 针对函数名和类名 模板语法会自动加括号调用(但是不支持传递额外的参数)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模板语法如何获取容器类型里面的数据  统一采用字符.</span></span><br><span class="line">.key </span><br><span class="line">.index</span><br><span class="line">.key.index.index.key</span><br><span class="line"></span><br><span class="line">过滤器</span><br><span class="line"><span class="comment"># 语法结构  最多只能有两个参数</span></span><br><span class="line">&#123;&#123; 变量名|过滤器名:传给过滤器的参数 &#125;&#125;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h3&gt;过滤器&lt;/h3&gt;</span><br><span class="line">&lt;p&gt;统计长度：&#123;&#123; s|length &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;默认值，意思就是当前面的值的布尔值是True，那么就显示前面的值，如果不是True，那么就显示默认值：&#123;&#123; b|default:&#x27;默认值&#x27; &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;文件大小：&#123;&#123; file_size|filesizeformat &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;未处理之前的日期：&#123;&#123; current_time &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;日期格式化(默认是UTC时间)：&#123;&#123; current_time|date:&#x27;Y-m-d H:i:s&#x27; &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;切片操作(支持步长)：&#123;&#123; l|slice:&#x27;0:4:2&#x27; &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;切割字符(包含三个点)：&#123;&#123; info|truncatechars:19 &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;切割单词(不包含三个点，中文英文都是按照空格切割)：&#123;&#123; English|truncatewords:4 &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;移除特定的字符(此示例将空格都移除了)：&#123;&#123; English|cut:&#x27; &#x27; &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;拼接操作：&#123;&#123; l|join:&#x27;-&#x27; &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;拼接操作(加法运算)：&#123;&#123; n|add:20 &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;拼接操作(字符串拼接)：&#123;&#123; s|add:English&#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;转义(加一个safe，告诉浏览器按照HTML格式显示，默认是取消转义的)：&#123;&#123; hhh|safe &#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;前端转义：&#123;&#123; sss|safe &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;取消转义：&#123;&#123; sss &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**补充：以后在写全栈项目时，前端代码不一定要在前端页面写，也可以在后端写好，然后转义后传递给前端页面**</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 路由</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r&#x27;^admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    url(<span class="string">r&#x27;^index/&#x27;</span>,views.index)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 视图函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 模板语法可以传递的后端Python数据类型</span></span><br><span class="line">    n=<span class="number">123</span></span><br><span class="line">    f=<span class="number">1.2</span></span><br><span class="line">    s=<span class="string">&#x27;你好哇&#x27;</span></span><br><span class="line">    b=<span class="literal">True</span></span><br><span class="line">    l=[<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>,<span class="string">&#x27;hi&#x27;</span>,<span class="string">&#x27;lucky&#x27;</span>]</span><br><span class="line">    t=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    d = &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;info&#x27;</span>: <span class="string">&#x27;这个人有意思&#x27;</span>, <span class="string">&#x27;hobby&#x27;</span>:[<span class="number">111</span>,<span class="number">222</span>,<span class="number">333</span>,&#123;<span class="string">&#x27;info&#x27;</span>:<span class="string">&#x27;NB&#x27;</span>&#125;]&#125;</span><br><span class="line">    se=&#123;<span class="string">&#x27;we&#x27;</span>,<span class="string">&#x27;are&#x27;</span>,<span class="string">&#x27;people&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">        print(<span class="string">&#x27;执行函数func&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;func函数的返回值&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>(<span class="params">object</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_self</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;self&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">        @staticmethod</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_func</span>():</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;func&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">        @classmethod</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_class</span>(<span class="params">cls</span>):</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;cls&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对象被展示到HTML页面上就类似于执行了打印操作也会触发__str__方法</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;call方法&#x27;</span></span><br><span class="line"></span><br><span class="line">    obj=MyClass()  <span class="comment"># 产生一个对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;index.html&#x27;</span>,locals())</span><br></pre></td></tr></table></figure>

index.html页面：

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;&#123; n &#125;&#125;</span><br><span class="line">    &#123;&#123; f &#125;&#125;</span><br><span class="line">    &#123;&#123; s &#125;&#125;</span><br><span class="line">    &#123;&#123; b &#125;&#125;</span><br><span class="line">    &#123;&#123; l &#125;&#125;</span><br><span class="line">    &#123;&#123; t &#125;&#125;</span><br><span class="line">    &#123;&#123; d &#125;&#125;</span><br><span class="line">    &#123;&#123; se &#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>传递函数名会自动加括号调用，但是模板语法不支持给函数额外的参数&#123;&#123; func &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>传递类名的时候也会自动加括号调用(实例化)&#123;&#123; MyClass &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>内部能够自动判断出当前变量名是否可以加括号调用，如果可以就会自动执行，针对的是函数名和类名<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; obj &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; obj.get_self &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; obj.get_func &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; obj.get_class &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; d.username &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Django模板语法的取值是固定的格式，只能采用句点符.</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; d.username &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; l.0 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; d.hobby.3.info &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"># 既可以点键，又可以点索引 还可以混用</span><br></pre></td></tr></table></figure>





#### 2.1 变量的基本使用

如果html代码中的数据不是固定死的，而是动态变化的，则必须在html中嵌入变量，为此，模板语法提供了变量的概念，允许我们在html代码中嵌入变量，我们只需要在视图函数中用render方法为html文件中指定的变量赋值即可，具体用法如下

test.html

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; dic &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; obj &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; li &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

我们需要在视图函数中为模板test.html的变量名msg、li、dic、obj、obj_li赋值,views.py内容如下

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 传给模板的变量值可以是任意python类型，如下</span></span><br><span class="line">    msg=<span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">    dic=&#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">object</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span></span><br><span class="line">            self.name=name</span><br><span class="line">            self.age=age</span><br><span class="line"></span><br><span class="line">    obj=Person(<span class="string">&#x27;egon&#x27;</span>,<span class="number">18</span>)</span><br><span class="line">    li = [<span class="number">1</span>,<span class="string">&#x27;aaa&#x27;</span>,obj]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;test.html&#x27;</span>,&#123;<span class="string">&#x27;msg&#x27;</span>:msg,<span class="string">&#x27;dic&#x27;</span>:dic,<span class="string">&#x27;obj&#x27;</span>:obj,<span class="string">&#x27;li&#x27;</span>:li&#125;)</span><br><span class="line">    <span class="comment"># 注意：</span></span><br><span class="line">    <span class="comment"># 1、render函数的第三个参数包含了要传给模板的变量值，是一个字典类型，该字典中的key必须与模板文件中的变量名相对应，render函数会去templates目录下找到模板文件，然后根据字典中的key对应到模板文件中的变量名进行赋值操作，最后将赋值后的模板文件内容返回给浏览器</span></span><br><span class="line">    <span class="comment"># 2、可以将render函数的第三个参数简写为locals(),如下</span></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;test.html&#x27;</span>,locals()) <span class="comment">#locals()会将函数test内定义的名字与值转换为字典中的k与v</span></span><br></pre></td></tr></table></figure>

#### 2.2 深度查询之句点符的使用

当视图函数传给模板的值中包含多个元素时，若想取出其中的单个元素，就必须使用句点符了。

句点符既可以引用容器类型的元素，也可以引用对象的方法，如下

test.html

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--调用字符串对象的upper方法，注意不要加括号--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; msg.upper &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--取字典中k1对应的值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; dic.k1 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--取对象的name属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; obj.name &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--取列表的第2个元素,然后变成大写--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; li.1.upper &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--取列表的第3个元素，并取该元素的age属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; li.2.age &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

#### 2.3 过滤器

过滤器类似于python的内置函数，用来把视图传入的变量值加以修饰后再显示，具体语法如下

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123; 变量名|过滤器名:传给过滤器的参数 &#125;&#125;</span><br></pre></td></tr></table></figure>

常用内置过滤器

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、default</span></span><br><span class="line"><span class="comment">#作用：如果一个变量值是False或者为空，使用default后指定的默认值，否则，使用变量本身的值，如果value=’‘则输出“nothing”</span></span><br><span class="line">&#123;&#123; value|default:<span class="string">&quot;nothing&quot;</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、length</span></span><br><span class="line"><span class="comment">#作用：返回值的长度。它对字符串、列表、字典等容器类型都起作用，如果value是 [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]，那么输出是4</span></span><br><span class="line">&#123;&#123; value|length &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、filesizeformat</span></span><br><span class="line"><span class="comment">#作用：将值的格式化为一个&quot;人类可读的&quot;文件尺寸(如13KB、4.1 MB、102bytes等等），如果 value 是 12312312321，输出将会是 11.5 GB</span></span><br><span class="line">&#123;&#123; value|filesizeformat &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#4、date</span></span><br><span class="line"><span class="comment">#作用：将日期按照指定的格式输出，如果value=datetime.datetime.now(),按照格式Y-m-d则输出2019-02-02</span></span><br><span class="line">&#123;&#123; value|date:<span class="string">&quot;Y-m-d&quot;</span> &#125;&#125;　　</span><br><span class="line"></span><br><span class="line"><span class="comment">#5、slice</span></span><br><span class="line"><span class="comment">#作用：对输出的字符串进行切片操作，顾头不顾尾,如果value=“egon“，则输出&quot;eg&quot;</span></span><br><span class="line">&#123;&#123; value|slice:<span class="string">&quot;0:2&quot;</span> &#125;&#125;　</span><br><span class="line"></span><br><span class="line"><span class="comment">#6、truncatechars</span></span><br><span class="line"><span class="comment">#作用：如果字符串字符多于指定的字符数量，那么会被截断。截断的字符串将以可翻译的省略号序列（“...”）结尾，如果value=”hello world egon 嘎嘎“，则输出&quot;hello...&quot;,注意8个字符也包含末尾的3个点</span></span><br><span class="line">&#123;&#123; value|truncatechars:<span class="number">8</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#7、truncatewords</span></span><br><span class="line"><span class="comment">#作用：同truncatechars，但truncatewords是按照单词截断，注意末尾的3个点不算作单词，如果value=”hello world egon 嘎嘎“，则输出&quot;hello world ...&quot;</span></span><br><span class="line">&#123;&#123; value|truncatewords:<span class="number">2</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#8、safe</span></span><br><span class="line"><span class="comment">#作用：出于安全考虑，Django的模板会对HTML标签、JS等语法标签进行自动转义,例如value=&quot;&lt;script&gt;alert(123)&lt;/script&gt;&quot;，模板变量&#123;&#123; value &#125;&#125;会被渲染成&amp;lt;script&amp;gt;alert(123)&amp;lt;/script&amp;gt;交给浏览器后会被解析成普通字符”&lt;script&gt;alert(123)&lt;/script&gt;“，失去了js代码的语法意义，但如果我们就想让模板变量&#123;&#123; value &#125;&#125;被渲染的结果又语法意义，那么就用到了过滤器safe，比如value=&#x27;&lt;a href=&quot;https://www.baidu.com&quot;&gt;点我啊&lt;/a&gt;&#x27;，在被safe过滤器处理后就成为了真正的超链接，不加safe过滤器则会当做普通字符显示’&lt;a href=&quot;https://www.baidu.com&quot;&gt;点我啊&lt;/a&gt;‘</span></span><br><span class="line">&#123;&#123; value|safe &#125;&#125;</span><br></pre></td></tr></table></figure>

#### 2.4 示例

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 视图函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    n=<span class="number">123</span></span><br><span class="line">    file_size=<span class="number">123123123</span></span><br><span class="line">    <span class="keyword">import</span> datetime</span><br><span class="line">    current_time=datetime.datetime.now()</span><br><span class="line">    info=<span class="string">&#x27;目录 Django请求生命周期流程图 路由层(urls.py) 无名有名分组 反向解析 路由分发 名称空间 伪静态 虚拟环境 Django版本区别 1、Django请求生命周期流程图***** 缓存数据库： 提前将你想要的数据准备好了，拿来即用，提高效率和响应时间。 2、路由层(urls.py) urls.py文件 from django.conf…&#x27;</span></span><br><span class="line">    English=<span class="string">&#x27;like the way I&#x27;</span><span class="string">&#x27;m feeling inside&#x27;</span></span><br><span class="line">    hhh=<span class="string">&#x27;&lt;h1&gt;hello world！&lt;/h1&gt;&#x27;</span></span><br><span class="line">    sss=<span class="string">&#x27;&lt;script&gt;alert(123)&lt;/script&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 后端转义</span></span><br><span class="line">    <span class="keyword">from</span> django.utils.safestring <span class="keyword">import</span> mark_safe</span><br><span class="line">    res=mark_safe(<span class="string">&#x27;&lt;h1&gt;你好哇&lt;/h1&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    f=<span class="number">1.2</span></span><br><span class="line">    s=<span class="string">&#x27;你好哇&#x27;</span></span><br><span class="line">    b=<span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;index.html&#x27;</span>,locals())</span><br></pre></td></tr></table></figure>

index.html页面：

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>过滤器<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>统计长度：&#123;&#123; s|length &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>默认值，意思就是当前面的值的布尔值是True，那么就显示前面的值，如果不是True，那么就显示默认值：&#123;&#123; b|default:&#x27;默认值&#x27; &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>文件大小：&#123;&#123; file_size|filesizeformat &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>未处理之前的日期：&#123;&#123; current_time &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>日期格式化(默认是UTC时间)：&#123;&#123; current_time|date:&#x27;Y-m-d H:i:s&#x27; &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>切片操作(支持步长)：&#123;&#123; l|slice:&#x27;0:4:2&#x27; &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>切割字符(包含三个点)：&#123;&#123; info|truncatechars:19 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>切割单词(不包含三个点，中文英文都是按照空格切割)：&#123;&#123; English|truncatewords:4 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>移除特定的字符(此示例将空格都移除了)：&#123;&#123; English|cut:&#x27; &#x27; &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>拼接操作：&#123;&#123; l|join:&#x27;-&#x27; &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>拼接操作(加法运算)：&#123;&#123; n|add:20 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>拼接操作(字符串拼接)：&#123;&#123; s|add:English&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>转义(加一个safe，告诉浏览器按照HTML格式显示，默认是取消转义的)：&#123;&#123; hhh|safe &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>取消转义：&#123;&#123; sss &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>前端转义：&#123;&#123; sss|safe &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>转义：&#123;&#123; res &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

**补充：以后在写全栈项目时，前端代码不一定要在前端页面写，也可以在后端写好，然后转义后传递给前端页面**

<img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20210514022236870.png" alt="image-20210514022236870" style="zoom: 67%;" />



其他过滤器（了解）

| 过滤器             | 描述                                                     | 示例                                                         |
| ------------------ | -------------------------------------------------------- | ------------------------------------------------------------ |
| upper              | 以大写方式输出                                           | `&#123;&#123; user.name | upper &#125;&#125;</code>                                    |<br>| add                | 给value加上一个数值                                      | <code>&#123;&#123; user.age | add:”5” &#125;&#125;</code>                                   |<br>| addslashes         | 单引号加上转义号                                         |                                                              |<br>| capfirst           | 第一个字母大写                                           | <code>&#123;&#123; ‘good’| capfirst &#125;&#125; 返回”Good”</code>                          |<br>| center             | 输出指定长度的字符串，把变量居中                         | <code>&#123;&#123; “abcd”| center:”50” &#125;&#125;</code>                                  |<br>| cut                | 删除指定字符串                                           | <code>&#123;&#123; “You are not a Englishman” | cut:”not” &#125;&#125;</code>               |<br>| date               | 格式化日期                                               |                                                              |<br>| default            | 如果值不存在，则使用默认值代替                           | <code>&#123;&#123; value | default:”(N/A)” &#125;&#125;</code>                              |<br>| default_if_none    | 如果值为None, 则使用默认值代替                           |                                                              |<br>| dictsort           | 按某字段排序，变量必须是一个dictionary                   | <code>&#123;% for moment in moments | dictsort:”id” %&#125;</code>                |<br>| dictsortreversed   | 按某字段倒序排序，变量必须是dictionary                   |                                                              |<br>| divisibleby        | 判断是否可以被数字整除                                   | <code>&#123;&#123; 224 | divisibleby:2 &#125;&#125; 返回 True</code>                        |<br>| escape             | 按HTML转义，比如将”&lt;”转换为”&amp;lt”                         |                                                              |<br>| filesizeformat     | 增加数字的可读性，转换结果为13KB,89MB,3Bytes等           | <code>&#123;&#123; 1024 | filesizeformat &#125;&#125; 返回 1.0KB</code>                   |<br>| first              | 返回列表的第1个元素，变量必须是一个列表                  |                                                              |<br>| floatformat        | 转换为指定精度的小数，默认保留1位小数                    | <code>&#123;&#123; 3.1415926 | floatformat:3 &#125;&#125; 返回 3.142 四舍五入</code>        |<br>| get_digit          | 从个位数开始截取指定位置的数字                           | <code>&#123;&#123; 123456 | get_digit:’1’&#125;&#125;</code>                                |<br>| join               | 用指定分隔符连接列表                                     | <code>&#123;&#123; [‘abc’,’45’] | join:’*’ &#125;&#125; 返回 abc*45</code>                  |<br>| length             | 返回列表中元素的个数或字符串长度                         |                                                              |<br>| length_is          | 检查列表，字符串长度是否符合指定的值                     | <code>&#123;&#123; ‘hello’| length_is:’3’ &#125;&#125;</code>                               |<br>| linebreaks         | 用或 标签包裹变量                                        | <code>&#123;&#123; “Hi\n\nDavid”|linebreaks &#125;&#125; 返回HiDavid</code>                 |<br>| linebreaksbr       | 用 标签代替换行符                                        |                                                              |<br>| linenumbers        | 为变量中的每一行加上行号                                 |                                                              |<br>| ljust              | 输出指定长度的字符串，变量左对齐                         | <code>&#123;&#123;‘ab’|ljust:5&#125;&#125;返回 ‘ab ’</code>                                 |<br>| lower              | 字符串变小写                                             |                                                              |<br>| make_list          | 将字符串转换为列表                                       |                                                              |<br>| pluralize          | 根据数字确定是否输出英文复数符号                         |                                                              |<br>| random             | 返回列表的随机一项                                       |                                                              |<br>| removetags         | 删除字符串中指定的HTML标记                               | <code>&#123;&#123;value | removetags: “h1 h2”&#125;&#125;</code>                            |<br>| rjust              | 输出指定长度的字符串，变量右对齐                         |                                                              |<br>| slice              | 切片操作， 返回列表                                      | <code>&#123;&#123;[3,9,1] | slice:’:2’&#125;&#125; 返回 [3,9]</code> <code>&#123;&#123; 'asdikfjhihgie' | slice:':5' &#125;&#125; 返回 ‘asdik’</code> |<br>| slugify            | 在字符串中留下减号和下划线，其它符号删除，空格用减号替换 | <code>&#123;&#123; '5-2=3and5 2=3' | slugify &#125;&#125; 返回 5-23and5-23</code>           |<br>| stringformat       | 字符串格式化，语法同python                               |                                                              |<br>| time               | 返回日期的时间部分                                       |                                                              |<br>| timesince          | 以“到现在为止过了多长时间”显示时间变量                   | 结果可能为 45days, 3 hours                                   |<br>| timeuntil          | 以“从现在开始到时间变量”还有多长时间显示时间变量         |                                                              |<br>| title              | 每个单词首字母大写                                       |                                                              |<br>| truncatewords      | 将字符串转换为省略表达方式                               | <code>&#123;&#123; 'This is a pen' | truncatewords:2 &#125;&#125;返回``This is ...</code>   |<br>| truncatewords_html | 同上，但保留其中的HTML标签                               | <code>&#123;&#123; '<p>This is a pen</p>' | truncatewords:2 &#125;&#125;返回``&lt;p&gt;This is ...&lt;/p&gt;</code> |<br>| urlencode          | 将字符串中的特殊字符转换为url兼容表达方式                | <code>&#123;&#123; ‘http://www.aaa.com/foo?a=b&b=c’ | urlencode&#125;&#125;</code>          |<br>| urlize             | 将变量字符串中的url由纯文本变为链接                      |                                                              |<br>| wordcount          | 返回变量字符串中的单词数                                 |                                                              |<br>| yesno              | 将布尔变量转换为字符串yes, no 或maybe                    | <code>&#123;&#123; True | yesno &#125;&#125;&#123;&#123; False | yesno &#125;&#125;&#123;&#123; None | yesno &#125;&#125; ``返回 ``yes``no ``maybe</code> |</p>
<h2 id="补充：django中处理XSS攻击的方式"><a href="#补充：django中处理XSS攻击的方式" class="headerlink" title="补充：django中处理XSS攻击的方式"></a>补充：django中处理XSS攻击的方式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Django中XSS攻击就是跨站脚本攻击，就是利用HTML对页面进行恶意的标签渲染，从而达到攻击网站的效果，更严重的情况是直接获取用户信息，对网站造成巨大损失。</span><br><span class="line">只不过Django自动帮我们做了这个防护功能，我们可以不必刻意做这些保护，但是对于开发者而言，在调用或者解除这些限制的时候要注意，不要留下漏洞。</span><br><span class="line">解除限制很简单，有两种方式。</span><br><span class="line">str&#x3D;&#39;&lt;a href&#x3D;&quot;&#x2F;page?page&#x3D;1&quot;&gt;1&lt;&#x2F;a&gt;&#39;</span><br><span class="line"></span><br><span class="line">（1）在前端模板语言中实现，只须用到帮助函数safe.如：</span><br><span class="line"></span><br><span class="line">　　&#123;&#123; str|safe &#125;&#125;</span><br><span class="line"></span><br><span class="line">（2）在后端views中实现：</span><br><span class="line"></span><br><span class="line">　　from django.utils.safestring import mark_safe</span><br><span class="line"></span><br><span class="line">　　str &#x3D; mark_safe(str)</span><br></pre></td></tr></table></figure>



<h2 id="三-模板语法之标签"><a href="#三-模板语法之标签" class="headerlink" title="三 模板语法之标签"></a>三 模板语法之标签</h2><p>标签是为了在模板中完成一些特殊功能,语法为<code>&#123;% 标签名 %&#125;</code>，一些标签还需要搭配结束标签 <code>&#123;% endtag %&#125;</code></p>
<h4 id="3-0-示例"><a href="#3-0-示例" class="headerlink" title="3.0 示例"></a>3.0 示例</h4><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>标签<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">&#123;% for foo in l %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; forloop &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过first和last是否为True来判断是不是第一次循环和最后一次循环，counter0就类似于索引值，counter就类似于计数：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20210514032000339.png" alt="image-20210514032000339"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;#将列表值打印出来#&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>标签<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">&#123;% for foo in l %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20210514032057089.png" alt="image-20210514032057089"></p>
<h5 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a><strong>if判断</strong></h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if b %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是True<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% else %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是False<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20210514032416998.png" alt="image-20210514032416998"></p>
<h5 id="for和if混合使用"><a href="#for和if混合使用" class="headerlink" title="for和if混合使用"></a>for和if混合使用</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% for foo in l %&#125;</span><br><span class="line">    &#123;% if forloop.first %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第一次循环<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% elif forloop.last %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是最后一次循环<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% else %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    &#123;% empty %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>for循环的可迭代对象内部没有元素，无法循环；例如lll=[],如果循环这个空列表时，就会符合empty这一循环<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20210514032954191.png" alt="image-20210514032954191"></p>
<p>补充：for循环的可迭代对象为空，则执行empty</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lll = []</span><br><span class="line"></span><br><span class="line">&#123;% <span class="keyword">for</span> foo <span class="keyword">in</span> lll %&#125;</span><br><span class="line">    &#123;% <span class="keyword">if</span> forloop.first %&#125;</span><br><span class="line">        &lt;p&gt;这是第一次打印&lt;/p&gt;</span><br><span class="line">    &#123;% <span class="keyword">elif</span> forloop.last %&#125;</span><br><span class="line">        &lt;p&gt;这是最后一次打印&lt;/p&gt;</span><br><span class="line">    &#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">        &lt;p&gt;&#123;&#123; foo &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    &#123;% empty %&#125;</span><br><span class="line">        &lt;p&gt;or循环的可迭代对象为空 没法循环&lt;/p&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20210514033307862.png" alt="image-20210514033307862"></p>
<h5 id="对字典的处理"><a href="#对字典的处理" class="headerlink" title="对字典的处理"></a>对字典的处理</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% for foo in d.keys %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&#123;% for foo in d.values %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&#123;% for foo in d.items %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20210514033430666.png"></p>
<h5 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% with d.username as username %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; username &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    在with语法内就可以通过as后面的别名快速的使用到前面通过复杂方式获取到的数据</span><br><span class="line">&#123;% endwith %&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-1-常用标签之for标签"><a href="#3-1-常用标签之for标签" class="headerlink" title="3.1 常用标签之for标签"></a>3.1 常用标签之for标签</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、遍历每一个元素：</span></span><br><span class="line">&#123;% <span class="keyword">for</span> person <span class="keyword">in</span> person_list %&#125;</span><br><span class="line">    &lt;p&gt;&#123;&#123; person.name &#125;&#125;&lt;/p&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、可以利用&#123;% for obj in list reversed %&#125;反向循环。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3、遍历一个字典：</span></span><br><span class="line">&#123;% <span class="keyword">for</span> key,val <span class="keyword">in</span> dic.items %&#125;</span><br><span class="line">    &lt;p&gt;&#123;&#123; key &#125;&#125;:&#123;&#123; val &#125;&#125;&lt;/p&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#4、循环序号可以通过&#123;&#123; forloop &#125;&#125;显示　</span></span><br><span class="line">forloop.counter            当前循环的索引值（从<span class="number">1</span>开始）</span><br><span class="line">forloop.counter0           当前循环的索引值（从<span class="number">0</span>开始）</span><br><span class="line">forloop.revcounter         当前循环的倒序索引值（从<span class="number">1</span>开始）</span><br><span class="line">forloop.revcounter0        当前循环的倒序索引值（从<span class="number">0</span>开始）</span><br><span class="line">forloop.first              当前循环是第一次循环则返回<span class="literal">True</span>，否则返回<span class="literal">False</span></span><br><span class="line">forloop.last               当前循环是最后一次循环则返回<span class="literal">True</span>，否则返回<span class="literal">False</span></span><br><span class="line">forloop.parentloop         本层循环的外层循环</span><br><span class="line"></span><br><span class="line"><span class="comment">#5、for标签可以带有一个可选的&#123;% empty %&#125; 从句，在变量person_list为空或者没有被找到时，则执行empty子句</span></span><br><span class="line">&#123;% <span class="keyword">for</span> person <span class="keyword">in</span> person_list %&#125;</span><br><span class="line">    &lt;p&gt;&#123;&#123; person.name &#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&#123;% empty %&#125;</span><br><span class="line">    &lt;p&gt;sorry,no person here&lt;/p&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p>url.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> re_path</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r&#x27;^test/&#x27;</span>,views.test)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>view.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">request</span>):</span></span><br><span class="line">    names=[<span class="string">&#x27;egon&#x27;</span>,<span class="string">&#x27;kevin&#x27;</span>]</span><br><span class="line">    dic=&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;egon&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">    list1=[]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;test.html&#x27;</span>,locals())</span><br></pre></td></tr></table></figure>

<p>test.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">&#123;% for name in names %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; forloop.counter0 &#125;&#125; &#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">输出结果为：</span></span><br><span class="line"><span class="comment">0 egon</span></span><br><span class="line"><span class="comment">1 kevin</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">&#123;% for name in names reversed %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; forloop.revcounter0 &#125;&#125; &#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">输出结果为：</span></span><br><span class="line"><span class="comment">1 kevin</span></span><br><span class="line"><span class="comment">0 egon</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">&#123;% for k,v in dic.items %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; forloop.counter &#125;&#125; &#123;&#123; k &#125;&#125; &#123;&#123; v &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">输出结果为：</span></span><br><span class="line"><span class="comment">1 name egon</span></span><br><span class="line"><span class="comment">2 age 18</span></span><br><span class="line"><span class="comment">3 sex male</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">&#123;% for item in list1 %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% empty %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>sorry,no value here<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">输出结果为：</span></span><br><span class="line"><span class="comment">sorry,no value here</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-常用标签之if标签"><a href="#3-2-常用标签之if标签" class="headerlink" title="3.2 常用标签之if标签"></a>3.2 常用标签之if标签</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、注意：</span></span><br><span class="line">&#123;% <span class="keyword">if</span> 条件 %&#125;条件为真时<span class="keyword">if</span>的子句才会生效，条件也可以是一个变量，<span class="keyword">if</span>会对变量进行求值，在变量值为空、或者视图没有为其传值的情况下均为<span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、具体语法</span></span><br><span class="line">&#123;% <span class="keyword">if</span> num &gt; <span class="number">100</span> <span class="keyword">or</span> num &lt; <span class="number">0</span> %&#125;</span><br><span class="line">    &lt;p&gt;无效&lt;/p&gt;</span><br><span class="line">&#123;% <span class="keyword">elif</span> num &gt; <span class="number">80</span> <span class="keyword">and</span> num &lt; <span class="number">100</span> %&#125;</span><br><span class="line">    &lt;p&gt;优秀&lt;/p&gt;</span><br><span class="line">&#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">    &lt;p&gt;凑活吧&lt;/p&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、if语句支持 and 、or、==、&gt;、&lt;、!=、&lt;=、&gt;=、in、not in、is、is not判断。</span></span><br></pre></td></tr></table></figure>



<h5 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h5><p>urls.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,register_converter,re_path</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># 输入http://127.0.0.1:8008/或者http://127.0.0.1:8008/index/都会转发给视图函数index</span></span><br><span class="line">    re_path(<span class="string">r&#x27;^$&#x27;</span>,views.index),</span><br><span class="line">    re_path(<span class="string">r&#x27;^index/$&#x27;</span>,views.index),</span><br><span class="line">    </span><br><span class="line">    re_path(<span class="string">r&#x27;^login/&#x27;</span>,views.login),</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>views.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;login.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    name=request.POST.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    pwd=request.POST.get(<span class="string">&#x27;pwd&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&#x27;egon&#x27;</span> <span class="keyword">and</span> pwd == <span class="string">&#x27;123&#x27;</span>:</span><br><span class="line">        current_user=name</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;index.html&#x27;</span>,locals())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        msg=<span class="string">&#x27;账号或密码错误&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;login.html&#x27;</span>,locals())</span><br></pre></td></tr></table></figure>

<p>在templates目录下新建模板文件index.html与login.html</p>
<p>index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">如果用户已经登录，则current_user变量有值，if判断结果为真，会打印变量current_user的值，为当前登录的用户名</span></span><br><span class="line"><span class="comment">如果用户没有登录，则current_user变量无值，if判断结果为假，会打印a标签要求用户先登录</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">&#123;% if current_user %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>当前登录用户为：&#123;&#123; current_user &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/login/&quot;</span>&gt;</span>请先登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>login.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--输错账号密码时的提示信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py runserver <span class="number">8008</span> <span class="comment">#在浏览器输入http://127.0.0.1:8008/,然后点击登录，输入账号密码进行验证......</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-常用标签之with标签（别名）"><a href="#3-3-常用标签之with标签（别名）" class="headerlink" title="3.3 常用标签之with标签（别名）"></a>3.3 常用标签之with标签（别名）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># with标签用来为一个复杂的变量名起别名,如果变量的值来自于数据库，在起别名后只需要使用别名即可，无需每次都向数据库发送请求来重新获取变量的值</span></span><br><span class="line">&#123;% <span class="keyword">with</span> li<span class="number">.1</span>.upper <span class="keyword">as</span> v %&#125;</span><br><span class="line">    &#123;&#123; v &#125;&#125;</span><br><span class="line">&#123;% endwith %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-常用标签之csrf-token标签"><a href="#3-4-常用标签之csrf-token标签" class="headerlink" title="3.4 常用标签之csrf_token标签"></a>3.4 常用标签之csrf_token标签</h4><p>会被渲染成一个隐藏的input标签，该标签包含了由服务端生成的一串随机字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当用form表单提交POST请求时必须加上标签&#123;% csrf_token%&#125;，该标签用于防止跨站伪造请求</span></span><br><span class="line">&lt;form action=<span class="string">&quot;&quot;</span> method=<span class="string">&quot;POST&quot;</span>&gt;</span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    &lt;p&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"><span class="comment"># 具体工作原理为：</span></span><br><span class="line"><span class="comment"># 1、在GET请求到form表单时，标签&#123;% csrf_token%&#125;会被渲染成一个隐藏的input标签，该标签包含了由服务端生成的一串随机字符串,如&lt;input type=&quot;hidden&quot; name=&quot;csrfmiddlewaretoken&quot; value=&quot;dmje28mFo...OvnZ5&quot;&gt;</span></span><br><span class="line"><span class="comment"># 2、在使用form表单提交POST请求时，会提交上述随机字符串，服务端在接收到该POST请求时会对比该随机字符串，对比成功则处理该POST请求，否则拒绝，以此来确定客户端的身份</span></span><br></pre></td></tr></table></figure>

<h2 id="四-自定义过滤器和标签-inclusion-tag"><a href="#四-自定义过滤器和标签-inclusion-tag" class="headerlink" title="四 自定义过滤器和标签,inclusion tag"></a>四 自定义过滤器和标签,inclusion tag</h2><h4 id="自定义过滤器-最多只能有两个参数"><a href="#自定义过滤器-最多只能有两个参数" class="headerlink" title="自定义过滤器(最多只能有两个参数)"></a>自定义过滤器(最多只能有两个参数)</h4><p>先做好准备：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、在应用下创建一个名字必须叫’templatetags‘文件夹</span><br><span class="line"><span class="number">2</span>、在该文件夹内创建任意名称的py文件，例如mytag.py</span><br><span class="line"><span class="number">3</span>、在该文件内必须写上代码：</span><br><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> template</span><br><span class="line">register = template.Library()</span><br></pre></td></tr></table></figure>

<p>mytag.py文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> template</span><br><span class="line">register = template.Library()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义过滤器</span></span><br><span class="line"><span class="meta">@register.filter(name=&#x27;baby&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_sum</span>(<span class="params">v1,v2</span>):</span>   <span class="comment"># 两个数字相加的过滤器</span></span><br><span class="line">    <span class="keyword">return</span> v1+v2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义标签</span></span><br><span class="line"><span class="meta">@register.simple_tag(name=&#x27;plus&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">a,b,c,d,参数等等</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;%s-%s-%s-%s&#x27;</span>%(a,b,c,d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义inclusion_tag</span></span><br><span class="line"><span class="comment"># 内部原理：先定义一个方法，在页面上调用该方法，并且可以传值，该方法会生成一些数据然后传递给一个HTML页面</span></span><br><span class="line"><span class="comment"># 之后将渲染好的结果放到调用的位置</span></span><br><span class="line"><span class="meta">@register.inclusion_tag(&#x27;left_menu.html&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left</span>(<span class="params">n</span>):</span></span><br><span class="line">    data = [<span class="string">&#x27;第&#123;&#125;项&#x27;</span>.format(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]  <span class="comment"># 这是一个列表生成式</span></span><br><span class="line">    <span class="comment"># 第一种方式将data传递给left_menu.html</span></span><br><span class="line">    <span class="comment"># return &#123;&#x27;data&#x27;:data&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第二种方式将data传递给left_menu.html，建议使用</span></span><br><span class="line">    <span class="keyword">return</span> locals()</span><br><span class="line"><span class="comment"># 总结：当html页面某一个地方的页面需要传参数才能动态的渲染出来，并且在多个页面上都需要使用到该局部 那么就考虑将该局部页面做成inclusion_tag形式</span></span><br></pre></td></tr></table></figure>

<p>index.html页面使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>自定义过滤器<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">&#123;% load mytag %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; n|baby:666 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>自定义标签<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">&#123;% load mytag %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>标签多个参数彼此之间空格隔开：&#123;% plus &#x27;jason&#x27; 12 12 12 %&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>自定义inclusion_tag<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>当HTML页面某个地方需要传参数才能够动态的渲染出来,并且在多个页面上都需要使用该局部，那么就可以考虑将该局部页面做成inclusion_tag形式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% load mytag %&#125;</span><br><span class="line">&#123;% left 6  %&#125;</span><br></pre></td></tr></table></figure>

<p>left_menu.html页面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;#清空之后，输入如下即可#&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &#123;% for foo in data %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-7148c19efae42ff18ce4cc773b4bc657_1440w.jpg" alt="img"></p>
<p>当内置的过滤器或标签无法满足我们需求时，我们可以自定义，具体操作步骤如下</p>
<p>1、在settings中的INSTALLED_APPS添加当前app的名字，不然django无法找到自定义的过滤器或标签</p>
<p>settings.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在settings.py中找到该列表，然后加以配置</span></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.contenttypes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;app01.apps.App01Config&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;app01&#x27;</span>, <span class="comment"># 添加当前app的名字</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>2、在文件夹app01中创建子文件夹templatetags(文件夹名只能是templatetags)</p>
<p>3、在templatetags新建任意.py文件，如my_tags.py，在该文件中自定义过滤器或标签，文件内容如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> template</span><br><span class="line">register = template.Library() <span class="comment"># 注意变量名必须为register,不可改变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1、自定义过滤器</span></span><br><span class="line"><span class="meta">@register.filter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_multi_filter</span>(<span class="params">v1 ,v2</span>):</span> <span class="comment"># 自定义的过滤器只能定义最多两个参数，针对&#123;&#123; value1 | filter_multi:value2 &#125;&#125;，参数传递为v1=value1,v2=value2</span></span><br><span class="line">    <span class="keyword">return</span>  v1 * v2</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、自定义标签</span></span><br><span class="line"><span class="meta">@register.simple_tag</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_multi_tag</span>(<span class="params">v1, v2</span>):</span> <span class="comment"># 自定义的标签可以定义多个参数</span></span><br><span class="line">    <span class="keyword">return</span> v1 * v2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#3、自定义标签扩展之mark_safe</span></span><br><span class="line"><span class="comment"># 注释：我们可以用内置的标签safe来让标签内容有语法意义，如果我们想让自定义标签处理的结果也有语法意义，则不能使用内置标签safe了，需要使用mark_safe，可以实现与内置标签safe同样的功能</span></span><br><span class="line"><span class="keyword">from</span> django.utils.safestring <span class="keyword">import</span> mark_safe</span><br><span class="line"></span><br><span class="line"><span class="meta">@register.simple_tag</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_input_tag</span>(<span class="params">id, name</span>):</span></span><br><span class="line">    res = <span class="string">&quot;&lt;input type=&#x27;text&#x27; id=&#x27;%s&#x27; name=&#x27;%s&#x27; /&gt;&quot;</span> % (id, name)</span><br><span class="line">    <span class="keyword">return</span> mark_safe(res)</span><br></pre></td></tr></table></figure>

<p>4、自定义过滤器或标签必须重新启动django方可生效</p>
<p>5、自定义过滤器或标签的使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--必须先加载存有自定义过滤器和标签的文件--&gt;</span></span><br><span class="line">&#123;% load my_tags %&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--salary的值为10，经过滤器my_multi_filter的处理结果为120--&gt;</span></span><br><span class="line">&#123;&#123; salary|my_multi_filter:12 &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--结果为2--&gt;</span></span><br><span class="line">&#123;% my_multi_tag 1 2 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">结果为一个input标签，该表的属性id=&quot;inp1&quot; name=&quot;username&quot;</span></span><br><span class="line"><span class="comment">注意：input的属性值均为字符串类型，所以my_input_tag后的两个值均为字符串类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">&#123;% my_input_tag &quot;inp1&quot; &quot;username&quot; %&#125; </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对比自定义标签与自定义过滤器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、自定义过滤器只能传两个参数，而自定义标签却可以传多个参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2、过滤器可以用于if判断，而标签不能</span></span><br><span class="line">&#123;% <span class="keyword">if</span> salary|my_multi_filter:<span class="number">12</span> &gt; <span class="number">200</span> %&#125;</span><br><span class="line">    &lt;p&gt;优秀&lt;/p&gt;</span><br><span class="line">&#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">    &lt;p&gt;垃圾&lt;/p&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>





<h2 id="五-模板的导入和继承"><a href="#五-模板的导入和继承" class="headerlink" title="五 模板的导入和继承"></a>五 模板的导入和继承</h2><h4 id="5-1、模板的继承-派生之extends标签、block标签"><a href="#5-1、模板的继承-派生之extends标签、block标签" class="headerlink" title="5.1、模板的继承\派生之extends标签、block标签"></a>5.1、模板的继承\派生之extends标签、block标签</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">有些网站页面整体没有太大变化，只有一些局部在做变化。</span><br><span class="line">先选好要继承哪个页面：</span><br><span class="line">`&#123;% extends <span class="string">&#x27;home.html&#x27;</span> %&#125;`</span><br><span class="line">在主页面划定好哪个部分是可以被替换的：</span><br><span class="line">`&#123;% block content %&#125;`</span><br><span class="line">`&#123;% endblock %&#125;`</span><br><span class="line">子页面继承模板页面后是跟模板页面一模一样的，需要在子页面上修改可以被替换的那部分。</span><br><span class="line"></span><br><span class="line">一般情况下，模板页面上应该至少有三块可以被修改的区域：</span><br><span class="line"><span class="number">1</span>、css区域</span><br><span class="line"><span class="number">2</span>、HTML区域</span><br><span class="line"><span class="number">3</span>、js区域</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">&#123;% block js %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block css %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">#    子页面除了可以自己写自己的外，还可以继续使用模板页面的内容#&#125;</span></span><br><span class="line">    &#123;&#123; block.super &#125;&#125;</span><br><span class="line">    &#123;&#123; block.super &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每一个页面都有自己独有的css代码，html代码，js代码，好维护</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一般来说，模板页面上划定的区域越多，该模板的扩展性越高，但是太多的话，还不如自己写。</span></span><br></pre></td></tr></table></figure>



<p>views.py文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;home.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;login.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;register.html&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>home.html页面：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;jQuery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;link href=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &#123;% block css %&#125;</span><br><span class="line">    </span><br><span class="line">    &#123;% endblock %&#125;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;nav class=&quot;navbar navbar-inverse&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;container-fluid&quot;&gt;</span><br><span class="line">        &lt;!-- Brand and toggle get grouped for better mobile display --&gt;</span><br><span class="line">        &lt;div class=&quot;navbar-header&quot;&gt;</span><br><span class="line">            &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot;</span><br><span class="line">                    data-target=<span class="string">&quot;#bs-example-navbar-collapse-1&quot;</span> aria-expanded=<span class="string">&quot;false&quot;</span>&gt;</span><br><span class="line">                &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt;</span><br><span class="line">                &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;</span><br><span class="line">                &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;</span><br><span class="line">                &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">            &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Brand&lt;/a&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- Collect the nav links, forms, and other content for toggling --&gt;</span><br><span class="line">        &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt;</span><br><span class="line">            &lt;ul class=&quot;nav navbar-nav&quot;&gt;</span><br><span class="line">                &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Link &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li class=&quot;dropdown&quot;&gt;</span><br><span class="line">                    &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot;</span><br><span class="line">                       aria-expanded=&quot;false&quot;&gt;Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">                    &lt;ul class=&quot;dropdown-menu&quot;&gt;</span><br><span class="line">                        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                        &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt;</span><br><span class="line">                        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                        &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt;</span><br><span class="line">                        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;One more separated link&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                    &lt;/ul&gt;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">            &lt;form class=&quot;navbar-form navbar-left&quot;&gt;</span><br><span class="line">                &lt;div class=&quot;form-group&quot;&gt;</span><br><span class="line">                    &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot;&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt;</span><br><span class="line">            &lt;/form&gt;</span><br><span class="line">            &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li class=&quot;dropdown&quot;&gt;</span><br><span class="line">                    &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot;</span><br><span class="line">                       aria-expanded=&quot;false&quot;&gt;Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">                    &lt;ul class=&quot;dropdown-menu&quot;&gt;</span><br><span class="line">                        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                        &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt;</span><br><span class="line">                        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                    &lt;/ul&gt;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt;</span><br><span class="line">    &lt;/div&gt;&lt;!-- /.container-fluid --&gt;</span><br><span class="line">&lt;/nav&gt;</span><br><span class="line">&lt;div class=&quot;container-fluid&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;row&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;col-md-3 col-xs-3&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;list-group&quot;&gt;</span><br><span class="line">                &lt;a href=&quot;/home/&quot; class=&quot;list-group-item active&quot;&gt;</span><br><span class="line">                    首页</span><br><span class="line">                &lt;/a&gt;</span><br><span class="line">                &lt;a href=&quot;/login/&quot; class=&quot;list-group-item&quot;&gt;登录&lt;/a&gt;</span><br><span class="line">                &lt;a href=&quot;/register/&quot; class=&quot;list-group-item&quot;&gt;注册&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;col-md-9 col-xs-9&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;panel panel-primary&quot;&gt;</span><br><span class="line">                &lt;div class=&quot;panel-heading&quot;&gt;</span><br><span class="line">                    &lt;h3 class=&quot;panel-title&quot;&gt;Panel title&lt;/h3&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;panel-body&quot;&gt;</span><br><span class="line">                    &#123;% block content %&#125;</span><br><span class="line">                        &lt;div class=&quot;jumbotron&quot;&gt;</span><br><span class="line">                            &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">                            &lt;p&gt;...&lt;/p&gt;</span><br><span class="line">                            &lt;p&gt;&lt;a class=&quot;btn btn-primary btn-lg&quot; href=&quot;#&quot; role=&quot;button&quot;&gt;Learn more&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                    &#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% block js %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>login.html页面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;home.html&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;#每个页面都可以有自己独有的css\js\html#&#125;</span><br><span class="line">&#123;% block css %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    h1&#123;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>登录页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;#    子页面除了可以自己写自己的外，还可以继续使用模板页面的内容#&#125;</span><br><span class="line">    &#123;&#123; block.super &#125;&#125;</span><br><span class="line">    &#123;&#123; block.super &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block js %&#125;</span><br><span class="line">&#123;#    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="string">&#x27;登录页面&#x27;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>#&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>register.html页面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;home.html&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>注册页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-2、模板的导入之include标签"><a href="#5-2、模板的导入之include标签" class="headerlink" title="5.2、模板的导入之include标签"></a>5.2、模板的导入之include标签</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">将页面的某个局部当成模块的形式，哪个地方需要就可以直接导入使用。</span><br><span class="line"></span><br><span class="line"><span class="comment">#作用：在一个模板文件中，引入/重用另外一个模板文件的内容，</span></span><br><span class="line">&#123;% include <span class="string">&#x27;模版名称&#x27;</span> %&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在创建一个ok.html页面，供其他页面引用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h3&gt;this is a nice form table!!!!!&lt;&#x2F;h3</span><br></pre></td></tr></table></figure>

<p>register.html页面导入ok.html使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% extends <span class="string">&#x27;home.html&#x27;</span> %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    &lt;h1&gt;注册页面&lt;/h1&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">    &lt;p&gt;username: &lt;input type=&quot;text&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;password: &lt;input type=&quot;text&quot;&gt;&lt;/p&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">    &lt;p&gt;模板的导入：&lt;/p&gt;</span><br><span class="line">    &#123;% include <span class="string">&#x27;ok.html&#x27;</span> %&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>



<p>总结与注意</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、标签extends必须放在首行，base.html中block越多可定制性越强</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2、include仅仅只是完全引用其他模板文件，而extends却可以搭配block在引用的基础上进行扩写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3、变量&#123;&#123; block.super &#125;&#125; 可以重用父类的内容，然后在父类基础上增加新内容，而不是完全覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4、为了提升可读性，我们可以给标签&#123;% endblock %&#125; 起一个名字 。例如：</span></span><br><span class="line">    &#123;% block content %&#125;</span><br><span class="line">    ...</span><br><span class="line">    &#123;% endblock content %&#125;　　</span><br><span class="line"><span class="comment">#5、在一个模版中不能出现重名的block标签。</span></span><br></pre></td></tr></table></figure>





<h2 id="静态文件配置"><a href="#静态文件配置" class="headerlink" title="静态文件配置"></a>静态文件配置</h2><p>我们在编写模板文件时，需要大量引用css、js、图片等静态文件，如果我们将这些文件在服务端存放的路径都固定写死那么将非常不利于后期的扩展，我们可以这么做</p>
<p>1、settings.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">STATIC_URL = <span class="string">&#x27;/static/&#x27;</span> <span class="comment"># 找到这一行，然后新增下述代码</span></span><br><span class="line">STATICFILES_DIRS = [</span><br><span class="line">    os.path.join(BASE_DIR, <span class="string">&#x27;statics&#x27;</span>),<span class="comment"># 获取静态文件在服务端的绝对路径</span></span><br><span class="line">]</span><br><span class="line"><span class="comment">#STATIC_URL = &#x27;/static/&#x27;就是为静态文件的绝对路径起了一个别名，以后我们只需要用路径/static/即可；相当于一个令牌，找静态文件以后会遍历STATICFILES_DIRS去找</span></span><br></pre></td></tr></table></figure>

<p>2、在项目根目录下新增文件夹statics，为了更便于管理，可以在statics下新建子文件夹css、js、img等</p>
<p>[<img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1825659-20191011222645014-1230254081.gif" alt="statics目录结构"></p>
<p>3、新建模板文件index.html,在该文件中对静态文件的引用如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/static/css/my.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>我是红色的，点我就绿<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/static/img/rb.jpeg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/static/js/jquery-3.3.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/static/js/my.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>综上，在配置完settings.py后，所有的静态文件路径都可以采用别名/static/作为起始，这在一定程度上会有利于程序的扩展性，但如果我们在项目后期维护时，连/static/这个值也需要修改，那意味着所有模板文件中也都需要跟着改了，扩展性依然很差，为此，django在一个名为static.py的文件中定义了标签static、get_static_prefix，二者都可以解决该问题</p>
<p>静态文件动态解析</p>
<p>test.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注意：必须先加载文件static.py--&gt;</span></span><br><span class="line">    &#123;% load static %&#125;</span><br><span class="line">    <span class="comment">&lt;!--注意：此处的static是一个定义在static.py中的一个标签，名字与文件名一样而已，不要搞混--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% static &#x27;css/my.css&#x27; %&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>我是红色的，点我就绿<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% static &#x27;img/rb.jpeg&#x27; %&#125;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% load static %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% static &#x27;js/jquery-3.3.1.min.js&#x27; %&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% static &#x27;js/my.js&#x27; %&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>标签static会接收传入的参数，然后这根据settings.py中变量STATIC_URL的值拼接出一个完整的路径，如果<code>STATIC_URL = &#39;/static/&#39;</code>，那么<code>href=&quot;&#123;% static 'css/my.css' %&#125;&quot;</code>会被渲染成<code>href=&quot;/static/css/my.css&quot;</code>，如果<code>STATIC_URL = &#39;/static123/&#39;</code>，那么<code>href=&quot;&#123;% static 'css/my.css' %&#125;&quot;</code>会被渲染成href=”/static123/css/my.css”。</p>
<p>标签get_static_prefix也可以完成同样的效果，只不过用法不同。我们不能为标签get_static_prefix传参，因为标签get_static_prefix代表的只是settings.py中STATIC_URL的值，所以我们需要做的是在get_static_prefix的基础上自行拼接路径，如下</p>
<p>test.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注意：同样需要先加载文件static.py--&gt;</span></span><br><span class="line">    &#123;% load static %&#125;</span><br><span class="line">    <span class="comment">&lt;!--使用标签get_static_prefix拼接路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% get_static_prefix %&#125;css/my.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>我是红色的，点我就绿<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% get_static_prefix %&#125;img/rb.jpeg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% load static %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% get_static_prefix %&#125;js/jquery-3.3.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% get_static_prefix %&#125;js/my.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果STATIC_URL = ‘/static/‘，那么<code>href=&quot;&#123;% get_static_prefix %&#125;css/my.css&quot;</code>会被渲染成href=”/static/css/my.css”，其它同理</p>
<p>[<img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1825659-20191011222645341-941881794..png" alt="1554200021270"></p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>08-Django进阶-模型-单表</title>
    <url>/posts/63794.html</url>
    <content><![CDATA[<p>Django Models 单表</p>
<a id="more"></a>



<h1 id="补充-QuerySet"><a href="#补充-QuerySet" class="headerlink" title="补充:QuerySet"></a>补充:QuerySet</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">想要从数据库内检索对象，你需要基于模型类，通过管理器（Manager）操作数据库并返回一个查询结果集（QuerySet）。</span><br><span class="line"></span><br><span class="line">每个QuerySet代表一些数据库对象的集合。它可以包含零个、一个或多个过滤器（filters）。Filters缩小查询结果的范围。在SQL语法中，一个QuerySet相当于一个SELECT语句，而filter则相当于WHERE或者LIMIT一类的子句。</span><br><span class="line"></span><br><span class="line">每个模型至少具有一个Manager，默认情况下，Django自动为我们提供了一个，也是最常用最重要的一个，99%的情况下我们都只使用它。它被称作objects，可以通过模型类直接调用它，但不能通过模型类的实例调用它，以此实现“表级别”操作和“记录级别”操作的强制分离。</span><br></pre></td></tr></table></figure>

<h2 id="一-ORM简介"><a href="#一-ORM简介" class="headerlink" title="一 ORM简介"></a>一 ORM简介</h2><p>查询数据层次图解：如果操作mysql，ORM是在pymysq之上又进行了一层封装</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gj1wrzhtrsj30jk0fiq4u.jpg" alt="image-20200924181833097"></p>
<ul>
<li>MVC或者MTV框架中包括一个重要的部分，就是ORM，它实现了数据模型与数据库的解耦，即数据模型的设计不需要依赖于特定的数据库，通过简单的配置就可以轻松更换数据库，这极大的减轻了开发人员的工作量，不需要面对因数据库变更而导致的无效劳动</li>
<li>ORM是“对象-关系-映射”的简称。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gj1wsfg8wkj314e0i24bb.jpg" alt="image-20200924181858413"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sql中的表                                                      </span></span><br><span class="line"></span><br><span class="line"> <span class="comment">#创建表:</span></span><br><span class="line">     CREATE TABLE employee(                                     </span><br><span class="line">                id INT PRIMARY KEY auto_increment ,                    </span><br><span class="line">                name VARCHAR (<span class="number">20</span>),                                      </span><br><span class="line">                gender BIT default <span class="number">1</span>,                                  </span><br><span class="line">                birthday DATA ,                                         </span><br><span class="line">                department VARCHAR (<span class="number">20</span>),                                </span><br><span class="line">                salary DECIMAL (<span class="number">8</span>,<span class="number">2</span>) unsigned,                          </span><br><span class="line">              );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">#sql中的表纪录                                                  </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#添加一条表纪录:                                                          </span></span><br><span class="line">      INSERT employee (name,gender,birthday,salary,department)            </span><br><span class="line">             VALUES   (<span class="string">&quot;alex&quot;</span>,<span class="number">1</span>,<span class="string">&quot;1985-12-12&quot;</span>,<span class="number">8000</span>,<span class="string">&quot;保洁部&quot;</span>);               </span><br><span class="line"></span><br><span class="line">  <span class="comment">#查询一条表纪录:                                                           </span></span><br><span class="line">      SELECT * FROM employee WHERE age=<span class="number">24</span>;                               </span><br><span class="line"></span><br><span class="line">  <span class="comment">#更新一条表纪录:                                                           </span></span><br><span class="line">      UPDATE employee SET birthday=<span class="string">&quot;1989-10-24&quot;</span> WHERE id=<span class="number">1</span>;              </span><br><span class="line"></span><br><span class="line">  <span class="comment">#删除一条表纪录:                                                          </span></span><br><span class="line">      DELETE FROM employee WHERE name=<span class="string">&quot;alex&quot;</span>                             </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#python的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">     id=models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">     name=models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">     gender=models.BooleanField()</span><br><span class="line">     birthday=models.DateField()</span><br><span class="line">     department=models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">     salary=models.DecimalField(max_digits=<span class="number">8</span>,decimal_places=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#python的类对象</span></span><br><span class="line">      <span class="comment">#添加一条表纪录:</span></span><br><span class="line">          emp=Employee(name=<span class="string">&quot;alex&quot;</span>,gender=<span class="literal">True</span>,birthday=<span class="string">&quot;1985-12-12&quot;</span>,epartment=<span class="string">&quot;保洁部&quot;</span>)</span><br><span class="line">          emp.save()</span><br><span class="line">      <span class="comment">#查询一条表纪录:</span></span><br><span class="line">          Employee.objects.filter(age=<span class="number">24</span>)</span><br><span class="line">      <span class="comment">#更新一条表纪录:</span></span><br><span class="line">          Employee.objects.filter(id=<span class="number">1</span>).update(birthday=<span class="string">&quot;1989-10-24&quot;</span>)</span><br><span class="line">      <span class="comment">#删除一条表纪录:</span></span><br><span class="line">          Employee.objects.filter(name=<span class="string">&quot;alex&quot;</span>).delete()</span><br></pre></td></tr></table></figure>

<h2 id="二-单表操作"><a href="#二-单表操作" class="headerlink" title="二 单表操作"></a>二 单表操作</h2><h3 id="2-1-创建表"><a href="#2-1-创建表" class="headerlink" title="2.1 创建表"></a>2.1 创建表</h3><h4 id="1-创建模型"><a href="#1-创建模型" class="headerlink" title="1 创建模型"></a>1 创建模型</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj1wt64t3tj30cy0f4t98.jpg" alt="image-20200924181936140"></p>
<p>创建名为book的app，在book下的models.py中创建模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    id = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">64</span>)</span><br><span class="line">    pub_data = models.DateField()</span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">5</span>, decimal_places=<span class="number">2</span>)</span><br><span class="line">    publish = models.CharField(max_length=<span class="number">12</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br></pre></td></tr></table></figure>

<h4 id="2-更多字段"><a href="#2-更多字段" class="headerlink" title="2 更多字段"></a>2 更多字段</h4><p>每个字段有一些特有的参数，例如，CharField需要max_length参数来指定<code>VARCHAR</code>数据库字段的大小。还有一些适用于所有字段的通用参数。 这些参数在文档中有详细定义，这里我们只简单介绍一些最常用的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">AutoField(Field)</span><br><span class="line">    - int自增列，必须填入参数 primary_key=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">BigAutoField(AutoField)</span><br><span class="line">    - bigint自增列，必须填入参数 primary_key=<span class="literal">True</span></span><br><span class="line">    注：当model中如果没有自增列，则自动会创建一个列名为id的列</span><br><span class="line">    <span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">        <span class="comment"># 自动创建一个列名为id的且为自增的整数列</span></span><br><span class="line">        username = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Group</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">        <span class="comment"># 自定义自增列</span></span><br><span class="line">        nid = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">        name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">SmallIntegerField(IntegerField):</span><br><span class="line">    - 小整数 <span class="number">-32768</span> ～ <span class="number">32767</span></span><br><span class="line"></span><br><span class="line">PositiveSmallIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField)</span><br><span class="line">    - 正小整数 <span class="number">0</span> ～ <span class="number">32767</span></span><br><span class="line">IntegerField(Field)</span><br><span class="line">    - 整数列(有符号的) <span class="number">-2147483648</span> ～ <span class="number">2147483647</span></span><br><span class="line"></span><br><span class="line">PositiveIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField)</span><br><span class="line">    - 正整数 <span class="number">0</span> ～ <span class="number">2147483647</span></span><br><span class="line"></span><br><span class="line">BigIntegerField(IntegerField):</span><br><span class="line">    - 长整型(有符号的) <span class="number">-9223372036854775808</span> ～ <span class="number">9223372036854775807</span></span><br><span class="line"></span><br><span class="line">自定义无符号整数字段</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnsignedIntegerField</span>(<span class="params">models.IntegerField</span>):</span></span><br><span class="line">         <span class="function"><span class="keyword">def</span> <span class="title">db_type</span>(<span class="params">self, connection</span>):</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;integer UNSIGNED&#x27;</span></span><br><span class="line"></span><br><span class="line">    PS: 返回值为字段在数据库中的属性，Django字段默认的值为：</span><br><span class="line">        <span class="string">&#x27;AutoField&#x27;</span>: <span class="string">&#x27;integer AUTO_INCREMENT&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;BigAutoField&#x27;</span>: <span class="string">&#x27;bigint AUTO_INCREMENT&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;BinaryField&#x27;</span>: <span class="string">&#x27;longblob&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;BooleanField&#x27;</span>: <span class="string">&#x27;bool&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;CharField&#x27;</span>: <span class="string">&#x27;varchar(%(max_length)s)&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;CommaSeparatedIntegerField&#x27;</span>: <span class="string">&#x27;varchar(%(max_length)s)&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;DateField&#x27;</span>: <span class="string">&#x27;date&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;DateTimeField&#x27;</span>: <span class="string">&#x27;datetime&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;DecimalField&#x27;</span>: <span class="string">&#x27;numeric(%(max_digits)s, %(decimal_places)s)&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;DurationField&#x27;</span>: <span class="string">&#x27;bigint&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;FileField&#x27;</span>: <span class="string">&#x27;varchar(%(max_length)s)&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;FilePathField&#x27;</span>: <span class="string">&#x27;varchar(%(max_length)s)&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;FloatField&#x27;</span>: <span class="string">&#x27;double precision&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;IntegerField&#x27;</span>: <span class="string">&#x27;integer&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;BigIntegerField&#x27;</span>: <span class="string">&#x27;bigint&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;IPAddressField&#x27;</span>: <span class="string">&#x27;char(15)&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;GenericIPAddressField&#x27;</span>: <span class="string">&#x27;char(39)&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NullBooleanField&#x27;</span>: <span class="string">&#x27;bool&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;OneToOneField&#x27;</span>: <span class="string">&#x27;integer&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;PositiveIntegerField&#x27;</span>: <span class="string">&#x27;integer UNSIGNED&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;PositiveSmallIntegerField&#x27;</span>: <span class="string">&#x27;smallint UNSIGNED&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;SlugField&#x27;</span>: <span class="string">&#x27;varchar(%(max_length)s)&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;SmallIntegerField&#x27;</span>: <span class="string">&#x27;smallint&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;TextField&#x27;</span>: <span class="string">&#x27;longtext&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;TimeField&#x27;</span>: <span class="string">&#x27;time&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;UUIDField&#x27;</span>: <span class="string">&#x27;char(32)&#x27;</span>,</span><br><span class="line"></span><br><span class="line">BooleanField(Field)</span><br><span class="line">    - 布尔值类型</span><br><span class="line"></span><br><span class="line">NullBooleanField(Field):</span><br><span class="line">    - 可以为空的布尔值</span><br><span class="line"></span><br><span class="line">CharField(Field)</span><br><span class="line">    - 字符类型</span><br><span class="line">    - 必须提供max_length参数， max_length表示字符长度</span><br><span class="line"></span><br><span class="line">TextField(Field)</span><br><span class="line">    - 文本类型</span><br><span class="line"></span><br><span class="line">EmailField(CharField)：</span><br><span class="line">    - 字符串类型，Django Admin以及ModelForm中提供验证机制</span><br><span class="line"></span><br><span class="line">IPAddressField(Field)</span><br><span class="line">    - 字符串类型，Django Admin以及ModelForm中提供验证 IPV4 机制</span><br><span class="line"></span><br><span class="line">GenericIPAddressField(Field)</span><br><span class="line">    - 字符串类型，Django Admin以及ModelForm中提供验证 Ipv4和Ipv6</span><br><span class="line">    - 参数：</span><br><span class="line">        protocol，用于指定Ipv4或Ipv6， <span class="string">&#x27;both&#x27;</span>,<span class="string">&quot;ipv4&quot;</span>,<span class="string">&quot;ipv6&quot;</span></span><br><span class="line">        unpack_ipv4， 如果指定为<span class="literal">True</span>，则输入::ffff:<span class="number">192.0</span><span class="number">.2</span><span class="number">.1</span>时候，可解析为<span class="number">192.0</span><span class="number">.2</span><span class="number">.1</span>，开启刺功能，需要protocol=<span class="string">&quot;both&quot;</span></span><br><span class="line"></span><br><span class="line">URLField(CharField)</span><br><span class="line">    - 字符串类型，Django Admin以及ModelForm中提供验证 URL</span><br><span class="line"></span><br><span class="line">SlugField(CharField)</span><br><span class="line">    - 字符串类型，Django Admin以及ModelForm中提供验证支持 字母、数字、下划线、连接符（减号）</span><br><span class="line"></span><br><span class="line">CommaSeparatedIntegerField(CharField)</span><br><span class="line">    - 字符串类型，格式必须为逗号分割的数字</span><br><span class="line"></span><br><span class="line">UUIDField(Field)</span><br><span class="line">    - 字符串类型，Django Admin以及ModelForm中提供对UUID格式的验证</span><br><span class="line"></span><br><span class="line">FilePathField(Field)</span><br><span class="line">    - 字符串，Django Admin以及ModelForm中提供读取文件夹下文件的功能</span><br><span class="line">    - 参数：</span><br><span class="line">            path,                      文件夹路径</span><br><span class="line">            match=<span class="literal">None</span>,                正则匹配</span><br><span class="line">            recursive=<span class="literal">False</span>,           递归下面的文件夹</span><br><span class="line">            allow_files=<span class="literal">True</span>,          允许文件</span><br><span class="line">            allow_folders=<span class="literal">False</span>,       允许文件夹</span><br><span class="line"></span><br><span class="line">FileField(Field)</span><br><span class="line">    - 字符串，路径保存在数据库，文件上传到指定目录</span><br><span class="line">    - 参数：</span><br><span class="line">        upload_to = <span class="string">&quot;&quot;</span>      上传文件的保存路径</span><br><span class="line">        storage = <span class="literal">None</span>      存储组件，默认django.core.files.storage.FileSystemStorage</span><br><span class="line"></span><br><span class="line">ImageField(FileField)</span><br><span class="line">    - 字符串，路径保存在数据库，文件上传到指定目录</span><br><span class="line">    - 参数：</span><br><span class="line">        upload_to = <span class="string">&quot;&quot;</span>      上传文件的保存路径</span><br><span class="line">        storage = <span class="literal">None</span>      存储组件，默认django.core.files.storage.FileSystemStorage</span><br><span class="line">        width_field=<span class="literal">None</span>,   上传图片的高度保存的数据库字段名（字符串）</span><br><span class="line">        height_field=<span class="literal">None</span>   上传图片的宽度保存的数据库字段名（字符串）</span><br><span class="line"></span><br><span class="line">DateTimeField(DateField)</span><br><span class="line">    - 日期+时间格式 YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]</span><br><span class="line"></span><br><span class="line">DateField(DateTimeCheckMixin, Field)</span><br><span class="line">    - 日期格式      YYYY-MM-DD</span><br><span class="line"></span><br><span class="line">TimeField(DateTimeCheckMixin, Field)</span><br><span class="line">    - 时间格式      HH:MM[:ss[.uuuuuu]]</span><br><span class="line"></span><br><span class="line">DurationField(Field)</span><br><span class="line">    - 长整数，时间间隔，数据库中按照bigint存储，ORM中获取的值为datetime.timedelta类型</span><br><span class="line"></span><br><span class="line">FloatField(Field)</span><br><span class="line">    - 浮点型</span><br><span class="line"></span><br><span class="line">DecimalField(Field)</span><br><span class="line">    - <span class="number">10</span>进制小数</span><br><span class="line">    - 参数：</span><br><span class="line">        max_digits，小数总长度</span><br><span class="line">        decimal_places，小数位长度</span><br><span class="line"></span><br><span class="line">BinaryField(Field)</span><br><span class="line">    - 二进制类型</span><br></pre></td></tr></table></figure>

<h4 id="3-更多参数"><a href="#3-更多参数" class="headerlink" title="3 更多参数"></a>3 更多参数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)null</span><br><span class="line"> </span><br><span class="line">如果为<span class="literal">True</span>，Django 将用NULL 来在数据库中存储空值。 默认值是 <span class="literal">False</span>.</span><br><span class="line"> </span><br><span class="line">(<span class="number">1</span>)blank</span><br><span class="line"> </span><br><span class="line">如果为<span class="literal">True</span>，该字段允许不填。默认为<span class="literal">False</span>。</span><br><span class="line">要注意，这与 null 不同。null纯粹是数据库范畴的，而 blank 是数据验证范畴的。</span><br><span class="line">如果一个字段的blank=<span class="literal">True</span>，表单的验证将允许该字段是空值。如果字段的blank=<span class="literal">False</span>，该字段就是必填的。</span><br><span class="line"> </span><br><span class="line">(<span class="number">2</span>)default</span><br><span class="line"> </span><br><span class="line">字段的默认值。可以是一个值或者可调用对象。如果可调用 ，每有新对象被创建它都会被调用。</span><br><span class="line"> </span><br><span class="line">(<span class="number">3</span>)primary_key</span><br><span class="line"> </span><br><span class="line">如果为<span class="literal">True</span>，那么这个字段就是模型的主键。如果你没有指定任何一个字段的primary_key=<span class="literal">True</span>，</span><br><span class="line">Django 就会自动添加一个IntegerField字段做为主键，所以除非你想覆盖默认的主键行为，</span><br><span class="line">否则没必要设置任何一个字段的primary_key=<span class="literal">True</span>。</span><br><span class="line"> </span><br><span class="line">(<span class="number">4</span>)unique</span><br><span class="line"> </span><br><span class="line">如果该值设置为 <span class="literal">True</span>, 这个数据字段的值在整张表中必须是唯一的</span><br><span class="line"> </span><br><span class="line">(<span class="number">5</span>)choices</span><br><span class="line">由二元组组成的一个可迭代对象（例如，列表或元组），用来给字段提供选择项。 如果设置了choices ，默认的表单将是一个选择框而不是标准的文本框，&lt;br&gt;而且这个选择框的选项就是choices 中的选项。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">       nid = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">       username = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">       <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">           <span class="comment"># 数据库中生成的表名称 默认 app名称 + 下划线 + 类名</span></span><br><span class="line">           db_table = <span class="string">&quot;table_name&quot;</span></span><br><span class="line"></span><br><span class="line">           <span class="comment"># 联合索引</span></span><br><span class="line">           index_together = [</span><br><span class="line">               (<span class="string">&quot;pub_date&quot;</span>, <span class="string">&quot;deadline&quot;</span>),</span><br><span class="line">           ]</span><br><span class="line"></span><br><span class="line">           <span class="comment"># 联合唯一索引</span></span><br><span class="line">           unique_together = ((<span class="string">&quot;driver&quot;</span>, <span class="string">&quot;restaurant&quot;</span>),)</span><br><span class="line"></span><br><span class="line">           <span class="comment"># admin中显示的表名称</span></span><br><span class="line">           verbose_name</span><br><span class="line"></span><br><span class="line">           <span class="comment"># verbose_name加s</span></span><br><span class="line">           verbose_name_plural</span><br></pre></td></tr></table></figure>

<h4 id="4-settings配置"><a href="#4-settings配置" class="headerlink" title="4 settings配置"></a>4 settings配置</h4><p>若想将模型转为mysql数据库中的表，需要在settings中配置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;lqz&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;PORT&#x27;</span>: <span class="number">3306</span>,</span><br><span class="line">        <span class="string">&#x27;ATOMIC_REQUEST&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&#x27;OPTIONS&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;init_command&quot;</span>: <span class="string">&quot;SET storage_engine=MyISAM&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;NAME&#x27;:要连接的数据库，连接前需要创建好</span></span><br><span class="line"><span class="string">&#x27;USER&#x27;:连接数据库的用户名</span></span><br><span class="line"><span class="string">&#x27;PASSWORD&#x27;:连接数据库的密码</span></span><br><span class="line"><span class="string">&#x27;HOST&#x27;:连接主机，默认本机</span></span><br><span class="line"><span class="string">&#x27;PORT&#x27;:端口 默认3306</span></span><br><span class="line"><span class="string">&#x27;ATOMIC_REQUEST&#x27;: True,</span></span><br><span class="line"><span class="string">设置为True统一个http请求对应的所有sql都放在一个事务中执行（要么所有都成功，要么所有都失败）。</span></span><br><span class="line"><span class="string">是全局性的配置， 如果要对某个http请求放水（然后自定义事务），可以用non_atomic_requests修饰器 </span></span><br><span class="line"><span class="string">&#x27;OPTIONS&#x27;: &#123;</span></span><br><span class="line"><span class="string">             &quot;init_command&quot;: &quot;SET storage_engine=MyISAM&quot;,</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">设置创建表的存储引擎为MyISAM，INNODB</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意1：</strong>NAME即数据库的名字，在mysql连接前该数据库必须已经创建，而上面的sqlite数据库下的db.sqlite3则是项目自动创建 USER和PASSWORD分别是数据库的用户名和密码。设置完后，再启动我们的Django项目前，我们需要激活我们的mysql。然后，启动项目，会报错：no module named MySQLdb 。这是因为django默认你导入的驱动是MySQLdb，可是MySQLdb 对于py3有很大问题，所以我们需要的驱动是PyMySQL 所以，我们只需要找到项目名文件下的<strong>init</strong>,在里面写入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure>

<p>最后通过两条数据库迁移命令即可在指定的数据库中创建表 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<p>**注意2:**确保配置文件中的INSTALLED_APPS中写入我们创建的app名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS &#x3D; [</span><br><span class="line">    &#39;django.contrib.admin&#39;,</span><br><span class="line">    &#39;django.contrib.auth&#39;,</span><br><span class="line">    &#39;django.contrib.contenttypes&#39;,</span><br><span class="line">    &#39;django.contrib.sessions&#39;,</span><br><span class="line">    &#39;django.contrib.messages&#39;,</span><br><span class="line">    &#39;django.contrib.staticfiles&#39;,</span><br><span class="line">    &quot;book&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>**注意3:**如果报错如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">django.core.exceptions.ImproperlyConfigured: mysqlclient 1.3.3 or newer is required; you have 0.7.11.None</span><br></pre></td></tr></table></figure>

<p>MySQLclient目前只支持到python3.4，因此如果使用的更高版本的python，需要修改如下：</p>
<p>通过查找路径C:\Programs\Python\Python36-32\Lib\site-packages\Django-2.0-py3.6.egg\django\db\backends\mysql<br>这个路径里的文件把</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if version &lt; (1, 3, 3):</span><br><span class="line">     raise ImproperlyConfigured(&quot;mysqlclient 1.3.3 or newer is required; you have %s&quot; % Database.__version__)</span><br></pre></td></tr></table></figure>

<p>注释掉就可以了</p>
<p><strong>注意4:</strong> 如果想打印orm转换过程中的sql，需要在settings中进行如下配置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LOGGING = &#123;</span><br><span class="line">    <span class="string">&#x27;version&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;disable_existing_loggers&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">&#x27;handlers&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;console&#x27;</span>:&#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>:<span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>:<span class="string">&#x27;logging.StreamHandler&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;loggers&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;django.db.backends&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;console&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;propagate&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>:<span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-增加，删除字段"><a href="#5-增加，删除字段" class="headerlink" title="5 增加，删除字段"></a>5 增加，删除字段</h4><p>　　删除，直接注释掉字段，执行数据库迁移命令即可</p>
<p>　　新增字段，在类里直接新增字段，直接执行数据库迁移命令会提示输入默认值，此时需要设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">publish &#x3D; models.CharField(max_length&#x3D;12,default&#x3D;&#39;人民出版社&#39;,null&#x3D;True)</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>　　<strong>1 数据库迁移记录都在 app01下的migrations里</strong></p>
<p>　　<strong>2 使用showmigrations命令可以查看没有执行migrate的文件</strong></p>
<p>　　<strong>3 makemigrations是生成一个文件，migrate是将更改提交到数据量</strong></p>
<h3 id="2-2-添加表纪录"><a href="#2-2-添加表纪录" class="headerlink" title="2.2 添加表纪录"></a>2.2 添加表纪录</h3><p><strong>方式1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># create方法的返回值book_obj就是插入book表中的python葵花宝典这本书籍纪录对象</span><br><span class="line">book_obj&#x3D;Book.objects.create(title&#x3D;&quot;python葵花宝典&quot;,state&#x3D;True,price&#x3D;100,publish&#x3D;&quot;苹果出版社&quot;,pub_date&#x3D;&quot;2012-12-12&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>方式2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">book_obj&#x3D;Book(title&#x3D;&quot;python葵花宝典&quot;,state&#x3D;True,price&#x3D;100,publish&#x3D;&quot;苹果出版社&quot;,pub_date&#x3D;&quot;2012-12-12&quot;)</span><br><span class="line">book_obj.save()</span><br></pre></td></tr></table></figure>

<h3 id="2-3-查询表纪录"><a href="#2-3-查询表纪录" class="headerlink" title="2.3 查询表纪录"></a>2.3 查询表纪录</h3><p><strong>查询API</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;<span class="number">1</span>&gt; all():                  查询所有结果</span><br><span class="line">  </span><br><span class="line">&lt;<span class="number">2</span>&gt; filter(**kwargs):       它包含了与所给筛选条件相匹配的对象</span><br><span class="line">  </span><br><span class="line">&lt;<span class="number">3</span>&gt; get(**kwargs):          返回与所给筛选条件相匹配的对象，返回结果有且只有一个，如果符合筛选条件的对象超过一个或者没有都会抛出错误。</span><br><span class="line">  </span><br><span class="line">&lt;<span class="number">4</span>&gt; exclude(**kwargs):      它包含了与所给筛选条件不匹配的对象</span><br><span class="line"> </span><br><span class="line">&lt;<span class="number">5</span>&gt; order_by(*field):       对查询结果排序(<span class="string">&#x27;-id&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">&lt;<span class="number">6</span>&gt; reverse():              对查询结果反向排序</span><br><span class="line">  </span><br><span class="line">&lt;<span class="number">8</span>&gt; count():                返回数据库中匹配查询(QuerySet)的对象数量。</span><br><span class="line">  </span><br><span class="line">&lt;<span class="number">9</span>&gt; first():                返回第一条记录</span><br><span class="line">  </span><br><span class="line">&lt;<span class="number">10</span>&gt; last():                返回最后一条记录</span><br><span class="line">  </span><br><span class="line">&lt;<span class="number">11</span>&gt; exists():              如果QuerySet包含数据，就返回<span class="literal">True</span>，否则返回<span class="literal">False</span></span><br><span class="line"> </span><br><span class="line">&lt;<span class="number">12</span>&gt; values(*field):        返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系列</span><br><span class="line">                            model的实例化对象，而是一个可迭代的字典序列</span><br><span class="line">&lt;<span class="number">13</span>&gt; values_list(*field):   它与values()非常相似，它返回的是一个元组序列，values返回的是一个字典序列</span><br><span class="line"> </span><br><span class="line">&lt;<span class="number">14</span>&gt; distinct():            从返回结果中剔除重复纪录</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 添加表记录++++++++++++++++++++++++++++++++++</span></span><br><span class="line">    <span class="comment"># 方式一</span></span><br><span class="line">    <span class="comment"># book=Book(name=&#x27;红楼梦&#x27;,pub_data=&#x27;2015-10-12&#x27;,price=88,publish=&#x27;老男孩出版社&#x27;)</span></span><br><span class="line">    <span class="comment"># book.save()</span></span><br><span class="line">    <span class="comment"># 方式二</span></span><br><span class="line">    <span class="comment"># Book.objects.create(name=&#x27;Python红宝书&#x27;,pub_data=&#x27;2010-10-12&#x27;,price=100,publish=&#x27;人民出版社&#x27;)</span></span><br><span class="line">    <span class="comment"># 查询表记录++++++++++++++++++++++++++++++++++</span></span><br><span class="line">    <span class="comment"># QUerySet数据类型（类似于一个列表，里面放着一些对象）</span></span><br><span class="line">    <span class="comment"># 1 方法的返回值是什么</span></span><br><span class="line">    <span class="comment"># 2 方法的调用者</span></span><br><span class="line">    <span class="comment"># (1) all方法 返回一个QuerySet对象</span></span><br><span class="line">    <span class="comment"># book_list=Book.objects.all()</span></span><br><span class="line">    <span class="comment"># print(book_list[1].name)</span></span><br><span class="line">    <span class="comment"># print(book_list)</span></span><br><span class="line">    <span class="comment"># for obj in book_list:</span></span><br><span class="line">    <span class="comment">#     print(obj.name)</span></span><br><span class="line">    <span class="comment"># (2)first last：调用者是queryset对象，返回值是对象</span></span><br><span class="line">    <span class="comment"># book=Book.objects.all().first()</span></span><br><span class="line">    <span class="comment"># book2=Book.objects.all().last()</span></span><br><span class="line">    <span class="comment"># print(book)</span></span><br><span class="line">    <span class="comment"># print(book2)</span></span><br><span class="line">    <span class="comment"># (3) filter  返回值是queryset对象(相当于where语句)</span></span><br><span class="line">    <span class="comment"># 可以加多个过滤条件</span></span><br><span class="line">    <span class="comment"># book=Book.objects.filter(name=&#x27;红楼梦&#x27;).first()</span></span><br><span class="line">    <span class="comment"># print(book)</span></span><br><span class="line">    <span class="comment"># (4)get方法 有且只有一个查询结果才有意义 返回值是一个对象</span></span><br><span class="line">    <span class="comment"># book=Book.objects.get(name=&#x27;红楼梦&#x27;)</span></span><br><span class="line">    <span class="comment"># print(book)</span></span><br><span class="line">    <span class="comment"># 直接报错</span></span><br><span class="line">    <span class="comment"># book = Book.objects.get(name=&#x27;红楼梦eee&#x27;)</span></span><br><span class="line">    <span class="comment"># --------------最常用-----------------</span></span><br><span class="line">    <span class="comment"># (5)exclude 除了查询之外的 返回值也是queryset</span></span><br><span class="line">    <span class="comment"># ret=Book.objects.exclude(name=&#x27;红楼梦&#x27;)</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line">    <span class="comment"># （6）order_by(默认升序，加个- 就是降序),可以多个过滤条件调用者是queryset返回值也是queryset</span></span><br><span class="line">    <span class="comment"># book_list=Book.objects.all().order_by(&#x27;id&#x27;)</span></span><br><span class="line">    <span class="comment"># book_list=Book.objects.all().order_by(&#x27;-id&#x27;,&#x27;price&#x27;)</span></span><br><span class="line">    <span class="comment"># print(book_list)</span></span><br><span class="line">    <span class="comment"># （7）count() 调用者是queryset，返回值是int</span></span><br><span class="line">    <span class="comment"># ret=Book.objects.all().count()</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line">    <span class="comment"># (8)exist()判断是是否有值，不能传参数，</span></span><br><span class="line">    <span class="comment"># ret=Book.objects.all().exists()</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line">    <span class="comment"># （9）values方法</span></span><br><span class="line">    <span class="comment"># 查询所有书籍的名称(里面传的值，前提是表有这个字段)也是queryset但是里面放的是字典</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    values原理</span></span><br><span class="line"><span class="string">    temp=[]</span></span><br><span class="line"><span class="string">    for obj in Book.objects.all():</span></span><br><span class="line"><span class="string">        temp.append(&#123;&#x27;name&#x27;:obj.name&#125;)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># ret=Book.objects.all().values(&#x27;name&#x27;)</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line">    <span class="comment"># 不加.all()也可以,调用是queryset返回值也是queryset</span></span><br><span class="line">    <span class="comment"># ret=Book.objects.values(&#x27;price&#x27;)</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line">    <span class="comment"># （10）value_list</span></span><br><span class="line">    <span class="comment"># ret=Book.objects.all().values_list(&#x27;price&#x27;,&#x27;name&#x27;)</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line">    <span class="comment"># (11) distinct  seletc * 的时候没有意义</span></span><br><span class="line">    <span class="comment"># SELECT DISTINCT name from app01_book;</span></span><br><span class="line">    <span class="comment"># 没有任何意义，不要这样么用</span></span><br><span class="line">    <span class="comment"># Book.objects.all().distinct()</span></span><br><span class="line">    <span class="comment"># ret=Book.objects.all().values(&#x27;name&#x27;).distinct()</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 双下划线模糊查询-----------------------</span></span><br><span class="line">    <span class="comment"># 查询价格大于100的书</span></span><br><span class="line">    <span class="comment"># ret=Book.objects.filter(price__gt=100)</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line">    <span class="comment"># 查询大于50小于100的书</span></span><br><span class="line">    <span class="comment"># ret=Book.objects.filter(price__gt=50,price__lt=100)</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line">    <span class="comment"># 查询已红楼开头的书</span></span><br><span class="line">    <span class="comment"># ret=Book.objects.filter(name__startswith=&#x27;红楼&#x27;)</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line">    <span class="comment"># 查询包含‘红’的书</span></span><br><span class="line">    <span class="comment"># ret= Book.objects.filter(name__contains=&#x27;红&#x27;)</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line">    <span class="comment"># icontains  不区分大小写</span></span><br><span class="line">    <span class="comment"># 价格在50，88，100 中的</span></span><br><span class="line">    <span class="comment"># ret=Book.objects.filter(price__in=[50,88,100])</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line">    <span class="comment"># 出版日期在2018年的</span></span><br><span class="line">    <span class="comment"># ret=Book.objects.filter(pub_data__year=2015,pub_data__month=2)</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line">    <span class="comment"># 删除，修改------------------------</span></span><br><span class="line">    <span class="comment"># delete：调用者可以是queryset也可以是model对象</span></span><br><span class="line">    <span class="comment"># 删除价格为188的书有返回值 (1, &#123;&#x27;app01.Book&#x27;: 1&#125;) 删除的个数，那张表，记录数</span></span><br><span class="line">    <span class="comment"># ret=Book.objects.filter(price=188).delete()</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line">    <span class="comment"># ret=Book.objects.filter(price=100).first().delete()</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改 update只能queryset来调用 返回值为int</span></span><br><span class="line">    <span class="comment"># ret=Book.objects.filter(name=&#x27;红楼梦1&#x27;).update(name=&#x27;红楼梦&#x27;)</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line">    <span class="comment"># 报错</span></span><br><span class="line">    <span class="comment"># Book.objects.filter(name=&#x27;红楼梦&#x27;).first().update(name=&#x27;红楼梦1&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ret=Book.objects.filter(name=&#x27;红楼梦1&#x27;).first()</span></span><br><span class="line">    <span class="comment"># print(ret.delete())</span></span><br><span class="line">    <span class="comment"># aa=Publish.objects.filter(name=&#x27;人民出版社&#x27;)</span></span><br><span class="line">    <span class="comment"># print(type(aa))</span></span><br><span class="line">    <span class="comment"># aa.delete()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;ok&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="基于双下划线的模糊查询"><a href="#基于双下划线的模糊查询" class="headerlink" title="基于双下划线的模糊查询　"></a>基于双下划线的模糊查询　</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Book.objects.filter(price__in=[<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>])</span><br><span class="line">Book.objects.filter(price__gt=<span class="number">100</span>)</span><br><span class="line">Book.objects.filter(price__lt=<span class="number">100</span>)</span><br><span class="line">Book.objects.filter(price__gte=<span class="number">100</span>)</span><br><span class="line">Book.objects.filter(price__lte=<span class="number">100</span>)</span><br><span class="line">Book.objects.filter(price__range=[<span class="number">100</span>,<span class="number">200</span>])</span><br><span class="line">Book.objects.filter(title__contains=<span class="string">&quot;python&quot;</span>)</span><br><span class="line">Book.objects.filter(title__icontains=<span class="string">&quot;python&quot;</span>)</span><br><span class="line">Book.objects.filter(title__startswith=<span class="string">&quot;py&quot;</span>)</span><br><span class="line">Book.objects.filter(pub_date__year=<span class="number">2012</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-5-删除表纪录"><a href="#2-5-删除表纪录" class="headerlink" title="2.5 删除表纪录"></a>2.5 删除表纪录</h3><p>删除方法就是 delete()。它运行时立即删除对象而不返回任何值。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model_obj.delete()</span><br></pre></td></tr></table></figure>

<p>你也可以一次性删除多个对象。每个 QuerySet 都有一个 delete() 方法，它一次性删除 QuerySet 中所有的对象。</p>
<p>例如，下面的代码将删除 pub_date 是2005年的 Entry 对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Entry.objects.filter(pub_date__year=<span class="number">2005</span>).delete()</span><br></pre></td></tr></table></figure>

<p>在 Django 删除对象时，会模仿 SQL 约束 ON DELETE CASCADE 的行为，换句话说，删除一个对象时也会删除与它相关联的外键对象。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = Blog.objects.get(pk=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># This will delete the Blog and all of its Entry objects.</span></span><br><span class="line">b.delete()</span><br></pre></td></tr></table></figure>

<p>要注意的是： delete() 方法是 QuerySet 上的方法，但并不适用于 Manager 本身。这是一种保护机制，是为了避免意外地调用 Entry.objects.delete() 方法导致 所有的 记录被误删除。如果你确认要删除所有的对象，那么你必须显式地调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Entry.objects.all().delete()</span><br></pre></td></tr></table></figure>

<p>如果不想级联删除，可以设置为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pubHouse = models.ForeignKey(to=<span class="string">&#x27;Publisher&#x27;</span>, on_delete=models.SET_NULL, blank=<span class="literal">True</span>, null=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-6-修改表纪录"><a href="#2-6-修改表纪录" class="headerlink" title="2.6 修改表纪录"></a>2.6 修改表纪录</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Book.objects.filter(title__startswith=<span class="string">&quot;py&quot;</span>).update(price=<span class="number">120</span></span><br></pre></td></tr></table></figure>

<p>此外，update()方法对于任何结果集（QuerySet）均有效，这意味着你可以同时更新多条记录update()方法会返回一个整型数值，表示受影响的记录条数。</p>
<h2 id="三-在Python脚本中调用Django环境"><a href="#三-在Python脚本中调用Django环境" class="headerlink" title="三 在Python脚本中调用Django环境"></a>三 在Python脚本中调用Django环境</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&quot;untitled15.settings&quot;</span>)</span><br><span class="line">    <span class="keyword">import</span> django</span><br><span class="line">    django.setup()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line">    books = models.Book.objects.all()</span><br><span class="line">    print(books)</span><br></pre></td></tr></table></figure>

<h2 id="四-Django终端打印SQL语句"><a href="#四-Django终端打印SQL语句" class="headerlink" title="四 Django终端打印SQL语句"></a>四 Django终端打印SQL语句</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LOGGING = &#123;</span><br><span class="line">    <span class="string">&#x27;version&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;disable_existing_loggers&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">&#x27;handlers&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;console&#x27;</span>:&#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>:<span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>:<span class="string">&#x27;logging.StreamHandler&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;loggers&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;django.db.backends&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;console&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;propagate&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>:<span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>09-Django进阶-模型-单表多表</title>
    <url>/posts/50472.html</url>
    <content><![CDATA[<p>Django Models 多表/子查询/联表查询/FQ</p>
<a id="more"></a>

<h1 id="一-表关系回顾"><a href="#一-表关系回顾" class="headerlink" title="一 表关系回顾"></a>一 表关系回顾</h1><p> 在讲解MySQL时，我们提到，把应用程序的所有数据都放在一张表里是极不合理的。</p>
<p> 比如我们开发一个员工管理系统，在数据库里只创建一张员工信息表，该表有四个字段：工号、姓名、部门名、部门职能描述，此时若公司有1万名员工，但只有3个部门，因为每一名员工后都需要跟着部门信息（部门名、部门职能），所以将会导致部门信息出现大量重复、浪费空间。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1825659-20191012154506056-742977620.gif" alt="img">]</p>
<p> 解决方法就是将数据存放于不同的表中，然后基于foreign key建立表之间的关联关系。</p>
<p> 细说的话，表之间存在三种关系：多对一、一对一、多对多，那如何确定两张表之间的关系呢？按照下述步骤操作即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">左表&lt;-------------------------------&gt;右表</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤一：先分析</span></span><br><span class="line"><span class="comment">#分析1、先站在左表的角度</span></span><br><span class="line">是否左表的多条记录可以对应右表的一条记录</span><br><span class="line"></span><br><span class="line"><span class="comment">#分析2、再站在右表的角度去找</span></span><br><span class="line">是否右表的多条记录可以对应左表的一条记录</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤二：后确定关系</span></span><br><span class="line"><span class="comment"># 多对一</span></span><br><span class="line">如果只有<span class="string">&quot;分析1&quot;</span>成立，那么可以确定两张表的关系是：左表多对一右表，关联字段应该创建在左表中，然后foreign key 右表一个字段（通常是id）</span><br><span class="line">如果只有<span class="string">&quot;分析2&quot;</span>成立，那么可以确定两张表的关系是：右表多对一左表，关联字段应该创建在右表中，然后foreign key 左表一个字段（通常是id）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一对一</span></span><br><span class="line">如果<span class="string">&quot;分析1&quot;</span>和<span class="string">&quot;分析2&quot;</span>都不成立，而是左表的一条记录唯一对应右表的一条记录，反之亦然。这种情况很简单，就是在左表foreign key右表的基础上，将左表的关联字段设置成unique即可</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多对多</span></span><br><span class="line">如果<span class="string">&quot;分析1&quot;</span>和<span class="string">&quot;分析2&quot;</span>同时成立，则证明这两张表是一个双向的多对一，即多对多,需要创建一张单独的新表来专门存放二者的关系，关联字段应该创建在新表中，然后在新表中分别foreign key两张表的id字段</span><br></pre></td></tr></table></figure>

<p>我们以一个图书管理系统为背景，设计了下述四张表，让我们来找一找它们之间的关系</p>
<p>书籍表：app01_book</p>
<p>出版社表：app01_publish</p>
<p>作者表：app01_author</p>
<p>作者详细信息表：app01_authordetail</p>
<h4 id="例1、app01-book与app01-publish"><a href="#例1、app01-book与app01-publish" class="headerlink" title="例1、app01_book与app01_publish"></a>例1、app01_book与app01_publish</h4><p>找关系</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">左表(app01_book)&lt;-------------------------------&gt;右表(app01_publish)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤一：</span></span><br><span class="line"><span class="comment">#分析1、先站在左表的角度</span></span><br><span class="line">左表的多条记录代表多版本书籍，右表的一条记录代表一个出版社，多本书籍对应同一个出版社 ✔️</span><br><span class="line"></span><br><span class="line"><span class="comment">#分析2、再站在右表的角度去找</span></span><br><span class="line">右表的多条记录代表多个出版社，左表的一条记录代表一本书，多个出版社不能出版同一本书 ✘</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤二：后确定关系</span></span><br><span class="line"><span class="comment"># 多对一</span></span><br><span class="line">只有<span class="string">&quot;分析1&quot;</span>成立，那么可以确定两张表的关系是：左表(app01_book)多对一右表(app01_publish)，关联字段应该创建在左表(app01_book)中，然后foreign key 右表(app01_publish)的id字段</span><br></pre></td></tr></table></figure>

<p>sql语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、由于foreign key的影响,必须先创建被关联表</span></span><br><span class="line">CREATE TABLE app01_publish (</span><br><span class="line">    id INT PRIMARY KEY auto_increment,</span><br><span class="line">    name VARCHAR (<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、才能创建出关联表</span></span><br><span class="line">CREATE TABLE app01_book (</span><br><span class="line">    id INT PRIMARY KEY auto_increment,</span><br><span class="line">    title VARCHAR (<span class="number">20</span>),</span><br><span class="line">    price DECIMAL (<span class="number">8</span>, <span class="number">2</span>),</span><br><span class="line">    pub_date DATE,</span><br><span class="line">    publish_id INT, <span class="comment"># 新增关联字段</span></span><br><span class="line">    FOREIGN KEY (publish_id) REFERENCES app01_publish (id) </span><br><span class="line">    ON UPDATE CASCADE ON DELETE CASCADE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="例2、app01-author与app01-authordetail"><a href="#例2、app01-author与app01-authordetail" class="headerlink" title="例2、app01_author与app01_authordetail"></a>例2、app01_author与app01_authordetail</h4><p>找关系</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">左表(app01_author)&lt;-------------------------------&gt;右表(app01_authordetail)</span><br><span class="line"></span><br><span class="line">一个作者唯一对应一条自己的详情信息，反之亦然，所以两张表是一对一的关系。在左表中新增关联字段并添加unique约束，然后foreign key右表</span><br></pre></td></tr></table></figure>

<p>sql语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、由于foreign key的影响,必须先创建被关联表</span></span><br><span class="line">CREATE TABLE app01_authordetail (</span><br><span class="line">    id INT PRIMARY KEY auto_increment,</span><br><span class="line">    tel VARCHAR (<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、才能创建出关联表</span></span><br><span class="line">CREATE TABLE app01_author (</span><br><span class="line">    id INT PRIMARY KEY auto_increment,</span><br><span class="line">    name VARCHAR (<span class="number">20</span>),</span><br><span class="line">    age INT,</span><br><span class="line">    authordetail_id INT UNIQUE, <span class="comment"># 新增关联字段,并添加唯一性约束unique</span></span><br><span class="line">    FOREIGN KEY (authordetail_id) REFERENCES app01_authordetail (id) </span><br><span class="line">    ON UPDATE CASCADE ON DELETE CASCADE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="例3、app01-book与app01-author"><a href="#例3、app01-book与app01-author" class="headerlink" title="例3、app01_book与app01_author"></a>例3、app01_book与app01_author</h4><p>找关系</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">左表(app01_book)&lt;-------------------------------&gt;右表(app01_author)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤一：</span></span><br><span class="line"><span class="comment">#分析1、先站在左表的角度</span></span><br><span class="line">左表的多条记录代表多版本书籍，右表的一条记录代表一个作者，多本书籍可以由同一个作者编写 ✔️</span><br><span class="line"></span><br><span class="line"><span class="comment">#分析2、再站在右表的角度去找</span></span><br><span class="line">右表的多条记录代表多个作者，左表的一条记录代表一本书，多个作者可以合作编写同一本书 ✔️</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤二：后确定关系</span></span><br><span class="line"><span class="comment"># 多对多</span></span><br><span class="line"><span class="string">&quot;分析1&quot;</span>和<span class="string">&quot;分析2&quot;</span>同时成立，证明这两张表是多对多的关系,需要创建一张单独的新表来专门存放二者的关系，关联字段应该创建在新表中，然后在新表中分别foreign key两张表的id字段</span><br></pre></td></tr></table></figure>

<p>sql语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、创建被关联表一：app01_book，例1中已创建</span></span><br><span class="line"><span class="comment"># 2、创建被关联表二：app01_author，例2中已创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、创建新表，存放app01_book于app01_author的关联关系</span></span><br><span class="line">CREATE TABLE app01_book_authors (</span><br><span class="line">    id INT PRIMARY KEY auto_increment,</span><br><span class="line">    book_id INT, <span class="comment"># 新增关联字段，用来关联表app01_book</span></span><br><span class="line">    author_id INT, <span class="comment"># 新增关联字段，用来关联表app01_author</span></span><br><span class="line">    FOREIGN KEY (book_id) REFERENCES app01_book (id) ON UPDATE CASCADE ON DELETE CASCADE,</span><br><span class="line">    FOREIGN KEY (author_id) REFERENCES app01_author (id) ON UPDATE CASCADE ON DELETE CASCADE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上述三个例子中生成的表如下</p>
<p>插图5，修改链接：<a href="https://www.processon.com/diagraming/5a895fdde4b0874437c9c580">https://www.processon.com/diagraming/5a895fdde4b0874437c9c580</a></p>
<p>[<img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1825659-20191012154506295-1608619351.-20210509234914708.jpg" alt="插图5"></p>
<h1 id="二-创建模型"><a href="#二-创建模型" class="headerlink" title="二 创建模型"></a>二 创建模型</h1><p>模型类如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Copyfrom django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表app01_publish</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publish</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    nid = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 表app01_book</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    nid = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    title = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">8</span>, decimal_places=<span class="number">2</span>)</span><br><span class="line">    pub_date = models.DateField()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 表app01_book多对一表app01_publish，参数to指定模型名，参数to_field指定要关联的那个字段</span></span><br><span class="line">    <span class="comment"># 默认与出版社的主键字段做外键关联</span></span><br><span class="line">    publish = models.ForeignKey(to=<span class="string">&#x27;Publish&#x27;</span>,to_field=<span class="string">&#x27;nid&#x27;</span>,on_delete=models.CASCADE)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 我们自己写sql时，针对书籍表与作者表的多对关系，需要自己创建新表，而基于django的orm，下面这一行代码可以帮我们自动创建那张关系表</span></span><br><span class="line">    authors=models.ManyToManyField(to=<span class="string">&#x27;Author&#x27;</span>) </span><br><span class="line">    <span class="comment"># 变量名为authors，则新表名为app01_book_authors，若变量名为xxx，则新表名为app01_book_xxx</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 表app01_author</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    nid = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 表app01_author一对一表app01_authordetail</span></span><br><span class="line">    author_detail = models.OneToOneField(to=<span class="string">&#x27;AuthorDetail&#x27;</span>,to_field=<span class="string">&#x27;nid&#x27;</span>,unique=<span class="literal">True</span>,on_delete=models.CASCADE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 表app01_authordetail</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthorDetail</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    nid = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    tel = models.CharField(max_length=<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>强调：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">在创建关联时，针对参数to，如果传入的是字符串（to=<span class="string">&quot;模型名&quot;</span>），则模型类的定义不区分先后顺序，如果传入的是模型名（to=Author），则Author类必须事先定义</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="1、单表查询-增删改查"><a href="#1、单表查询-增删改查" class="headerlink" title="1、单表查询(增删改查)"></a>1、单表查询(增删改查)</h1><p>Django自带的sqlite3数据库对日期格式不是很敏感，处理的时候容易出错，所以我们直接切换成mysql。</p>
<p>settings.py文件配置数据库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment"># &#x27;ENGINE&#x27;: &#x27;django.db.backends.sqlite3&#x27;,</span></span><br><span class="line">        <span class="comment"># &#x27;NAME&#x27;: os.path.join(BASE_DIR, &#x27;db.sqlite3&#x27;),</span></span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>:<span class="string">&#x27;django.db.backends.mysql&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>:<span class="string">&#x27;day64&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>:<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>:<span class="string">&#x27;dingding&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;HOST&#x27;</span>:<span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;PORT&#x27;</span>:<span class="number">3306</span>,</span><br><span class="line">        <span class="string">&#x27;CHARSET&#x27;</span>:<span class="string">&#x27;utf8&#x27;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">#    这里还可以设置mysql的严格模式，如下：</span></span><br><span class="line">   <span class="comment">#      &#x27;OPTIONS&#x27;: &#123;</span></span><br><span class="line">   <span class="comment">#          &#x27;init_command&#x27;: &quot;SET sql_mode=&#x27;STRICT_TRANS_TABLES&#x27;&quot;,</span></span><br><span class="line">   <span class="comment">#          &#x27;charset&#x27;: &#x27;utf8mb4&#x27;,</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>init文件中做代码声明：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure>

<p>再到models.py文件创建一张表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line">    register_time = models.DateField()  <span class="comment"># 年月日格式</span></span><br><span class="line">    <span class="comment"># DateTimeField：年月日 时分秒格式</span></span><br><span class="line">    <span class="comment"># auto_now:每次操作数据的时候，该字段会自动将当前时间更新</span></span><br><span class="line">    <span class="comment"># auto_now_add:在创建数据的时候回自动将当前创建时间记录下来，如果之后不人为修改，那么该数据就会一直不变。例如我们记录用户的注册时间。</span></span><br><span class="line">    <span class="comment"># register_time1 = models.DateTimeField(auto_now=True,auto_now_add=True)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;对象：%s&#x27;</span>%self.name           <span class="comment"># 如果不加这段函数，默认返回的数据对象是User object 形式，加上之后返回的数据对象是“对象：jack_sam”，方便我们看清楚数据</span></span><br></pre></td></tr></table></figure>

<p>然后同步到数据库中：<br>python3.8 <a href="https://link.zhihu.com/?target=http://manage.py/">manage.py</a> makemigrations<br>python3.8 <a href="https://link.zhihu.com/?target=http://manage.py/">manage.py</a> migrate</p>
<blockquote>
<p>测试脚本</p>
</blockquote>
<p>当只想测试Django中某一个py文件的内容，我们可以不用写前后端交互的形式，而是直接写一个测试脚本即可。</p>
<p>tests.py文件(应用下的tests.py或者自己新建的py文件都可以)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&quot;day64.settings&quot;</span>)       <span class="comment"># 这是manage.py文件中拷贝的</span></span><br><span class="line">    <span class="keyword">import</span> django</span><br><span class="line">    django.setup()</span><br><span class="line">    <span class="comment"># 下面就可以测试Django里面的单个py文件了</span></span><br><span class="line">    <span class="keyword">from</span> app01 <span class="keyword">import</span> models       <span class="comment"># 所有代码必须要写在测试环境的后面，就是说要等环境准备完毕后才能书写</span></span><br><span class="line">    models.User.objects.all()</span><br></pre></td></tr></table></figure>

<h3 id="单表查询-增删改"><a href="#单表查询-增删改" class="headerlink" title="单表查询-增删改"></a>单表查询-增删改</h3><blockquote>
<p><strong>create方法返回值是对象</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&quot;day64.settings&quot;</span>)</span><br><span class="line">    <span class="keyword">import</span> django</span><br><span class="line">    django.setup()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line">    models.User.objects.all()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 增</span></span><br><span class="line">     <span class="comment"># 方式1：</span></span><br><span class="line">     models.User.objects.create(name=<span class="string">&#x27;nimo&#x27;</span>,age=<span class="number">18</span>,register_time=<span class="string">&#x27;2020-01-12&#x27;</span>)</span><br><span class="line">     res = models.User.objects.create(name=<span class="string">&#x27;jack&#x27;</span>,age=<span class="number">19</span>,register_time=<span class="string">&#x27;2019-01-13&#x27;</span>)</span><br><span class="line">     print(res)</span><br><span class="line">     <span class="comment"># 对象：这个返回值就是当前被创建对象本身。</span></span><br><span class="line">     <span class="comment"># 方式2：</span></span><br><span class="line">      <span class="keyword">import</span> datetime</span><br><span class="line">      ctime = datetime.datetime.now()</span><br><span class="line">      user_obj = models.User(name=<span class="string">&#x27;ross&#x27;</span>,age=<span class="number">20</span>,register_time=ctime)</span><br><span class="line">      user_obj.save()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删</span></span><br><span class="line">      <span class="comment"># 方式1:</span></span><br><span class="line">      res = models.User.objects.filter(id=<span class="number">2</span>).delete()</span><br><span class="line">      建议写pk，pk会自动查找当前表的主键字段，指代的就是当前表的主键字段，用了pk之后，我们不需要知道当前表的主键字段名称也可进行删除操作。</span><br><span class="line">      res = models.User.objects.filter(pk=<span class="number">2</span>).delete()</span><br><span class="line">      print(res)  <span class="comment"># 返回的是删除操作所影响的行数</span></span><br><span class="line">      (<span class="number">1</span>, &#123;<span class="string">&#x27;app01.User&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line">      <span class="comment"># 方式2：</span></span><br><span class="line">      user_obj1 = models.User.objects.filter(pk=<span class="number">8</span>).first()</span><br><span class="line">      user_obj1.delete()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 改</span></span><br><span class="line">    <span class="comment"># 方式1：</span></span><br><span class="line">    models.User.objects.filter(pk=<span class="number">4</span>).update(name=<span class="string">&#x27;nimoding&#x27;</span>)</span><br><span class="line">    <span class="comment"># 方式2：</span></span><br><span class="line">    user_obj2 = models.User.objects.get(pk=<span class="number">5</span>)</span><br><span class="line">    print(user_obj2)</span><br><span class="line">    <span class="comment"># 对象：jack_sam,get拿到的直接就是这个数据对象，就不需要用filter(pk=5).first()了。</span></span><br><span class="line">    <span class="comment"># 但是该方法不推荐使用，因为如果数据不存在，数据会直接报错；filter则不会报错</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># user_obj2 = models.User.objects.filter(pk=5).first()</span></span><br><span class="line">    <span class="comment"># user_obj2.name = &#x27;jack_sam&#x27;</span></span><br><span class="line">    <span class="comment"># user_obj2.save()</span></span><br></pre></td></tr></table></figure>

<h1 id="2、常见的查询方法-必知必会13条"><a href="#2、常见的查询方法-必知必会13条" class="headerlink" title="2、常见的查询方法(必知必会13条)"></a>2、常见的查询方法(必知必会13条)</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&quot;day64.settings&quot;</span>)</span><br><span class="line">    <span class="keyword">import</span> django</span><br><span class="line">    django.setup()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line">    models.User.objects.all()</span><br><span class="line">    <span class="comment"># 1、all() 查询所有数据</span></span><br><span class="line">    <span class="comment"># 2、filter() 过滤查询</span></span><br><span class="line">    <span class="comment"># 3、get() 直接拿到数据对象，但是条件不存在会直接报错</span></span><br><span class="line">    <span class="comment"># 4、first() 拿到queryset里面第一个元素</span></span><br><span class="line">    res = models.User.objects.all().first()</span><br><span class="line">    print(res.name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5、last()  拿到queryset里面最后一个元素</span></span><br><span class="line">    res = models.User.objects.all().last()</span><br><span class="line">    print(res.name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 6、values() 列表中嵌套字典 值字典   ---- 返回值不是数据对象</span></span><br><span class="line">    <span class="comment"># 只取User表中name字段和age字段</span></span><br><span class="line">    res = models.User.objects.values(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">    print(res)</span><br><span class="line">    <span class="comment"># 返回结果可以看成是列表中嵌套字典</span></span><br><span class="line">    <span class="comment"># &lt;QuerySet [&#123;&#x27;name&#x27;: &#x27;jack&#x27;, &#x27;age&#x27;: 19&#125;, &#123;&#x27;name&#x27;: &#x27;nimoding&#x27;, &#x27;age&#x27;: 18&#125;, &#123;&#x27;name&#x27;: &#x27;jack_sam&#x27;, &#x27;age&#x27;: 19&#125;, &#123;&#x27;name&#x27;: &#x27;ross&#x27;, &#x27;age&#x27;: 20&#125;, &#123;&#x27;name&#x27;: &#x27;ross&#x27;, &#x27;age&#x27;: 20&#125;, &#123;&#x27;name&#x27;: &#x27;ross&#x27;, &#x27;age&#x27;: 20&#125;, &#123;&#x27;name&#x27;: &#x27;ross&#x27;, &#x27;age&#x27;: 20&#125;, &#123;&#x27;name&#x27;: &#x27;ross&#x27;, &#x27;age&#x27;: 20&#125;, &#123;&#x27;name&#x27;: &#x27;ross&#x27;, &#x27;age&#x27;: 20&#125;, &#123;&#x27;name&#x27;: &#x27;ross&#x27;, &#x27;age&#x27;: 20&#125;, &#123;&#x27;name&#x27;: &#x27;ross&#x27;, &#x27;age&#x27;: 20&#125;]&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 7、values_list() 列表嵌套元组 值元祖   ---- 返回值不是数据对象 ---- 用在choice比较多</span></span><br><span class="line">    res = models.User.objects.values_list(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">    print(res)</span><br><span class="line">    <span class="comment"># 返回的结果可以看成是列表嵌套元组</span></span><br><span class="line">    <span class="comment"># &lt;QuerySet [(&#x27;jack&#x27;, 19), (&#x27;nimoding&#x27;, 18), (&#x27;jack_sam&#x27;, 19), (&#x27;ross&#x27;, 20), (&#x27;ross&#x27;, 20), (&#x27;ross&#x27;, 20), (&#x27;ross&#x27;, 20), (&#x27;ross&#x27;, 20), (&#x27;ross&#x27;, 20), (&#x27;ross&#x27;, 20), (&#x27;ross&#x27;, 20)]&gt;</span></span><br><span class="line">    print(res.query)  <span class="comment"># 查看内部封装的SQL语句</span></span><br><span class="line">    <span class="comment"># SELECT `app01_user`.`name`, `app01_user`.`age` FROM `app01_user`</span></span><br><span class="line">    <span class="comment"># 这种查看SQL语句的方式只适用于queryset对象，只有queryset对象才能够点query查看内部SQL语句</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 8、distinct() 去重</span></span><br><span class="line">    res = models.User.objects.all()</span><br><span class="line">    print(res)</span><br><span class="line">    <span class="comment"># &lt;QuerySet [&lt;User: 对象：jack&gt;, &lt;User: 对象：nimoding&gt;, &lt;User: 对象：jack_sam&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：nimo&gt;, &lt;User: 对象：jack&gt;]&gt;</span></span><br><span class="line"></span><br><span class="line">    res = models.User.objects.values(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>).distinct()   <span class="comment"># 去重不要带主键</span></span><br><span class="line">    print(res)</span><br><span class="line">    <span class="comment"># &lt;QuerySet [&#123;&#x27;name&#x27;: &#x27;jack&#x27;, &#x27;age&#x27;: 19&#125;, &#123;&#x27;name&#x27;: &#x27;nimoding&#x27;, &#x27;age&#x27;: 18&#125;, &#123;&#x27;name&#x27;: &#x27;jack_sam&#x27;, &#x27;age&#x27;: 19&#125;, &#123;&#x27;name&#x27;: &#x27;ross&#x27;, &#x27;age&#x27;: 20&#125;, &#123;&#x27;name&#x27;: &#x27;nimo&#x27;, &#x27;age&#x27;: 18&#125;]&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 9、order_by()</span></span><br><span class="line">    res = models.User.objects.order_by(<span class="string">&#x27;age&#x27;</span>) <span class="comment"># 默认升序</span></span><br><span class="line">    res1 = models.User.objects.order_by(<span class="string">&#x27;-age&#x27;</span>) <span class="comment"># 加一个减号就是降序了</span></span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 10、reverse()  # 反转的前提是数据已经排序了</span></span><br><span class="line">    res = models.User.objects.all()</span><br><span class="line">    res1 = models.User.objects.order_by(<span class="string">&#x27;age&#x27;</span>).reverse()</span><br><span class="line">    print(res)</span><br><span class="line">    print(res1)</span><br><span class="line">    <span class="comment"># &lt;QuerySet [&lt;User: 对象：jack&gt;, &lt;User: 对象：nimoding&gt;, &lt;User: 对象：jack_sam&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：nimo&gt;, &lt;User: 对象：jack&gt;]&gt;</span></span><br><span class="line">    <span class="comment"># &lt;QuerySet [&lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：jack&gt;, &lt;User: 对象：jack_sam&gt;, &lt;User: 对象：jack&gt;, &lt;User: 对象：nimoding&gt;, &lt;User: 对象：nimo&gt;]&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 11、count()</span></span><br><span class="line">    res = models.User.objects.count()  <span class="comment"># 当前数据行数</span></span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 12、exclude()</span></span><br><span class="line">    res = models.User.objects.exclude(name=<span class="string">&#x27;ross&#x27;</span>)  <span class="comment"># 排除符合条件的数据</span></span><br><span class="line">    print(res)</span><br><span class="line">    <span class="comment"># &lt;QuerySet [&lt;User: 对象：jack&gt;, &lt;User: 对象：nimoding&gt;, &lt;User: 对象：jack_sam&gt;, &lt;User: 对象：nimo&gt;, &lt;User: 对象：jack&gt;]&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 13、exists()  # 基本用不到，因为数据本身就自带布尔值</span></span><br><span class="line">    res = models.User.objects.filter(pk=<span class="number">4</span>).exists()   <span class="comment"># 判断是否存在，返回布尔值</span></span><br><span class="line">    print(res)</span><br></pre></td></tr></table></figure>

<h3 id="2-1-相关截图："><a href="#2-1-相关截图：" class="headerlink" title="2.1.相关截图："></a>2.1.相关截图：</h3><p><strong>&lt;1&gt; all(): 查询所有结果</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1342004-20180620150444179-1547126914.png" alt="img"></p>
<p><strong>&lt;2&gt; filter(\</strong>kwargs): 它包含了与所给筛选条件相匹配的对象**</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1342004-20180620150651361-592927926.png" alt="img"></p>
<p><strong>&lt;3&gt; get(\</strong>kwargs): 返回与所给筛选条件相匹配的对象，返回结果有且只有一个，如果符合筛选条件的对象超过一个或者没有都会抛出错误。**</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1342004-20180620150839363-1744654160.png" alt="img"></p>
<p><strong>&lt;4&gt; exclude(\</strong>kwargs): 它包含了与所给筛选条件不匹配的对象**</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1342004-20180620151130718-29597851.png" alt="img"></p>
<p><strong>&lt;5&gt; values(*field): 返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系列model的实例化对象，而是一个可迭代的字典序列</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1342004-20180620151319973-577855569.png" alt="img"></p>
<p><strong>&lt;6&gt; values_list(*field): 它与values()非常相似，它返回的是一个元组序列，values返回的是一个字典序列</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1342004-20180620151410181-1703038947.png" alt="img"></p>
<p><strong>&lt;7&gt; order_by(*field): 对查询结果排序</strong></p>
<p><strong>&lt;8&gt; reverse(): 对查询结果反向排序，请注意reverse()通常只能在具有已定义顺序的QuerySet上调用(在model类的Meta中指定ordering或调用order_by()方法)。</strong></p>
<p><strong>&lt;9&gt; distinct(): 从返回结果中剔除重复纪录(如果你查询跨越多个表，可能在计算QuerySet时得到重复的结果。此时可以使用distinct()，注意只有在PostgreSQL中支持按字段去重。)</strong></p>
<p><strong>&lt;10&gt; count(): 返回数据库中匹配查询(QuerySet)的对象数量。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1342004-20180620151740220-356341461.png" alt="img"></p>
<p><strong>&lt;11&gt; first(): 返回第一条记录</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1342004-20180620151857709-1858002534.png" alt="img"></p>
<p><strong>&lt;12&gt; last(): 返回最后一条记录</strong></p>
<p><strong>&lt;13&gt; exists(): 如果QuerySet包含数据，就返回True，否则返回False</strong></p>
<h1 id="3、-增删改和13个必会查询操作总结："><a href="#3、-增删改和13个必会查询操作总结：" class="headerlink" title="3、 增删改和13个必会查询操作总结："></a>3、 增删改和13个必会查询操作总结：</h1><h4 id="Create返回值是被创建对象本身"><a href="#Create返回值是被创建对象本身" class="headerlink" title="Create返回值是被创建对象本身"></a>Create返回值是被创建对象本身</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 方式1：</span><br><span class="line">     models.User.objects.create(name&#x3D;&#39;nimo&#39;,age&#x3D;18,register_time&#x3D;&#39;2020-01-12&#39;)</span><br><span class="line">     res &#x3D; models.User.objects.create(name&#x3D;&#39;jack&#39;,age&#x3D;19,register_time&#x3D;&#39;2019-01-13&#39;)</span><br><span class="line">     print(res)</span><br><span class="line">     # 对象：这个返回值就是当前被创建对象本身。</span><br></pre></td></tr></table></figure>

<h4 id="delete返回值是操作影响的行数"><a href="#delete返回值是操作影响的行数" class="headerlink" title="delete返回值是操作影响的行数"></a>delete返回值是操作影响的行数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 删</span><br><span class="line">      # 方式1:</span><br><span class="line">      res &#x3D; models.User.objects.filter(id&#x3D;2).delete()</span><br><span class="line">      建议写pk，pk会自动查找当前表的主键字段，指代的就是当前表的主键字段，用了pk之后，我们不需要知道当前表的主键字段名称也可进行删除操作。</span><br><span class="line">      res &#x3D; models.User.objects.filter(pk&#x3D;2).delete()</span><br><span class="line">      print(res)  # 返回的是删除操作所影响的行数</span><br><span class="line">      (1, &#123;&#39;app01.User&#39;: 1&#125;)</span><br><span class="line">      # 方式2：</span><br><span class="line">      user_obj1 &#x3D; models.User.objects.filter(pk&#x3D;8).first()</span><br><span class="line">      user_obj1.delete()</span><br></pre></td></tr></table></figure>

<h4 id="update返回值为1"><a href="#update返回值为1" class="headerlink" title="update返回值为1"></a>update返回值为1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 改</span><br><span class="line">    # 方式1：</span><br><span class="line">    models.User.objects.filter(pk&#x3D;4).update(name&#x3D;&#39;nimoding&#39;)</span><br></pre></td></tr></table></figure>

<h4 id="返回QuerySet对象的方法有"><a href="#返回QuerySet对象的方法有" class="headerlink" title="返回QuerySet对象的方法有"></a><strong>返回QuerySet对象的方法有</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">all()</span><br><span class="line"></span><br><span class="line">filter()</span><br><span class="line"></span><br><span class="line">exclude()</span><br><span class="line"></span><br><span class="line">order_by()</span><br><span class="line"></span><br><span class="line">reverse()</span><br><span class="line"></span><br><span class="line">distinct()</span><br></pre></td></tr></table></figure>

<h4 id="特殊的QuerySet"><a href="#特殊的QuerySet" class="headerlink" title="特殊的QuerySet"></a>特殊的QuerySet</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">values()       返回一个可迭代的字典序列</span><br><span class="line"></span><br><span class="line">values_list() 返回一个可迭代的元祖序列</span><br></pre></td></tr></table></figure>

<h4 id="返回具体对象的"><a href="#返回具体对象的" class="headerlink" title="返回具体对象的"></a><strong>返回具体对象的</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get()</span><br><span class="line"></span><br><span class="line">first()</span><br><span class="line"></span><br><span class="line">last()</span><br></pre></td></tr></table></figure>

<h4 id="返回布尔值的方法有："><a href="#返回布尔值的方法有：" class="headerlink" title="返回布尔值的方法有："></a><strong>返回布尔值的方法有：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exists()</span><br></pre></td></tr></table></figure>

<h4 id="返回数字的方法有"><a href="#返回数字的方法有" class="headerlink" title="返回数字的方法有"></a><strong>返回数字的方法有</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">count()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看ORM内部SQL语句的方式</p>
</blockquote>
<p>方式1：<br>print(res.query) # 只有queryset对象才能够点query查看内部封装的SQL语句</p>
<p><img src="https://pic2.zhimg.com/80/v2-220e7a8689db6d878c8545aa3cfdff09_1440w.jpg" alt="img"></p>
<p>方式2：<br>去配置文件中配置，将如下代码添加到settings.py文件中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LOGGING = &#123;</span><br><span class="line">    <span class="string">&#x27;version&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;disable_existing_loggers&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">&#x27;handlers&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;console&#x27;</span>:&#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>:<span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>:<span class="string">&#x27;logging.StreamHandler&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;loggers&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;django.db.backends&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;console&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;propagate&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>:<span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic1.zhimg.com/80/v2-663135a506fd109e95eface33ae25774_1440w.jpg" alt="img"></p>
<p>红色部分就是我们运行tests.py文件后自动显示出来的。能看到每段代码背后的SQL语句。</p>
<h1 id="3、神奇的双下划线查询-filter中使用，范围模糊查询"><a href="#3、神奇的双下划线查询-filter中使用，范围模糊查询" class="headerlink" title="3、神奇的双下划线查询(filter中使用，范围模糊查询)"></a>3、神奇的双下划线查询(filter中使用，范围模糊查询)</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&quot;day64.settings&quot;</span>)</span><br><span class="line">    <span class="keyword">import</span> django</span><br><span class="line">    django.setup()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line">    models.User.objects.all()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 年龄大于35岁数据</span></span><br><span class="line">    res = models.User.objects.filter(age__gt=<span class="number">35</span>)  <span class="comment"># 大于</span></span><br><span class="line">    res1 = models.User.objects.filter(age__gte=<span class="number">35</span>) <span class="comment"># 大于等于</span></span><br><span class="line">    res2 = models.User.objects.filter(age__lt=<span class="number">35</span>)  <span class="comment"># 小于</span></span><br><span class="line">    res3 = models.User.objects.filter(age__lte=<span class="number">35</span>) <span class="comment"># 小于等于</span></span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 年龄是18或40或32</span></span><br><span class="line">    res = models.User.objects.filter(age__in=[<span class="number">18</span>,<span class="number">32</span>,<span class="number">40</span>])</span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 年龄在18-50之间(首尾都包含了)</span></span><br><span class="line">    res = models.User.objects.filter(age__range=[<span class="number">18</span>,<span class="number">50</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询出名字里含有n的数据(默认区分大小写) 模糊查询</span></span><br><span class="line">    res =models.User.objects.filter(name__contains=<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询出名字里含有n的数据(忽略大小写)</span></span><br><span class="line">    res = models.User.objects.filter(name__icontains=<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 名字以什么开头什么结尾</span></span><br><span class="line">    res = models.User.objects.filter(name__startswith=<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">    res1 = models.User.objects.filter(name__endswith=<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询出注册时间是1月的数据</span></span><br><span class="line">    res =models.User.objects.filter(register_time__month=<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    res =models.User.objects.filter(register_time__year =<span class="string">&#x27;2020&#x27;</span>) <span class="comment"># 按年份</span></span><br></pre></td></tr></table></figure>

<h1 id="4、多表操作-创建表"><a href="#4、多表操作-创建表" class="headerlink" title="4、多表操作-创建表"></a>4、多表操作-创建表</h1><p>models.py文件中创建表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">8</span>,decimal_places=<span class="number">2</span>)</span><br><span class="line">    publish_date = models.DateField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 书籍与出版社一对多的关系：</span></span><br><span class="line">    publish = models.ForeignKey(to=<span class="string">&#x27;Publish&#x27;</span>)</span><br><span class="line">    <span class="comment"># 书籍与作者多对多关系：</span></span><br><span class="line">    authors = models.ManyToManyField(to=<span class="string">&#x27;Author&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publish</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    addr = models.CharField(max_length=<span class="number">64</span>)</span><br><span class="line">    email = models.EmailField() <span class="comment"># 本质是varchar(254)类型，但是校验性组件中EmailField只能存邮箱类型</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line">    <span class="comment"># 一对一关系</span></span><br><span class="line">    author_detail = models.OneToOneField(to=<span class="string">&#x27;AuthorDetail&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthorDetail</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    phone = models.BigIntegerField() <span class="comment"># 电话号码用IntegerField不够，要用BigIntegerField或者CharField</span></span><br><span class="line">    addr = models.CharField(max_length=<span class="number">64</span>)</span><br></pre></td></tr></table></figure>

<p><strong>同步到数据库：</strong><br>python3.8 <a href="https://link.zhihu.com/?target=http://manage.py/">manage.py</a> makemigrations<br>python3.8 <a href="https://link.zhihu.com/?target=http://manage.py/">manage.py</a> migrate</p>
<h1 id="5、外键字段的增删改查"><a href="#5、外键字段的增删改查" class="headerlink" title="5、外键字段的增删改查"></a>5、外键字段的增删改查</h1><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1qC4y1s71m?p=785">外键的增删改查www.bilibili.com<img src="https://pic2.zhimg.com/v2-e6cdf00518a61ad1b907ca86ddfe4439_180x120.jpg" alt="图标"></a></p>
<h2 id="一对多外键增删改查-直接id或者对象"><a href="#一对多外键增删改查-直接id或者对象" class="headerlink" title="一对多外键增删改查(直接id或者对象)"></a>一对多外键增删改查(直接id或者对象)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&quot;day64.settings&quot;</span>)</span><br><span class="line">    <span class="keyword">import</span> django</span><br><span class="line">    django.setup()</span><br><span class="line">    <span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line">    models.User.objects.all()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 一对多外键增删改查</span></span><br><span class="line">    <span class="comment"># 增</span></span><br><span class="line">    <span class="comment"># 方式1：直接写实际字段,写id值</span></span><br><span class="line">      models.Book.objects.create(title=<span class="string">&#x27;三国演义&#x27;</span>,price=<span class="number">123.123</span>,publish_id=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 方式2：写虚拟字段,传对象</span></span><br><span class="line">      publish_obj = models.Publish.objects.filter(pk=<span class="number">2</span>).first()</span><br><span class="line">      models.Book.objects.create(title=<span class="string">&#x27;红楼梦&#x27;</span>,price=<span class="number">223.123</span>,publish=publish_obj)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删</span></span><br><span class="line">      models.Book.objects.filter(pk=<span class="number">2</span>).delete()  <span class="comment"># 级联删除</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 改</span></span><br><span class="line">      models.Book.objects.filter(pk=<span class="number">1</span>).update(publish_id=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">      publish_obj = models.Publish.objects.filter(pk=<span class="number">1</span>).first()</span><br><span class="line">      models.Book.objects.filter(pk=<span class="number">1</span>).update(publish = publish_obj)</span><br></pre></td></tr></table></figure>

<h2 id="多对多外键增删改查"><a href="#多对多外键增删改查" class="headerlink" title="多对多外键增删改查"></a>多对多外键增删改查</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&quot;day64.settings&quot;</span>)</span><br><span class="line">    <span class="keyword">import</span> django</span><br><span class="line">    django.setup()</span><br><span class="line">    <span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line">    models.User.objects.all()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 多对多外键增删改查(就是在操作第三张表)</span></span><br><span class="line">    <span class="comment"># 增</span></span><br><span class="line">    <span class="comment"># 如何给书籍添加作者？书籍和作者是多对多关系</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># add：给第三张关系表添加数据，括号内既可以传数字也可以传对象，都支持多个。</span></span><br><span class="line">    <span class="comment"># 方式1：</span></span><br><span class="line">    book_obj = models.Book.objects.filter(pk=<span class="number">1</span>).first()</span><br><span class="line">    <span class="comment"># print(book_obj.authors)  # .authors就相当于你已经到了第三张关系表了</span></span><br><span class="line">    <span class="comment"># app01.Author.None</span></span><br><span class="line">    book_obj.authors.add(<span class="number">1</span>)    <span class="comment"># 去第三张表中添加一个关系：给书籍id=1的书籍绑定一个主键=1的作者</span></span><br><span class="line">    book_obj.authors.add(<span class="number">2</span>,<span class="number">3</span>)  <span class="comment"># 给书籍id=1的书籍绑定一个主键=2和主键=3的作者</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方式2：</span></span><br><span class="line">    book_obj = models.Book.objects.filter(pk=<span class="number">3</span>).first()</span><br><span class="line">    author_obj = models.Author.objects.filter(pk=<span class="number">1</span>).first()</span><br><span class="line">    author_obj1 = models.Author.objects.filter(pk=<span class="number">2</span>).first()</span><br><span class="line">    author_obj2 = models.Author.objects.filter(pk=<span class="number">3</span>).first()</span><br><span class="line">    book_obj.authors.add(author_obj)</span><br><span class="line">    book_obj.authors.add(author_obj1,author_obj2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删</span></span><br><span class="line">    <span class="comment"># 删除书籍id=3作者id=2的数据</span></span><br><span class="line">    <span class="comment"># 获取书籍id=3</span></span><br><span class="line">    book_obj = models.Book.objects.filter(pk=<span class="number">3</span>).first()</span><br><span class="line">    book_obj.authors.remove(<span class="number">2</span>) <span class="comment"># 支持传多个</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取作者id=1</span></span><br><span class="line">    author_obj = models.Author.objects.filter(pk=<span class="number">1</span>).first()</span><br><span class="line">    author_obj1 = models.Author.objects.filter(pk=<span class="number">2</span>).first()</span><br><span class="line">    book_obj.authors.remove(author_obj,author_obj1) <span class="comment"># 支持传对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 改(先删除后新增)</span></span><br><span class="line">    <span class="comment"># 方式1：</span></span><br><span class="line">    <span class="comment"># 针对book的id=3的数据进行修改</span></span><br><span class="line">    book_obj = models.Book.objects.filter(pk=<span class="number">3</span>).first()</span><br><span class="line">    <span class="comment"># 书籍id=3的数据中将作者id改成2和3</span></span><br><span class="line">    book_obj.authors.set([<span class="number">2</span>,<span class="number">3</span>])   <span class="comment"># 括号内必须放一个可迭代对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方式2：放对象</span></span><br><span class="line">    <span class="comment"># 书籍id=3的数据中将作者id改成1</span></span><br><span class="line">    author_obj = models.Author.objects.filter(pk=<span class="number">1</span>).first()</span><br><span class="line">    book_obj.authors.set([author_obj])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 清空</span></span><br><span class="line">    <span class="comment"># 假如一本书下架了，我们将这本书和作者的绑定关系清空</span></span><br><span class="line">    <span class="comment"># 清空书籍id=3与其他作者的关系</span></span><br><span class="line">    book_obj = models.Book.objects.filter(pk=<span class="number">3</span>).first()</span><br><span class="line">    book_obj.authors.clear()</span><br><span class="line">    <span class="comment"># clear括号内不要任何参数</span></span><br></pre></td></tr></table></figure>

<h1 id="6、正反向概念"><a href="#6、正反向概念" class="headerlink" title="6、正反向概念"></a>6、正反向概念</h1><p>Book书籍表(外键字段在书籍表) —– Publish出版社表<br>从书籍查找出版社就是正向查找<br>从出版社查找书籍就是反向查找</p>
<p><strong>正向查询按字段</strong><br><strong>反向查询按表名小写(看情况加_set后缀或者.all()后缀)</strong></p>
<h1 id="7、多表查询"><a href="#7、多表查询" class="headerlink" title="7、多表查询"></a>7、多表查询</h1><blockquote>
<p><strong>子查询(基于对象的跨表查询)</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、查询书籍主键=1的出版社名称</span></span><br><span class="line">book_obj = models.Book.objects.filter(pk=<span class="number">1</span>).first()</span><br><span class="line"><span class="comment"># 拿到书籍信息后，从书籍查出版社是属于正向查询，所以要按字段查询</span></span><br><span class="line">res = book_obj.publish</span><br><span class="line">print(res.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、查询书籍主键=1的作者</span></span><br><span class="line">book_obj = models.Book.objects.filter(pk=<span class="number">1</span>).first()</span><br><span class="line"><span class="comment"># 从书籍查作者，外键在书籍表中，所以要按字段查询</span></span><br><span class="line"><span class="comment"># res = book_obj.authors</span></span><br><span class="line"><span class="comment"># print(res)</span></span><br><span class="line"><span class="comment"># app01.Author.None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 后面要加.all(),拿到的就是QuerySet对象</span></span><br><span class="line">res = book_obj.authors.all()</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># &lt;QuerySet [&lt;Author: Author object&gt;, &lt;Author: Author object&gt;, &lt;Author: Author object&gt;]&gt;</span></span><br><span class="line"></span><br><span class="line">res = book_obj.authors.values(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># &lt;QuerySet [&#123;&#x27;name&#x27;: &#x27;tank&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;jack&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;ross&#x27;&#125;]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、查询作者jack的电话号码</span></span><br><span class="line">author_obj = models.Author.objects.filter(name=<span class="string">&#x27;jack&#x27;</span>).first()</span><br><span class="line"><span class="comment"># 从作者表查询作者详情表，外键在作者表中，所以是正向查询,按字段查找</span></span><br><span class="line">res = author_obj.author_detail</span><br><span class="line">print(res.phone)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 什么时候需要加.all()</span></span><br><span class="line"><span class="comment"># 当你的结果可能有多个时就需要加.all()，如果结果是一个，则直接拿到数据对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、查询出版社是东方出版社出版的书</span></span><br><span class="line"><span class="comment"># 从出版社表查找书籍表，外键字段在书籍表中，所以属于反向查询，按表名小写查找</span></span><br><span class="line">publish_obj = models.Publish.objects.filter(name=<span class="string">&#x27;东方出版社&#x27;</span>).first()</span><br><span class="line">res = publish_obj.book_set.all()</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># 拿到了6本书</span></span><br><span class="line"><span class="comment"># &lt;QuerySet [&lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5、查询作者是jack的书籍</span></span><br><span class="line">author_obj = models.Author.objects.filter(name=<span class="string">&#x27;jack&#x27;</span>).first()</span><br><span class="line"><span class="comment"># 通过作者查询书籍是反向</span></span><br><span class="line">res = author_obj.book_set.all()</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># &lt;QuerySet [&lt;Book: Book object&gt;]&gt;</span></span><br><span class="line">print(res.values())</span><br><span class="line"><span class="comment"># &lt;QuerySet [&#123;&#x27;id&#x27;: 1, &#x27;title&#x27;: &#x27;三国演义&#x27;, &#x27;price&#x27;: Decimal(&#x27;123.12&#x27;), &#x27;publish_date&#x27;: datetime.date(2020, 8, 20), &#x27;publish_id&#x27;: 2&#125;]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6、查询手机号是1373900888的作者姓名</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">author_detail_obj = models.AuthorDetail.objects.filter(phone=<span class="number">1373900888</span>).first()</span><br><span class="line">res = author_detail_obj.author</span><br><span class="line">print(res.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当你的查询结果可以有多个时，就必须加_set.all()，当你的结果只有一个时，不需要加_set.all()</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>联表查询(基于双下划线的跨表查询)</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&quot;day64.settings&quot;</span>)</span><br><span class="line">    <span class="keyword">import</span> django</span><br><span class="line">    django.setup()</span><br><span class="line">    <span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line">    models.User.objects.all()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1、查询jack的手机号(一行代码搞定)</span></span><br><span class="line">    res = models.Author.objects.filter(name=<span class="string">&#x27;jack&#x27;</span>).values(<span class="string">&#x27;author_detail__phone&#x27;</span>)</span><br><span class="line">    print(res)</span><br><span class="line">    <span class="comment"># &lt;QuerySet [&#123;&#x27;author_detail__phone&#x27;: 13212128888&#125;]&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 反向查询，不用.Author</span></span><br><span class="line">    res = models.AuthorDetail.objects.filter(author__name=<span class="string">&#x27;jack&#x27;</span>).values(<span class="string">&#x27;phone&#x27;</span>)</span><br><span class="line">    print(res)</span><br><span class="line">    <span class="comment"># &lt;QuerySet [&#123;&#x27;phone&#x27;: 13212128888&#125;]&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2、查询书籍主键=1的出版社名称和书的名称</span></span><br><span class="line">    res = models.Book.objects.filter(pk=<span class="number">1</span>).values(<span class="string">&#x27;publish__name&#x27;</span>,<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line">    print(res)</span><br><span class="line">    <span class="comment"># &lt; QuerySet[&#123;&#x27;publish__name&#x27;: &#x27;人民出版社&#x27;, &#x27;title&#x27;: &#x27;三国演义&#x27;&#125;] &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 反向查询</span></span><br><span class="line">    res = models.Publish.objects.filter(book__id=<span class="number">1</span>).values(<span class="string">&#x27;book__title&#x27;</span>,<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    print(res)</span><br><span class="line">    <span class="comment"># &lt;QuerySet [&#123;&#x27;book__title&#x27;: &#x27;三国演义&#x27;, &#x27;name&#x27;: &#x27;人民出版社&#x27;&#125;]&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3、查询书籍主键为1的作者姓名</span></span><br><span class="line">    res = models.Book.objects.filter(pk=<span class="number">1</span>).values(<span class="string">&#x27;authors__name&#x27;</span>)</span><br><span class="line">    print(res)</span><br><span class="line">    <span class="comment"># &lt;QuerySet [&#123;&#x27;authors__name&#x27;: &#x27;tank&#x27;&#125;, &#123;&#x27;authors__name&#x27;: &#x27;jack&#x27;&#125;, &#123;&#x27;authors__name&#x27;: &#x27;ross&#x27;&#125;]&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 反向查询</span></span><br><span class="line">    res = models.Author.objects.filter(book__id=<span class="number">1</span>).values(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    print(res)</span><br><span class="line">    <span class="comment"># &lt;QuerySet [&#123;&#x27;name&#x27;: &#x27;tank&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;jack&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;ross&#x27;&#125;]&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4、查询书籍主键=1的作者的手机号</span></span><br><span class="line">    res = models.Book.objects.filter(pk=<span class="number">1</span>).values(<span class="string">&#x27;authors__author_detail__phone&#x27;</span>)</span><br><span class="line">    print(res)</span><br><span class="line">    <span class="comment"># &lt;QuerySet [&#123;&#x27;authors__author_detail__phone&#x27;: 2312123&#125;, &#123;&#x27;authors__author_detail__phone&#x27;: 13212128888&#125;, &#123;&#x27;authors__author_detail__phone&#x27;: 13739008888&#125;]&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="8、聚合查询"><a href="#8、聚合查询" class="headerlink" title="8、聚合查询"></a>8、聚合查询</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 聚合查询(需要先导入)</span></span><br><span class="line"><span class="comment"># 只要是跟数据库相关的模块，基本上都在django.db.models里面，如果没有，应该在django.db里面</span></span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Min,Max,Sum,Count,Avg</span><br><span class="line"><span class="comment"># 聚合查询一般都是配合分组一起使用的</span></span><br><span class="line"><span class="comment"># 1、统计所有书的平均价格</span></span><br><span class="line">res = models.Book.objects.aggregate(Avg(<span class="string">&#x27;price&#x27;</span>))</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># &#123;&#x27;price__avg&#x27;: 143.350769&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、五个聚合函数</span></span><br><span class="line">res = models.Book.objects.aggregate(Avg(<span class="string">&#x27;price&#x27;</span>),Max(<span class="string">&#x27;price&#x27;</span>),Min(<span class="string">&#x27;price&#x27;</span>),Count(<span class="string">&#x27;price&#x27;</span>),Sum(<span class="string">&#x27;price&#x27;</span>))</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># &#123;&#x27;price__avg&#x27;: 143.350769, &#x27;price__max&#x27;: Decimal(&#x27;223.12&#x27;), &#x27;price__min&#x27;: Decimal(&#x27;23.12&#x27;), &#x27;price__count&#x27;: 13, &#x27;price__sum&#x27;: Decimal(&#x27;1863.56&#x27;)&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="9、分组查询"><a href="#9、分组查询" class="headerlink" title="9、分组查询"></a>9、分组查询</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里需要注意的是annotate分组依据就是他前面的值values，</span><br><span class="line">如果前面没有特点的字段，则默认按照ID分组，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关键字：annotate 和 values 连用 就是代表 group by 分组</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">   <span class="comment"># 分组查询(annotate)</span></span><br><span class="line">   <span class="comment"># mysql分组查询特点：</span></span><br><span class="line">   <span class="comment"># 分组之后默认只能获取到分组的依据，组内其他字段都无法直接获取了。因为设置了严格模式，ONLY_FULL_GROUP_BY</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">from</span> django.db.models <span class="keyword">import</span> Min, Max, Sum, Count, Avg</span><br><span class="line">   <span class="comment"># 1、统计每一本书的作者个数</span></span><br><span class="line">   <span class="comment"># res = models.Book.objects.annotate()   # 默认按照models.后面的表来分组</span></span><br><span class="line">   <span class="comment"># res = models.Book.objects.annotate(author_num = Count(&#x27;authors__pk&#x27;))</span></span><br><span class="line">   res = models.Book.objects.annotate(author_num = Count(<span class="string">&#x27;authors&#x27;</span>)).values(<span class="string">&#x27;title&#x27;</span>,<span class="string">&#x27;author_num&#x27;</span>)</span><br><span class="line">   print(res)</span><br><span class="line">   <span class="comment"># &lt;QuerySet [&#123;&#x27;title&#x27;: &#x27;三国演义&#x27;, &#x27;author_num&#x27;: 3&#125;, &#123;&#x27;title&#x27;: &#x27;红楼梦&#x27;, &#x27;author_num&#x27;: 0&#125;, &#123;&#x27;title&#x27;: &#x27;三国演义&#x27;, &#x27;author_num&#x27;: 0&#125;, &#123;&#x27;title&#x27;: &#x27;红楼梦&#x27;, &#x27;author_num&#x27;: 0&#125;, &#123;&#x27;title&#x27;: &#x27;三国演义&#x27;, &#x27;author_num&#x27;: 0&#125;, &#123;&#x27;title&#x27;: &#x27;红楼梦&#x27;, &#x27;author_num&#x27;: 0&#125;, &#123;&#x27;title&#x27;: &#x27;三国演义&#x27;, &#x27;author_num&#x27;: 0&#125;, &#123;&#x27;title&#x27;: &#x27;红楼梦&#x27;, &#x27;author_num&#x27;: 0&#125;, &#123;&#x27;title&#x27;: &#x27;三国演义&#x27;, &#x27;author_num&#x27;: 0&#125;, &#123;&#x27;title&#x27;: &#x27;红楼梦&#x27;, &#x27;author_num&#x27;: 0&#125;, &#123;&#x27;title&#x27;: &#x27;你今天真好看&#x27;, &#x27;author_num&#x27;: 0&#125;, &#123;&#x27;title&#x27;: &#x27;人性的弱点&#x27;, &#x27;author_num&#x27;: 0&#125;, &#123;&#x27;title&#x27;: &#x27;次第花开&#x27;, &#x27;author_num&#x27;: 0&#125;]&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 按照书名进行分组，就不会有重复数据了：</span></span><br><span class="line">   res = models.Book.objects.values(<span class="string">&#x27;title&#x27;</span>).annotate(author_num = Count(<span class="string">&#x27;authors&#x27;</span>)).values(<span class="string">&#x27;title&#x27;</span>,<span class="string">&#x27;author_num&#x27;</span>)</span><br><span class="line">   print(res)</span><br><span class="line">   <span class="comment"># &lt;QuerySet [&#123;&#x27;title&#x27;: &#x27;三国演义&#x27;, &#x27;author_num&#x27;: 3&#125;, &#123;&#x27;title&#x27;: &#x27;红楼梦&#x27;, &#x27;author_num&#x27;: 0&#125;, &#123;&#x27;title&#x27;: &#x27;你今天真好看&#x27;, &#x27;author_num&#x27;: 0&#125;, &#123;&#x27;title&#x27;: &#x27;人性的弱点&#x27;, &#x27;author_num&#x27;: 0&#125;, &#123;&#x27;title&#x27;: &#x27;次第花开&#x27;, &#x27;author_num&#x27;: 0&#125;]&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment"># 2、统计每个出版社卖的最便宜的书的价格</span></span><br><span class="line">   <span class="comment"># 通过出版社查找书，是反向查询，</span></span><br><span class="line">   res = models.Publish.objects.annotate(book_min_price = Min(<span class="string">&#x27;book__price&#x27;</span>)).values(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;book_min_price&#x27;</span>)</span><br><span class="line">   print(res)</span><br><span class="line">   <span class="comment"># &lt;QuerySet [&#123;&#x27;name&#x27;: &#x27;东方出版社&#x27;, &#x27;book_min_price&#x27;: Decimal(&#x27;45.12&#x27;)&#125;, &#123;&#x27;name&#x27;: &#x27;人民出版社&#x27;, &#x27;book_min_price&#x27;: Decimal(&#x27;23.12&#x27;)&#125;]&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment"># 3、统计不止一个作者的图书</span></span><br><span class="line">   res = models.Book.objects.annotate(author_num = Count(<span class="string">&#x27;authors&#x27;</span>)).filter(author_num__gte = <span class="number">2</span>).values(<span class="string">&#x27;title&#x27;</span>,<span class="string">&#x27;author_num&#x27;</span>)</span><br><span class="line">   print(res)</span><br><span class="line">   <span class="comment"># &lt;QuerySet [&#123;&#x27;title&#x27;: &#x27;三国演义&#x27;, &#x27;author_num&#x27;: 3&#125;]&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 只要你的ORM语句得出的结果还是一个queryset对象，那么它就可以继续无限制的.queryset对象封装的方法</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 4、查询每个作者出的书的总价格</span></span><br><span class="line">   <span class="comment"># 反向查询</span></span><br><span class="line">   res = models.Author.objects.annotate(book_price_sum = Sum(<span class="string">&#x27;book__price&#x27;</span>)).values(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;book_price_sum&#x27;</span>)</span><br><span class="line">   print(res)</span><br><span class="line">   <span class="comment"># &lt;QuerySet [&#123;&#x27;name&#x27;: &#x27;tank&#x27;, &#x27;book_price_sum&#x27;: Decimal(&#x27;123.12&#x27;)&#125;, &#123;&#x27;name&#x27;: &#x27;jack&#x27;, &#x27;book_price_sum&#x27;: Decimal(&#x27;123.12&#x27;)&#125;, &#123;&#x27;name&#x27;: &#x27;ross&#x27;, &#x27;book_price_sum&#x27;: Decimal(&#x27;123.12&#x27;)&#125;]&gt;</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照指定的字段分组：</span></span><br><span class="line">   <span class="comment"># res = models.Book.objects.values(&#x27;title&#x27;).annotate()</span></span><br></pre></td></tr></table></figure>

<h1 id="10、F与Q查询"><a href="#10、F与Q查询" class="headerlink" title="10、F与Q查询"></a>10、F与Q查询</h1><p>我们先给Book表增加两个字段：库存量、卖出量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">8</span>,decimal_places=<span class="number">2</span>)</span><br><span class="line">    publish_date = models.DateField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 库存</span></span><br><span class="line">    inventory = models.IntegerField(default=<span class="number">1000</span>)</span><br><span class="line">    <span class="comment"># 卖出</span></span><br><span class="line">    sale = models.IntegerField(default=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 书籍与出版社一对多的关系：</span></span><br><span class="line">    publish = models.ForeignKey(to=<span class="string">&#x27;Publish&#x27;</span>)</span><br><span class="line">    <span class="comment"># 书籍与作者多对多关系：</span></span><br><span class="line">    authors = models.ManyToManyField(to=<span class="string">&#x27;Author&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>然后同步到数据库中：</strong><br>makemigrations<br>migrate</p>
<blockquote>
<p><strong>F查询</strong></p>
<p><strong>当查询条件的左右两边都来自于表中则可以使用F查询，帮助你获取到表中某个字段对应的数据</strong></p>
<p><strong>F查询甚至还可以统一修改表中字段数据</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、查询卖出数大于库存数的书籍</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</span><br><span class="line">res = models.Book.objects.filter(sale__gt=F(<span class="string">&#x27;inventory&#x27;</span>))</span><br><span class="line">print(res.values(<span class="string">&#x27;title&#x27;</span>))</span><br><span class="line"><span class="comment"># &lt;QuerySet [&#123;&#x27;title&#x27;: &#x27;红楼梦&#x27;&#125;]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、将所有书的价格提升50元</span></span><br><span class="line">models.Book.objects.update(price = F(<span class="string">&#x27;price&#x27;</span>)+<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、将所有书的名称后面加上爆款两个字</span></span><br><span class="line"><span class="comment"># 在操作字符类型数据的时候，需要导入以下两个模块</span></span><br><span class="line"><span class="keyword">from</span> django.db.models.functions <span class="keyword">import</span> Concat</span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Value</span><br><span class="line">models.Book.objects.update(title = Concat(F(<span class="string">&#x27;title&#x27;</span>),Value(<span class="string">&#x27;(爆款)&#x27;</span>)))</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Q查询</strong></p>
<p><strong>filter默认支持and连接查询条件，如果需要修改多个查询条件之间的关系；可以使用Q  与或非</strong></p>
<p><strong>高阶用法：能够将查询条件的左边也变成字符串的形式，而不再是变量名的形式</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Q查询</span></span><br><span class="line"><span class="comment"># 1、查询卖出数大于1000或者价格小于300的书籍</span></span><br><span class="line"><span class="comment"># filter括号内多个参数是and的关系</span></span><br><span class="line">res = models.Book.objects.filter(sale__gt=<span class="number">1000</span>,price__lt=<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们需要借助于Q查询</span></span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line"><span class="comment"># 中间逗号隔开，是and的关系</span></span><br><span class="line">res = models.Book.objects.filter(Q(sale__gt=<span class="number">1000</span>),Q(price__lt=<span class="number">300</span>))</span><br><span class="line">print(res.values(<span class="string">&#x27;title&#x27;</span>))</span><br><span class="line"><span class="comment"># &lt;QuerySet []&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 中间竖杠|隔开，是or的关系</span></span><br><span class="line">res1 = models.Book.objects.filter(Q(sale__gt=<span class="number">1000</span>)|Q(price__lt=<span class="number">300</span>))</span><br><span class="line">print(res1.values(<span class="string">&#x27;title&#x27;</span>))</span><br><span class="line"><span class="comment"># &lt;QuerySet [&#123;&#x27;title&#x27;: &#x27;红楼梦(爆款)&#x27;&#125;, &#123;&#x27;title&#x27;: &#x27;你今天真好看(爆款)&#x27;&#125;, &#123;&#x27;title&#x27;: &#x27;次第花开(爆款)&#x27;&#125;]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ~是not关系，表示卖出数&lt;=1000或者价格&gt;=300的书籍</span></span><br><span class="line">res2 = models.Book.objects.filter(~Q(sale__gt=<span class="number">1000</span>)|~Q(price__lt=<span class="number">300</span>))</span><br><span class="line">print(res2.values(<span class="string">&#x27;title&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Q的高阶用法：能够将查询条件的左边也变成字符串的形式，而不再是变量名的形式</span></span><br><span class="line">q=Q()                              <span class="comment"># 先生成一个Q对象</span></span><br><span class="line">q.connector = <span class="string">&#x27;or&#x27;</span>  <span class="comment"># 默认是and关系，通过connector修改关系。</span></span><br><span class="line">q.children.append((<span class="string">&#x27;sale__gt&#x27;</span>,<span class="number">1000</span>))</span><br><span class="line">q.children.append((<span class="string">&#x27;price__lt&#x27;</span>,<span class="number">300</span>))</span><br><span class="line">res = models.Book.objects.filter(q)</span><br><span class="line">print(res.values(<span class="string">&#x27;title&#x27;</span>))</span><br><span class="line"><span class="comment"># &lt;QuerySet [&#123;&#x27;title&#x27;: &#x27;红楼梦(爆款)&#x27;&#125;, &#123;&#x27;title&#x27;: &#x27;你今天真好看(爆款)&#x27;&#125;, &#123;&#x27;title&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>value里面的参数对应的是sql语句中的select要查找显示的字段，</p>
<p>filter里面的参数相当于where或者having里面的筛选条件</p>
<p>annotate本身表示group by的作用，前面找寻分组依据，内部放置显示可能用到的聚合运算式，后面跟filter来增加限制条件，最后的value来表示分组后想要查找的字段值</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1342004-20180621160603196-86991215.png" alt="img"></p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="从已有数据库中反向生成model类："><a href="#从已有数据库中反向生成model类：" class="headerlink" title="从已有数据库中反向生成model类："></a>从已有数据库中反向生成model类：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py inspectdb &gt; all_models.py</span><br></pre></td></tr></table></figure>



<h3 id="原生SQL三种查询方式的示例："><a href="#原生SQL三种查询方式的示例：" class="headerlink" title="原生SQL三种查询方式的示例："></a>原生SQL三种查询方式的示例：</h3><p><a href="https://www.cnblogs.com/fmgao-technology/p/10119671.html#_label0">https://www.cnblogs.com/fmgao-technology/p/10119671.html#_label0</a></p>
<h4 id="Raw执行原生SQL语句"><a href="#Raw执行原生SQL语句" class="headerlink" title="Raw执行原生SQL语句"></a>Raw执行原生SQL语句</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = models.Book.objects.raw(<span class="string">&#x27;select * from app01_book&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line">这个 RawQuerySet 能像普通的 QuerySet 一样被迭代获取对象实例</span><br></pre></td></tr></table></figure>

<h4 id="Cursor-直接执行自定义SQL（raw无法满足需求的时候）"><a href="#Cursor-直接执行自定义SQL（raw无法满足需求的时候）" class="headerlink" title="Cursor 直接执行自定义SQL（raw无法满足需求的时候）"></a>Cursor 直接执行自定义SQL（raw无法满足需求的时候）</h4><p>官网链接：<a href="https://docs.djangoproject.com/zh-hans/3.2/topics/db/sql/">https://docs.djangoproject.com/zh-hans/3.2/topics/db/sql/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.db import connection</span><br><span class="line"></span><br><span class="line">def my_custom_sql(self):</span><br><span class="line">    with connection.cursor() as cursor:</span><br><span class="line">        cursor.execute(&quot;UPDATE bar SET foo &#x3D; 1 WHERE baz &#x3D; %s&quot;, [self.baz])</span><br><span class="line">        cursor.execute(&quot;SELECT foo FROM bar WHERE baz &#x3D; %s&quot;, [self.baz])</span><br><span class="line">        row &#x3D; cursor.fetchone()</span><br><span class="line"></span><br><span class="line">    return row</span><br></pre></td></tr></table></figure>

<h4 id="extra-执行结果集的操作"><a href="#extra-执行结果集的操作" class="headerlink" title="extra 执行结果集的操作"></a>extra 执行结果集的操作</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">使用extra:</span><br><span class="line"><span class="number">1</span>:Book.objects.filter(publisher__name=<span class="string">&#x27;广东人员出版社&#x27;</span>).extra(where=[<span class="string">&#x27;price&gt;50&#x27;</span>])</span><br><span class="line">Book.objects.filter(publisher__name=<span class="string">&#x27;广东人员出版社&#x27;</span>,price__gt=<span class="number">50</span>)</span><br><span class="line"><span class="number">2</span>:Book.objects.extra(select=&#123;<span class="string">&#x27;count&#x27;</span>:<span class="string">&#x27;select count(*) from hello_Book&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>



<p>数据库设计三大范式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原子性（Atomicity）：不可分割的最小单位</span><br><span class="line">一致性（Consistency）：跟原子性相辅相成</span><br><span class="line">隔离性（Isolation）：事务之间互相不干扰</span><br><span class="line">持久性（Durability）：事务一旦确认永久生效</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>09-Django进阶-模型-多表</title>
    <url>/posts/43887.html</url>
    <content><![CDATA[<p>Django Models 多表/子查询/联表查询/FQ</p>
<a id="more"></a>

<h2 id="一-创建模型"><a href="#一-创建模型" class="headerlink" title="一 创建模型"></a>一 创建模型</h2><p>实例：我们来假定下面这些概念，字段和关系</p>
<p>作者模型：一个作者有姓名和年龄。</p>
<p>作者详细模型：把作者的详情放到详情表，包含生日，手机号，家庭住址等信息。作者详情模型和作者模型之间是一对一的关系（one-to-one）</p>
<p>出版商模型：出版商有名称，所在城市以及email。</p>
<p>书籍模型： 书籍有书名和出版日期，一本书可能会有多个作者，一个作者也可以写多本书，所以作者和书籍的关系就是多对多的关联关系(many-to-many);一本书只应该由一个出版商出版，所以出版商和书籍是一对多关联关系(one-to-many)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Book</span><br><span class="line"></span><br><span class="line">   id    title   price  publish    </span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>      php     <span class="number">100</span>   人民出版社  </span><br><span class="line">   <span class="number">2</span>      python  <span class="number">200</span>   老男孩出版社   </span><br><span class="line">   <span class="number">3</span>      go      <span class="number">100</span>   人民出版社  </span><br><span class="line">   <span class="number">4</span>      java    <span class="number">300</span>   人民出版社  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">为了存储出版社的邮箱，地址，在第一个表后面加字段</span><br><span class="line"></span><br><span class="line">Book</span><br><span class="line"></span><br><span class="line">   id    title   price  publish    email    addr    </span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>      php     <span class="number">100</span>   人民出版社   <span class="number">111</span>      北京</span><br><span class="line">   <span class="number">2</span>      python  <span class="number">200</span>   老男孩出版社 <span class="number">222</span>      上海</span><br><span class="line">   <span class="number">3</span>      go      <span class="number">100</span>   人民出版社   <span class="number">111</span>      北京</span><br><span class="line">   <span class="number">4</span>      java    <span class="number">300</span>   人民出版社   <span class="number">111</span>      北京</span><br><span class="line">   </span><br><span class="line">这样会有大量重复的数据，浪费空间</span><br><span class="line"></span><br><span class="line"><span class="comment">####################################################################################</span></span><br><span class="line"></span><br><span class="line">一对多：一个出版社对应多本书（关联信息建在多的一方，也就是book表中）</span><br><span class="line"></span><br><span class="line">Book</span><br><span class="line"></span><br><span class="line">   id    title   price     publish_id   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>      php     <span class="number">100</span>         <span class="number">1</span></span><br><span class="line">   <span class="number">2</span>      python  <span class="number">200</span>         <span class="number">1</span></span><br><span class="line">   <span class="number">3</span>      go      <span class="number">100</span>         <span class="number">2</span>  </span><br><span class="line">   <span class="number">4</span>      java    <span class="number">300</span>         <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Publish</span><br><span class="line"></span><br><span class="line">    id    name       email    addr    </span><br><span class="line">     <span class="number">1</span>    人民出版社   <span class="number">111</span>      北京       </span><br><span class="line">     <span class="number">2</span>    沙河出版社   <span class="number">222</span>      沙河</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总结：一旦确定表关系是一对多：在多对应的表中创建关联字段（在多的表里创建关联字段）  ，publish_id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查询python这本书的出版社的邮箱(子查询)</span><br><span class="line"></span><br><span class="line">   select publish_id <span class="keyword">from</span> Book where title=“python”</span><br><span class="line">   select email <span class="keyword">from</span> Publish where id=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">####################################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">多对多：一本书有多个作者，一个作者出多本书</span><br><span class="line"></span><br><span class="line">Book</span><br><span class="line"></span><br><span class="line">   id    title   price     publish_id    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>      php     <span class="number">100</span>         <span class="number">1</span>               </span><br><span class="line">   <span class="number">2</span>      python  <span class="number">200</span>         <span class="number">1</span></span><br><span class="line">   <span class="number">3</span>      go      <span class="number">100</span>         <span class="number">2</span>  </span><br><span class="line">   <span class="number">4</span>      java    <span class="number">300</span>         <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Author</span><br><span class="line">         id  name  age   addr</span><br><span class="line"></span><br><span class="line">         <span class="number">1</span>    alex  <span class="number">34</span>   beijing</span><br><span class="line">         <span class="number">2</span>    egon  <span class="number">55</span>   nanjing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Book2Author</span><br><span class="line"></span><br><span class="line">    id    book_id  author_id</span><br><span class="line">     <span class="number">1</span>       <span class="number">2</span>         <span class="number">1</span></span><br><span class="line">     <span class="number">2</span>       <span class="number">2</span>         <span class="number">2</span></span><br><span class="line"></span><br><span class="line">     <span class="number">3</span>       <span class="number">3</span>         <span class="number">2</span></span><br><span class="line"></span><br><span class="line">总结：一旦确定表关系是多对多：创建第三张关系表（创建中间表，中间表就三个字段，自己的id，书籍id和作者id） ：</span><br><span class="line">          </span><br><span class="line">          id      book_id   author_id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># lqz出版过的书籍名称(子查询)</span></span><br><span class="line"></span><br><span class="line">select id <span class="keyword">from</span> Author where name=<span class="string">&#x27;lqz&#x27;</span></span><br><span class="line"></span><br><span class="line">select book_id <span class="keyword">from</span> Book2Author where  author_id=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">select title <span class="keyword">from</span> Book where id =book_id</span><br><span class="line"></span><br><span class="line"><span class="comment">####################################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一对一：对作者详细信息的扩展（作者表和作者详情表）</span><br><span class="line"></span><br><span class="line">Author</span><br><span class="line">         id  name  age     ad_id(UNIQUE) </span><br><span class="line"></span><br><span class="line">         <span class="number">1</span>    lqz  <span class="number">34</span>       <span class="number">1</span>     </span><br><span class="line">         <span class="number">2</span>    egon  <span class="number">55</span>       <span class="number">2</span>     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AuthorDetail</span><br><span class="line"></span><br><span class="line">   id    addr      gender    tel   gf_name   author_id(UNIQUE)</span><br><span class="line">    <span class="number">1</span>   beijing    male      <span class="number">110</span>   小花           <span class="number">1</span></span><br><span class="line">    <span class="number">2</span>   nanjing    male      <span class="number">911</span>   杠娘           <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总结： 一旦确定是一对一的关系：在两张表中的任意一张表中建立关联字段＋Unique</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">====================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Publish  </span><br><span class="line">Book</span><br><span class="line">Author</span><br><span class="line">AuthorDetail</span><br><span class="line">Book2Author</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE publish(</span><br><span class="line">                id INT PRIMARY KEY auto_increment ,</span><br><span class="line">                name VARCHAR (<span class="number">20</span>)</span><br><span class="line">              );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE book(</span><br><span class="line">                id INT PRIMARY KEY auto_increment ,</span><br><span class="line">                title VARCHAR (<span class="number">20</span>),</span><br><span class="line">                price DECIMAL (<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">                pub_date DATE ,</span><br><span class="line">                publish_id INT ,</span><br><span class="line">                FOREIGN KEY (publish_id) REFERENCES publish(id)</span><br><span class="line">              );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE authordetail(</span><br><span class="line">                id INT PRIMARY KEY auto_increment ,</span><br><span class="line">                tel VARCHAR (<span class="number">20</span>)</span><br><span class="line">              );</span><br><span class="line"></span><br><span class="line">CREATE TABLE author(</span><br><span class="line">                id INT PRIMARY KEY auto_increment ,</span><br><span class="line">                name VARCHAR (<span class="number">20</span>),</span><br><span class="line">                age INT,</span><br><span class="line">                authordetail_id INT UNIQUE ,</span><br><span class="line">                FOREIGN KEY (authordetail_id) REFERENCES authordetail(id)</span><br><span class="line">              );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE  TABLE book2author(</span><br><span class="line">       id INT PRIMARY KEY auto_increment ,</span><br><span class="line">       book_id INT ,</span><br><span class="line">       author_id INT ,</span><br><span class="line">       FOREIGN KEY (book_id) REFERENCES book(id),</span><br><span class="line">       FOREIGN KEY (author_id) REFERENCES author(id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>注意：关联字段与外键约束没有必然的联系（建管理字段是为了进行查询，建约束是为了不出现脏数据）</strong></p>
<p>在Models创建如下模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    nid = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">5</span>, decimal_places=<span class="number">2</span>)</span><br><span class="line">    publish_date = models.DateField()</span><br><span class="line">    <span class="comment"># 阅读数</span></span><br><span class="line">    <span class="comment"># reat_num=models.IntegerField(default=0)</span></span><br><span class="line">    <span class="comment"># 评论数</span></span><br><span class="line">    <span class="comment"># commit_num=models.IntegerField(default=0)</span></span><br><span class="line"></span><br><span class="line">    publish = models.ForeignKey(to=<span class="string">&#x27;Publish&#x27;</span>,to_field=<span class="string">&#x27;nid&#x27;</span>,on_delete=models.CASCADE)</span><br><span class="line">    authors=models.ManyToManyField(to=<span class="string">&#x27;Author&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    nid = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line">    author_detail = models.OneToOneField(to=<span class="string">&#x27;AuthorDatail&#x27;</span>,to_field=<span class="string">&#x27;nid&#x27;</span>,unique=<span class="literal">True</span>,on_delete=models.CASCADE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthorDatail</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    nid = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    telephone = models.BigIntegerField()</span><br><span class="line">    birthday = models.DateField()</span><br><span class="line">    addr = models.CharField(max_length=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publish</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    nid = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    city = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    email = models.EmailField()</span><br></pre></td></tr></table></figure>

<p>生成的表如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gj6qcrj0acj30q80pygqi.jpg" alt="image-20200928222403872"></p>
<p>注意事项：</p>
<ul>
<li>表的名称<code>myapp_modelName</code>，是根据 模型中的元数据自动生成的，也可以覆写为别的名称　　</li>
<li><code>id</code> 字段是自动添加的</li>
<li>对于外键字段，Django 会在字段名上添加<code>&quot;_id&quot;</code> 来创建数据库中的列名</li>
<li>这个例子中的<code>CREATE TABLE</code> SQL 语句使用PostgreSQL 语法格式，要注意的是Django 会根据settings 中指定的数据库类型来使用相应的SQL 语句。</li>
<li>定义好模型之后，你需要告诉Django _使用_这些模型。你要做的就是修改配置文件中的INSTALL_APPSZ中设置，在其中添加<code>models.py</code>所在应用的名称。</li>
<li>外键字段 ForeignKey 有一个 null=True 的设置(它允许外键接受空值 NULL)，你可以赋给它空值 None 。</li>
</ul>
<h2 id="二-添加表记录"><a href="#二-添加表记录" class="headerlink" title="二 添加表记录"></a>二 添加表记录</h2><h3 id="一对多的"><a href="#一对多的" class="headerlink" title="一对多的"></a>一对多的</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">方式<span class="number">1</span>:</span><br><span class="line">   publish_obj=Publish.objects.get(nid=<span class="number">1</span>)</span><br><span class="line">   book_obj=Book.objects.create(title=<span class="string">&quot;&quot;</span>,publishDate=<span class="string">&quot;2012-12-12&quot;</span>,price=<span class="number">100</span>,publish=publish_obj)</span><br><span class="line">  </span><br><span class="line">方式<span class="number">2</span>:</span><br><span class="line">   book_obj=Book.objects.create(title=<span class="string">&quot;&quot;</span>,publishDate=<span class="string">&quot;2012-12-12&quot;</span>,price=<span class="number">100</span>,publish_id=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>核心：book_obj.publish与book_obj.publish_id是什么？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">关键点:</span><br><span class="line"></span><br><span class="line"> 一 book_obj.publish=Publish.objects.filter(id=book_obj.publish_id).first()</span><br><span class="line"></span><br><span class="line"> 二 book_obj.authors.all()</span><br><span class="line">    关键点:book.authors.all()  <span class="comment"># 与这本书关联的作者集合</span></span><br><span class="line"></span><br><span class="line">     <span class="number">1</span> book.id=<span class="number">3</span></span><br><span class="line">     <span class="number">2</span> book_authors</span><br><span class="line">         id  book_id  author_ID</span><br><span class="line">         <span class="number">3</span>      <span class="number">3</span>             <span class="number">1</span></span><br><span class="line">         <span class="number">4</span>      <span class="number">3</span>             <span class="number">2</span></span><br><span class="line"></span><br><span class="line">     <span class="number">3</span>  author</span><br><span class="line">        id   name</span><br><span class="line">        <span class="number">1</span>   lqz</span><br><span class="line">        <span class="number">2</span>   egon</span><br><span class="line"></span><br><span class="line"> book_obj.authors.all()    -------&gt;   [lqz,egon]</span><br><span class="line"><span class="comment"># -----一对多添加</span></span><br><span class="line">pub=Publish.objects.create(name=<span class="string">&#x27;egon出版社&#x27;</span>,email=<span class="string">&#x27;445676@qq.com&#x27;</span>,city=<span class="string">&#x27;山东&#x27;</span>)</span><br><span class="line">print(pub)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为book表绑定和publish的关系</span></span><br><span class="line"><span class="keyword">import</span> datetime,time</span><br><span class="line">now=datetime.datetime.now().__str__()</span><br><span class="line">now = datetime.datetime.now().strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line">print(type(now))</span><br><span class="line">print(now)</span><br><span class="line"><span class="comment"># 日期类型必须是日期对象或者字符串形式的2018-09-12（2018-9-12），其它形式不行</span></span><br><span class="line">Book.objects.create(name=<span class="string">&#x27;海燕3&#x27;</span>,price=<span class="number">333.123</span>,publish_date=now,publish_id=<span class="number">2</span>)</span><br><span class="line">Book.objects.create(name=<span class="string">&#x27;海3燕3&#x27;</span>,price=<span class="number">35.123</span>,publish_date=<span class="string">&#x27;2018/02/28&#x27;</span>,publish=pub)</span><br><span class="line">pub=Publish.objects.filter(nid=<span class="number">1</span>).first()</span><br><span class="line">book=Book.objects.create(name=<span class="string">&#x27;测试书籍&#x27;</span>,price=<span class="number">33</span>,publish_date=<span class="string">&#x27;2018-7-28&#x27;</span>,publish=pub)</span><br><span class="line">print(book.publish.name)</span><br><span class="line"><span class="comment"># 查询出版了红楼梦这本书出版社的邮箱</span></span><br><span class="line">book=Book.objects.filter(name=<span class="string">&#x27;红楼梦&#x27;</span>).first()</span><br><span class="line">print(book.publish.email)</span><br></pre></td></tr></table></figure>

<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当前生成的书籍对象</span></span><br><span class="line">  book_obj=Book.objects.create(title=<span class="string">&quot;追风筝的人&quot;</span>,price=<span class="number">200</span>,publishDate=<span class="string">&quot;2012-11-12&quot;</span>,publish_id=<span class="number">1</span>)</span><br><span class="line">  <span class="comment"># 为书籍绑定的做作者对象</span></span><br><span class="line">  yuan=Author.objects.filter(name=<span class="string">&quot;yuan&quot;</span>).first() <span class="comment"># 在Author表中主键为2的纪录</span></span><br><span class="line">  egon=Author.objects.filter(name=<span class="string">&quot;alex&quot;</span>).first() <span class="comment"># 在Author表中主键为1的纪录</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 绑定多对多关系,即向关系表book_authors中添加纪录</span></span><br><span class="line">  book_obj.authors.add(yuan,egon)    <span class="comment">#  将某些特定的 model 对象添加到被关联对象集合中。   =======    book_obj.authors.add(*[])</span></span><br><span class="line">book = Book.objects.filter(name=<span class="string">&#x27;红楼梦&#x27;</span>).first()</span><br><span class="line">egon=Author.objects.filter(name=<span class="string">&#x27;egon&#x27;</span>).first()</span><br><span class="line">lqz=Author.objects.filter(name=<span class="string">&#x27;lqz&#x27;</span>).first()</span><br><span class="line"><span class="comment"># 1 没有返回值，直接传对象</span></span><br><span class="line">book.authors.add(lqz,egon)</span><br><span class="line"><span class="comment"># 2 直接传作者id</span></span><br><span class="line">book.authors.add(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 3 直接传列表,会打散</span></span><br><span class="line">book.authors.add(*[<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 解除多对多关系</span></span><br><span class="line">book = Book.objects.filter(name=<span class="string">&#x27;红楼梦&#x27;</span>).first()</span><br><span class="line"><span class="comment"># 1 传作者id</span></span><br><span class="line">book.authors.remove(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 2 传作者对象</span></span><br><span class="line">egon = Author.objects.filter(name=<span class="string">&#x27;egon&#x27;</span>).first()</span><br><span class="line">book.authors.remove(egon)</span><br><span class="line"><span class="comment">#3 传*列表</span></span><br><span class="line">book.authors.remove(*[<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="comment">#4 删除所有</span></span><br><span class="line">book.authors.clear()</span><br><span class="line"><span class="comment"># 5 拿到与 这本书关联的所有作者，结果是queryset对象，作者列表</span></span><br><span class="line">ret=book.authors.all()</span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"><span class="comment"># 6 queryset对象，又可以继续点（查询红楼梦这本书所有作者的名字）</span></span><br><span class="line">ret=book.authors.all().values(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">print(ret)</span><br><span class="line"><span class="comment"># 以上总结：</span></span><br><span class="line"><span class="comment"># （1）</span></span><br><span class="line"><span class="comment"># book=Book.objects.filter(name=&#x27;红楼梦&#x27;).first()</span></span><br><span class="line"><span class="comment"># print(book)</span></span><br><span class="line"><span class="comment"># 在点publish的时候，其实就是拿着publish_id又去app01_publish这个表里查数据了</span></span><br><span class="line"><span class="comment"># print(book.publish)</span></span><br><span class="line"><span class="comment"># （2）book.authors.all()</span></span><br></pre></td></tr></table></figure>

<p>核心:book_obj.authors.all()是什么？</p>
<p><strong>多对多关系其它常用API：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">book_obj.authors.remove()      <span class="comment"># 将某个特定的对象从被关联对象集合中去除。    ======   book_obj.authors.remove(*[])</span></span><br><span class="line">book_obj.authors.clear()       <span class="comment">#清空被关联对象集合</span></span><br><span class="line">book_obj.authors.set()         <span class="comment">#先清空再设置</span></span><br></pre></td></tr></table></figure>

<h2 id="三-基于对象的跨表查询"><a href="#三-基于对象的跨表查询" class="headerlink" title="三 基于对象的跨表查询"></a>三 基于对象的跨表查询</h2><h3 id="一对多查询（publish与book）"><a href="#一对多查询（publish与book）" class="headerlink" title="一对多查询（publish与book）"></a>一对多查询（publish与book）</h3><p>正向查询（按字段：publish）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询主键为1的书籍的出版社所在的城市</span></span><br><span class="line">book_obj=Book.objects.filter(pk=<span class="number">1</span>).first()</span><br><span class="line"><span class="comment"># book_obj.publish 是主键为1的书籍对象关联的出版社对象</span></span><br><span class="line">print(book_obj.publish.city)</span><br></pre></td></tr></table></figure>

<p>反向查询（按表名：book_set）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">publish=Publish.objects.get(name=<span class="string">&quot;苹果出版社&quot;</span>)</span><br><span class="line"><span class="comment">#publish.book_set.all() : 与苹果出版社关联的所有书籍对象集合</span></span><br><span class="line">book_list=publish.book_set.all()    </span><br><span class="line"><span class="keyword">for</span> book_obj <span class="keyword">in</span> book_list:</span><br><span class="line">       print(book_obj.title)</span><br><span class="line"><span class="comment"># 一对多正向查询</span></span><br><span class="line"> book=Book.objects.filter(name=<span class="string">&#x27;红楼梦&#x27;</span>).first()</span><br><span class="line"> print(book.publish)<span class="comment">#与这本书关联的出版社对象</span></span><br><span class="line"> print(book.publish.name)</span><br><span class="line"> <span class="comment"># 一对多反向查询</span></span><br><span class="line"> <span class="comment"># 人民出版社出版过的书籍名称</span></span><br><span class="line"> pub=Publish.objects.filter(name=<span class="string">&#x27;人民出版社&#x27;</span>).first()</span><br><span class="line"> ret=pub.book_set.all()</span><br><span class="line"> print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="一对一查询（Author-与-AuthorDetail）"><a href="#一对一查询（Author-与-AuthorDetail）" class="headerlink" title="一对一查询（Author 与 AuthorDetail）"></a>一对一查询（Author 与 AuthorDetail）</h3><p>正向查询(按字段：authorDetail)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">egon&#x3D;Author.objects.filter(name&#x3D;&quot;egon&quot;).first()</span><br><span class="line">print(egon.authorDetail.telephone)</span><br></pre></td></tr></table></figure>

<p>反向查询(按表名：author)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询所有住址在北京的作者的姓名</span></span><br><span class="line"> </span><br><span class="line">authorDetail_list=AuthorDetail.objects.filter(addr=<span class="string">&quot;beijing&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> authorDetail_list:</span><br><span class="line">     print(obj.author.name)</span><br><span class="line"><span class="comment"># 一对一正向查询</span></span><br><span class="line"><span class="comment"># lqz的手机号</span></span><br><span class="line">lqz=Author.objects.filter(name=<span class="string">&#x27;lqz&#x27;</span>).first()</span><br><span class="line">tel=lqz.author_detail.telephone</span><br><span class="line">print(tel)</span><br><span class="line"><span class="comment"># 一对一反向查询</span></span><br><span class="line"><span class="comment"># 地址在北京的作者姓名</span></span><br><span class="line">author_detail=AuthorDatail.objects.filter(addr=<span class="string">&#x27;北京&#x27;</span>).first()</span><br><span class="line">name=author_detail.author.name</span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure>

<h3 id="多对多查询-Author-与-Book"><a href="#多对多查询-Author-与-Book" class="headerlink" title="多对多查询 (Author 与 Book)"></a>多对多查询 (Author 与 Book)</h3><p>正向查询(按字段：authors)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 眉所有作者的名字以及手机号</span></span><br><span class="line"> </span><br><span class="line">book_obj=Book.objects.filter(title=<span class="string">&quot;眉&quot;</span>).first()</span><br><span class="line">authors=book_obj.authors.all()</span><br><span class="line"><span class="keyword">for</span> author_obj <span class="keyword">in</span> authors:</span><br><span class="line">     print(author_obj.name,author_obj.authorDetail.telephone)</span><br></pre></td></tr></table></figure>

<p>反向查询(按表名：book_set)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询egon出过的所有书籍的名字</span></span><br><span class="line">  author_obj=Author.objects.get(name=<span class="string">&quot;egon&quot;</span>)</span><br><span class="line">  book_list=author_obj.book_set.all()        <span class="comment">#与egon作者相关的所有书籍</span></span><br><span class="line">  <span class="keyword">for</span> book_obj <span class="keyword">in</span> book_list:</span><br><span class="line">    print(book_obj.title)</span><br><span class="line"><span class="comment"># 正向查询----查询红楼梦所有作者名称</span></span><br><span class="line">book=Book.objects.filter(name=<span class="string">&#x27;红楼梦&#x27;</span>).first()</span><br><span class="line">ret=book.authors.all()</span><br><span class="line">print(ret)</span><br><span class="line"><span class="keyword">for</span> auth <span class="keyword">in</span> ret:</span><br><span class="line">print(auth.name)</span><br><span class="line"><span class="comment"># 反向查询 查询lqz这个作者写的所有书</span></span><br><span class="line">author=Author.objects.filter(name=<span class="string">&#x27;lqz&#x27;</span>).first()</span><br><span class="line">ret=author.book_set.all()</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>你可以通过在 ForeignKey() 和ManyToManyField的定义中设置 related_name 的值来覆写 FOO_set 的名称。例如，如果 Article model 中做一下更改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">publish = ForeignKey(Book, related_name=<span class="string">&#x27;bookList&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>那么接下来就会如我们看到这般:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询 人民出版社出版过的所有书籍</span></span><br><span class="line"> </span><br><span class="line">publish=Publish.objects.get(name=<span class="string">&quot;人民出版社&quot;</span>)</span><br><span class="line">book_list=publish.bookList.all()  <span class="comment"># 与人民出版社关联的所有书籍对象集合</span></span><br></pre></td></tr></table></figure>

<h2 id="四-基于双下划线的跨表查询"><a href="#四-基于双下划线的跨表查询" class="headerlink" title="四 基于双下划线的跨表查询"></a>四 基于双下划线的跨表查询</h2><p>Django 还提供了一种直观而高效的方式在查询(lookups)中表示关联关系，它能自动确认 SQL JOIN 联系。要做跨关系查询，就使用两个下划线来链接模型(model)间关联字段的名称，直到最终链接到你想要的model 为止。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">正向查询按字段,反向查询按表名小写用来告诉ORM引擎join哪张表</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 练习:  查询苹果出版社出版过的所有书籍的名字与价格(一对多)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正向查询 按字段:publish</span></span><br><span class="line"></span><br><span class="line">queryResult=Book.objects.filter(publish__name=<span class="string">&quot;苹果出版社&quot;</span>).values_list(<span class="string">&quot;title&quot;</span>,<span class="string">&quot;price&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反向查询 按表名:book</span></span><br><span class="line">queryResult=Publish.objects.filter(name=<span class="string">&quot;苹果出版社&quot;</span>).values_list(<span class="string">&quot;book__title&quot;</span>,<span class="string">&quot;book__price&quot;</span>)</span><br><span class="line">查询的本质一样，就是select <span class="keyword">from</span>的表不一样</span><br><span class="line"><span class="comment"># 正向查询按字段，反向查询按表名小写</span></span><br><span class="line"><span class="comment"># 查询红楼梦这本书出版社的名字</span></span><br><span class="line"><span class="comment"># select * from app01_book inner join app01_publish</span></span><br><span class="line"><span class="comment"># on app01_book.publish_id=app01_publish.nid</span></span><br><span class="line">ret=Book.objects.filter(name=<span class="string">&#x27;红楼梦&#x27;</span>).values(<span class="string">&#x27;publish__name&#x27;</span>)</span><br><span class="line">print(ret)</span><br><span class="line">ret=Publish.objects.filter(book__name=<span class="string">&#x27;红楼梦&#x27;</span>).values(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="多对多查询"><a href="#多对多查询" class="headerlink" title="多对多查询　"></a>多对多查询　</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 练习: 查询lqz出过的所有书籍的名字(多对多)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正向查询 按字段:authors:</span></span><br><span class="line">queryResult=Book.objects.filter(authors__name=<span class="string">&quot;lqz&quot;</span>).values_list(<span class="string">&quot;title&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反向查询 按表名:book</span></span><br><span class="line">queryResult=Author.objects.filter(name=<span class="string">&quot;lqz&quot;</span>).values_list(<span class="string">&quot;book__title&quot;</span>,<span class="string">&quot;book__price&quot;</span>)</span><br><span class="line"><span class="comment"># 正向查询按字段，反向查询按表名小写</span></span><br><span class="line"><span class="comment"># 查询红楼梦这本书出版社的名字</span></span><br><span class="line"><span class="comment"># select * from app01_book inner join app01_publish</span></span><br><span class="line"><span class="comment"># on app01_book.publish_id=app01_publish.nid</span></span><br><span class="line">ret=Book.objects.filter(name=<span class="string">&#x27;红楼梦&#x27;</span>).values(<span class="string">&#x27;publish__name&#x27;</span>)</span><br><span class="line">print(ret)</span><br><span class="line">ret=Publish.objects.filter(book__name=<span class="string">&#x27;红楼梦&#x27;</span>).values(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">print(ret)</span><br><span class="line"><span class="comment"># sql 语句就是from的表不一样</span></span><br><span class="line"><span class="comment"># -------多对多正向查询</span></span><br><span class="line"><span class="comment"># 查询红楼梦所有的作者</span></span><br><span class="line">ret=Book.objects.filter(name=<span class="string">&#x27;红楼梦&#x27;</span>).values(<span class="string">&#x27;authors__name&#x27;</span>)</span><br><span class="line">print(ret)</span><br><span class="line"><span class="comment"># ---多对多反向查询</span></span><br><span class="line">ret=Author.objects.filter(book__name=<span class="string">&#x27;红楼梦&#x27;</span>).values(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">ret=Author.objects.filter(book__name=<span class="string">&#x27;红楼梦&#x27;</span>).values(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;author_detail__addr&#x27;</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="一对一查询"><a href="#一对一查询" class="headerlink" title="一对一查询"></a>一对一查询</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询alex的手机号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正向查询</span></span><br><span class="line">ret=Author.objects.filter(name=<span class="string">&quot;lqz&quot;</span>).values(<span class="string">&quot;authordetail__telephone&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反向查询</span></span><br><span class="line">ret=AuthorDetail.objects.filter(author__name=<span class="string">&quot;lqz&quot;</span>).values(<span class="string">&quot;telephone&quot;</span>)</span><br><span class="line"><span class="comment"># 查询lqz的手机号</span></span><br><span class="line"><span class="comment"># 正向查</span></span><br><span class="line">ret=Author.objects.filter(name=<span class="string">&#x27;lqz&#x27;</span>).values(<span class="string">&#x27;author_detail__telephone&#x27;</span>)</span><br><span class="line">print(ret)</span><br><span class="line"><span class="comment"># 反向查</span></span><br><span class="line">ret= AuthorDatail.objects.filter(author__name=<span class="string">&#x27;lqz&#x27;</span>).values(<span class="string">&#x27;telephone&#x27;</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="进阶练习-连续跨表"><a href="#进阶练习-连续跨表" class="headerlink" title="进阶练习(连续跨表)"></a>进阶练习(连续跨表)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 练习: 查询人民出版社出版过的所有书籍的名字以及作者的姓名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正向查询</span></span><br><span class="line">queryResult=Book.objects.filter(publish__name=<span class="string">&quot;人民出版社&quot;</span>).values_list(<span class="string">&quot;title&quot;</span>,<span class="string">&quot;authors__name&quot;</span>)</span><br><span class="line"><span class="comment"># 反向查询</span></span><br><span class="line">queryResult=Publish.objects.filter(name=<span class="string">&quot;人民出版社&quot;</span>).values_list(<span class="string">&quot;book__title&quot;</span>,<span class="string">&quot;book__authors__age&quot;</span>,<span class="string">&quot;book__authors__name&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 练习: 手机号以151开头的作者出版过的所有书籍名称以及出版社名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式1:</span></span><br><span class="line">queryResult=Book.objects.filter(authors__authorDetail__telephone__regex=<span class="string">&quot;151&quot;</span>).values_list(<span class="string">&quot;title&quot;</span>,<span class="string">&quot;publish__name&quot;</span>)</span><br><span class="line"><span class="comment"># 方式2:    </span></span><br><span class="line">ret=Author.objects.filter(authordetail__telephone__startswith=<span class="string">&quot;151&quot;</span>).values(<span class="string">&quot;book__title&quot;</span>,<span class="string">&quot;book__publish__name&quot;</span>)</span><br><span class="line"><span class="comment"># ----进阶练习，连续跨表</span></span><br><span class="line"><span class="comment"># 查询手机号以33开头的作者出版过的书籍名称以及书籍出版社名称</span></span><br><span class="line"><span class="comment"># author_datail author book publish</span></span><br><span class="line"><span class="comment"># 基于authorDatail表</span></span><br><span class="line"></span><br><span class="line">ret=AuthorDatail.objects.filter(telephone__startswith=<span class="string">&#x27;33&#x27;</span>).values(<span class="string">&#x27;author__book__name&#x27;</span>,<span class="string">&#x27;author__book__publish__name&#x27;</span>)</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于Author表</span></span><br><span class="line"> ret=Author.objects.filter(author_detail__telephone__startswith=<span class="number">33</span>).values(<span class="string">&#x27;book__name&#x27;</span>,<span class="string">&#x27;book__publish__name&#x27;</span>)</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于Book表</span></span><br><span class="line">ret=Book.objects.filter(authors__author_detail__telephone__startswith=<span class="string">&#x27;33&#x27;</span>).values(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;publish__name&#x27;</span>)</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于Publish表  </span></span><br><span class="line">ret=Publish.objects.filter(book__authors__author_detail__telephone__startswith=<span class="string">&#x27;33&#x27;</span>).values(<span class="string">&#x27;book__name&#x27;</span>,<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="related-name"><a href="#related-name" class="headerlink" title="related_name"></a>related_name</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">publish = ForeignKey(Blog, related_name=<span class="string">&#x27;bookList&#x27;</span>)</span><br><span class="line"><span class="comment"># 练习: 查询人民出版社出版过的所有书籍的名字与价格(一对多)</span></span><br><span class="line"><span class="comment"># 反向查询 不再按表名:book,而是related_name:bookList</span></span><br><span class="line">queryResult=Publish.objects.filter(name=<span class="string">&quot;人民出版社&quot;</span>).values_list(<span class="string">&quot;bookList__title&quot;</span>,<span class="string">&quot;bookList__price&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>反向查询时，如果定义了related_name ，则用related_name替换表名</p>
<h2 id="五-聚合查询与分组查询"><a href="#五-聚合查询与分组查询" class="headerlink" title="五 聚合查询与分组查询"></a>五 聚合查询与分组查询</h2><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p><code>aggregate</code>(*args, **kwargs)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算所有图书的平均价格</span></span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Avg</span><br><span class="line">Book.objects.all().aggregate(Avg(<span class="string">&#x27;price&#x27;</span>))</span><br><span class="line"><span class="comment">#&#123;&#x27;price__avg&#x27;: 34.35&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>aggregate()</code>是<code>QuerySet</code> 的一个终止子句，意思是说，它返回一个包含一些键值对的字典。键的名称是聚合值的标识符，值是计算出来的聚合值。键的名称是按照字段和聚合函数的名称自动生成出来的。如果你想要为聚合值指定一个名称，可以向聚合子句提供它。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Book.objects.aggregate(average_price=Avg(<span class="string">&#x27;price&#x27;</span>))</span><br><span class="line"><span class="comment">#&#123;&#x27;average_price&#x27;: 34.35&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果你希望生成不止一个聚合，你可以向<code>aggregate()</code>子句中添加另一个参数。所以，如果你也想知道所有图书价格的最大值和最小值，可以这样查询：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Avg, Max, Min</span><br><span class="line">Book.objects.aggregate(Avg(<span class="string">&#x27;price&#x27;</span>), Max(<span class="string">&#x27;price&#x27;</span>), Min(<span class="string">&#x27;price&#x27;</span>))</span><br><span class="line"><span class="comment">#&#123;&#x27;price__avg&#x27;: 34.35, &#x27;price__max&#x27;: Decimal(&#x27;81.20&#x27;), &#x27;price__min&#x27;: Decimal(&#x27;12.99&#x27;)&#125;</span></span><br><span class="line"><span class="comment"># 查询所有书籍的平均价格</span></span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Avg,Count,Max,Min</span><br><span class="line">ret=Book.objects.all().aggregate(Avg(<span class="string">&#x27;price&#x27;</span>))</span><br><span class="line"><span class="comment"># &#123;&#x27;price__avg&#x27;: 202.896&#125;</span></span><br><span class="line"><span class="comment"># 可以改名字</span></span><br><span class="line">ret=Book.objects.all().aggregate(avg_price=Avg(<span class="string">&#x27;price&#x27;</span>))</span><br><span class="line"><span class="comment"># 统计平均价格和最大价格</span></span><br><span class="line">ret=Book.objects.all().aggregate(avg_price=Avg(<span class="string">&#x27;price&#x27;</span>),max_price=Max(<span class="string">&#x27;price&#x27;</span>))</span><br><span class="line"><span class="comment"># 统计最小价格</span></span><br><span class="line">ret = Book.objects.all().aggregate(avg_price=Avg(<span class="string">&#x27;price&#x27;</span>), min_price=Min(<span class="string">&#x27;price&#x27;</span>))</span><br><span class="line"><span class="comment"># 统计个数和平均价格</span></span><br><span class="line">ret = Book.objects.all().aggregate(avg_price=Avg(<span class="string">&#x27;price&#x27;</span>), max_price=Max(<span class="string">&#x27;price&#x27;</span>),count=Count(<span class="string">&#x27;price&#x27;</span>))</span><br><span class="line">ret = Book.objects.all().aggregate(avg_price=Avg(<span class="string">&#x27;price&#x27;</span>), max_price=Max(<span class="string">&#x27;price&#x27;</span>),count=Count(<span class="string">&#x27;nid&#x27;</span>))</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>annotate()为调用的<code>QuerySet</code>中每一个对象都生成一个独立的统计值（统计方法用聚合函数）。</p>
<p>总结 ：跨表分组查询本质就是将关联表join成一张表，再按单表的思路进行分组查询。　</p>
<h3 id="查询练习"><a href="#查询练习" class="headerlink" title="查询练习"></a>查询练习</h3><p>练习：统计每一本书作者个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Avg, Max, Sum, Min, Max, Count</span><br><span class="line">book_list = models.Book.objects.all().annotate(author_num=Count(<span class="string">&quot;authors&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> book <span class="keyword">in</span> book_list:</span><br><span class="line">     print(book.name)</span><br><span class="line">     print(book.author_num)</span><br><span class="line">book_list = models.Book.objects.all().annotate(author_num=Count(<span class="string">&quot;authors&quot;</span>)).values(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;author_num&#x27;</span>)</span><br><span class="line">print(book_list)</span><br></pre></td></tr></table></figure>

<p>练习：统计每一个出版社的最便宜的书</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">publishList=Publish.objects.annotate(MinPrice=Min(<span class="string">&quot;book__price&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> publish_obj <span class="keyword">in</span> publishList:</span><br><span class="line">    print(publish_obj.name,publish_obj.MinPrice)</span><br></pre></td></tr></table></figure>

<p>annotate的返回值是querySet，如果不想遍历对象，可以用上valuelist：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">queryResult= Publish.objects.annotate(MinPrice=Min(<span class="string">&quot;book__price&quot;</span>)).values_list(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;MinPrice&quot;</span>)</span><br><span class="line">print(queryResult)</span><br></pre></td></tr></table></figure>

<p>练习：统计每一本以py开头的书籍的作者个数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">queryResult=Book.objects.filter(title__startswith=<span class="string">&quot;Py&quot;</span>).annotate(num_authors=Count(<span class="string">&#x27;authors&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>练习：统计不止一个作者的图书：（作者数量大于一）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ret=models.Book.objects.annotate(author_num=Count(<span class="string">&quot;authors&quot;</span>)).filter(author_num__gt=<span class="number">1</span>).values(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;author_num&#x27;</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<p>练习：根据一本图书作者数量的多少对查询集 <code>QuerySet</code>进行排序:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Book.objects.annotate(num_authors=Count(<span class="string">&#x27;authors&#x27;</span>)).order_by(<span class="string">&#x27;num_authors&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>练习：查询各个作者出的书的总价格:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ret=models.Author.objects.annotate(sum_price=Sum(<span class="string">&quot;book__price&quot;</span>)).values(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;sum_price&quot;</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<p>练习：查询每个出版社的名称和书籍个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ret=models.Publish.objects.all().annotate(c=Count(<span class="string">&#x27;book__name&#x27;</span>)).values(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">print(ret)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">       查询每一个部门名称以及对应的员工数</span></span><br><span class="line"><span class="string">       book:</span></span><br><span class="line"><span class="string">       id  name   price      publish</span></span><br><span class="line"><span class="string">        1   金品   11.2        1</span></span><br><span class="line"><span class="string">        2   西游   14.2        2</span></span><br><span class="line"><span class="string">        3   东游   16.2        2</span></span><br><span class="line"><span class="string">        4   北邮   19.2        3</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 示例一：查询每一个出版社id，以及出书平均价格</span></span><br><span class="line">    <span class="comment"># select publish_id,avg(price) from app01_book group by publish_id;</span></span><br><span class="line">    <span class="comment"># annotate</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#  annotate() 内写聚合函数</span></span><br><span class="line">    <span class="comment">#  values在前表示group by的字段</span></span><br><span class="line">    <span class="comment">#  values在后表示取某几个字段</span></span><br><span class="line">    <span class="comment">#  filter在前表示where</span></span><br><span class="line">    <span class="comment">#  filter在后表示having</span></span><br><span class="line">    <span class="comment"># from django.db.models import Avg, Count, Max, Min</span></span><br><span class="line">    <span class="comment"># ret=models.Book.objects.values(&#x27;publish_id&#x27;).annotate(avg=Avg(&#x27;price&#x27;)).values(&#x27;publish_id&#x27;,&#x27;avg&#x27;)</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询出版社id大于1的出版社id，以及出书平均价格</span></span><br><span class="line">    <span class="comment">#select publish_id,avg(price) from app01_book where publish_id&gt;1 group by publish_id;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ret=models.Book.objects.values(&#x27;publish_id&#x27;).filter(publish_id__gt=1).annotate(avg=Avg(&#x27;price&#x27;)).values(&#x27;publish_id&#x27;,&#x27;avg&#x27;)</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询出版社id大于1的出版社id，以及出书平均价格大于30的</span></span><br><span class="line">    <span class="comment"># select publish_id,avg(price)as aaa from app01_book where publish_id&gt;1 group by publish_id HAVING aaa&gt;30;</span></span><br><span class="line">    <span class="comment"># ret = models.Book.objects.values(&#x27;publish_id&#x27;).filter(publish_id__gt=1).annotate(avg=Avg(&#x27;price&#x27;)).filter(avg__gt=30).values(</span></span><br><span class="line">    <span class="comment">#     &#x27;publish_id&#x27;, &#x27;avg&#x27;)</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">## 查询每一个出版社出版的书籍个数</span></span><br><span class="line">    <span class="comment"># pk 代指主键</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ret=models.Book.objects.get(pk=1)</span></span><br><span class="line">    <span class="comment"># print(ret.name)</span></span><br><span class="line">    <span class="comment"># ret=models.Publish.objects.values(&#x27;pk&#x27;).annotate(count=Count(&#x27;book__id&#x27;)).values(&#x27;name&#x27;,&#x27;count&#x27;)</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line">    <span class="comment"># 如果没有指定group by的字段，默认就用基表（Publish）主键字段作为group by的字段</span></span><br><span class="line">    <span class="comment"># ret=models.Publish.objects.annotate(count=Count(&#x27;book__id&#x27;)).values(&#x27;name&#x27;,&#x27;count&#x27;)</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 另一种方式实现</span></span><br><span class="line">    <span class="comment"># ret=models.Book.objects.values(&#x27;publish&#x27;).annotate(count=Count(&#x27;id&#x27;)).values(&#x27;publish__name&#x27;,&#x27;count&#x27;)</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#查询每个作者的名字，以及出版过书籍的最高价格(建议使用分组的表作为基表)</span></span><br><span class="line">    <span class="comment"># 如果不用分组的表作为基表，数据不完整可能会出现问题</span></span><br><span class="line">    <span class="comment"># ret=models.Author.objects.values(&#x27;pk&#x27;).annotate(max=Max(&#x27;book__price&#x27;)).values(&#x27;name&#x27;,&#x27;max&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ret = models.Author.objects.annotate(max=Max(&#x27;book__price&#x27;)).values(&#x27;name&#x27;, &#x27;max&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ret= models.Book.objects.values(&#x27;authors__id&#x27;).annotate(max=Max(&#x27;price&#x27;)).values(&#x27;authors__name&#x27;,&#x27;max&#x27;)</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#查询每一个书籍的名称，以及对应的作者个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ret=models.Book.objects.values(&#x27;pk&#x27;).annotate(count=Count(&#x27;authors__id&#x27;)).values(&#x27;name&#x27;,&#x27;count&#x27;)</span></span><br><span class="line">    <span class="comment"># ret=models.Book.objects.annotate(count=Count(&#x27;authors__id&#x27;)).values(&#x27;name&#x27;,&#x27;count&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ret=models.Author.objects.values(&#x27;book__id&#x27;).annotate(count=Count(&#x27;id&#x27;)).values(&#x27;book__name&#x27;,&#x27;count&#x27;)</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#统计不止一个作者的图书</span></span><br><span class="line">    <span class="comment"># ret=models.Book.objects.values(&#x27;pk&#x27;).annotate(count=Count(&#x27;authors__id&#x27;)).filter(count__gt=1).values(&#x27;name&#x27;,&#x27;count&#x27;)</span></span><br><span class="line">    <span class="comment"># ret = models.Author.objects.values(&#x27;book__id&#x27;).annotate(count=Count(&#x27;id&#x27;)).filter(count__gt=1).values(&#x27;book__name&#x27;, &#x27;count&#x27;)</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 统计价格数大于10元，作者的图书</span></span><br><span class="line">    ret = models.Book.objects.values(<span class="string">&#x27;pk&#x27;</span>).filter(price__gt=<span class="number">10</span>).annotate(count=Count(<span class="string">&#x27;authors__id&#x27;</span>)).values(<span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">                                                                                                           <span class="string">&#x27;count&#x27;</span>)</span><br><span class="line">    print(ret)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#统计价格数大于10元，作者个数大于1的图书</span></span><br><span class="line">    ret = models.Book.objects.values(<span class="string">&#x27;pk&#x27;</span>).filter(price__gt=<span class="number">10</span>).annotate(count=Count(<span class="string">&#x27;authors__id&#x27;</span>)).filter(count__gt=<span class="number">1</span>).values(<span class="string">&#x27;name&#x27;</span>,                                                                                                    <span class="string">&#x27;count&#x27;</span>)</span><br><span class="line">    print(ret)</span><br></pre></td></tr></table></figure>

<h2 id="六-F查询与Q查询"><a href="#六-F查询与Q查询" class="headerlink" title="六 F查询与Q查询"></a>六 F查询与Q查询</h2><h3 id="F查询"><a href="#F查询" class="headerlink" title="F查询"></a>F查询</h3><p>在上面所有的例子中，我们构造的过滤器都只是将字段值与某个常量做比较。如果我们要对两个字段的值做比较，那该怎么做呢？</p>
<p>Django 提供 F() 来做这样的比较。F() 的实例可以在查询中引用字段，来比较同一个 model 实例中两个不同字段的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询评论数大于收藏数的书籍</span><br><span class="line">from django.db.models import F</span><br><span class="line">Book.objects.filter(commnetNum__lt&#x3D;F(&#39;keepNum&#39;))</span><br></pre></td></tr></table></figure>

<p>Django 支持 F() 对象之间以及 F() 对象和常数之间的加减乘除和取模的操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询评论数大于收藏数2倍的书籍</span><br><span class="line">Book.objects.filter(commnetNum__lt&#x3D;F(&#39;keepNum&#39;)*2)</span><br></pre></td></tr></table></figure>

<p>修改操作也可以使用F函数,比如将每一本书的价格提高30元：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Book.objects.all().update(price&#x3D;F(&quot;price&quot;)+30)</span><br></pre></td></tr></table></figure>

<h3 id="Q查询"><a href="#Q查询" class="headerlink" title="Q查询"></a>Q查询</h3><p><code>filter()</code> 等方法中的关键字参数查询都是一起进行“AND” 的。 如果你需要执行更复杂的查询（例如<code>OR</code> 语句），你可以使用<code>Q 对象</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.db.models import Q</span><br><span class="line">Q(title__startswith&#x3D;&#39;Py&#39;)</span><br></pre></td></tr></table></figure>

<p><code>Q</code> 对象可以使用<code>&amp;</code> 和<code>|</code> 操作符组合起来。当一个操作符在两个<code>Q</code> 对象上使用时，它产生一个新的<code>Q</code> 对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bookList&#x3D;Book.objects.filter(Q(authors__name&#x3D;&quot;lqz&quot;)|Q(authors__name&#x3D;&quot;egon&quot;))</span><br></pre></td></tr></table></figure>

<p>等同于下面的SQL <code>WHERE</code> 子句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WHERE name &#x3D;&quot;lqz&quot; OR name &#x3D;&quot;egon&quot;</span><br></pre></td></tr></table></figure>

<p>你可以组合<code>&amp;</code> 和<code>|</code> 操作符以及使用括号进行分组来编写任意复杂的<code>Q</code> 对象。同时，<code>Q</code> 对象可以使用<code>~</code> 操作符取反，这允许组合正常的查询和取反(<code>NOT</code>) 查询：</p>
<p>查询函数可以混合使用<code>Q 对象</code>和关键字参数。所有提供给查询函数的参数（关键字参数或<code>Q</code> 对象）都将”AND”在一起。但是，如果出现<code>Q</code> 对象，它必须位于所有关键字参数的前面。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bookList=Book.objects.filter(Q(publishDate__year=<span class="number">2016</span>) | Q(publishDate__year=<span class="number">2017</span>), title__icontains=<span class="string">&quot;python&quot;</span>)</span><br><span class="line"><span class="comment"># 查询评论数大于阅读数的书籍</span></span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F,Q</span><br><span class="line"><span class="comment"># select * from book where commit_num&gt;read_num;</span></span><br><span class="line"><span class="comment"># 这样肯定是不行的</span></span><br><span class="line"><span class="comment"># Book.objects.filter(commit_num__gt=read_num)</span></span><br><span class="line">ret=Book.objects.filter(commit_num__gt=F(<span class="string">&#x27;reat_num&#x27;</span>))</span><br><span class="line">print(ret)</span><br><span class="line"><span class="comment"># 把所有书籍的价格加10</span></span><br><span class="line">Book.objects.all().update(price=F(<span class="string">&#x27;price&#x27;</span>)+<span class="number">10</span>)</span><br><span class="line"><span class="comment"># ----Q函数，描述一个与，或，非的关系</span></span><br><span class="line"><span class="comment"># 查询名字叫红楼梦或者价格大于100的书</span></span><br><span class="line">ret=Book.objects.filter(Q(name=<span class="string">&#x27;红楼梦&#x27;</span>)|Q(price__gt=<span class="number">100</span>))</span><br><span class="line">print(ret)</span><br><span class="line"><span class="comment"># 查询名字叫红楼梦和价格大于100的书</span></span><br><span class="line">ret = Book.objects.filter(Q(name=<span class="string">&#x27;红楼梦&#x27;</span>) &amp; Q(price__gt=<span class="number">100</span>))</span><br><span class="line">print(ret)</span><br><span class="line"><span class="comment"># # 等同于</span></span><br><span class="line">ret2=Book.objects.filter(name=<span class="string">&#x27;红楼梦&#x27;</span>,price__gt=<span class="number">100</span>)</span><br><span class="line">print(ret2)</span><br><span class="line"><span class="comment"># 也可以Q套Q</span></span><br><span class="line"><span class="comment"># 查询名字叫红楼梦和价格大于100  或者 nid大于2</span></span><br><span class="line">ret=Book.objects.filter((Q(name=<span class="string">&#x27;红楼梦&#x27;</span>) &amp; Q(price__gt=<span class="number">100</span>))|Q(nid__gt=<span class="number">2</span>))</span><br><span class="line">print(ret)</span><br><span class="line"><span class="comment"># ----非</span></span><br><span class="line">ret=Book.objects.filter(~Q(name=<span class="string">&#x27;红楼梦&#x27;</span>))</span><br><span class="line">print(ret)</span><br><span class="line"><span class="comment"># Q和键值对联合使用，但是键值对必须放在Q的后面(描述的是一个且的关系)</span></span><br><span class="line"><span class="comment"># 查询名字不是红楼梦，并且价格大于100的书</span></span><br><span class="line">ret=Book.objects.filter(~Q(name=<span class="string">&#x27;红楼梦&#x27;</span>),price__gt=<span class="number">100</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>10-Django进阶-模型-更多字段与参数</title>
    <url>/posts/61909.html</url>
    <content><![CDATA[<p>Django Models 更多字段与参数</p>
<a id="more"></a>

<p>表格+案例</p>
<p>参考：</p>
<p><a href="http://www.liuqingzheng.top/python/Django%E6%A1%86%E6%9E%B6/10-%E6%A8%A1%E5%9E%8B%E5%B1%82-%E5%B8%B8%E7%94%A8%E9%9D%9E%E5%B8%B8%E7%94%A8%E5%AD%97%E6%AE%B5%E5%92%8C%E5%8F%82%E6%95%B0/">表格+案例</a></p>
<h2 id="1-ORM字段"><a href="#1-ORM字段" class="headerlink" title="1 ORM字段"></a>1 ORM字段</h2><h4 id="AutoField"><a href="#AutoField" class="headerlink" title="AutoField"></a>AutoField</h4><p>int自增列，必须填入参数 primary_key=True。当model中如果没有自增列，则自动会创建一个列名为id的列。</p>
<h4 id="IntegerField"><a href="#IntegerField" class="headerlink" title="IntegerField"></a>IntegerField</h4><p>一个整数类型,范围在 -2147483648 to 2147483647。</p>
<h4 id="CharField"><a href="#CharField" class="headerlink" title="CharField"></a>CharField</h4><p>字符类型，必须提供max_length参数， max_length表示字符长度。</p>
<h4 id="DateField-年月日"><a href="#DateField-年月日" class="headerlink" title="DateField (年月日)"></a>DateField (年月日)</h4><p>日期字段，日期格式 YYYY-MM-DD，相当于Python中的datetime.date()实例。</p>
<p>print(datetime.date(year=2020,month=5,day=4))<br>2020-05-04</p>
<h4 id="DateTimeField-年月日时分秒"><a href="#DateTimeField-年月日时分秒" class="headerlink" title="DateTimeField (年月日时分秒)"></a>DateTimeField (年月日时分秒)</h4><p>日期时间字段，格式 YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]，相当于Python中的datetime.datetime()实例</p>
<p>print(datetime.datetime(year=2020,month=5,day=4))<br>2020-05-04 00:00:00</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DateField 和 DateTimeField区别</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">DateField     年月日</span></span><br><span class="line"><span class="string">DateTimeField 年月日时分秒</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">两个重要参数: auto_now 和 auto_now_add</span><br><span class="line">  create_time_tow = models.DateTimeField(<span class="string">&#x27;创建时间&#x27;</span>, auto_now_add=<span class="literal">True</span>)</span><br><span class="line">  update_time_tow = models.DateTimeField(<span class="string">&#x27;更新时间&#x27;</span>, auto_now=<span class="literal">True</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   auto_now:     每次  新增或者修改 save()操作数据的时候，该字段会自动将当前时间更新。存储“最后修改时间”的场景下。              </span></span><br><span class="line"><span class="string">   auto_now_add: 在创建(新增)数据的时候，会自动将当前创建时间记录下来，之后只要不人为修改，那么就一直不变。存储“创建时间”的场景下</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">###### 注意update 操作数据，auto_now 不会改变； 使用save才会自动更新时间  #########</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：form表单提交的时候，前端也需要格式化，因为数据库存的字段就是这种格式2020-05-02</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">也可以使用datetime模块设置时间，但是需要注意:!!!!</span><br><span class="line">  <span class="keyword">import</span> datetime</span><br><span class="line">    create_time = models.DateTimeField(<span class="string">&#x27;创建时间&#x27;</span>, default=datetime.now())</span><br><span class="line">    update_time = models.DateTimeField(<span class="string">&#x27;更新时间&#x27;</span>, default=datetime.now)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">default=datetime.now()   启动加载的时候就已经确定,坑</span></span><br><span class="line"><span class="string">    model每次初始化，都会自动设置该字段的默认值为初始化时间。</span></span><br><span class="line"><span class="string">default=datetime.now     调用的时候才确定</span></span><br><span class="line"><span class="string">    model每次进行新增或修改操作，都会自动设置该字段的值为操作时间。设置后仍可以使用ORM手动修改该字段。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">###要注意的点</span></span><br><span class="line">除非想设置动态默认时间为项目的启动时间，否则default=datetime.now()这种用法是错误的，会得到期望之外的结果。</span><br><span class="line"><span class="comment">###### 注意update 操作数据，auto_now 不会改变； 使用save才会自动更新时间</span></span><br><span class="line">使用User.objects.update方法时，设置的default=datetime.now和auto_now=<span class="literal">True</span>都不会生效，由于设置了auto_now=<span class="literal">True</span>的字段不能手动修改，此时只能使用save方法修改数据，这对于多个数据的更新是不友好的。</span><br><span class="line">因此如果设置动态默认时间的字段，应该使用default=datetime.now和auto_now_add=<span class="literal">True</span>来实现。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">############   结论</span></span><br><span class="line">错误设置方式  create_time = models.DateTimeField(<span class="string">&#x27;创建时间&#x27;</span>, default=datetime.now()) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建时间场景 </span></span><br><span class="line">create_time_tow = models.DateTimeField(<span class="string">&#x27;创建时间&#x27;</span>, auto_now_add=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 最后修改时间场景</span></span><br><span class="line">update_time_tow = models.DateTimeField(<span class="string">&#x27;更新时间&#x27;</span>, auto_now=<span class="literal">True</span>)</span><br><span class="line">update_time = models.DateTimeField(<span class="string">&#x27;更新时间&#x27;</span>, default=datetime.now)</span><br><span class="line"><span class="comment">## 需要注意</span></span><br><span class="line">注意update 操作数据，设置的default=datetime.now和auto_now=<span class="literal">True</span>都不会生效； 使用save才会自动更新时间；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">null=<span class="literal">True</span>和blank=<span class="literal">True</span>的区别</span><br><span class="line"><span class="number">1.</span> null针对数据库，如果null=<span class="literal">True</span>，表示数据库的该字段可以为空。</span><br><span class="line"><span class="number">2.</span> blank针对表单的，如果blank=<span class="literal">True</span>，表示表单填写该字段时可以不填。</span><br><span class="line">mysql中空值不占用空间，NULL占用空间，而且使用NULL会使索引的效率下降。因此从性能上来说，不建议使用null=<span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20210517234333170.png" alt="image-20210517234333170"></p>
<h3 id="常用和非常用字段"><a href="#常用和非常用字段" class="headerlink" title="常用和非常用字段"></a>常用和非常用字段</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AutoField(Field)</span><br><span class="line">- int自增列，必须填入参数 primary_key&#x3D;True</span><br><span class="line"></span><br><span class="line">BigAutoField(AutoField)</span><br><span class="line">- bigint自增列，必须填入参数 primary_key&#x3D;True</span><br><span class="line"></span><br><span class="line">注：当model中如果没有自增列，则自动会创建一个列名为id的列</span><br><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class UserInfo(models.Model):</span><br><span class="line"># 自动创建一个列名为id的且为自增的整数列</span><br><span class="line">username &#x3D; models.CharField(max_length&#x3D;32)</span><br><span class="line"></span><br><span class="line">class Group(models.Model):</span><br><span class="line"># 自定义自增列</span><br><span class="line">nid &#x3D; models.AutoField(primary_key&#x3D;True)</span><br><span class="line">name &#x3D; models.CharField(max_length&#x3D;32)</span><br><span class="line"></span><br><span class="line">SmallIntegerField(IntegerField):</span><br><span class="line">- 小整数 -32768 ～ 32767</span><br><span class="line"></span><br><span class="line">PositiveSmallIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField)</span><br><span class="line">- 正小整数 0 ～ 32767</span><br><span class="line">IntegerField(Field)</span><br><span class="line">- 整数列(有符号的) -2147483648 ～ 2147483647</span><br><span class="line"></span><br><span class="line">PositiveIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField)</span><br><span class="line">- 正整数 0 ～ 2147483647</span><br><span class="line"></span><br><span class="line">BigIntegerField(IntegerField):</span><br><span class="line">- 长整型(有符号的) -9223372036854775808 ～ 9223372036854775807</span><br><span class="line"></span><br><span class="line">BooleanField(Field)</span><br><span class="line">- 传布尔值   存0&#x2F;1</span><br><span class="line"></span><br><span class="line">NullBooleanField(Field):</span><br><span class="line">- 可以为空的布尔值</span><br><span class="line"></span><br><span class="line">CharField(Field)</span><br><span class="line">- 字符类型</span><br><span class="line">- 必须提供max_length参数， max_length表示字符长度</span><br><span class="line"></span><br><span class="line">TextField(Field)</span><br><span class="line">- 文本类型</span><br><span class="line"></span><br><span class="line">EmailField(CharField)：</span><br><span class="line">- 字符串类型，Django Admin以及ModelForm中提供验证机制</span><br><span class="line"></span><br><span class="line">IPAddressField(Field)</span><br><span class="line">- 字符串类型，Django Admin以及ModelForm中提供验证 IPV4 机制</span><br><span class="line"></span><br><span class="line">GenericIPAddressField(Field)</span><br><span class="line">- 字符串类型，Django Admin以及ModelForm中提供验证 Ipv4和Ipv6</span><br><span class="line">- 参数：</span><br><span class="line">protocol，用于指定Ipv4或Ipv6， &#39;both&#39;,&quot;ipv4&quot;,&quot;ipv6&quot;</span><br><span class="line">unpack_ipv4， 如果指定为True，则输入::ffff:192.0.2.1时候，可解析为192.0.2.1，开启此功能，需要protocol&#x3D;&quot;both&quot;</span><br><span class="line"></span><br><span class="line">URLField(CharField)</span><br><span class="line">- 字符串类型，Django Admin以及ModelForm中提供验证 URL</span><br><span class="line"></span><br><span class="line">SlugField(CharField)</span><br><span class="line">- 字符串类型，Django Admin以及ModelForm中提供验证支持 字母、数字、下划线、连接符（减号）</span><br><span class="line"></span><br><span class="line">CommaSeparatedIntegerField(CharField)</span><br><span class="line">- 字符串类型，格式必须为逗号分割的数字</span><br><span class="line"></span><br><span class="line">UUIDField(Field)</span><br><span class="line">- 字符串类型，Django Admin以及ModelForm中提供对UUID格式的验证</span><br><span class="line"></span><br><span class="line">FilePathField(Field)</span><br><span class="line">- 字符串，Django Admin以及ModelForm中提供读取文件夹下文件的功能</span><br><span class="line">- 参数：</span><br><span class="line">path,                      文件夹路径</span><br><span class="line">match&#x3D;None,                正则匹配</span><br><span class="line">recursive&#x3D;False,           递归下面的文件夹</span><br><span class="line">allow_files&#x3D;True,          允许文件</span><br><span class="line">allow_folders&#x3D;False,       允许文件夹</span><br><span class="line"></span><br><span class="line">FileField(Field)</span><br><span class="line">- 字符串，路径保存在数据库，文件上传到指定目录</span><br><span class="line">- 参数：</span><br><span class="line">upload_to &#x3D; &quot;&quot;      上传文件的保存路径</span><br><span class="line">storage &#x3D; None      存储组件，默认django.core.files.storage.FileSystemStorage</span><br><span class="line"></span><br><span class="line">ImageField(FileField)</span><br><span class="line">- 字符串，路径保存在数据库，文件上传到指定目录</span><br><span class="line">- 参数：</span><br><span class="line">upload_to &#x3D; &quot;&quot;      上传文件的保存路径</span><br><span class="line">storage &#x3D; None      存储组件，默认django.core.files.storage.FileSystemStorage</span><br><span class="line">width_field&#x3D;None,   上传图片的高度保存的数据库字段名（字符串）</span><br><span class="line">height_field&#x3D;None   上传图片的宽度保存的数据库字段名（字符串）</span><br><span class="line"></span><br><span class="line">DateTimeField(DateField)</span><br><span class="line">- 日期+时间格式 YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]</span><br><span class="line"></span><br><span class="line">DateField(DateTimeCheckMixin, Field)</span><br><span class="line">- 日期格式      YYYY-MM-DD</span><br><span class="line"></span><br><span class="line">TimeField(DateTimeCheckMixin, Field)</span><br><span class="line">- 时间格式      HH:MM[:ss[.uuuuuu]]</span><br><span class="line"></span><br><span class="line">DurationField(Field)</span><br><span class="line">- 长整数，时间间隔，数据库中按照bigint存储，ORM中获取的值为datetime.timedelta类型</span><br><span class="line"></span><br><span class="line">FloatField(Field)</span><br><span class="line">- 浮点型</span><br><span class="line"></span><br><span class="line">DecimalField(Field)</span><br><span class="line">- 10进制小数</span><br><span class="line">- 参数：</span><br><span class="line">max_digits，小数总长度</span><br><span class="line">decimal_places，小数位长度</span><br><span class="line"></span><br><span class="line">BinaryField(Field)</span><br><span class="line">- 二进制类型</span><br><span class="line">对应关系：</span><br><span class="line">    &#39;AutoField&#39;: &#39;integer AUTO_INCREMENT&#39;,</span><br><span class="line">    &#39;BigAutoField&#39;: &#39;bigint AUTO_INCREMENT&#39;,</span><br><span class="line">    &#39;BinaryField&#39;: &#39;longblob&#39;,</span><br><span class="line">    &#39;BooleanField&#39;: &#39;bool&#39;,</span><br><span class="line">    &#39;CharField&#39;: &#39;varchar(%(max_length)s)&#39;,</span><br><span class="line">    &#39;CommaSeparatedIntegerField&#39;: &#39;varchar(%(max_length)s)&#39;,</span><br><span class="line">    &#39;DateField&#39;: &#39;date&#39;,</span><br><span class="line">    &#39;DateTimeField&#39;: &#39;datetime&#39;,</span><br><span class="line">    &#39;DecimalField&#39;: &#39;numeric(%(max_digits)s, %(decimal_places)s)&#39;,</span><br><span class="line">    &#39;DurationField&#39;: &#39;bigint&#39;,</span><br><span class="line">    &#39;FileField&#39;: &#39;varchar(%(max_length)s)&#39;,</span><br><span class="line">    &#39;FilePathField&#39;: &#39;varchar(%(max_length)s)&#39;,</span><br><span class="line">    &#39;FloatField&#39;: &#39;double precision&#39;,</span><br><span class="line">    &#39;IntegerField&#39;: &#39;integer&#39;,</span><br><span class="line">    &#39;BigIntegerField&#39;: &#39;bigint&#39;,</span><br><span class="line">    &#39;IPAddressField&#39;: &#39;char(15)&#39;,</span><br><span class="line">    &#39;GenericIPAddressField&#39;: &#39;char(39)&#39;,</span><br><span class="line">    &#39;NullBooleanField&#39;: &#39;bool&#39;,</span><br><span class="line">    &#39;OneToOneField&#39;: &#39;integer&#39;,</span><br><span class="line">    &#39;PositiveIntegerField&#39;: &#39;integer UNSIGNED&#39;,</span><br><span class="line">    &#39;PositiveSmallIntegerField&#39;: &#39;smallint UNSIGNED&#39;,</span><br><span class="line">    &#39;SlugField&#39;: &#39;varchar(%(max_length)s)&#39;,</span><br><span class="line">    &#39;SmallIntegerField&#39;: &#39;smallint&#39;,</span><br><span class="line">    &#39;TextField&#39;: &#39;longtext&#39;,</span><br><span class="line">    &#39;TimeField&#39;: &#39;time&#39;,</span><br><span class="line">    &#39;UUIDField&#39;: &#39;char(32)&#39;,</span><br></pre></td></tr></table></figure>

<h2 id="2-ORM常见字段参数"><a href="#2-ORM常见字段参数" class="headerlink" title="2 ORM常见字段参数"></a>2 ORM常见字段参数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#### null</span></span><br><span class="line">用于表示某个字段可以为空。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### **unique**</span></span><br><span class="line">如果设置为unique=<span class="literal">True</span> 则该字段在此表中必须是唯一的 。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### **db_index**</span></span><br><span class="line">如果db_index=<span class="literal">True</span> 则代表着为此字段设置索引。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### **default**</span></span><br><span class="line">为该字段设置默认值。</span><br><span class="line"></span><br><span class="line"><span class="comment">###  DateField和DateTimeField</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">#### auto_now_add</span></span><br><span class="line">      配置auto_now_add=<span class="literal">True</span>，创建数据记录的时候会把当前时间添加到数据库。</span><br><span class="line"></span><br><span class="line">      <span class="comment">#### auto_now</span></span><br><span class="line">      配置上auto_now=<span class="literal">True</span>，每次更新数据记录的时候会更新该字段。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">null                数据库中字段是否可以为空</span><br><span class="line">db_column           数据库中字段的列名</span><br><span class="line">db_tablespace</span><br><span class="line">default             数据库中字段的默认值</span><br><span class="line">primary_key         数据库中字段是否为主键</span><br><span class="line">db_index            数据库中字段是否可以建立索引</span><br><span class="line">unique              数据库中字段是否可以建立唯一索引</span><br><span class="line">unique_for_date     数据库中字段【日期】部分是否可以建立唯一索引</span><br><span class="line">unique_for_month    数据库中字段【月】部分是否可以建立唯一索引</span><br><span class="line">unique_for_year     数据库中字段【年】部分是否可以建立唯一索引</span><br><span class="line"></span><br><span class="line">verbose_name        Admin中显示的字段名称</span><br><span class="line">blank               Admin中是否允许用户输入为空</span><br><span class="line">editable            Admin中是否可以编辑</span><br><span class="line">help_text           Admin中该字段的提示信息</span><br><span class="line">choices             Admin中显示选择框的内容，用不变动的数据放在内存中从而避免跨表操作</span><br><span class="line">如：gf = models.IntegerField(choices=[(<span class="number">0</span>, <span class="string">&#x27;何穗&#x27;</span>),(<span class="number">1</span>, <span class="string">&#x27;大表姐&#x27;</span>),],default=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">error_messages      自定义错误信息（字典类型），从而定制想要显示的错误信息；</span><br><span class="line">字典健：null, blank, invalid, invalid_choice, unique, <span class="keyword">and</span> unique_for_date</span><br><span class="line">如：&#123;<span class="string">&#x27;null&#x27;</span>: <span class="string">&quot;不能为空.&quot;</span>, <span class="string">&#x27;invalid&#x27;</span>: <span class="string">&#x27;格式错误&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">validators          自定义错误验证（列表类型），从而定制想要的验证规则</span><br><span class="line"><span class="keyword">from</span> django.core.validators <span class="keyword">import</span> RegexValidator</span><br><span class="line"><span class="keyword">from</span> django.core.validators <span class="keyword">import</span> EmailValidator,URLValidator,DecimalValidator,\</span><br><span class="line">MaxLengthValidator,MinLengthValidator,MaxValueValidator,MinValueValidator</span><br><span class="line">如：</span><br><span class="line">test = models.CharField(</span><br><span class="line">max_length=<span class="number">32</span>,</span><br><span class="line">error_messages=&#123;</span><br><span class="line"><span class="string">&#x27;c1&#x27;</span>: <span class="string">&#x27;优先错信息1&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;c2&#x27;</span>: <span class="string">&#x27;优先错信息2&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;c3&#x27;</span>: <span class="string">&#x27;优先错信息3&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">validators=[</span><br><span class="line">RegexValidator(regex=<span class="string">&#x27;root_\d+&#x27;</span>, message=<span class="string">&#x27;错误了&#x27;</span>, code=<span class="string">&#x27;c1&#x27;</span>),</span><br><span class="line">RegexValidator(regex=<span class="string">&#x27;root_112233\d+&#x27;</span>, message=<span class="string">&#x27;又错误了&#x27;</span>, code=<span class="string">&#x27;c2&#x27;</span>),</span><br><span class="line">EmailValidator(message=<span class="string">&#x27;又错误了&#x27;</span>, code=<span class="string">&#x27;c3&#x27;</span>), ]</span><br><span class="line">                            )</span><br></pre></td></tr></table></figure>

<h2 id="3-关系字段"><a href="#3-关系字段" class="headerlink" title="3 关系字段"></a>3 关系字段</h2><h3 id="ForeignKey"><a href="#ForeignKey" class="headerlink" title="ForeignKey"></a>ForeignKey</h3><p>外键类型在ORM中用来表示外键关联关系，一般把ForeignKey字段设置在 ‘一对多’中’多’的一方。</p>
<p>ForeignKey可以和其他表做关联关系同时也可以和自身做关联关系。</p>
<h4 id="to"><a href="#to" class="headerlink" title="to"></a>to</h4><p>设置要关联的表</p>
<h4 id="to-field"><a href="#to-field" class="headerlink" title="to_field"></a>to_field</h4><p>设置要关联的表的字段</p>
<h4 id="related-name"><a href="#related-name" class="headerlink" title="related_name"></a>related_name</h4><p>反向操作时，使用的字段名，用于代替原反向查询时的’表名_set’。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Classes(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;32)</span><br><span class="line"></span><br><span class="line">class Student(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;32)</span><br><span class="line">    theclass &#x3D; models.ForeignKey(to&#x3D;&quot;Classes&quot;)</span><br></pre></td></tr></table></figure>

<p>当我们要查询某个班级关联的所有学生（反向查询）时，我们会这么写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">models.Classes.objects.first().student_set.all()</span><br></pre></td></tr></table></figure>

<p>当我们在ForeignKey字段中添加了参数 related_name 后，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;32)</span><br><span class="line">    theclass &#x3D; models.ForeignKey(to&#x3D;&quot;Classes&quot;, related_name&#x3D;&quot;students&quot;)</span><br></pre></td></tr></table></figure>

<p>当我们要查询某个班级关联的所有学生（反向查询）时，我们会这么写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">models.Classes.objects.first().students.all()</span><br></pre></td></tr></table></figure>

<h4 id="related-query-name"><a href="#related-query-name" class="headerlink" title="related_query_name"></a><strong>related_query_name</strong></h4><p>反向查询操作时，使用的连接前缀，用于替换表名。</p>
<h4 id="on-delete"><a href="#on-delete" class="headerlink" title="on_delete"></a><strong>on_delete</strong></h4><p>　　当删除关联表中的数据时，当前表与其关联的行的行为。</p>
<p>　　<strong>models.CASCADE</strong><br>　　删除关联数据，与之关联也删除</p>
<p>　　<strong>models.DO_NOTHING</strong><br>　　删除关联数据，引发错误IntegrityError</p>
<p>　　<strong>models.PROTECT</strong><br>　　删除关联数据，引发错误ProtectedError</p>
<p>　　<strong>models.SET_NULL</strong><br>　　删除关联数据，与之关联的值设置为null（前提FK字段需要设置为可空）</p>
<p>　　<strong>models.SET_DEFAULT</strong><br>　　删除关联数据，与之关联的值设置为默认值（前提FK字段需要设置默认值）</p>
<p>　　<strong>models.SET</strong></p>
<p>　　删除关联数据，<br>　　a. 与之关联的值设置为指定值，设置：models.SET(值)<br>　　b. 与之关联的值设置为可执行对象的返回值，设置：models.SET(可执行对象)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModel</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    user = models.ForeignKey(</span><br><span class="line">        to=<span class="string">&quot;User&quot;</span>,</span><br><span class="line">        to_field=<span class="string">&quot;id&quot;</span>，</span><br><span class="line">        on_delete=models.SET(func)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h4 id="db-constraint"><a href="#db-constraint" class="headerlink" title="db_constraint"></a>db_constraint</h4><p>是否在数据库中创建外键约束，默认为True。</p>
<p>db_constraint=False,这个就是保留跨表查询的便利(双下划线跨表查询```),但是不用约束字段了,一般公司都用false,这样就省的报错,因为没有了约束(Field字段对象,既约束,又建立表与表之间的关系) </p>
<p>但是会存在脏数据，需要程序控制</p>
<h3 id="OneToOneField"><a href="#OneToOneField" class="headerlink" title="OneToOneField"></a>OneToOneField</h3><p>一对一字段。</p>
<p>通常一对一字段用来扩展已有字段。</p>
<p>一对一的关联关系多用在当一张表的不同字段查询频次差距过大的情况下，将本可以存储在一张表的字段拆开放置在两张表中，然后将两张表建立一对一的关联关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Author(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;32)</span><br><span class="line">    info &#x3D; models.OneToOneField(to&#x3D;&#39;AuthorInfo&#39;)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">class AuthorInfo(models.Model):</span><br><span class="line">    phone &#x3D; models.CharField(max_length&#x3D;11)</span><br><span class="line">    email &#x3D; models.EmailField()</span><br></pre></td></tr></table></figure>

<h4 id="to-1"><a href="#to-1" class="headerlink" title="to"></a>to</h4><p>设置要关联的表。</p>
<h4 id="to-field-1"><a href="#to-field-1" class="headerlink" title="to_field"></a>to_field</h4><p>设置要关联的字段。</p>
<h4 id="on-delete-1"><a href="#on-delete-1" class="headerlink" title="on_delete"></a>on_delete</h4><p>同ForeignKey字段。</p>
<h3 id="ManyToManyField"><a href="#ManyToManyField" class="headerlink" title="ManyToManyField"></a>ManyToManyField</h3><p>用于表示多对多的关联关系。在数据库中通过第三张表来建立关联关系</p>
<h4 id="to-2"><a href="#to-2" class="headerlink" title="to"></a>to</h4><p>设置要关联的表</p>
<h4 id="related-name-1"><a href="#related-name-1" class="headerlink" title="related_name"></a>related_name</h4><p>同ForeignKey字段。</p>
<h4 id="related-query-name-1"><a href="#related-query-name-1" class="headerlink" title="related_query_name"></a>related_query_name</h4><p>同ForeignKey字段。</p>
<h4 id="symmetrical"><a href="#symmetrical" class="headerlink" title="symmetrical"></a>symmetrical</h4><p>仅用于多对多自关联时，指定内部是否创建反向操作的字段。默认为True。</p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;16)</span><br><span class="line">    friends &#x3D; models.ManyToManyField(&quot;self&quot;)</span><br></pre></td></tr></table></figure>

<p>此时，person对象就没有person_set属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;16)</span><br><span class="line">    friends &#x3D; models.ManyToManyField(&quot;self&quot;, symmetrical&#x3D;False)</span><br></pre></td></tr></table></figure>

<p>此时，person对象现在就可以使用person_set属性进行反向查询。</p>
<h4 id="through"><a href="#through" class="headerlink" title="through"></a>through</h4><p>在使用ManyToManyField字段时，Django将自动生成一张表来管理多对多的关联关系。</p>
<p>但我们也可以手动创建第三张表来管理多对多关系，此时就需要通过through来指定第三张表的表名。</p>
<h4 id="through-fields"><a href="#through-fields" class="headerlink" title="through_fields"></a><strong>through_fields</strong></h4><p>设置关联的字段。</p>
<h4 id="db-table"><a href="#db-table" class="headerlink" title="db_table"></a>db_table</h4><p>默认创建第三张表时，数据库中表的名称。</p>
<h2 id="4-多对多关联关系的三种方式"><a href="#4-多对多关联关系的三种方式" class="headerlink" title="4 多对多关联关系的三种方式"></a>4 多对多关联关系的三种方式</h2><h3 id="方式一：自行创建第三张表"><a href="#方式一：自行创建第三张表" class="headerlink" title="方式一：自行创建第三张表"></a>方式一：自行创建第三张表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Book(models.Model):</span><br><span class="line">    title &#x3D; models.CharField(max_length&#x3D;32, verbose_name&#x3D;&quot;书名&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Author(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;32, verbose_name&#x3D;&quot;作者姓名&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 自己创建第三张表，分别通过外键关联书和作者</span><br><span class="line">class Author2Book(models.Model):</span><br><span class="line">    author &#x3D; models.ForeignKey(to&#x3D;&quot;Author&quot;)</span><br><span class="line">    book &#x3D; models.ForeignKey(to&#x3D;&quot;Book&quot;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        unique_together &#x3D; (&quot;author&quot;, &quot;book&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="方式二：通过ManyToManyField自动创建第三张表"><a href="#方式二：通过ManyToManyField自动创建第三张表" class="headerlink" title="方式二：通过ManyToManyField自动创建第三张表"></a>方式二：通过ManyToManyField自动创建第三张表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Book(models.Model):</span><br><span class="line">    title &#x3D; models.CharField(max_length&#x3D;32, verbose_name&#x3D;&quot;书名&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 通过ORM自带的ManyToManyField自动创建第三张表</span><br><span class="line">class Author(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;32, verbose_name&#x3D;&quot;作者姓名&quot;)</span><br><span class="line">    books &#x3D; models.ManyToManyField(to&#x3D;&quot;Book&quot;, related_name&#x3D;&quot;authors&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="方式三：设置ManyTomanyField并指定自行创建的第三张表"><a href="#方式三：设置ManyTomanyField并指定自行创建的第三张表" class="headerlink" title="方式三：设置ManyTomanyField并指定自行创建的第三张表"></a>方式三：设置ManyTomanyField并指定自行创建的第三张表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Book(models.Model):</span><br><span class="line">    title &#x3D; models.CharField(max_length&#x3D;32, verbose_name&#x3D;&quot;书名&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 自己创建第三张表，并通过ManyToManyField指定关联</span><br><span class="line">class Author(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;32, verbose_name&#x3D;&quot;作者姓名&quot;)</span><br><span class="line">    books &#x3D; models.ManyToManyField(to&#x3D;&quot;Book&quot;, through&#x3D;&quot;Author2Book&quot;, through_fields&#x3D;(&quot;author&quot;, &quot;book&quot;))</span><br><span class="line">    # through_fields接受一个2元组（&#39;field1&#39;，&#39;field2&#39;）：</span><br><span class="line">    # 其中field1是定义ManyToManyField的模型外键的名（author），field2是关联目标模型（book）的外键名。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Author2Book(models.Model):</span><br><span class="line">    author &#x3D; models.ForeignKey(to&#x3D;&quot;Author&quot;)</span><br><span class="line">    book &#x3D; models.ForeignKey(to&#x3D;&quot;Book&quot;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        unique_together &#x3D; (&quot;author&quot;, &quot;book&quot;)</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>当我们需要在第三张关系表中存储额外的字段时，就要使用第三种方式。</p>
<p>但是当我们使用第三种方式创建多对多关联关系时，就无法使用set、add、remove、clear方法来管理多对多的关系了，需要通过第三张表的model来管理多对多关系。</p>
<h2 id="5-元信息"><a href="#5-元信息" class="headerlink" title="5 元信息"></a>5 元信息</h2><p>ORM对应的类里面包含另一个Meta类，而Meta类封装了一些数据库的信息。主要字段如下:</p>
<h3 id="abcstarct"><a href="#abcstarct" class="headerlink" title="abcstarct"></a>abcstarct</h3><p>abstract=True # 抽象表，不在数据库建立出表</p>
<h4 id="db-table-1"><a href="#db-table-1" class="headerlink" title="db_table"></a><strong>db_table</strong></h4><p>ORM在数据库中的表名默认是 <strong>app_</strong>类名，可以通过<strong>db_table</strong>可以重写表名。</p>
<h4 id="index-together"><a href="#index-together" class="headerlink" title="index_together"></a>index_together</h4><p>联合索引。</p>
<h4 id="unique-together"><a href="#unique-together" class="headerlink" title="unique_together"></a>unique_together</h4><p>联合唯一索引。</p>
<h4 id="ordering"><a href="#ordering" class="headerlink" title="ordering"></a>ordering</h4><p>指定默认按什么字段排序。</p>
<p>只有设置了该属性，我们查询到的结果才可以被reverse()。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UserInfo(models.Model):</span><br><span class="line">    nid &#x3D; models.AutoField(primary_key&#x3D;True)</span><br><span class="line">    username &#x3D; models.CharField(max_length&#x3D;32)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        # 数据库中生成的表名称 默认 app名称 + 下划线 + 类名</span><br><span class="line">        db_table &#x3D; &quot;table_name&quot;</span><br><span class="line"></span><br><span class="line">        # 联合索引</span><br><span class="line">        index_together &#x3D; [</span><br><span class="line">            (&quot;pub_date&quot;, &quot;deadline&quot;),</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        # 联合唯一索引</span><br><span class="line">        unique_together &#x3D; ((&quot;driver&quot;, &quot;restaurant&quot;),)</span><br><span class="line">        </span><br><span class="line">        ordering &#x3D; (&#39;name&#39;,)</span><br><span class="line">        </span><br><span class="line">        # admin中显示的表名称</span><br><span class="line">        verbose_name&#x3D;&#39;哈哈&#39;</span><br><span class="line"></span><br><span class="line">        # verbose_name加s</span><br><span class="line">        verbose_name_plural&#x3D;verbose_name</span><br></pre></td></tr></table></figure>

<h2 id="6-自定义字段（了解）"><a href="#6-自定义字段（了解）" class="headerlink" title="6 自定义字段（了解）"></a>6 自定义字段（了解）</h2><p>自定义char类型字段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedCharField</span>(<span class="params">models.Field</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    自定义的char类型的字段类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, max_length, *args, **kwargs</span>):</span></span><br><span class="line">        self.max_length = max_length</span><br><span class="line">        super(FixedCharField, self).__init__(max_length=max_length, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_type</span>(<span class="params">self, connection</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        限定生成数据库表的字段类型为char，长度为max_length指定的值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;char(%s)&#x27;</span> % self.max_length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    id = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    title = models.CharField(max_length=<span class="number">25</span>)</span><br><span class="line">    <span class="comment"># 使用自定义的char类型的字段</span></span><br><span class="line">    cname = FixedCharField(max_length=<span class="number">25</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>11-Django进阶-模型-事务和查询优化</title>
    <url>/posts/40409.html</url>
    <content><![CDATA[<p>Django Models 事务/查询优化/ORM更多字段</p>
<a id="more"></a>

<h2 id="1、Django中如何开启事务"><a href="#1、Django中如何开启事务" class="headerlink" title="1、Django中如何开启事务"></a>1、Django中如何开启事务</h2><blockquote>
<p><strong>事务的ACID四个特性：</strong></p>
</blockquote>
<p>原子性（Atomicity）：不可分割的最小单位<br>一致性（Consistency）：跟原子性相辅相成<br>隔离性（Isolation）：事务之间互相不干扰<br>持久性（Durability）：事务一旦确认永久生效</p>
<p>事务的回滚rollback<br>事务的确认commit</p>
<blockquote>
<p><strong>数据库三大设计范式</strong></p>
</blockquote>
<p><strong>待完善……</strong></p>
<blockquote>
<p><strong>如何开启事务</strong></p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;day64.settings&quot;)</span><br><span class="line">    import django</span><br><span class="line">    django.setup()</span><br><span class="line">    from app01 import models</span><br><span class="line">    models.User.objects.all()</span><br><span class="line"></span><br><span class="line">    # 开启事务</span><br><span class="line">    from django.db import transaction</span><br><span class="line">    try:</span><br><span class="line">        with transaction.atomic():</span><br><span class="line">            # sql1</span><br><span class="line">            # sql2</span><br><span class="line">            # 在with代码块内书写的所有orm操作都属于同一个事务</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br><span class="line">    print(&#x27;other operation&#x27;)</span><br></pre></td></tr></table></figure>

<h2 id="2、orm中常用字段及参数"><a href="#2、orm中常用字段及参数" class="headerlink" title="2、orm中常用字段及参数"></a>2、orm中常用字段及参数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">AutoField(Field)    - int自增列，必须填入参数 primary_key=<span class="literal">True</span></span><br><span class="line">BigAutoField(AutoField)    - bigint自增列，必须填入参数 primary_key=<span class="literal">True</span></span><br><span class="line">SmallIntegerField(IntegerField):    - 小整数 <span class="number">-32768</span> ～ <span class="number">32767</span></span><br><span class="line">PositiveSmallIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField)    - 正小整数 <span class="number">0</span> ～ <span class="number">32767</span></span><br><span class="line">IntegerField(Field)    - 整数列(有符号的) <span class="number">-2147483648</span> ～ <span class="number">2147483647</span></span><br><span class="line">PositiveIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField)    - 正整数 <span class="number">0</span> ～ <span class="number">2147483647</span></span><br><span class="line">BigIntegerField(IntegerField):    - 长整型(有符号的) <span class="number">-9223372036854775808</span> ～ <span class="number">9223372036854775807</span></span><br><span class="line">BooleanField(Field)    - 布尔值类型</span><br><span class="line">                该字段传布尔值(<span class="literal">False</span>/<span class="literal">True</span>)，数据库里面存<span class="number">0</span>或<span class="number">1</span></span><br><span class="line">NullBooleanField(Field):    - 可以为空的布尔值</span><br><span class="line">CharField(Field)    - 字符类型</span><br><span class="line">    - 必须提供max_length参数， max_length表示字符长度</span><br><span class="line">TextField(Field)    - 文本类型</span><br><span class="line">               -该字段可以用来存大段内容(文章、博客)，没有字数限制</span><br><span class="line">EmailField(CharField)：    - 字符串类型，Django Admin以及ModelForm中提供验证机制,本质上是varchar(<span class="number">254</span>)</span><br><span class="line">IPAddressField(Field)    - 字符串类型，Django Admin以及ModelForm中提供验证 IPV4 机制</span><br><span class="line">GenericIPAddressField(Field)    - 字符串类型，Django Admin以及ModelForm中提供验证 Ipv4和Ipv6</span><br><span class="line">    - 参数：</span><br><span class="line">        protocol，用于指定Ipv4或Ipv6， <span class="string">&#x27;both&#x27;</span>,<span class="string">&quot;ipv4&quot;</span>,<span class="string">&quot;ipv6&quot;</span></span><br><span class="line">        unpack_ipv4， 如果指定为<span class="literal">True</span>，则输入::ffff:<span class="number">192.0</span><span class="number">.2</span><span class="number">.1</span>时候，可解析为<span class="number">192.0</span><span class="number">.2</span><span class="number">.1</span>，开启刺功能，需要protocol=<span class="string">&quot;both&quot;</span></span><br><span class="line">URLField(CharField)    - 字符串类型，Django Admin以及ModelForm中提供验证 URL</span><br><span class="line">SlugField(CharField)    - 字符串类型，Django Admin以及ModelForm中提供验证支持 字母、数字、下划线、连接符（减号）</span><br><span class="line">CommaSeparatedIntegerField(CharField)    - 字符串类型，格式必须为逗号分割的数字</span><br><span class="line">UUIDField(Field)    - 字符串类型，Django Admin以及ModelForm中提供对UUID格式的验证</span><br><span class="line">FilePathField(Field)    - 字符串，Django Admin以及ModelForm中提供读取文件夹下文件的功能</span><br><span class="line">    - 参数：</span><br><span class="line">            path,                      文件夹路径</span><br><span class="line">            match=<span class="literal">None</span>,                正则匹配</span><br><span class="line">            recursive=<span class="literal">False</span>,           递归下面的文件夹</span><br><span class="line">            allow_files=<span class="literal">True</span>,          允许文件</span><br><span class="line">            allow_folders=<span class="literal">False</span>,       允许文件夹</span><br><span class="line">FileField(Field)    - 字符串，路径保存在数据库，文件上传到指定目录</span><br><span class="line">    - 参数：</span><br><span class="line">        upload_to = <span class="string">&quot;&quot;</span>      上传文件的保存路径,upload_to=<span class="string">&quot;/data&quot;</span>,给该字段传一个文件对象，会自动将文件保存到/data目录下，然后将文件路径保存到数据库中。</span><br><span class="line">        storage = <span class="literal">None</span>      存储组件，默认django.core.files.storage.FileSystemStorage</span><br><span class="line">ImageField(FileField)    - 字符串，路径保存在数据库，文件上传到指定目录</span><br><span class="line">    - 参数：</span><br><span class="line">        upload_to = <span class="string">&quot;&quot;</span>      上传文件的保存路径</span><br><span class="line">        storage = <span class="literal">None</span>      存储组件，默认django.core.files.storage.FileSystemStorage</span><br><span class="line">        width_field=<span class="literal">None</span>,   上传图片的高度保存的数据库字段名（字符串）</span><br><span class="line">        height_field=<span class="literal">None</span>   上传图片的宽度保存的数据库字段名（字符串）</span><br><span class="line">DateTimeField(DateField)    - 日期+时间格式 YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]</span><br><span class="line">DateField(DateTimeCheckMixin, Field)    - 日期格式      YYYY-MM-DD</span><br><span class="line">TimeField(DateTimeCheckMixin, Field)    - 时间格式      HH:MM[:ss[.uuuuuu]]</span><br><span class="line">    - 参数：</span><br><span class="line">              auto_now:每次修改数据的时候都会自动更新当前时间</span><br><span class="line">              auto_nowadd:只在创建数据的时候记录创建时间后续不会自动修改了 </span><br><span class="line">DurationField(Field)    - 长整数，时间间隔，数据库中按照bigint存储，ORM中获取的值为datetime.timedelta类型</span><br><span class="line">FloatField(Field)    - 浮点型</span><br><span class="line">DecimalField(Field)    - <span class="number">10</span>进制小数</span><br><span class="line">    - 参数：</span><br><span class="line">        max_digits，小数总长度</span><br><span class="line">        decimal_places，小数位长度</span><br><span class="line">BinaryField(Field)- 二进制类型</span><br></pre></td></tr></table></figure>

<p>ORM字段与MySQL字段对应关系: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对应关系：</span><br><span class="line">    &#39;AutoField&#39;: &#39;integer AUTO_INCREMENT&#39;,</span><br><span class="line">    &#39;BigAutoField&#39;: &#39;bigint AUTO_INCREMENT&#39;,</span><br><span class="line">    &#39;BinaryField&#39;: &#39;longblob&#39;,</span><br><span class="line">    &#39;BooleanField&#39;: &#39;bool&#39;,</span><br><span class="line">    &#39;CharField&#39;: &#39;varchar(%(max_length)s)&#39;,</span><br><span class="line">    &#39;CommaSeparatedIntegerField&#39;: &#39;varchar(%(max_length)s)&#39;,</span><br><span class="line">    &#39;DateField&#39;: &#39;date&#39;,</span><br><span class="line">    &#39;DateTimeField&#39;: &#39;datetime&#39;,</span><br><span class="line">    &#39;DecimalField&#39;: &#39;numeric(%(max_digits)s, %(decimal_places)s)&#39;,</span><br><span class="line">    &#39;DurationField&#39;: &#39;bigint&#39;,</span><br><span class="line">    &#39;FileField&#39;: &#39;varchar(%(max_length)s)&#39;,</span><br><span class="line">    &#39;FilePathField&#39;: &#39;varchar(%(max_length)s)&#39;,</span><br><span class="line">    &#39;FloatField&#39;: &#39;double precision&#39;,</span><br><span class="line">    &#39;IntegerField&#39;: &#39;integer&#39;,</span><br><span class="line">    &#39;BigIntegerField&#39;: &#39;bigint&#39;,</span><br><span class="line">    &#39;IPAddressField&#39;: &#39;char(15)&#39;,</span><br><span class="line">    &#39;GenericIPAddressField&#39;: &#39;char(39)&#39;,</span><br><span class="line">    &#39;NullBooleanField&#39;: &#39;bool&#39;,</span><br><span class="line">    &#39;OneToOneField&#39;: &#39;integer&#39;,</span><br><span class="line">    &#39;PositiveIntegerField&#39;: &#39;integer UNSIGNED&#39;,</span><br><span class="line">    &#39;PositiveSmallIntegerField&#39;: &#39;smallint UNSIGNED&#39;,</span><br><span class="line">    &#39;SlugField&#39;: &#39;varchar(%(max_length)s)&#39;,</span><br><span class="line">    &#39;SmallIntegerField&#39;: &#39;smallint&#39;,</span><br><span class="line">    &#39;TextField&#39;: &#39;longtext&#39;,</span><br><span class="line">    &#39;TimeField&#39;: &#39;time&#39;,</span><br><span class="line">    &#39;UUIDField&#39;: &#39;char(32)&#39;,</span><br></pre></td></tr></table></figure>



<p><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/Dominic-Ji/p/9203990.html">Django ORM中常用字段和参数www.cnblogs.com<img src="https://pic1.zhimg.com/v2-ed5750f1acb8a8b91efb2c9995ca5428_ipico.jpg" alt="图标"></a><a href="https://zhuanlan.zhihu.com/p/74423815">菲宇：一文读懂｜Django之Model操作数据库详解zhuanlan.zhihu.com<img src="https://pic3.zhimg.com/v2-70593981c47bb2c83d0c3e247612648e_180x120.jpg" alt="图标"></a></p>
<p>Django除了给你提供很多字段之外，还支持自定义字段</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义字段类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCharField</span>(<span class="params">models.Field</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,max_length,*args,**kwargs</span>):</span></span><br><span class="line">        self.max_length = max_length</span><br><span class="line">        <span class="comment"># 调用父类的init方法</span></span><br><span class="line">        super().__init__(max_length=max_length,*args,**kwargs)    <span class="comment"># 一定要是关键字的形式传入 </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_type</span>(<span class="params">self, connection</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        返回真正的数据类型及各种约束条件</span></span><br><span class="line"><span class="string">        :param connection:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;char(%s)&#x27;</span>%self.max_length</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">8</span>,decimal_places=<span class="number">2</span>)</span><br><span class="line">    publish_date = models.DateField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 库存</span></span><br><span class="line">    inventory = models.IntegerField(default=<span class="number">1000</span>)</span><br><span class="line">    <span class="comment"># 卖出</span></span><br><span class="line">    sale = models.IntegerField(default=<span class="number">1000</span>)</span><br><span class="line">    <span class="comment"># 自定义字段类型使用</span></span><br><span class="line">    MyField = MyCharField(max_length=<span class="number">16</span>,null=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 书籍与出版社一对多的关系：</span></span><br><span class="line">    publish = models.ForeignKey(to=<span class="string">&#x27;Publish&#x27;</span>)</span><br><span class="line">    <span class="comment"># 书籍与作者多对多关系：</span></span><br><span class="line">    authors = models.ManyToManyField(to=<span class="string">&#x27;Author&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-9419eed97b6738272cc392f4f19b17ff_1440w.jpg" alt="img"></p>
<h3 id="2-1-字段参数"><a href="#2-1-字段参数" class="headerlink" title="2.1 字段参数"></a>2.1 字段参数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">null</span><br><span class="line">用于表示某个字段可以为空。</span><br><span class="line"></span><br><span class="line">unique</span><br><span class="line">如果设置为unique&#x3D;True 则该字段在此表中必须是唯一的 。</span><br><span class="line"></span><br><span class="line">db_index</span><br><span class="line">如果db_index&#x3D;True 则代表着为此字段设置索引。</span><br><span class="line"></span><br><span class="line">default</span><br><span class="line">为该字段设置默认值。</span><br></pre></td></tr></table></figure>

<h3 id="2-2-DateField和DateTimeField"><a href="#2-2-DateField和DateTimeField" class="headerlink" title="2.2 DateField和DateTimeField"></a>2.2 DateField和DateTimeField</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto_now_add</span><br><span class="line">配置auto_now_add&#x3D;True，创建数据记录的时候会把当前时间添加到数据库。</span><br><span class="line"></span><br><span class="line">auto_now</span><br><span class="line">配置上auto_now&#x3D;True，每次更新数据记录的时候会更新该字段。</span><br></pre></td></tr></table></figure>

<h3 id="2-3-关系字段"><a href="#2-3-关系字段" class="headerlink" title="2.3 关系字段"></a>2.3 关系字段</h3><h4 id="ForeignKey"><a href="#ForeignKey" class="headerlink" title="ForeignKey"></a>ForeignKey</h4><p>外键类型在ORM中用来表示外键关联关系，一般把ForeignKey字段设置在 ‘一对多’中’多’的一方。</p>
<p>ForeignKey可以和其他表做关联关系同时也可以和自身做关联关系。</p>
<p>注意： </p>
<p><strong>ForeignKey(unique=True) 等价于 OneToOneField()</strong></p>
<blockquote>
<p>模型层里面1.x外键默认都是级联更新删除<br>但是2.x和3.x中需要手动配置参数</p>
</blockquote>
<p>1.x:<br>models.ForeignKey(to=’Publish’)<br>2.x和3.x:<br>models.ForeignKey(to=’Publish’,on_delete = models.CASCADE())</p>
<h4 id="字段参数"><a href="#字段参数" class="headerlink" title="字段参数"></a>字段参数</h4><h5 id="unique-True"><a href="#unique-True" class="headerlink" title="unique=True"></a>unique=True</h5><p><strong>ForeignKey(unique=True) 等价于 OneToOneField()</strong></p>
<h5 id="to"><a href="#to" class="headerlink" title="to"></a>to</h5><p>设置要关联的表</p>
<h5 id="to-field"><a href="#to-field" class="headerlink" title="to_field"></a>to_field</h5><p>设置要关联的表的字段，默认是领一张表的主键字段</p>
<h5 id="on-delete"><a href="#on-delete" class="headerlink" title="on_delete"></a><strong>on_delete</strong></h5><p>当删除关联表中的数据时，当前表与其关联的行的行为。</p>
<p><strong>models.CASCADE</strong></p>
<p>删除关联数据，与之关联也删除</p>
<h5 id="db-constraint"><a href="#db-constraint" class="headerlink" title="db_constraint"></a>db_constraint</h5><p>是否在数据库中创建外键约束，默认为True</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">models.DO_NOTHING</span><br><span class="line">删除关联数据，引发错误IntegrityError</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">models.PROTECT</span><br><span class="line">删除关联数据，引发错误ProtectedError</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">models.SET_NULL</span><br><span class="line">删除关联数据，与之关联的值设置为null（前提FK字段需要设置为可空）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">models.SET_DEFAULT</span><br><span class="line">删除关联数据，与之关联的值设置为默认值（前提FK字段需要设置默认值）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">models.SET</span><br><span class="line"></span><br><span class="line">删除关联数据，</span><br><span class="line">a. 与之关联的值设置为指定值，设置：models.SET(值)</span><br><span class="line">b. 与之关联的值设置为可执行对象的返回值，设置：models.SET(可执行对象)</span><br><span class="line">其余字段参数</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def func():</span><br><span class="line">    return 10</span><br><span class="line"></span><br><span class="line">class MyModel(models.Model):</span><br><span class="line">    user &#x3D; models.ForeignKey(</span><br><span class="line">        to&#x3D;&quot;User&quot;,</span><br><span class="line">        to_field&#x3D;&quot;id&quot;，</span><br><span class="line">        on_delete&#x3D;models.SET(func)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h4 id="OneToOneField"><a href="#OneToOneField" class="headerlink" title="OneToOneField"></a>OneToOneField</h4><p>一对一字段。</p>
<p>通常一对一字段用来扩展已有字段。(通俗的说就是一个人的所有信息不是放在一张表里面的，简单的信息一张表，隐私的信息另一张表，之间通过一对一外键关联)</p>
<h4 id="字段参数-1"><a href="#字段参数-1" class="headerlink" title="字段参数"></a>字段参数</h4><h5 id="to-1"><a href="#to-1" class="headerlink" title="to"></a>to</h5><p>设置要关联的表。</p>
<h5 id="to-field-1"><a href="#to-field-1" class="headerlink" title="to_field"></a>to_field</h5><p>设置要关联的字段。</p>
<h5 id="on-delete-1"><a href="#on-delete-1" class="headerlink" title="on_delete"></a>on_delete</h5><p>当删除关联表中的数据时，当前表与其关联的行的行为。(参考上面的例子)</p>
<h2 id="3、数据库查询优化"><a href="#3、数据库查询优化" class="headerlink" title="3、数据库查询优化"></a>3、数据库查询优化</h2><p>only与defer<br>select_related与prefetch_related</p>
<p>orm语句的特点：<br><strong>惰性查询</strong>：如果你仅仅只是书写了orm语句，在后面根本没有用到该语句所查询出来的参数，就不会执行查询，不会走数据库；要用到数据了才会走数据库。</p>
<h3 id="only与defer区别"><a href="#only与defer区别" class="headerlink" title="only与defer区别"></a><strong>only与defer区别</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&quot;day64.settings&quot;</span>)</span><br><span class="line">    <span class="keyword">import</span> django</span><br><span class="line">    django.setup()</span><br><span class="line">    <span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line">    <span class="comment"># res = models.User.objects.all()</span></span><br><span class="line">    <span class="comment"># print(res)</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    执行的SQL语句：</span></span><br><span class="line"><span class="string">    (0.001) SELECT `app01_user`.`id`, `app01_user`.`name`, `app01_user`.`age`, `app01_user`.`register_time` FROM `app01_user` LIMIT 21; args=()</span></span><br><span class="line"><span class="string">    结果为：</span></span><br><span class="line"><span class="string">    &lt;QuerySet [&lt;User: 对象：jack&gt;, &lt;User: 对象：nimoding&gt;, &lt;User: 对象：jack_sam&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：ross&gt;, &lt;User: 对象：nimo&gt;, &lt;User: 对象：jack&gt;, &lt;User: 对象：ross1&gt;, &lt;User: 对象：ross2&gt;]&gt;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 想要获取书籍表中所有书的名字</span></span><br><span class="line">    <span class="comment"># res = models.Book.objects.values(&#x27;title&#x27;)</span></span><br><span class="line">    <span class="comment"># print(res)</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    执行的SQL语句：</span></span><br><span class="line"><span class="string">    (0.001) SELECT @@SQL_AUTO_IS_NULL; args=None</span></span><br><span class="line"><span class="string">    (0.001) SELECT `app01_book`.`title` FROM `app01_book` LIMIT 21; args=()</span></span><br><span class="line"><span class="string">    结果为：</span></span><br><span class="line"><span class="string">    &lt;QuerySet [&#123;&#x27;title&#x27;: &#x27;三国演义(爆款)&#x27;&#125;, &#123;&#x27;title&#x27;: &#x27;红楼梦(爆款)&#x27;&#125;, &#123;&#x27;title&#x27;: &#x27;三国演义(爆款)&#x27;&#125;, &#123;&#x27;title&#x27;: &#x27;红楼梦(爆款)&#x27;&#125;, &#123;&#x27;title&#x27;: &#x27;三国演义(爆款)&#x27;&#125;, &#123;&#x27;title&#x27;: &#x27;红楼梦(爆款)&#x27;&#125;, &#123;&#x27;title&#x27;: &#x27;三国演义(爆款)&#x27;&#125;, &#123;&#x27;title&#x27;: &#x27;红楼梦(爆款)&#x27;&#125;, &#123;&#x27;title&#x27;: &#x27;三国演义(爆款)&#x27;&#125;, &#123;&#x27;title&#x27;: &#x27;红楼梦(爆款)&#x27;&#125;, &#123;&#x27;title&#x27;: &#x27;你今天真好看(爆款)&#x27;&#125;, &#123;&#x27;title&#x27;: &#x27;人性的弱点(爆款)&#x27;&#125;, &#123;&#x27;title&#x27;: &#x27;次第花开(爆款)&#x27;&#125;]&gt;</span></span><br><span class="line"><span class="string">    拿到的是类似列表中套字典的格式数据，并不是只包含书籍的名字。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># for i in res:</span></span><br><span class="line">    <span class="comment">#     # print(i[&#x27;title&#x27;])</span></span><br><span class="line">    <span class="comment">#     print(i.get(&#x27;title&#x27;))</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    需要通过一个for循环才能真正拿到只有书籍名称的数据：</span></span><br><span class="line"><span class="string">    SQL语句为：</span></span><br><span class="line"><span class="string">    (0.002) SELECT `app01_book`.`title` FROM `app01_book`; args=()</span></span><br><span class="line"><span class="string">    结果为：</span></span><br><span class="line"><span class="string">    红楼梦(爆款)</span></span><br><span class="line"><span class="string">    三国演义(爆款)</span></span><br><span class="line"><span class="string">    红楼梦(爆款)</span></span><br><span class="line"><span class="string">    你今天真好看(爆款)</span></span><br><span class="line"><span class="string">    人性的弱点(爆款)</span></span><br><span class="line"><span class="string">    次第花开(爆款)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进一步要求实现的功能：获取到一个数据对象，然后.title就能够拿到书名这一个字段</span></span><br><span class="line">    <span class="comment"># only测试：</span></span><br><span class="line">    <span class="comment"># res = models.Book.objects.only(&#x27;title&#x27;)</span></span><br><span class="line">    <span class="comment"># print(res)</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    SQL语句：</span></span><br><span class="line"><span class="string">    (0.001) SELECT `app01_book`.`id`, `app01_book`.`title` FROM `app01_book` LIMIT 21; args=()</span></span><br><span class="line"><span class="string">    结果为：</span></span><br><span class="line"><span class="string">    &lt;QuerySet [&lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;]&gt;</span></span><br><span class="line"><span class="string">    这里拿到的是一个对象</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 既然res拿到的是对象，那我们可以通过for循环拿到title字段</span></span><br><span class="line">    <span class="comment"># for i in res:</span></span><br><span class="line">    <span class="comment">#     print(i.title)  # 点only括号内的字段，不会走数据库</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    SQL语句：</span></span><br><span class="line"><span class="string">    (0.001) SELECT `app01_book`.`id`, `app01_book`.`title` FROM `app01_book`; args=()</span></span><br><span class="line"><span class="string">    结果为：</span></span><br><span class="line"><span class="string">    红楼梦(爆款)</span></span><br><span class="line"><span class="string">    你今天真好看(爆款)</span></span><br><span class="line"><span class="string">    人性的弱点(爆款)</span></span><br><span class="line"><span class="string">    次第花开(爆款)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># for i in res:</span></span><br><span class="line">    <span class="comment">#     print(i.price)  # 点only括号内没有的字段，会重新走数据库查询</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    SQL和结果：(没获取一条数据都会走一下数据库)</span></span><br><span class="line"><span class="string">    373.12</span></span><br><span class="line"><span class="string">    473.12</span></span><br><span class="line"><span class="string">    (0.000) SELECT `app01_book`.`id`, `app01_book`.`price` FROM `app01_book` WHERE `app01_book`.`id` = 8; args=(8,)</span></span><br><span class="line"><span class="string">    (0.000) SELECT `app01_book`.`id`, `app01_book`.`price` FROM `app01_book` WHERE `app01_book`.`id` = 9; args=(9,)</span></span><br><span class="line"><span class="string">    373.12</span></span><br><span class="line"><span class="string">    (0.001) SELECT `app01_book`.`id`, `app01_book`.`price` FROM `app01_book` WHERE `app01_book`.`id` = 10; args=(10,)</span></span><br><span class="line"><span class="string">    (0.002) SELECT `app01_book`.`id`, `app01_book`.`price` FROM `app01_book` WHERE `app01_book`.`id` = 11; args=(11,)</span></span><br><span class="line"><span class="string">    473.12</span></span><br><span class="line"><span class="string">    (0.001) SELECT `app01_book`.`id`, `app01_book`.`price` FROM `app01_book` WHERE `app01_book`.`id` = 13; args=(13,)</span></span><br><span class="line"><span class="string">    273.12</span></span><br><span class="line"><span class="string">    314.12</span></span><br><span class="line"><span class="string">    (0.000) SELECT `app01_book`.`id`, `app01_book`.`price` FROM `app01_book` WHERE `app01_book`.`id` = 14; args=(14,)</span></span><br><span class="line"><span class="string">    295.12</span></span><br><span class="line"><span class="string">    (0.001) SELECT `app01_book`.`id`, `app01_book`.`price` FROM `app01_book` WHERE `app01_book`.`id` = 15; args=(15,)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># res = models.Book.objects.all()  不需要走数据库查询</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># defer测试</span></span><br><span class="line">    res = models.Book.objects.defer(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line">    <span class="comment"># print(res)</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    SQL语句：</span></span><br><span class="line"><span class="string">    (0.001) SELECT `app01_book`.`id`, `app01_book`.`price`, `app01_book`.`publish_date`, `app01_book`.`inventory`, `app01_book`.`sale`, `app01_book`.`MyField`, `app01_book`.`publish_id` FROM `app01_book` LIMIT 21; args=()</span></span><br><span class="line"><span class="string">    结果为：</span></span><br><span class="line"><span class="string">    &lt;QuerySet [&lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;]&gt;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># for i in res:</span></span><br><span class="line">    <span class="comment">#     print(i.price)</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    SQL语句和结果：</span></span><br><span class="line"><span class="string">    (0.001) SELECT `app01_book`.`id`, `app01_book`.`price`, `app01_book`.`publish_date`, `app01_book`.`inventory`, `app01_book`.`sale`, `app01_book`.`MyField`, `app01_book`.`publish_id` FROM `app01_book`; args=()</span></span><br><span class="line"><span class="string">    373.12</span></span><br><span class="line"><span class="string">    473.12</span></span><br><span class="line"><span class="string">    373.12</span></span><br><span class="line"><span class="string">    473.12</span></span><br><span class="line"><span class="string">    373.12</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">        print(i.title)  <span class="comment"># 每次循环都会走数据库</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    SQL语句和结果：</span></span><br><span class="line"><span class="string">    红楼梦(爆款)</span></span><br><span class="line"><span class="string">    (0.001) SELECT `app01_book`.`id`, `app01_book`.`title` FROM `app01_book` WHERE `app01_book`.`id` = 11; args=(11,)</span></span><br><span class="line"><span class="string">    你今天真好看(爆款)</span></span><br><span class="line"><span class="string">    人性的弱点(爆款)</span></span><br><span class="line"><span class="string">    (0.000) SELECT `app01_book`.`id`, `app01_book`.`title` FROM `app01_book` WHERE `app01_book`.`id` = 13; args=(13,)</span></span><br><span class="line"><span class="string">    (0.001) SELECT `app01_book`.`id`, `app01_book`.`title` FROM `app01_book` WHERE `app01_book`.`id` = 14; args=(14,)</span></span><br><span class="line"><span class="string">    次第花开(爆款)</span></span><br><span class="line"><span class="string">    (0.001) SELECT `app01_book`.`id`, `app01_book`.`title` FROM `app01_book` WHERE `app01_book`.`id` = 15; args=(15,)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="总结：values-only-defer"><a href="#总结：values-only-defer" class="headerlink" title="总结：values only defer"></a>总结：values only defer</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 和values 的区别</span></span><br><span class="line">    <span class="number">0.</span>values获取的是queryset 里面是列表套的字典，里面不是数据对象，无法通过.获取属性数据。</span><br><span class="line">      如果获取其他字段，还需要额外走数据库查询。</span><br><span class="line"><span class="comment"># only和defer区别</span></span><br><span class="line">    <span class="number">1.</span>values获取的是queryset 里面是列表套的数据对象 点only括号内的字段，不会再走数据库查询; 点only括号内没有的字段，会重新走数据库查询</span><br><span class="line">    <span class="number">2.</span>defer和only刚好相反，查询defer括号内放的字段，需要重新走数据库，查询非defer括号内的字段则不需要再走数据库。</span><br></pre></td></tr></table></figure>





<h3 id="select-related与prefetch-related区别"><a href="#select-related与prefetch-related区别" class="headerlink" title="select_related与prefetch_related区别"></a><strong>select_related与prefetch_related区别</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&quot;day64.settings&quot;</span>)</span><br><span class="line">    <span class="keyword">import</span> django</span><br><span class="line">    django.setup()</span><br><span class="line">    <span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line">    models.User.objects.all()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># select_related与prefetch_related都跟跨表操作有关</span></span><br><span class="line">    <span class="comment"># 两者对用户来讲没有什么差距但是两者本质不一样：</span></span><br><span class="line">    <span class="comment"># select_related是inner join联表操作，prefetch_related是子查询</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># res = models.Book.objects.all()</span></span><br><span class="line">    <span class="comment"># for i in res:</span></span><br><span class="line">    <span class="comment">#     print(i.publish.name)</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    每拿一次数据都会走一次数据库</span></span><br><span class="line"><span class="string">    SQL语句和结果：</span></span><br><span class="line"><span class="string">    东方出版社</span></span><br><span class="line"><span class="string">    人民出版社</span></span><br><span class="line"><span class="string">    人民出版社</span></span><br><span class="line"><span class="string">    东方出版社</span></span><br><span class="line"><span class="string">    东方出版社</span></span><br><span class="line"><span class="string">    (0.001) SELECT `app01_publish`.`id`, `app01_publish`.`name`, `app01_publish`.`addr`, `app01_publish`.`email` FROM `app01_publish` WHERE `app01_publish`.`id` = 1; args=(1,)</span></span><br><span class="line"><span class="string">    (0.001) SELECT `app01_publish`.`id`, `app01_publish`.`name`, `app01_publish`.`addr`, `app01_publish`.`email` FROM `app01_publish` WHERE `app01_publish`.`id` = 2; args=(2,)</span></span><br><span class="line"><span class="string">    (0.001) SELECT `app01_publish`.`id`, `app01_publish`.`name`, `app01_publish`.`addr`, `app01_publish`.`email` FROM `app01_publish` WHERE `app01_publish`.`id` = 2; args=(2,)</span></span><br><span class="line"><span class="string">    (0.001) SELECT `app01_publish`.`id`, `app01_publish`.`name`, `app01_publish`.`addr`, `app01_publish`.`email` FROM `app01_publish` WHERE `app01_publish`.`id` = 1; args=(1,)</span></span><br><span class="line"><span class="string">    (0.001) SELECT `app01_publish`.`id`, `app01_publish`.`name`, `app01_publish`.`addr`, `app01_publish`.`email` FROM `app01_publish` WHERE `app01_publish`.`id` = 1; args=(1,)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接下来我们用select_related测试：</span></span><br><span class="line">    res = models.Book.objects.select_related(<span class="string">&#x27;publish&#x27;</span>)  <span class="comment"># INNER JOIN</span></span><br><span class="line">    <span class="comment"># print(res)</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    SQL语句和结果：</span></span><br><span class="line"><span class="string">    (0.001) SELECT `app01_book`.`id`, </span></span><br><span class="line"><span class="string">    `app01_book`.`title`, </span></span><br><span class="line"><span class="string">    `app01_book`.`price`, </span></span><br><span class="line"><span class="string">    `app01_book`.`publish_date`, </span></span><br><span class="line"><span class="string">    `app01_book`.`inventory`, </span></span><br><span class="line"><span class="string">    `app01_book`.`sale`, </span></span><br><span class="line"><span class="string">    `app01_book`.`MyField`, </span></span><br><span class="line"><span class="string">    `app01_book`.`publish_id`, </span></span><br><span class="line"><span class="string">    `app01_publish`.`id`,</span></span><br><span class="line"><span class="string">    `app01_publish`.`name`, </span></span><br><span class="line"><span class="string">    `app01_publish`.`addr`, </span></span><br><span class="line"><span class="string">    `app01_publish`.`email` </span></span><br><span class="line"><span class="string">    FROM `app01_book` INNER JOIN `app01_publish` </span></span><br><span class="line"><span class="string">    ON (`app01_book`.`publish_id` = `app01_publish`.`id`) </span></span><br><span class="line"><span class="string">    LIMIT 21; args=()</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &lt;QuerySet [&lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;]&gt;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># for i in res:</span></span><br><span class="line">    <span class="comment">#     print(i.publish.name)</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    SQL语句和结果：(跟直接print(res)效果一样)</span></span><br><span class="line"><span class="string">    (0.002) SELECT `app01_book`.`id`, `app01_book`.`title`, `app01_book`.`price`, `app01_book`.`publish_date`, `app01_book`.`inventory`, `app01_book`.`sale`, `app01_book`.`MyField`, `app01_book`.`publish_id`, `app01_publish`.`id`, `app01_publish`.`name`, `app01_publish`.`addr`, `app01_publish`.`email` FROM `app01_book` INNER JOIN `app01_publish` ON (`app01_book`.`publish_id` = `app01_publish`.`id`); args=()</span></span><br><span class="line"><span class="string">    东方出版社</span></span><br><span class="line"><span class="string">    人民出版社</span></span><br><span class="line"><span class="string">    人民出版社</span></span><br><span class="line"><span class="string">    东方出版社</span></span><br><span class="line"><span class="string">    东方出版社</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># select_related内部直接先将book表和publish表连起来，然后一次性将大表里面的所有数据全部封装给查询出来的对象</span></span><br><span class="line">    <span class="comment"># 这时无论是.book数据还是.publish数据都无需再走数据库查询了。</span></span><br><span class="line">    <span class="comment"># 注意select_related括号内只能放外键字段(可以放一对多、一对一，不支持多对多)</span></span><br><span class="line">    <span class="comment">#  可以是这种形式select_related(外键字段1__外键字段2__外键字段3……)</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># prefetch_related测试：</span></span><br><span class="line">    res = models.Book.objects.prefetch_related(<span class="string">&#x27;publish&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">        print(i.publish.name)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    SQL语句和结果：</span></span><br><span class="line"><span class="string">    这里运行了两条SQL语句</span></span><br><span class="line"><span class="string">    (0.002) SELECT `app01_book`.`id`, `app01_book`.`title`, `app01_book`.`price`, `app01_book`.`publish_date`, `app01_book`.`inventory`, `app01_book`.`sale`, `app01_book`.`MyField`, `app01_book`.`publish_id` FROM `app01_book`; args=()</span></span><br><span class="line"><span class="string">    (0.001) SELECT `app01_publish`.`id`, `app01_publish`.`name`, `app01_publish`.`addr`, `app01_publish`.`email` FROM `app01_publish` WHERE `app01_publish`.`id` IN (1, 2); args=(1, 2)</span></span><br><span class="line"><span class="string">    人民出版社</span></span><br><span class="line"><span class="string">    人民出版社</span></span><br><span class="line"><span class="string">    东方出版社</span></span><br><span class="line"><span class="string">    人民出版社</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># prefetch_related该方法内部其实就是子查询，将子查询查询出来的所有结果也封装到了对象中。</span></span><br></pre></td></tr></table></figure>

<h4 id="总结：select-related和prefetch-related"><a href="#总结：select-related和prefetch-related" class="headerlink" title="总结：select_related和prefetch_related"></a>总结：select_related和prefetch_related</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 使用方法上无差异</span><br><span class="line"><span class="number">2.</span> select_related内部本质是联表inner join，然后一次性将大表里面的所有数据全部查询出来封装到对象中，之后对象点.表字段也不会走数据库了。</span><br><span class="line">    <span class="comment"># 这时无论是.book数据还是.publish数据都无需再走数据库查询了。</span></span><br><span class="line">    <span class="comment"># 注意select_related括号内只能放外键字段(可以放一对多、一对一，不支持多对多)</span></span><br><span class="line">    <span class="comment">#  可以是这种形式select_related(外键字段1__外键字段2__外键字段3……)</span></span><br><span class="line">   prefetch_related该方法内部其实就是子查询，将子查询查询出来的所有结果也封装到了对象中。 看起来比select_related多执行了几句sql语句。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 性能差异：需要看具体情况，看起来比select_related多执行了几句sql语句，但是因为联表操作也有可能很耗时，子查询反而更快。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>12-Django进阶-模型-进阶操作</title>
    <url>/posts/48247.html</url>
    <content><![CDATA[<p>查询优化/ 中介模型</p>
<a id="more"></a>

<h2 id="一-QuerySet对象"><a href="#一-QuerySet对象" class="headerlink" title="一 QuerySet对象"></a>一 QuerySet对象</h2><h3 id="1-1可切片"><a href="#1-1可切片" class="headerlink" title="1.1可切片"></a><strong>1.1可切片</strong></h3><p>使用Python 的切片语法来限制<code>查询集</code>记录的数目 。它等同于SQL 的<code>LIMIT</code> 和<code>OFFSET</code> 子句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entry.objects.all()[:5]      # (LIMIT 5)</span><br><span class="line">Entry.objects.all()[5:10]    # (OFFSET 5 LIMIT 5)</span><br></pre></td></tr></table></figure>

<p>不支持负的索引（例如<code>Entry.objects.all()[-1]</code>）。通常，<code>查询集</code> 的切片返回一个新的<code>查询集</code> —— 它不会执行查询。</p>
<h3 id="1-2可迭代"><a href="#1-2可迭代" class="headerlink" title="1.2可迭代"></a><strong>1.2可迭代</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">articleList&#x3D;models.Article.objects.all()</span><br><span class="line"></span><br><span class="line">for article in articleList:</span><br><span class="line">    print(article.title)</span><br></pre></td></tr></table></figure>

<h3 id="1-3惰性查询"><a href="#1-3惰性查询" class="headerlink" title="1.3惰性查询"></a><strong>1.3惰性查询</strong></h3><p><code>查询集</code> 是惰性执行的 —— 创建<code>查询集</code>不会带来任何数据库的访问。你可以将过滤器保持一整天，直到<code>查询集</code> 需要求值时，Django 才会真正运行这个查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">queryResult&#x3D;models.Article.objects.all() # not hits database</span><br><span class="line"> </span><br><span class="line">print(queryResult) # hits database</span><br><span class="line"> </span><br><span class="line">for article in queryResult:</span><br><span class="line">    print(article.title)    # hits database</span><br></pre></td></tr></table></figure>

<p>一般来说，只有在“请求”<code>查询集</code> 的结果时才会到数据库中去获取它们。当你确实需要结果时，<code>查询集</code> 通过访问数据库来<em>求值</em></p>
<h3 id="1-4缓存机制"><a href="#1-4缓存机制" class="headerlink" title="1.4缓存机制"></a><strong>1.4缓存机制</strong></h3><p>每个<code>查询集</code>都包含一个缓存来最小化对数据库的访问。理解它是如何工作的将让你编写最高效的代码。</p>
<p>在一个新创建的<code>查询集</code>中，缓存为空。首次对<code>查询集</code>进行求值 —— 同时发生数据库查询 ——Django 将保存查询的结果到<code>查询集</code>的缓存中并返回明确请求的结果（例如，如果正在迭代<code>查询集</code>，则返回下一个结果）。接下来对该<code>查询集</code> 的求值将重用缓存的结果。</p>
<p>请牢记这个缓存行为，因为对<code>查询集</code>使用不当的话，它会坑你的。例如，下面的语句创建两个<code>查询集</code>，对它们求值，然后扔掉它们：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print([a.title for a in models.Article.objects.all()])</span><br><span class="line">print([a.create_time for a in models.Article.objects.all()])</span><br></pre></td></tr></table></figure>

<p>这意味着相同的数据库查询将执行两次，显然倍增了你的数据库负载。同时，还有可能两个结果列表并不包含相同的数据库记录，因为在两次请求期间有可能有Article被添加进来或删除掉。为了避免这个问题，只需保存<code>查询集</code>并重新使用它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">queryResult&#x3D;models.Article.objects.all()</span><br><span class="line">print([a.title for a in queryResult])</span><br><span class="line">print([a.create_time for a in queryResult])</span><br></pre></td></tr></table></figure>

<h4 id="何时查询集不会被缓存"><a href="#何时查询集不会被缓存" class="headerlink" title="何时查询集不会被缓存?"></a>何时查询集不会被缓存?</h4><p>查询集不会永远缓存它们的结果。当只对查询集的部分进行求值时会检查缓存， 如果这个部分不在缓存中，那么接下来查询返回的记录都将不会被缓存。所以，这意味着使用切片或索引来限制查询集将不会填充缓存。</p>
<p>例如，重复获取查询集对象中一个特定的索引将每次都查询数据库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">queryset &#x3D; Entry.objects.all()</span><br><span class="line">print queryset[5] # Queries the database</span><br><span class="line">print queryset[5] # Queries the database again</span><br></pre></td></tr></table></figure>

<p>然而，如果已经对全部查询集求值过，则将检查缓存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">queryset &#x3D; Entry.objects.all()</span><br><span class="line">[entry for entry in queryset] # Queries the database</span><br><span class="line">print queryset[5] # Uses cache</span><br><span class="line">print queryset[5] # Uses cache</span><br></pre></td></tr></table></figure>

<p>下面是一些其它例子，它们会使得全部的查询集被求值并填充到缓存中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[entry for entry in queryset]</span><br><span class="line">bool(queryset)</span><br><span class="line">entry in queryset</span><br><span class="line">list(queryset)</span><br></pre></td></tr></table></figure>

<p>注：简单地打印查询集不会填充缓存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">queryResult&#x3D;models.Article.objects.all()</span><br><span class="line">print(queryResult) #  hits database</span><br><span class="line">print(queryResult) #  hits database</span><br></pre></td></tr></table></figure>

<h3 id="1-5-exists-与iterator-方法"><a href="#1-5-exists-与iterator-方法" class="headerlink" title="1.5 exists()与iterator()方法"></a><strong>1.5 exists()与iterator()方法</strong></h3><h4 id="exists："><a href="#exists：" class="headerlink" title="exists："></a>exists：</h4><p>简单的使用if语句进行判断也会完全执行整个queryset并且把数据放入cache，虽然你并不需要这些 数据！为了避免这个，可以用exists()方法来检查是否有数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if queryResult.exists():</span><br><span class="line">    #SELECT (1) AS &quot;a&quot; FROM &quot;blog_article&quot; LIMIT 1; args&#x3D;()</span><br><span class="line">        print(&quot;exists...&quot;)</span><br></pre></td></tr></table></figure>

<h4 id="iterator"><a href="#iterator" class="headerlink" title="iterator:"></a>iterator:</h4><p>当queryset非常巨大时，cache会成为问题。</p>
<p>处理成千上万的记录时，将它们一次装入内存是很浪费的。更糟糕的是，巨大的queryset可能会锁住系统 进程，让你的程序濒临崩溃。要避免在遍历数据的同时产生queryset cache，可以使用iterator()方法 来获取数据，处理完数据就将其丢弃。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objs &#x3D; Book.objects.all().iterator()</span><br><span class="line"># iterator()可以一次只从数据库获取少量数据，这样可以节省内存</span><br><span class="line">for obj in objs:</span><br><span class="line">    print(obj.title)</span><br><span class="line">#BUT,再次遍历没有打印,因为迭代器已经在上一次遍历(next)到最后一次了,没得遍历了</span><br><span class="line">for obj in objs:</span><br><span class="line">    print(obj.title)</span><br></pre></td></tr></table></figure>

<p>当然，使用iterator()方法来防止生成cache，意味着遍历同一个queryset时会重复执行查询。所以使 #用iterator()的时候要当心，确保你的代码在操作一个大的queryset时没有重复执行查询。</p>
<p><strong>总结:</strong></p>
<p>queryset的cache是用于减少程序对数据库的查询，在通常的使用下会保证只有在需要的时候才会查询数据库。 使用exists()和iterator()方法可以优化程序对内存的使用。不过，由于它们并不会生成queryset cache，可能 会造成额外的数据库查询。</p>
<h2 id="二-中介模型"><a href="#二-中介模型" class="headerlink" title="二 中介模型"></a>二 中介模型</h2><p>处理类似搭配 pizza 和 topping 这样简单的多对多关系时，使用标准的<code>ManyToManyField</code> 就可以了。但是，有时你可能需要关联数据到两个模型之间的关系上。</p>
<p>例如，有这样一个应用，它记录音乐家所属的音乐小组。我们可以用一个<code>ManyToManyField</code> 表示小组和成员之间的多对多关系。但是，有时你可能想知道更多成员关系的细节，比如成员是何时加入小组的。</p>
<p>对于这些情况，Django 允许你指定一个中介模型来定义多对多关系。 你可以将其他字段放在中介模型里面。源模型的<code>ManyToManyField</code> 字段将使用<code>through</code> 参数指向中介模型。对于上面的音乐小组的例子，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"> </span><br><span class="line">class Person(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;128)</span><br><span class="line"> </span><br><span class="line">    def __str__(self):              # __unicode__ on Python 2</span><br><span class="line">        return self.name</span><br><span class="line"> </span><br><span class="line">class Group(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;128)</span><br><span class="line">    members &#x3D; models.ManyToManyField(Person, through&#x3D;&#39;Membership&#39;)</span><br><span class="line"> </span><br><span class="line">    def __str__(self):              # __unicode__ on Python 2</span><br><span class="line">        return self.name</span><br><span class="line"> </span><br><span class="line">class Membership(models.Model):</span><br><span class="line">    person &#x3D; models.ForeignKey(Person)</span><br><span class="line">    group &#x3D; models.ForeignKey(Group)</span><br><span class="line">    date_joined &#x3D; models.DateField()</span><br><span class="line">    invite_reason &#x3D; models.CharField(max_length&#x3D;64)</span><br></pre></td></tr></table></figure>

<p>既然你已经设置好<code>ManyToManyField</code> 来使用中介模型（在这个例子中就是<code>Membership</code>），接下来你要开始创建多对多关系。你要做的就是创建中介模型的实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; ringo &#x3D; Person.objects.create(name&#x3D;&quot;Ringo Starr&quot;)</span><br><span class="line">&gt;&gt;&gt; paul &#x3D; Person.objects.create(name&#x3D;&quot;Paul McCartney&quot;)</span><br><span class="line">&gt;&gt;&gt; beatles &#x3D; Group.objects.create(name&#x3D;&quot;The Beatles&quot;)</span><br><span class="line">&gt;&gt;&gt; m1 &#x3D; Membership(person&#x3D;ringo, group&#x3D;beatles,</span><br><span class="line">...     date_joined&#x3D;date(1962, 8, 16),</span><br><span class="line">...     invite_reason&#x3D;&quot;Needed a new drummer.&quot;)</span><br><span class="line">&gt;&gt;&gt; m1.save()</span><br><span class="line">&gt;&gt;&gt; beatles.members.all()</span><br><span class="line">[&lt;Person: Ringo Starr&gt;]</span><br><span class="line">&gt;&gt;&gt; ringo.group_set.all()</span><br><span class="line">[&lt;Group: The Beatles&gt;]</span><br><span class="line">&gt;&gt;&gt; m2 &#x3D; Membership.objects.create(person&#x3D;paul, group&#x3D;beatles,</span><br><span class="line">...     date_joined&#x3D;date(1960, 8, 1),</span><br><span class="line">...     invite_reason&#x3D;&quot;Wanted to form a band.&quot;)</span><br><span class="line">&gt;&gt;&gt; beatles.members.all()</span><br><span class="line">[&lt;Person: Ringo Starr&gt;, &lt;Person: Paul McCartney&gt;]</span><br></pre></td></tr></table></figure>

<p>与普通的多对多字段不同，你不能使用<code>add</code>、 <code>create</code>和赋值语句（比如，<code>beatles.members = [...]</code>）来创建关系：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># THIS WILL NOT WORK</span><br><span class="line">&gt;&gt;&gt; beatles.members.add(john)</span><br><span class="line"># NEITHER WILL THIS</span><br><span class="line">&gt;&gt;&gt; beatles.members.create(name&#x3D;&quot;George Harrison&quot;)</span><br><span class="line"># AND NEITHER WILL THIS</span><br><span class="line">&gt;&gt;&gt; beatles.members &#x3D; [john, paul, ringo, george]</span><br></pre></td></tr></table></figure>

<p>为什么不能这样做？ 这是因为你不能只创建 <code>Person</code>和 <code>Group</code>之间的关联关系，你还要指定 <code>Membership</code>模型中所需要的所有信息；而简单的<code>add</code>、<code>create</code> 和赋值语句是做不到这一点的。所以它们不能在使用中介模型的多对多关系中使用。此时，唯一的办法就是创建中介模型的实例。</p>
<p><code>remove()</code>方法被禁用也是出于同样的原因。但是<code>clear()</code> 方法却是可用的。它可以清空某个实例所有的多对多关系：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; # Beatles have broken up</span><br><span class="line">&gt;&gt;&gt; beatles.members.clear()</span><br><span class="line">&gt;&gt;&gt; # Note that this deletes the intermediate model instances</span><br><span class="line">&gt;&gt;&gt; Membership.objects.all()</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<h2 id="三-查询优化"><a href="#三-查询优化" class="headerlink" title="三 查询优化"></a>三 查询优化</h2><h3 id="3-1表数据"><a href="#3-1表数据" class="headerlink" title="3.1表数据"></a>3.1表数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UserInfo(AbstractUser):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    用户信息</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    nid &#x3D; models.BigAutoField(primary_key&#x3D;True)</span><br><span class="line">    nickname &#x3D; models.CharField(verbose_name&#x3D;&#39;昵称&#39;, max_length&#x3D;32)</span><br><span class="line">    telephone &#x3D; models.CharField(max_length&#x3D;11, blank&#x3D;True, null&#x3D;True, unique&#x3D;True, verbose_name&#x3D;&#39;手机号码&#39;)</span><br><span class="line">    avatar &#x3D; models.FileField(verbose_name&#x3D;&#39;头像&#39;,upload_to &#x3D; &#39;avatar&#x2F;&#39;,default&#x3D;&quot;&#x2F;avatar&#x2F;default.png&quot;)</span><br><span class="line">    create_time &#x3D; models.DateTimeField(verbose_name&#x3D;&#39;创建时间&#39;, auto_now_add&#x3D;True)</span><br><span class="line"> </span><br><span class="line">    fans &#x3D; models.ManyToManyField(verbose_name&#x3D;&#39;粉丝们&#39;,</span><br><span class="line">                                  to&#x3D;&#39;UserInfo&#39;,</span><br><span class="line">                                  through&#x3D;&#39;UserFans&#39;,</span><br><span class="line">                                  related_name&#x3D;&#39;f&#39;,</span><br><span class="line">                                  through_fields&#x3D;(&#39;user&#39;, &#39;follower&#39;))</span><br><span class="line"> </span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.username</span><br><span class="line"> </span><br><span class="line">class UserFans(models.Model):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    互粉关系表</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    nid &#x3D; models.AutoField(primary_key&#x3D;True)</span><br><span class="line">    user &#x3D; models.ForeignKey(verbose_name&#x3D;&#39;博主&#39;, to&#x3D;&#39;UserInfo&#39;, to_field&#x3D;&#39;nid&#39;, related_name&#x3D;&#39;users&#39;)</span><br><span class="line">    follower &#x3D; models.ForeignKey(verbose_name&#x3D;&#39;粉丝&#39;, to&#x3D;&#39;UserInfo&#39;, to_field&#x3D;&#39;nid&#39;, related_name&#x3D;&#39;followers&#39;)</span><br><span class="line"> </span><br><span class="line">class Blog(models.Model):</span><br><span class="line"> </span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    博客信息</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    nid &#x3D; models.BigAutoField(primary_key&#x3D;True)</span><br><span class="line">    title &#x3D; models.CharField(verbose_name&#x3D;&#39;个人博客标题&#39;, max_length&#x3D;64)</span><br><span class="line">    site &#x3D; models.CharField(verbose_name&#x3D;&#39;个人博客后缀&#39;, max_length&#x3D;32, unique&#x3D;True)</span><br><span class="line">    theme &#x3D; models.CharField(verbose_name&#x3D;&#39;博客主题&#39;, max_length&#x3D;32)</span><br><span class="line">    user &#x3D; models.OneToOneField(to&#x3D;&#39;UserInfo&#39;, to_field&#x3D;&#39;nid&#39;)</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.title</span><br><span class="line"> </span><br><span class="line">class Category(models.Model):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    博主个人文章分类表</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    nid &#x3D; models.AutoField(primary_key&#x3D;True)</span><br><span class="line">    title &#x3D; models.CharField(verbose_name&#x3D;&#39;分类标题&#39;, max_length&#x3D;32)</span><br><span class="line"> </span><br><span class="line">    blog &#x3D; models.ForeignKey(verbose_name&#x3D;&#39;所属博客&#39;, to&#x3D;&#39;Blog&#39;, to_field&#x3D;&#39;nid&#39;)</span><br><span class="line"> </span><br><span class="line">class Article(models.Model):</span><br><span class="line"> </span><br><span class="line">    nid &#x3D; models.BigAutoField(primary_key&#x3D;True)</span><br><span class="line">    title &#x3D; models.CharField(max_length&#x3D;50, verbose_name&#x3D;&#39;文章标题&#39;)</span><br><span class="line">    desc &#x3D; models.CharField(max_length&#x3D;255, verbose_name&#x3D;&#39;文章描述&#39;)</span><br><span class="line">    read_count &#x3D; models.IntegerField(default&#x3D;0)</span><br><span class="line">    comment_count&#x3D; models.IntegerField(default&#x3D;0)</span><br><span class="line">    up_count &#x3D; models.IntegerField(default&#x3D;0)</span><br><span class="line">    down_count &#x3D; models.IntegerField(default&#x3D;0)</span><br><span class="line">    category &#x3D; models.ForeignKey(verbose_name&#x3D;&#39;文章类型&#39;, to&#x3D;&#39;Category&#39;, to_field&#x3D;&#39;nid&#39;, null&#x3D;True)</span><br><span class="line">    create_time &#x3D; models.DateField(verbose_name&#x3D;&#39;创建时间&#39;)</span><br><span class="line">    blog &#x3D; models.ForeignKey(verbose_name&#x3D;&#39;所属博客&#39;, to&#x3D;&#39;Blog&#39;, to_field&#x3D;&#39;nid&#39;)</span><br><span class="line">    tags &#x3D; models.ManyToManyField(</span><br><span class="line">        to&#x3D;&quot;Tag&quot;,</span><br><span class="line">        through&#x3D;&#39;Article2Tag&#39;,</span><br><span class="line">        through_fields&#x3D;(&#39;article&#39;, &#39;tag&#39;),</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class ArticleDetail(models.Model):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    文章详细表</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    nid &#x3D; models.AutoField(primary_key&#x3D;True)</span><br><span class="line">    content &#x3D; models.TextField(verbose_name&#x3D;&#39;文章内容&#39;, )</span><br><span class="line"> </span><br><span class="line">    article &#x3D; models.OneToOneField(verbose_name&#x3D;&#39;所属文章&#39;, to&#x3D;&#39;Article&#39;, to_field&#x3D;&#39;nid&#39;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class Comment(models.Model):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    评论表</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    nid &#x3D; models.BigAutoField(primary_key&#x3D;True)</span><br><span class="line">    article &#x3D; models.ForeignKey(verbose_name&#x3D;&#39;评论文章&#39;, to&#x3D;&#39;Article&#39;, to_field&#x3D;&#39;nid&#39;)</span><br><span class="line">    content &#x3D; models.CharField(verbose_name&#x3D;&#39;评论内容&#39;, max_length&#x3D;255)</span><br><span class="line">    create_time &#x3D; models.DateTimeField(verbose_name&#x3D;&#39;创建时间&#39;, auto_now_add&#x3D;True)</span><br><span class="line"> </span><br><span class="line">    parent_comment &#x3D; models.ForeignKey(&#39;self&#39;, blank&#x3D;True, null&#x3D;True, verbose_name&#x3D;&#39;父级评论&#39;)</span><br><span class="line">    user &#x3D; models.ForeignKey(verbose_name&#x3D;&#39;评论者&#39;, to&#x3D;&#39;UserInfo&#39;, to_field&#x3D;&#39;nid&#39;)</span><br><span class="line"> </span><br><span class="line">    up_count &#x3D; models.IntegerField(default&#x3D;0)</span><br><span class="line"> </span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.content</span><br><span class="line"> </span><br><span class="line">class ArticleUpDown(models.Model):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    点赞表</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    nid &#x3D; models.AutoField(primary_key&#x3D;True)</span><br><span class="line">    user &#x3D; models.ForeignKey(&#39;UserInfo&#39;, null&#x3D;True)</span><br><span class="line">    article &#x3D; models.ForeignKey(&quot;Article&quot;, null&#x3D;True)</span><br><span class="line">    models.BooleanField(verbose_name&#x3D;&#39;是否赞&#39;)</span><br><span class="line"> </span><br><span class="line">class CommentUp(models.Model):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    点赞表</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    nid &#x3D; models.AutoField(primary_key&#x3D;True)</span><br><span class="line">    user &#x3D; models.ForeignKey(&#39;UserInfo&#39;, null&#x3D;True)</span><br><span class="line">    comment &#x3D; models.ForeignKey(&quot;Comment&quot;, null&#x3D;True)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class Tag(models.Model):</span><br><span class="line">    nid &#x3D; models.AutoField(primary_key&#x3D;True)</span><br><span class="line">    title &#x3D; models.CharField(verbose_name&#x3D;&#39;标签名称&#39;, max_length&#x3D;32)</span><br><span class="line">    blog &#x3D; models.ForeignKey(verbose_name&#x3D;&#39;所属博客&#39;, to&#x3D;&#39;Blog&#39;, to_field&#x3D;&#39;nid&#39;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class Article2Tag(models.Model):</span><br><span class="line">    nid &#x3D; models.AutoField(primary_key&#x3D;True)</span><br><span class="line">    article &#x3D; models.ForeignKey(verbose_name&#x3D;&#39;文章&#39;, to&#x3D;&quot;Article&quot;, to_field&#x3D;&#39;nid&#39;)</span><br><span class="line">    tag &#x3D; models.ForeignKey(verbose_name&#x3D;&#39;标签&#39;, to&#x3D;&quot;Tag&quot;, to_field&#x3D;&#39;nid&#39;)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-select-related"><a href="#3-2-select-related" class="headerlink" title="3.2 select_related"></a>3.2 select_related</h3><h4 id="3-2-1简单使用"><a href="#3-2-1简单使用" class="headerlink" title="3.2.1简单使用"></a><strong>3.2.1简单使用</strong></h4><p>对于一对一字段（OneToOneField）和外键字段（ForeignKey），可以使用select_related 来对QuerySet进行优化。</p>
<p>select_related 返回一个<code>QuerySet</code>，当执行它的查询时它沿着外键关系查询关联的对象的数据。它会生成一个复杂的查询并引起性能的损耗，但是在以后使用外键关系时将不需要数据库查询。</p>
<p>简单说，在对QuerySet使用select_related()函数后，Django会获取相应外键对应的对象，从而在之后需要的时候不必再查询数据库了。</p>
<p>下面的例子解释了普通查询和<code>select_related()</code> 查询的区别。</p>
<p>查询id=2的文章的分类名称,下面是一个标准的查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Hits the database.</span><br><span class="line">article&#x3D;models.Article.objects.get(nid&#x3D;2)</span><br><span class="line"> </span><br><span class="line"># Hits the database again to get the related Blog object.</span><br><span class="line">print(article.category.title)</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"> </span><br><span class="line">SELECT</span><br><span class="line">    &quot;blog_article&quot;.&quot;nid&quot;,</span><br><span class="line">    &quot;blog_article&quot;.&quot;title&quot;,</span><br><span class="line">    &quot;blog_article&quot;.&quot;desc&quot;,</span><br><span class="line">    &quot;blog_article&quot;.&quot;read_count&quot;,</span><br><span class="line">    &quot;blog_article&quot;.&quot;comment_count&quot;,</span><br><span class="line">    &quot;blog_article&quot;.&quot;up_count&quot;,</span><br><span class="line">    &quot;blog_article&quot;.&quot;down_count&quot;,</span><br><span class="line">    &quot;blog_article&quot;.&quot;category_id&quot;,</span><br><span class="line">    &quot;blog_article&quot;.&quot;create_time&quot;,</span><br><span class="line">     &quot;blog_article&quot;.&quot;blog_id&quot;,</span><br><span class="line">     &quot;blog_article&quot;.&quot;article_type_id&quot;</span><br><span class="line">             FROM &quot;blog_article&quot;</span><br><span class="line">             WHERE &quot;blog_article&quot;.&quot;nid&quot; &#x3D; 2; args&#x3D;(2,)</span><br><span class="line"> </span><br><span class="line">SELECT</span><br><span class="line">     &quot;blog_category&quot;.&quot;nid&quot;,</span><br><span class="line">     &quot;blog_category&quot;.&quot;title&quot;,</span><br><span class="line">     &quot;blog_category&quot;.&quot;blog_id&quot;</span><br><span class="line">              FROM &quot;blog_category&quot;</span><br><span class="line">              WHERE &quot;blog_category&quot;.&quot;nid&quot; &#x3D; 4; args&#x3D;(4,)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#39;&#39;&#39;</span><br></pre></td></tr></table></figure>

<p>如果我们使用select_related()函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">articleList&#x3D;models.Article.objects.select_related(&quot;category&quot;).all()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    for article_obj in articleList:</span><br><span class="line">        #  Doesn&#39;t hit the database, because article_obj.category</span><br><span class="line">        #  has been prepopulated in the previous query.</span><br><span class="line">        #不再查询数据库，因为第一次查询，数据已经填充进去了</span><br><span class="line">        print(article_obj.category.title)</span><br><span class="line">SELECT</span><br><span class="line">     &quot;blog_article&quot;.&quot;nid&quot;,</span><br><span class="line">     &quot;blog_article&quot;.&quot;title&quot;,</span><br><span class="line">     &quot;blog_article&quot;.&quot;desc&quot;,</span><br><span class="line">     &quot;blog_article&quot;.&quot;read_count&quot;,</span><br><span class="line">     &quot;blog_article&quot;.&quot;comment_count&quot;,</span><br><span class="line">     &quot;blog_article&quot;.&quot;up_count&quot;,</span><br><span class="line">     &quot;blog_article&quot;.&quot;down_count&quot;,</span><br><span class="line">     &quot;blog_article&quot;.&quot;category_id&quot;,</span><br><span class="line">     &quot;blog_article&quot;.&quot;create_time&quot;,</span><br><span class="line">     &quot;blog_article&quot;.&quot;blog_id&quot;,</span><br><span class="line">     &quot;blog_article&quot;.&quot;article_type_id&quot;,</span><br><span class="line"> </span><br><span class="line">     &quot;blog_category&quot;.&quot;nid&quot;,</span><br><span class="line">     &quot;blog_category&quot;.&quot;title&quot;,</span><br><span class="line">     &quot;blog_category&quot;.&quot;blog_id&quot;</span><br><span class="line"> </span><br><span class="line">FROM &quot;blog_article&quot;</span><br><span class="line">LEFT OUTER JOIN &quot;blog_category&quot; ON (&quot;blog_article&quot;.&quot;category_id&quot; &#x3D; &quot;blog_category&quot;.&quot;nid&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-多外键查询"><a href="#3-2-2-多外键查询" class="headerlink" title="**3.2.2 多外键查询 **"></a>**3.2.2 多外键查询 **</h4><p>这是针对category的外键查询，如果是另外一个外键呢？让我们一起看下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">article&#x3D;models.Article.objects.select_related(&quot;category&quot;).get(nid&#x3D;1)</span><br><span class="line">print(article.articledetail)</span><br></pre></td></tr></table></figure>

<p>观察logging结果，发现依然需要查询两次，所以需要改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">article&#x3D;models.Article.objects.select_related(&quot;category&quot;,&quot;articledetail&quot;).get(nid&#x3D;1)</span><br><span class="line">print(article.articledetail)</span><br></pre></td></tr></table></figure>

<p>或者：1.7以后支持链式操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">article&#x3D;models.Article.objects</span><br><span class="line">　　　　　　　　　　　　　.select_related(&quot;category&quot;)</span><br><span class="line">　　　　　　　　　　　　　.select_related(&quot;articledetail&quot;)</span><br><span class="line">　　　　　　　　　　　　　.get(nid&#x3D;1)  # django 1.7 支持链式操作</span><br><span class="line">print(article.articledetail)</span><br><span class="line">SELECT</span><br><span class="line"> </span><br><span class="line">    &quot;blog_article&quot;.&quot;nid&quot;,</span><br><span class="line">    &quot;blog_article&quot;.&quot;title&quot;,</span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">    &quot;blog_category&quot;.&quot;nid&quot;,</span><br><span class="line">    &quot;blog_category&quot;.&quot;title&quot;,</span><br><span class="line">    &quot;blog_category&quot;.&quot;blog_id&quot;,</span><br><span class="line"> </span><br><span class="line">    &quot;blog_articledetail&quot;.&quot;nid&quot;,</span><br><span class="line">    &quot;blog_articledetail&quot;.&quot;content&quot;,</span><br><span class="line">    &quot;blog_articledetail&quot;.&quot;article_id&quot;</span><br><span class="line"> </span><br><span class="line">   FROM &quot;blog_article&quot;</span><br><span class="line">   LEFT OUTER JOIN &quot;blog_category&quot; ON (&quot;blog_article&quot;.&quot;category_id&quot; &#x3D; &quot;blog_category&quot;.&quot;nid&quot;)</span><br><span class="line">   LEFT OUTER JOIN &quot;blog_articledetail&quot; ON (&quot;blog_article&quot;.&quot;nid&quot; &#x3D; &quot;blog_articledetail&quot;.&quot;article_id&quot;)</span><br><span class="line">   WHERE &quot;blog_article&quot;.&quot;nid&quot; &#x3D; 1; args&#x3D;(1,)</span><br></pre></td></tr></table></figure>

<h4 id="3-2-3-深层查询"><a href="#3-2-3-深层查询" class="headerlink" title="3.2.3 深层查询"></a><strong>3.2.3 深层查询</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询id&#x3D;1的文章的用户姓名</span><br><span class="line"> </span><br><span class="line">    article&#x3D;models.Article.objects.select_related(&quot;blog&quot;).get(nid&#x3D;1)</span><br><span class="line">    print(article.blog.user.username)</span><br></pre></td></tr></table></figure>

<p>依然需要查询两次：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    &quot;blog_article&quot;.&quot;nid&quot;,</span><br><span class="line">    &quot;blog_article&quot;.&quot;title&quot;,</span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">     &quot;blog_blog&quot;.&quot;nid&quot;,</span><br><span class="line">     &quot;blog_blog&quot;.&quot;title&quot;,</span><br><span class="line"> </span><br><span class="line">   FROM &quot;blog_article&quot; INNER JOIN &quot;blog_blog&quot; ON (&quot;blog_article&quot;.&quot;blog_id&quot; &#x3D; &quot;blog_blog&quot;.&quot;nid&quot;)</span><br><span class="line">   WHERE &quot;blog_article&quot;.&quot;nid&quot; &#x3D; 1;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">SELECT</span><br><span class="line">    &quot;blog_userinfo&quot;.&quot;password&quot;,</span><br><span class="line">    &quot;blog_userinfo&quot;.&quot;last_login&quot;,</span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">FROM &quot;blog_userinfo&quot;</span><br><span class="line">WHERE &quot;blog_userinfo&quot;.&quot;nid&quot; &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>这是因为第一次查询没有query到userInfo表，所以，修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">article&#x3D;models.Article.objects.select_related(&quot;blog__user&quot;).get(nid&#x3D;1)</span><br><span class="line">print(article.blog.user.username)</span><br><span class="line">SELECT</span><br><span class="line"> </span><br><span class="line">&quot;blog_article&quot;.&quot;nid&quot;, &quot;blog_article&quot;.&quot;title&quot;,</span><br><span class="line">......</span><br><span class="line"> </span><br><span class="line"> &quot;blog_blog&quot;.&quot;nid&quot;, &quot;blog_blog&quot;.&quot;title&quot;,</span><br><span class="line">......</span><br><span class="line"> </span><br><span class="line"> &quot;blog_userinfo&quot;.&quot;password&quot;, &quot;blog_userinfo&quot;.&quot;last_login&quot;,</span><br><span class="line">......</span><br><span class="line"> </span><br><span class="line">FROM &quot;blog_article&quot;</span><br><span class="line"> </span><br><span class="line">INNER JOIN &quot;blog_blog&quot; ON (&quot;blog_article&quot;.&quot;blog_id&quot; &#x3D; &quot;blog_blog&quot;.&quot;nid&quot;)</span><br><span class="line"> </span><br><span class="line">INNER JOIN &quot;blog_userinfo&quot; ON (&quot;blog_blog&quot;.&quot;user_id&quot; &#x3D; &quot;blog_userinfo&quot;.&quot;nid&quot;)</span><br><span class="line">WHERE &quot;blog_article&quot;.&quot;nid&quot; &#x3D; 1;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-4-总结"><a href="#3-2-4-总结" class="headerlink" title="3.2.4 总结"></a><strong>3.2.4 总结</strong></h4><ol>
<li>select_related主要针一对一和多对一关系进行优化。</li>
<li>select_related使用SQL的JOIN语句进行优化，通过减少SQL查询的次数来进行优化、提高性能。</li>
<li>可以通过可变长参数指定需要select_related的字段名。也可以通过使用双下划线“__”连接字段名来实现指定的递归查询。</li>
<li>没有指定的字段不会缓存，没有指定的深度不会缓存，如果要访问的话Django会再次进行SQL查询。</li>
<li>也可以通过depth参数指定递归的深度，Django会自动缓存指定深度内所有的字段。如果要访问指定深度外的字段，Django会再次进行SQL查询。</li>
<li>也接受无参数的调用，Django会尽可能深的递归查询所有的字段。但注意有Django递归的限制和性能的浪费。</li>
<li>Django &gt;= 1.7，链式调用的select_related相当于使用可变长参数。Django &lt; 1.7，链式调用会导致前边的select_related失效，只保留最后一个。</li>
</ol>
<h3 id="3-3-prefetch-related"><a href="#3-3-prefetch-related" class="headerlink" title="3.3 prefetch_related()"></a>3.3 <strong>prefetch_related()</strong></h3><p>对于多对多字段（ManyToManyField）和一对多字段，可以使用prefetch_related()来进行优化。</p>
<p>prefetch_related()和select_related()的设计目的很相似，都是为了减少SQL查询的数量，但是实现的方式不一样。后者是通过JOIN语句，在SQL查询内解决问题。但是对于多对多关系，使用SQL语句解决就显得有些不太明智，因为JOIN得到的表将会很长，会导致SQL语句运行时间的增加和内存占用的增加。若有n个对象，每个对象的多对多字段对应Mi条，就会生成Σ(n)Mi 行的结果表。</p>
<p>prefetch_related()的解决方法是，分别查询每个表，然后用Python处理他们之间的关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询所有文章关联的所有标签</span><br><span class="line">    article_obj&#x3D;models.Article.objects.all()</span><br><span class="line">    for i in article_obj:</span><br><span class="line"> </span><br><span class="line">        print(i.tags.all())  #4篇文章: hits database 5</span><br></pre></td></tr></table></figure>

<p>改为prefetch_related：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询所有文章关联的所有标签</span><br><span class="line">    article_obj&#x3D;models.Article.objects.prefetch_related(&quot;tags&quot;).all()</span><br><span class="line">    for i in article_obj:</span><br><span class="line"> </span><br><span class="line">        print(i.tags.all())  #4篇文章: hits database 2</span><br><span class="line">SELECT &quot;blog_article&quot;.&quot;nid&quot;,</span><br><span class="line">               &quot;blog_article&quot;.&quot;title&quot;,</span><br><span class="line">               ......</span><br><span class="line"> </span><br><span class="line">FROM &quot;blog_article&quot;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">SELECT</span><br><span class="line">  (&quot;blog_article2tag&quot;.&quot;article_id&quot;) AS &quot;_prefetch_related_val_article_id&quot;,</span><br><span class="line">  &quot;blog_tag&quot;.&quot;nid&quot;,</span><br><span class="line">  &quot;blog_tag&quot;.&quot;title&quot;,</span><br><span class="line">  &quot;blog_tag&quot;.&quot;blog_id&quot;</span><br><span class="line">   FROM &quot;blog_tag&quot;</span><br><span class="line">  INNER JOIN &quot;blog_article2tag&quot; ON (&quot;blog_tag&quot;.&quot;nid&quot; &#x3D; &quot;blog_article2tag&quot;.&quot;tag_id&quot;)</span><br><span class="line">  WHERE &quot;blog_article2tag&quot;.&quot;article_id&quot; IN (1, 2, 3, 4);</span><br><span class="line">def select_related(self, *fields)</span><br><span class="line">     性能相关：表之间进行join连表操作，一次性获取关联的数据。</span><br><span class="line">     model.tb.objects.all().select_related()</span><br><span class="line">     model.tb.objects.all().select_related(&#39;外键字段&#39;)</span><br><span class="line">     model.tb.objects.all().select_related(&#39;外键字段__外键字段&#39;)</span><br><span class="line"></span><br><span class="line">def prefetch_related(self, *lookups)</span><br><span class="line">    性能相关：多表连表操作时速度会慢，使用其执行多次SQL查询在Python代码中实现连表操作。</span><br><span class="line">            # 获取所有用户表</span><br><span class="line">            # 获取用户类型表where id in (用户表中的查到的所有用户ID)</span><br><span class="line">            models.UserInfo.objects.prefetch_related(&#39;外键字段&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            from django.db.models import Count, Case, When, IntegerField</span><br><span class="line">            Article.objects.annotate(</span><br><span class="line">                numviews&#x3D;Count(Case(</span><br><span class="line">                    When(readership__what_time__lt&#x3D;treshold, then&#x3D;1),</span><br><span class="line">                    output_field&#x3D;CharField(),</span><br><span class="line">                ))</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            students &#x3D; Student.objects.all().annotate(num_excused_absences&#x3D;models.Sum(</span><br><span class="line">                models.Case(</span><br><span class="line">                    models.When(absence__type&#x3D;&#39;Excused&#39;, then&#x3D;1),</span><br><span class="line">                default&#x3D;0,</span><br><span class="line">                output_field&#x3D;models.IntegerField()</span><br><span class="line">            )))</span><br><span class="line">  # 加select_related 主动做链表，相当于直接链表把数据全取出来了，</span><br><span class="line">    # 不加：for循环几次，就再次查几次数据库</span><br><span class="line">    # select_related(&#39;author_detail&#39;)参数是fk的字段，可能有多个外键，所以可以写多个</span><br><span class="line">    ret&#x3D;models.Author.objects.all().select_related(&#39;author_detail&#39;)</span><br><span class="line">    for i in ret:</span><br><span class="line">        print(i.author_detail.addr)</span><br><span class="line">    ret &#x3D; models.Author.objects.all()</span><br><span class="line">    for i in ret:</span><br><span class="line">        print(i.author_detail.addr)</span><br><span class="line"></span><br><span class="line">#     用了fk,但是不做链表，做多次查询,把结果集都放到对象中</span><br><span class="line">#     两次查询，相当于select * from author_detail where nid in [1,2]</span><br><span class="line">    ret&#x3D;models.Author.objects.all().prefetch_related(&#39;author_detail&#39;)</span><br><span class="line">    for i in ret:</span><br><span class="line">        print(i.author_detail.addr)</span><br><span class="line"># 总结：数据量少，可以用select_related</span><br><span class="line">#     数据量比较多用prefetch_related</span><br></pre></td></tr></table></figure>

<h2 id="四-extra"><a href="#四-extra" class="headerlink" title="四 extra"></a>四 extra</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extra(select&#x3D;None, where&#x3D;None, params&#x3D;None, </span><br><span class="line">      tables&#x3D;None, order_by&#x3D;None, select_params&#x3D;None)</span><br></pre></td></tr></table></figure>

<p>有些情况下，Django的查询语法难以简单的表达复杂的 <code>WHERE</code> 子句，对于这种情况, Django 提供了 <code>extra()</code> <code>QuerySet</code>修改机制 — 它能在 <code>QuerySet</code>生成的SQL从句中注入新子句</p>
<p>extra可以指定一个或多个 <code>参数</code>,例如 <code>select</code>, <code>where</code> or <code>tables</code>. 这些参数都不是必须的，但是你至少要使用一个!要注意这些额外的方式对不同的数据库引擎可能存在移植性问题.(因为你在显式的书写SQL语句),除非万不得已,尽量避免这样做</p>
<h3 id="4-1参数之select"><a href="#4-1参数之select" class="headerlink" title="4.1参数之select"></a>4.1参数之select</h3><p>The <code>select</code> 参数可以让你在 <code>SELECT</code> 从句中添加其他字段信息，它应该是一个字典，存放着属性名到 SQL 从句的映射。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">queryResult&#x3D;models.Article</span><br><span class="line">　　　　　　　　　　　.objects.extra(select&#x3D;&#123;&#39;is_recent&#39;: &quot;create_time &gt; &#39;2017-09-05&#39;&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p>结果集中每个 Entry 对象都有一个额外的属性is_recent, 它是一个布尔值，表示 Article对象的create_time 是否晚于2017-09-05.</p>
<p>练习：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># in sqlite:</span><br><span class="line">    article_obj&#x3D;models.Article.objects</span><br><span class="line">　　　　　　　　　　　　　　.filter(nid&#x3D;1)</span><br><span class="line">　　　　　　　　　　　　　　.extra(select&#x3D;&#123;&quot;standard_time&quot;:&quot;strftime(&#39;%%Y-%%m-%%d&#39;,create_time)&quot;&#125;)</span><br><span class="line">　　　　　　　　　　　　　　.values(&quot;standard_time&quot;,&quot;nid&quot;,&quot;title&quot;)</span><br><span class="line">    print(article_obj)</span><br><span class="line">    # &lt;QuerySet [&#123;&#39;title&#39;: &#39;MongoDb 入门教程&#39;, &#39;standard_time&#39;: &#39;2017-09-03&#39;, &#39;nid&#39;: 1&#125;]&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-2参数之where-tables"><a href="#4-2参数之where-tables" class="headerlink" title="4.2参数之where / tables"></a>4.2参数之<code>where</code> / <code>tables</code></h3><p>您可以使用<code>where</code>定义显式SQL <code>WHERE</code>子句 - 也许执行非显式连接。您可以使用<code>tables</code>手动将表添加到SQL <code>FROM</code>子句。</p>
<p><code>where</code>和<code>tables</code>都接受字符串列表。所有<code>where</code>参数均为“与”任何其他搜索条件。</p>
<p>举例来讲：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">queryResult&#x3D;models.Article</span><br><span class="line">　　　　　　　　　　　.objects.extra(where&#x3D;[&#39;nid in (1,3) OR title like &quot;py%&quot; &#39;,&#39;nid&gt;2&#39;])</span><br><span class="line">extra, 额外查询条件以及相关表，排序</span><br><span class="line">            </span><br><span class="line">                models.UserInfo.objects.filter(id__gt&#x3D;1)</span><br><span class="line">                models.UserInfo.objects.all() </span><br><span class="line">                # id name age ut_id</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">                models.UserInfo.objects.extra(self, select&#x3D;None, where&#x3D;None, params&#x3D;None, tables&#x3D;None, order_by&#x3D;None, select_params&#x3D;None)</span><br><span class="line">                # a. 映射</span><br><span class="line">                    # select </span><br><span class="line">                    # select_params&#x3D;None</span><br><span class="line">                    # select 此处 from 表</span><br><span class="line">                </span><br><span class="line">                # b. 条件</span><br><span class="line">                    # where&#x3D;None</span><br><span class="line">                    # params&#x3D;None,</span><br><span class="line">                    # select * from 表 where 此处</span><br><span class="line">                </span><br><span class="line">                # c. 表</span><br><span class="line">                    # tables</span><br><span class="line">                    # select * from 表,此处</span><br><span class="line">                    </span><br><span class="line">                # c. 排序</span><br><span class="line">                    # order_by&#x3D;None</span><br><span class="line">                    # select * from 表 order by 此处</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                models.UserInfo.objects.extra(</span><br><span class="line">                    select&#x3D;&#123;&#39;newid&#39;:&#39;select count(1) from app01_usertype where id&gt;%s&#39;&#125;,</span><br><span class="line">                    select_params&#x3D;[1,],</span><br><span class="line">                    where &#x3D; [&#39;age&gt;%s&#39;],</span><br><span class="line">                    params&#x3D;[18,],</span><br><span class="line">                    order_by&#x3D;[&#39;-age&#39;],</span><br><span class="line">                    tables&#x3D;[&#39;app01_usertype&#39;]</span><br><span class="line">                )</span><br><span class="line">                &quot;&quot;&quot;</span><br><span class="line">                select </span><br><span class="line">                    app01_userinfo.id,</span><br><span class="line">                    (select count(1) from app01_usertype where id&gt;1) as newid</span><br><span class="line">                from app01_userinfo,app01_usertype</span><br><span class="line">                where </span><br><span class="line">                    app01_userinfo.age &gt; 18</span><br><span class="line">                order by </span><br><span class="line">                    app01_userinfo.age desc</span><br><span class="line">                &quot;&quot;&quot;</span><br><span class="line">                </span><br><span class="line">                result &#x3D; models.UserInfo.objects.filter(id__gt&#x3D;1).extra(</span><br><span class="line">                    where&#x3D;[&#39;app01_userinfo.id &lt; %s&#39;],</span><br><span class="line">                    params&#x3D;[100,],</span><br><span class="line">                    tables&#x3D;[&#39;app01_usertype&#39;],</span><br><span class="line">                    order_by&#x3D;[&#39;-app01_userinfo.id&#39;],</span><br><span class="line">                    select&#x3D;&#123;&#39;uid&#39;:1,&#39;sw&#39;:&quot;select count(1) from app01_userinfo&quot;&#125;</span><br><span class="line">                )</span><br><span class="line">                print(result.query)</span><br><span class="line">                # SELECT (1) AS &quot;uid&quot;, (select count(1) from app01_userinfo) AS &quot;sw&quot;, &quot;app01_userinfo&quot;.&quot;id&quot;, &quot;app01_userinfo&quot;.&quot;name&quot;, &quot;app01_userinfo&quot;.&quot;age&quot;, &quot;app01_userinfo&quot;.&quot;ut_id&quot; FROM &quot;app01_userinfo&quot; , &quot;app01_usertype&quot; WHERE (&quot;app01_userinfo&quot;.&quot;id&quot; &gt; 1 AND (app01_userinfo.id &lt; 100)) ORDER BY (&quot;app01_userinfo&quot;.id) DESC</span><br><span class="line"># 在对象中加入字段</span><br><span class="line">ret&#x3D;models.Author.objects.all().filter(nid__gt&#x3D;1).extra(select&#x3D;&#123;&#39;n&#39;:&#39;select count(*) from app01_book where nid&gt;%s&#39;&#125;,select_params&#x3D;[1])</span><br><span class="line">print(ret[0].n)</span><br><span class="line">print(ret.query)</span><br><span class="line"># 给字段重命名</span><br><span class="line">ret&#x3D;models.Author.objects.all().filter(author_detail__telephone&#x3D;132234556).extra(select&#x3D;&#123;&#39;bb&#39;:&quot;app01_authordatail.telephone&quot;&#125;).values(&#39;bb&#39;)</span><br><span class="line">print(ret)</span><br><span class="line">print(ret.query)</span><br></pre></td></tr></table></figure>

<h2 id="五-原生sql"><a href="#五-原生sql" class="headerlink" title="五 原生sql"></a>五 原生sql</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.db import connection, connections</span><br><span class="line"></span><br><span class="line">cursor &#x3D; connection.cursor() # connection&#x3D;default数据</span><br><span class="line">cursor &#x3D; connections[&#39;db2&#39;].cursor()</span><br><span class="line"></span><br><span class="line">cursor.execute(&quot;&quot;&quot;SELECT * from auth_user where id &#x3D; %s&quot;&quot;&quot;, [1])</span><br><span class="line"></span><br><span class="line">row &#x3D; cursor.fetchone()</span><br><span class="line">row &#x3D; cursor.fetchall()</span><br><span class="line">ret &#x3D; models.Author.objects.raw(&#39;select * from app01_author where nid&gt;1&#39;)</span><br><span class="line">print(ret)</span><br><span class="line">for i in ret:</span><br><span class="line">    print(i)</span><br><span class="line">print(ret.query)</span><br><span class="line"># 会把book的字段放到author对象中</span><br><span class="line">ret &#x3D; models.Author.objects.raw(&#39;select * from app01_book where nid&gt;1&#39;)</span><br><span class="line">print(ret)</span><br><span class="line">for i in ret:</span><br><span class="line">    print(i.price)</span><br><span class="line">    print(type(i))</span><br></pre></td></tr></table></figure>

<h2 id="六-整体插入"><a href="#六-整体插入" class="headerlink" title="六 整体插入"></a>六 整体插入</h2><p>创建对象时，尽可能使用bulk_create()来减少SQL查询的数量。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entry.objects.bulk_create([</span><br><span class="line">    Entry(headline&#x3D;&quot;Python 3.0 Released&quot;),</span><br><span class="line">    Entry(headline&#x3D;&quot;Python 3.1 Planned&quot;)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>…更优于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entry.objects.create(headline&#x3D;&quot;Python 3.0 Released&quot;)</span><br><span class="line">Entry.objects.create(headline&#x3D;&quot;Python 3.1 Planned&quot;)</span><br></pre></td></tr></table></figure>

<p>注意该方法有很多注意事项，所以确保它适用于你的情况。</p>
<p>这也可以用在ManyToManyFields中，所以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my_band.members.add(me, my_friend)</span><br></pre></td></tr></table></figure>

<p>…更优于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my_band.members.add(me)</span><br><span class="line">my_band.members.add(my_friend)</span><br></pre></td></tr></table></figure>

<p>…其中Bands和Artists具有多对多关联。</p>
<h2 id="七-事务操作"><a href="#七-事务操作" class="headerlink" title="七 事务操作"></a>七 事务操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 事务操作</span><br><span class="line">from django.db import transaction</span><br><span class="line">with transaction.atomic():</span><br></pre></td></tr></table></figure>

<h2 id="八-defer和only"><a href="#八-defer和only" class="headerlink" title="八 defer和only"></a>八 defer和only</h2><p>defer(‘id’,’name’):取出对象，字段除了id和name都有<br>only(‘id’,’name’):取的对象，只有id和name<br>如果点，依然能点出其它列，但是不要点了，因为取没有的列，会再次查询数据库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ret=models.Author.objects.only(<span class="string">&#x27;nid&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ret:</span><br><span class="line">    <span class="comment"># 查询不在的字段，会再次查询数据库，造成数据库压力大</span></span><br><span class="line">    print(i.name)</span><br></pre></td></tr></table></figure>





<h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#### 验证一</span></span><br><span class="line">    <span class="comment"># models.Publish.objects.all()  # 不会查询</span></span><br><span class="line">    <span class="comment"># res = models.Publish.objects.all()  # 不会查询</span></span><br><span class="line">    <span class="comment"># print(res)  # 会查询</span></span><br><span class="line">    <span class="comment"># time.sleep(20)</span></span><br><span class="line">    <span class="comment"># print(res) # 还会重新查询</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 验证二：</span></span><br><span class="line">    <span class="comment"># res = models.Publish.objects.all()  # 不会查询</span></span><br><span class="line">    <span class="comment"># print([a.name for a in res])</span></span><br><span class="line">    <span class="comment"># time.sleep(20)</span></span><br><span class="line">    <span class="comment"># print([a.city for a in res]) # 不会再次查，数据是老数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 验证三：</span></span><br><span class="line">    print([a.name <span class="keyword">for</span> a <span class="keyword">in</span> models.Publish.objects.all()]) <span class="comment"># 会查询</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print([a.city <span class="keyword">for</span> a <span class="keyword">in</span> models.Publish.objects.all()]) <span class="comment"># 会重新查询</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这种操作叫“提交”查询结果集，是推荐的方式，最小化SQL访问</span><br><span class="line">res = models.Publish.objects.all()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）切片和索引不会命中缓存</span><br><span class="line">不会建立缓存：简单的打印QuerySetprint(res)，返回只是全部查询集的一个切片。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）键值</span><br><span class="line"> print([a.city <span class="keyword">for</span> a <span class="keyword">in</span> res])  这种情况不属于切片也不属于索引，所以在有查询结果集（res） 的情况下，不会再次查，数据是老数据</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）不提交查询结果集 （res=xxx）</span><br><span class="line">每次都重新查询</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>13-Django进阶-模型-choices参数和多对多创建</title>
    <url>/posts/36762.html</url>
    <content><![CDATA[<p>choices\多对多关系创建\MTV\MVC</p>
<a id="more"></a>

<h2 id="1、choices参数-数据库字段设计常见"><a href="#1、choices参数-数据库字段设计常见" class="headerlink" title="1、choices参数(数据库字段设计常见)"></a>1、choices参数(数据库字段设计常见)</h2><p>针对可以列举完全的可能性字段，要如何存储？例如性别、学历、工作经验、招聘来源。<br>一般会采用choices参数。</p>
<p>我们先在models.py文件中创建表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    username = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line">    <span class="comment"># 性别字段</span></span><br><span class="line">    <span class="comment"># 字段类型为数字类型：</span></span><br><span class="line">    gender_choices = (</span><br><span class="line">        (<span class="number">1</span>,<span class="string">&#x27;male&#x27;</span>),</span><br><span class="line">        (<span class="number">2</span>,<span class="string">&#x27;female&#x27;</span>),</span><br><span class="line">        (<span class="number">3</span>,<span class="string">&#x27;other&#x27;</span>),</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 该gender字段存的还是数字，但是如果存的数字在上面元组列举的范围之内，那么可以方便获取到数字对应的真正的内容</span></span><br><span class="line">    gender = models.IntegerField(choices = gender_choices)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 字段类型为字符类型：</span></span><br><span class="line">    score_choices = (</span><br><span class="line">        (<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;优秀&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;良好&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;及格&#x27;</span>),</span><br><span class="line">    )</span><br><span class="line">    score = models.CharField(choices = score_choices)</span><br></pre></td></tr></table></figure>

<p>然后执行数据库迁移命令：<br>makemigrations<br>migrate</p>
<p>然后在tests.py文件中进行测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&quot;day66.settings&quot;</span>)</span><br><span class="line">    <span class="keyword">import</span> django</span><br><span class="line">    django.setup()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line">    <span class="comment"># 存数据，gender_choices中没有列举出来的数字也能存进去</span></span><br><span class="line">    <span class="comment"># models.User.objects.create(username=&#x27;nimo&#x27;,age=18,gender=1)</span></span><br><span class="line">    <span class="comment"># models.User.objects.create(username=&#x27;nimo1&#x27;,age=28,gender=2)</span></span><br><span class="line">    <span class="comment"># models.User.objects.create(username=&#x27;nimo2&#x27;,age=38,gender=3)</span></span><br><span class="line">    <span class="comment"># models.User.objects.create(username=&#x27;nimo3&#x27;,age=48,gender=4)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取数据</span></span><br><span class="line">    user_obj = models.User.objects.filter(pk=<span class="number">1</span>).first()</span><br><span class="line">    user_obj1 = models.User.objects.filter(pk=<span class="number">4</span>).first()</span><br><span class="line">    <span class="comment"># 对于choices参数的字段，如果要获取对应信息，固定写法：get_字段名_display()</span></span><br><span class="line">    print(user_obj.get_gender_display())</span><br><span class="line">    <span class="comment"># male</span></span><br><span class="line">    print(user_obj1.get_gender_display())</span><br><span class="line">    <span class="comment"># 4    针对这种没有对应关系的数据，直接返回字段的值</span></span><br></pre></td></tr></table></figure>

<h2 id="2、MTV与MVC模型"><a href="#2、MTV与MVC模型" class="headerlink" title="2、MTV与MVC模型"></a>2、MTV与MVC模型</h2><p>Django号称是MTV模型：models、templates、views<br>Django本质也是MVC模型：models、views、controller<br>VUE框架是MVVM模型</p>
<h2 id="3、多对多关系的三种创建方式"><a href="#3、多对多关系的三种创建方式" class="headerlink" title="3、多对多关系的三种创建方式"></a>3、多对多关系的三种创建方式</h2><h3 id="全自动：利用orm自动帮我们创建第三张关系表"><a href="#全自动：利用orm自动帮我们创建第三张关系表" class="headerlink" title="全自动：利用orm自动帮我们创建第三张关系表"></a><strong>全自动：利用orm自动帮我们创建第三张关系表</strong></h3><p>优点：一条命令就可以创建外键关系，方便，orm还提供操作第三张关系表的方法<br>缺点：第三张关系表的拓展性极差，无法额外添加字段</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    <span class="comment"># 创建多对多外键关系</span></span><br><span class="line">    authors = models.ManyToManyField(to=<span class="string">&#x27;Author&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br></pre></td></tr></table></figure>

<h3 id="纯手动"><a href="#纯手动" class="headerlink" title="纯手动"></a><strong>纯手动</strong></h3><p>优点：中间关系表可拓展，可增加字段<br>缺点：自己写代码，就没有正向反向的概念了，也就无法使用orm提供的简单的方法，例如add\remove，不建议该方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book2Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    book_id = models.ForeignKey(to=<span class="string">&#x27;Book&#x27;</span>)</span><br><span class="line">    author_id = models.ForeignKey(to=<span class="string">&#x27;Author&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="半自动"><a href="#半自动" class="headerlink" title="半自动"></a><strong>半自动</strong></h3><p>优点：中间关系表可拓展，也可以通过orm操作中间关系表(支持orm的正反向查询)<br>缺点：没法使用orm的add,set,remove,clear这四个方法<br><strong>为了拓展性更高，我们一般采用半自动</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    <span class="comment"># through=&#x27;Book2Author&#x27;就是告诉orm，中间表用我自己创建的，不需要再自动为我创建了。</span></span><br><span class="line">    <span class="comment"># through_fields指定两张表的外键字段：</span></span><br><span class="line">    <span class="comment">## 第一个参数表示从第三张表查当前表需要通过的字段book，第二个参数表示从第三张表查另一张表需要通过的字段author</span></span><br><span class="line">    <span class="comment">## through_fields先后顺序，通过第三张表查询对应的表，需要用到哪个字段，就把哪个字段放前面</span></span><br><span class="line">    <span class="comment">## 简化判断，当前在谁身上建立外键，就把关联字段放在前面。</span></span><br><span class="line">    authors = models.ManyToManyField(to=<span class="string">&#x27;Author&#x27;</span>,</span><br><span class="line">                                     through=<span class="string">&#x27;Book2Author&#x27;</span>,</span><br><span class="line">                                     through_fields=(<span class="string">&#x27;book&#x27;</span>,<span class="string">&#x27;author&#x27;</span>)</span><br><span class="line">                                     )</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line"><span class="comment">#    books = models.ManyToManyField(to=&#x27;Author&#x27;,</span></span><br><span class="line"><span class="comment">#                                     through=&#x27;Book2Author&#x27;,</span></span><br><span class="line"><span class="comment">#                                     through_fields=(&#x27;author&#x27;,&#x27;book&#x27;)</span></span><br><span class="line"><span class="comment">#                                     )</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book2Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    book = models.ForeignKey(to=<span class="string">&#x27;Book&#x27;</span>)</span><br><span class="line">    author = models.ForeignKey(to=<span class="string">&#x27;Author&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>14-Ajax-批量插入数据-分页</title>
    <url>/posts/18955.html</url>
    <content><![CDATA[<p>Ajax/Django自带的序列化组件JsonResponse</p>
<a id="more"></a>

<h2 id="0-同步异步补充"><a href="#0-同步异步补充" class="headerlink" title="0. 同步异步补充"></a>0. 同步异步补充</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">同步就是整个处理过程顺序执行，当各个过程都执行完毕，并返回结果。是一种线性执行的方式，执行的流程不能跨越。一般用于流程性比较强的程序，比如用户登录，需要对用户验证完成后才能登录系统。</span><br><span class="line"></span><br><span class="line">异步则是只是发送了调用的指令，调用者无需等待被调用的方法完全执行完毕；而是继续执行下面的流程。是一种并行处理的方式，不必等待一个程序执行完，可以执行其它的任务，比如页面数据加载过程，不需要等所有数据获取后再显示页面。</span><br><span class="line"></span><br><span class="line">他们的区别就在于一个需要等待，一个不需要等待，在部分情况下，我们的项目开发中都会优先选择不需要等待的异步交互方式，比如日志记录就可以使用异步方式进行保存。</span><br></pre></td></tr></table></figure>



<h2 id="1、Ajax简介"><a href="#1、Ajax简介" class="headerlink" title="1、Ajax简介"></a>1、Ajax简介</h2><p><strong>异步提交，局部刷新。</strong><br>示例：github注册页面，可以动态获取用户名实时跟后端确认并实时展示到前端(局部刷新)</p>
<p><strong>朝后端发送请求的方式有如下几种：</strong><br>1、浏览器地址栏直接输入url回车(GET请求)<br>2、a标签href属性(GET请求)<br>3、form表单(GET请求/POST请求) - 所有数据拿到再一起提交给后端<br>4、<strong>Ajax</strong>(GET请求/POST请求) - 局部刷新</p>
<p>Ajax-asynchronous JavaScript and XML，翻译成中文就是异步的JavaScript和XML，使用JavaScript语法和服务器进行异步交互，传输XML数据。</p>
<p>Ajax不是新的编程语言，而是一种使用现有标准的新方法(就类似于装饰器的概念)。<br>Ajax最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。Ajax不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。</p>
<p><strong>我们现在只学习jQuery封装之后的Ajax版本，所以前端页面在使用Ajax时要确保导入了jQuery</strong>。(并不只有jQuery框架能够实现Ajax，其他框架也可以，原理一样。)</p>
<p><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/Dominic-Ji/p/9234099.html">AJAX - JasonJi - 博客园www.cnblogs.com<img src="https://pic3.zhimg.com/v2-130f82d81e682faf4e010a97aa9fba92_180x120.jpg" alt="图标"></a></p>
<h2 id="2、Ajax基本语法"><a href="#2、Ajax基本语法" class="headerlink" title="2、Ajax基本语法"></a>2、Ajax基本语法</h2><p><strong>示例</strong>：<br>页面上三个input框：在前两个框中输入数字，点击按钮，朝后端发送Ajax请求，后端计算出结果再返回给前端动态展示到第三个框中(页面不准刷新)</p>
<p>下面是Ajax最基本的语法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;d1&quot;</span>&gt;</span>+</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;d2&quot;</span>&gt;</span>=</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;d3&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>计算<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 先给计算按钮绑定一个点击事件</span></span></span><br><span class="line"><span class="javascript">    $(<span class="string">&#x27;#btn&#x27;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 朝后端发送ajax请求</span></span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 1、指定朝哪个后端发送ajax请求，不写的话，默认就是朝当前地址提交数据</span></span></span><br><span class="line"><span class="javascript">            url:<span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 2、请求方式,不指定的话默认就是get，都是小写</span></span></span><br><span class="line"><span class="javascript">            type:<span class="string">&#x27;post&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 3、数据</span></span></span><br><span class="line">            &#123;#测试数据看后端能否接收到：#&#125;</span><br><span class="line">            &#123;#data:&#123;&#x27;username&#x27;:&#x27;hello&#x27;,&#x27;password&#x27;:123&#125;,#&#125;</span><br><span class="line">            &#123;#接收前端的数据：#&#125;</span><br><span class="line"><span class="javascript">            data:&#123;<span class="string">&#x27;i1&#x27;</span>:$(<span class="string">&#x27;#d1&#x27;</span>).val(),</span></span><br><span class="line"><span class="javascript">                  <span class="string">&#x27;i2&#x27;</span>:$(<span class="string">&#x27;#d2&#x27;</span>).val()</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            <span class="comment">// 4、回调函数,当后端给你返回结果的时候会自动触发，args接受后端的返回结果</span></span></span><br><span class="line"><span class="javascript">            success:<span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                 <span class="comment">// 异步回调处理机制，后端无论返回什么都只会被回调函数接收，而不再影响这个浏览器页面了。</span></span></span><br><span class="line">                &#123;#alert(args)#&#125;</span><br><span class="line"><span class="javascript">                <span class="comment">// 通过DOM操作动态渲染到第三个input框里</span></span></span><br><span class="line"><span class="javascript">                $(<span class="string">&#x27;#d3&#x27;</span>).val(args)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;# 后端如果用HTTPResponse返回数据，回调函数不会自动帮你反序列化</span><br><span class="line"># 解决方式：1、前端利用JSON.parse()，或者2、Ajax里面配置一个datatype参数</span><br><span class="line"></span><br><span class="line">&#123;# 如果后端用的是JsonResponse返回数据，回调函数会自动帮你反序列化#&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、前后端传输数据编码格式-contentType"><a href="#3、前后端传输数据编码格式-contentType" class="headerlink" title="3、前后端传输数据编码格式(contentType)"></a>3、前后端传输数据编码格式(contentType)</h2><p>我们主要研究post请求数据的编码格式(get请求的话是直接放在url后面的，能直接看到get请求的编码格式)</p>
<p><strong>可以朝后端发送post请求的方式：</strong><br>form表单<br>Ajax请求</p>
<p><strong>前后端传输数据的编码格式：</strong><br>urlencoded<br>formdata<br>application/json</p>
<blockquote>
<p>form表单</p>
</blockquote>
<p><strong>form表单默认的编码格式：</strong><br><strong>Content-Type:</strong> application/x-www-form-urlencoded(从请求头RequestHeader中可以找到)<br>数据格式为：username=jack&amp;username=132</p>
<p>Django后端针对符合urlencoded编码格式的数据**(类似于username=jack&amp;username=132)**都会自动帮你解析封装到request.POST中；<br>如果我们将编码格式改成了formdata(&lt;**form action=”” method=”post” enctype=”multipart/form-data”**&gt;),那么form表单既可以发送普通键值对也可以发送文件了，Django后端针对普通的键值对会解析到request.POST中，但是文件会被解析到request.FILES中</p>
<p>urlencoded编码：<br>解析到request.POST中<br>form-data编码：<br>普通键值对解析到request.POST中<br>文件解析到request.FILES中</p>
<p>form表单无法发送json格式数据，如果要发送json数据，需要用到Ajax。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>file: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-danger&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span> <span class="attr">id</span>=<span class="string">&quot;d1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">&#x27;#d1&#x27;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">            url:<span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            type:<span class="string">&#x27;post&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            data:&#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;jack&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">12</span>&#125;,</span></span><br><span class="line"><span class="javascript">            success:<span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>views.py文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        print(request.POST)</span><br><span class="line">        <span class="comment"># &lt;QueryDict: &#123;&#x27;username&#x27;: [&#x27;jack&#x27;, &#x27;123&#x27;]&#125;&gt;</span></span><br><span class="line">        print(request.FILES)</span><br><span class="line">        <span class="comment"># &lt;MultiValueDict: &#123;&#x27;file&#x27;: [&lt;TemporaryUploadedFile: WechatIMG261.jpeg (image/jpeg)&gt;]&#125;&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;index.html&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="4、Ajax发送json格式数据-向后端发数据"><a href="#4、Ajax发送json格式数据-向后端发数据" class="headerlink" title="4、Ajax发送json格式数据(向后端发数据)"></a>4、Ajax发送json格式数据(向后端发数据)</h2><p>Ajax发送json格式数据需要注意：<br>1、contentType参数:’application/json’； 指定发送到后端的数据格式</p>
<p>2、数据是真正的json格式数据<br>3、Django后端不会帮你处理json格式数据，需要我们通过request.body(<strong>二进制字节</strong>)获取并处理</p>
<p>前后端传输数据的时候一定要确保编码格式跟数据真正的格式是一致的。</p>
<p>可以看到请求头中数据类型已经变成了json：<br><strong>Content-Type: application/json</strong><br>后端拿到的是json格式的数据：<br>{“username”:”jack”,”age”:15}</p>
<p>ab_json.html页面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-danger&quot;</span> <span class="attr">id</span>=<span class="string">&quot;d1&quot;</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;#写一个朝后端发送Ajax请求的操作，数据是json格式的#&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">&#x27;#d1&#x27;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">            url:<span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            type:<span class="string">&#x27;post&#x27;</span>,</span></span><br><span class="line">            &#123;#data:&#123;&#x27;username&#x27;:&#x27;jack&#x27;,&#x27;age&#x27;:15&#125;,#&#125;</span><br><span class="line"><span class="javascript">            data:<span class="built_in">JSON</span>.stringify(&#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;jack&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">15</span>&#125;),</span></span><br><span class="line"><span class="javascript">            dataType:<span class="string">&#x27;JSON&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            contentType:<span class="string">&#x27;application/json&#x27;</span>, <span class="comment">// 指定告诉后端的编码格式</span></span></span><br><span class="line"><span class="javascript">            success:<span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span></span><br><span class="line">                                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>views.py文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ab_json</span>(<span class="params">request</span>):</span></span><br><span class="line">    print(request.is_ajax())  <span class="comment"># 用来判断当前请求是否是ajax请求</span></span><br><span class="line">    <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">    print(request.POST)</span><br><span class="line">    <span class="comment"># &lt;QueryDict: &#123;&#125;&gt;   这个POST中没有拿到数据，因为ajax发送的是json格式数据，不在POST中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Django对json格式的数据不会做任何处理，需要我们手动处理</span></span><br><span class="line">    print(request.body)</span><br><span class="line">    <span class="comment"># b&#x27;&#123;&quot;username&quot;:&quot;jack&quot;,&quot;age&quot;:15&#125;&#x27;   # 是二进制格式的json数据</span></span><br><span class="line">    <span class="comment"># json_str = request.body.decode(&#x27;utf-8&#x27;)</span></span><br><span class="line">    <span class="comment"># json_dict = json.loads(json_str)</span></span><br><span class="line"></span><br><span class="line">    json_dict = json.loads(request.body)</span><br><span class="line">    <span class="comment"># json.loads内部支持自动解码再反序列化，当你传入的是二进制数据，内部会自动帮你转成字符串类型，然后再反序列化成字典格式。</span></span><br><span class="line">    print(json_dict)</span><br><span class="line">    <span class="comment"># &#123;&#x27;username&#x27;: &#x27;jack&#x27;, &#x27;age&#x27;: 15&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;ab_json.html&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="5、Ajax发送文件"><a href="#5、Ajax发送文件" class="headerlink" title="5、Ajax发送文件"></a>5、Ajax发送文件</h2><p>Ajax发送文件需要注意：<br>1、需要借助js内置对象<strong>Formdata</strong>，既可以添加普通键值对，又添加文件对象<br>2、需要指定两个关键性的参数：<strong>contentType:false</strong> 和  <strong>processData:false</strong><br>3、Django后端能直接识别到formdata对象，并且能够将内部的普通键值对自动解析封装到<strong>request.POST</strong>，将文件数据自动封装到<strong>request.FILES中</strong></p>
<p>ab_file.html页面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>username:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;d1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>password:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;d2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;d3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-info&quot;</span> <span class="attr">id</span>=<span class="string">&quot;d4&quot;</span>&gt;</span>click me <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 写一个Ajax请求操作：点击按钮朝后端发送普通键值对和文件数据</span></span></span><br><span class="line"><span class="javascript">    $(<span class="string">&#x27;#d4&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 1.先创建一个FormData内置对象：</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> formDataObj = <span class="keyword">new</span> FormData();</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 2.给FormData对象添加普通键值对</span></span></span><br><span class="line"><span class="javascript">        formDataObj.append(<span class="string">&#x27;username&#x27;</span>,$(<span class="string">&#x27;#d1&#x27;</span>).val());</span></span><br><span class="line"><span class="javascript">        formDataObj.append(<span class="string">&#x27;password&#x27;</span>,$(<span class="string">&#x27;#d2&#x27;</span>).val());</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 3.给FormData对象添加文件对象</span></span></span><br><span class="line"><span class="javascript">        formDataObj.append(<span class="string">&#x27;myfile&#x27;</span>,$(<span class="string">&#x27;#d3&#x27;</span>)[<span class="number">0</span>].files[<span class="number">0</span>])</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 4.将对象基于Ajax发送给后端</span></span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">            url:<span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            type:<span class="string">&#x27;post&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            data:formDataObj,  <span class="comment">// 直接将FormData对象放在data后面即可</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="comment">// Ajax发送文件必须要指定的两个参数</span></span></span><br><span class="line"><span class="javascript">            contentType:<span class="literal">false</span>,  <span class="comment">// 不需要使用任何编码，Django后端能够自动识别formdata对象</span></span></span><br><span class="line"><span class="javascript">            processData:<span class="literal">false</span>,  <span class="comment">// 告诉浏览器不要对数据进行任何处理，直接发给后端就行</span></span></span><br><span class="line">            </span><br><span class="line"><span class="javascript">            success:<span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>views.py文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ab_file</span>(<span class="params">request</span>):</span></span><br><span class="line">    print(request.is_ajax())</span><br><span class="line">    <span class="keyword">if</span> request.is_ajax():</span><br><span class="line">        <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">            print(request.POST)</span><br><span class="line">            print(request.FILES)</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;ab_file.html&#x27;</span>)</span><br><span class="line"><span class="comment"># Django后端能自动识别formdata对象并封装解析</span></span><br></pre></td></tr></table></figure>

<h2 id="补充0-后端返回-回调反序列化"><a href="#补充0-后端返回-回调反序列化" class="headerlink" title="补充0: 后端返回 回调反序列化"></a>补充0: 后端返回 回调反序列化</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 后端如果用HTTPResponse返回数据，回调函数不会自动帮你反序列化</span></span><br><span class="line"><span class="comment"># 解决方式：1、前端利用JSON.parse()，或者2、Ajax里面配置一个datatype参数</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="comment"># 如果后端用的是JsonResponse返回数据，回调函数会自动帮你反序列化#&#125;</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $(<span class="string">&#x27;#d1&#x27;</span>).click(function () &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            type:<span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">                        data: &#123;&#125;,</span><br><span class="line">              <span class="comment"># data:JSON.stringify(&#123;&#x27;username&#x27;:&#x27;jack&#x27;,&#x27;age&#x27;:15&#125;),  // 如果要发送Json数据需要转换；默认发送过去是键值对</span></span><br><span class="line">            dataType:<span class="string">&#x27;JSON&#x27;</span>,  // 反序列化</span><br><span class="line">            contentType:<span class="string">&#x27;application/json&#x27;</span>, // 指定告诉后端的编码格式</span><br><span class="line">            success:function (args) &#123;</span><br><span class="line">                                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h2 id="补充1-如何利用ajax发送整个表单数据"><a href="#补充1-如何利用ajax发送整个表单数据" class="headerlink" title="补充1: 如何利用ajax发送整个表单数据"></a>补充1: 如何利用ajax发送整个表单数据</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    $(<span class="string">&#x27;#id_commit&#x27;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 发送ajax请求  既包含普通对象又包含文件</span></span><br><span class="line">        <span class="keyword">let</span> formDataObj = <span class="keyword">new</span> FormData()</span><br><span class="line">        <span class="comment">// 1. 添加普通键值对</span></span><br><span class="line">        &#123;#console.log($(&#x27;#myform&#x27;).serializeArray())#&#125;</span><br><span class="line">        &#123;#)[&#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;]#&#125; // 只包含普通键值对</span><br><span class="line">        $.each($(<span class="string">&#x27;#myform&#x27;</span>).serializeArray(), <span class="function"><span class="keyword">function</span> (<span class="params">index,obj</span>)</span>&#123;</span><br><span class="line">            &#123;#console.log(index, obj)#&#125;</span><br><span class="line">            formDataObj.append(obj.name, obj.value)</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 添加文件数据</span></span><br><span class="line">        formDataObj.append(<span class="string">&#x27;avatar&#x27;</span>, $(<span class="string">&#x27;#myfile&#x27;</span>)[<span class="number">0</span>].files[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送Ajax请求</span></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            type:<span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">            data:formDataObj,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 需要指定两个关键性的参数</span></span><br><span class="line">            contentType: <span class="literal">false</span>,</span><br><span class="line">            processData: <span class="literal">false</span>,</span><br><span class="line">            </span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">args</span>)</span>&#123;</span><br><span class="line">                alert(args)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="补充2-刷新页面方式"><a href="#补充2-刷新页面方式" class="headerlink" title="补充2: 刷新页面方式"></a>补充2: 刷新页面方式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 删除后需要刷新用户显示页面</span><br><span class="line">&#x2F;&#x2F; 方式1：</span><br><span class="line">&#123;#window.location.reload()#&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 方式2：利用DOM操作动态刷新,通过DOM操作标签查找将已删除的那行数据给移除</span><br><span class="line">&#x2F;&#x2F; 即要删除tr标签所在的那一行，tr标签是删除标签的父标签的父标签</span><br><span class="line">currentBtn.parent().parent().remove()</span><br></pre></td></tr></table></figure>

<h2 id="补充3-form表单提交的坑"><a href="#补充3-form表单提交的坑" class="headerlink" title="补充3: form表单提交的坑"></a>补充3: form表单提交的坑</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    密码: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">submit 绑定Ajax 请求会提交两次</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>补充4：模板</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 先给计算按钮绑定一个点击事件</span></span><br><span class="line">    $(<span class="string">&#x27;#btn&#x27;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 朝后端发送ajax请求</span></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            <span class="comment">// 1、指定朝哪个后端发送ajax请求，不写的话，默认就是朝当前地址提交数据</span></span><br><span class="line">            url:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="comment">// 2、请求方式,不指定的话默认就是get，都是小写</span></span><br><span class="line">            type:<span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">            <span class="comment">// 3、数据</span></span><br><span class="line">            &#123;#测试数据看后端能否接收到：#&#125;</span><br><span class="line">            data: <span class="built_in">JSON</span>.stringify(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;jason&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>&#125;),  <span class="comment">// 如果要传字典需要序列化传给后端；否则传过去的格式就是b&#x27;name=jason&amp;age=18&#x27;</span></span><br><span class="line">            &#123;#接收前端的数据：#&#125;</span><br><span class="line">            contentType:<span class="string">&#x27;application/json&#x27;</span>, <span class="comment">// 指定告诉后端的编码格式</span></span><br><span class="line">              dataType: <span class="string">&#x27;JSON&#x27;</span>,  <span class="comment">// 反序列化</span></span><br><span class="line">            <span class="comment">// 4、回调函数,当后端给你返回结果的时候会自动触发，args接受后端的返回结果</span></span><br><span class="line">            success:<span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">                 <span class="comment">// 异步回调处理机制，后端无论返回什么都只会被回调函数接收，而不再影响这个浏览器页面了。</span></span><br><span class="line">                &#123;#alert(args)#&#125;</span><br><span class="line">                <span class="comment">// 通过DOM操作动态渲染到第三个input框里</span></span><br><span class="line">                $(<span class="string">&#x27;#d3&#x27;</span>).val(args)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>





<h2 id="6、Django自带的序列化组件-drf做铺垫"><a href="#6、Django自带的序列化组件-drf做铺垫" class="headerlink" title="6、Django自带的序列化组件(drf做铺垫)"></a>6、Django自带的序列化组件(drf做铺垫)</h2><p>要使用sqlite3需要安装sqlite3的驱动。</p>
<p>序列化的意义：<br>工作中大部分项目都是前后端分离的，也就意味着我们无法直接使用Django提供的模板语法来实现前后端数据交互，所以这时我们需要将数据处理成大家公共的都能处理的格式(json格式)，一般情况下都是处理成列表套字典的形式[{},{}]；<br>针对数据的封装很繁琐，有现成的模块可以完成：<br>1、Django内置的模块<br>2、第三方模块：Django restframework</p>
<p>我们先创建一张表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    username = models.CharField(max_length=<span class="number">32</span>,verbose_name=<span class="string">&#x27;用户名&#x27;</span>)</span><br><span class="line">    age = models.IntegerField(verbose_name=<span class="string">&#x27;年龄&#x27;</span>)</span><br><span class="line">    gender_choices = (</span><br><span class="line">        (<span class="number">1</span>,<span class="string">&#x27;male&#x27;</span>),</span><br><span class="line">        (<span class="number">2</span>,<span class="string">&#x27;female&#x27;</span>),</span><br><span class="line">        (<span class="number">3</span>,<span class="string">&#x27;others&#x27;</span>),</span><br><span class="line">    )</span><br><span class="line">    gender = models.IntegerField(choices = gender_choices,verbose_name=<span class="string">&#x27;性别&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>执行数据库迁移命令后手动添加测试数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into app01_user(username, age, gender) VALUES(&#39;jack&#39;,12,1);</span><br><span class="line">insert into app01_user(username, age, gender) VALUES(&#39;nimo&#39;,22,2);</span><br><span class="line">insert into app01_user(username, age, gender) VALUES(&#39;ross&#39;,32,3);</span><br><span class="line">insert into app01_user(username, age, gender) VALUES(&#39;tank&#39;,42,4);</span><br></pre></td></tr></table></figure>

<p><strong>需求：前端获取到后端用户表中所有数据，要求是列表套字典格式。</strong></p>
<p>views.py文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ab_ser</span>(<span class="params">request</span>):</span></span><br><span class="line">    user_queryset = models.User.objects.all()</span><br><span class="line">    user_list = []</span><br><span class="line">    <span class="keyword">for</span> user_obj <span class="keyword">in</span> user_queryset:</span><br><span class="line">        tmp = &#123;</span><br><span class="line">            <span class="string">&#x27;pk&#x27;</span>:user_obj.pk,</span><br><span class="line">            <span class="string">&#x27;username&#x27;</span>:user_obj.username,</span><br><span class="line">            <span class="string">&#x27;age&#x27;</span>:user_obj.age,</span><br><span class="line">            <span class="string">&#x27;gender&#x27;</span>:user_obj.get_gender_display()</span><br><span class="line">        &#125;</span><br><span class="line">        user_list.append(tmp)</span><br><span class="line">    <span class="comment"># return render(request,&#x27;ab_ser.html&#x27;,locals())</span></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(user_list,safe=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">前端获取的数据：</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">&#123;&quot;pk&quot;: 1, &quot;username&quot;: &quot;jack&quot;, &quot;age&quot;: 12, &quot;gender&quot;: &quot;male&quot;&#125;, </span></span><br><span class="line"><span class="string">&#123;&quot;pk&quot;: 2, &quot;username&quot;: &quot;nimo&quot;, &quot;age&quot;: 22, &quot;gender&quot;: &quot;female&quot;&#125;, </span></span><br><span class="line"><span class="string">&#123;&quot;pk&quot;: 3, &quot;username&quot;: &quot;ross&quot;, &quot;age&quot;: 32, &quot;gender&quot;: &quot;others&quot;&#125;, </span></span><br><span class="line"><span class="string">&#123;&quot;pk&quot;: 4, &quot;username&quot;: &quot;tank&quot;, &quot;age&quot;: 42, &quot;gender&quot;: 4&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">前后端分离的项目中，后端开发只需要写代码将数据处理好能够序列化返回给前端即可(返回特定数据)，再写一个接口文档告诉前端每个字段的含义</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>使用序列化模块的方式：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接下来我们用序列化模块尝试：</span></span><br><span class="line"><span class="comment"># (封装程度更高)</span></span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.core <span class="keyword">import</span> serializers</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ab_ser</span>(<span class="params">request</span>):</span></span><br><span class="line">    user_queryset = models.User.objects.all()</span><br><span class="line">    <span class="comment"># 序列化</span></span><br><span class="line">    res = serializers.serialize(<span class="string">&#x27;json&#x27;</span>,user_queryset)</span><br><span class="line">    <span class="comment"># 会自动将数据变成json格式的字符串，并且内部非常全面</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(res)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">&#123;&quot;model&quot;: &quot;app01.user&quot;, </span></span><br><span class="line"><span class="string">    &quot;pk&quot;: 1, &quot;fields&quot;: &#123;&quot;username&quot;: &quot;jack&quot;, &quot;age&quot;: 12, &quot;gender&quot;: 1&#125;&#125;, </span></span><br><span class="line"><span class="string">&#123;&quot;model&quot;: &quot;app01.user&quot;, </span></span><br><span class="line"><span class="string">    &quot;pk&quot;: 2, &quot;fields&quot;: &#123;&quot;username&quot;: &quot;nimo&quot;, &quot;age&quot;: 22, &quot;gender&quot;: 2&#125;&#125;, </span></span><br><span class="line"><span class="string">&#123;&quot;model&quot;: &quot;app01.user&quot;, </span></span><br><span class="line"><span class="string">    &quot;pk&quot;: 3, &quot;fields&quot;: &#123;&quot;username&quot;: &quot;ross&quot;, &quot;age&quot;: 32, &quot;gender&quot;: 3&#125;&#125;, </span></span><br><span class="line"><span class="string">&#123;&quot;model&quot;: &quot;app01.user&quot;, </span></span><br><span class="line"><span class="string">    &quot;pk&quot;: 4, &quot;fields&quot;: &#123;&quot;username&quot;: &quot;tank&quot;, &quot;age&quot;: 42, &quot;gender&quot;: 4&#125;&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string"># 后端开发写接口就是利用序列化组件渲染数据，然后写一个接口文档，将需要注意的都标注，例如这里的gender字段数字所对应的含义。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>ab_set.html页面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&#123;% for user_obj in user_queryset %&#125;</span><br><span class="line">    user_obj</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="7、Ajax结合sweetalert实现删除按钮的二次确认操作"><a href="#7、Ajax结合sweetalert实现删除按钮的二次确认操作" class="headerlink" title="7、Ajax结合sweetalert实现删除按钮的二次确认操作"></a>7、Ajax结合sweetalert实现删除按钮的二次确认操作</h2><p><a href="https://link.zhihu.com/?target=https://lipis.github.io/bootstrap-sweetalert/">SweetAlert for Bootstraplipis.github.io</a></p>
<p>我们使用这个模板：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">swal(&#123;</span><br><span class="line">  title: &quot;Are you sure?&quot;,</span><br><span class="line">  text: &quot;Your will not be able to recover this imaginary file!&quot;,</span><br><span class="line">  type: &quot;warning&quot;,</span><br><span class="line">  showCancelButton: true,</span><br><span class="line">  confirmButtonClass: &quot;btn-danger&quot;,</span><br><span class="line">  confirmButtonText: &quot;Yes, delete it!&quot;,</span><br><span class="line">  closeOnConfirm: false</span><br><span class="line">&#125;,</span><br><span class="line">function()&#123;</span><br><span class="line">  swal(&quot;Deleted!&quot;, &quot;Your imaginary file has been deleted.&quot;, &quot;success&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-0d878876399715a843c1cf9bf0d20356_1440w.jpg" alt="img"></p>
<p>views.py文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_list</span>(<span class="params">request</span>):</span></span><br><span class="line">    user_queryset = models.User.objects.all()</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;user_list.html&#x27;</span>,locals())</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_delete</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    前后端在用Ajax进行交互的时候，后端通常给Ajax的回调函数返回一个字典格式的数据</span></span><br><span class="line"><span class="string">    :param request:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> request.is_ajax():</span><br><span class="line">        <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">            back_dic = &#123;<span class="string">&#x27;code&#x27;</span>:<span class="number">1000</span>,<span class="string">&#x27;msg&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">            time.sleep(<span class="number">2</span>)  <span class="comment"># 模拟延迟也可以设置在后端这个地方</span></span><br><span class="line">            delete_id = request.POST.get(<span class="string">&#x27;delete_id&#x27;</span>)</span><br><span class="line">            models.User.objects.filter(pk=delete_id).delete()</span><br><span class="line">            back_dic[<span class="string">&#x27;msg&#x27;</span>]=<span class="string">&#x27;数据已经删除&#x27;</span></span><br><span class="line">            <span class="comment"># 删除数据后，我们需要告诉前端我们操作的结果</span></span><br><span class="line">            <span class="keyword">return</span> JsonResponse(back_dic)</span><br></pre></td></tr></table></figure>

<p>user_list.html页面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;jQuery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    &#123;#    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span>#&#125;</span><br><span class="line">    &#123;#    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>#&#125;</span><br><span class="line">    &#123;# 静态文件的配置 #&#125;</span><br><span class="line">    &#123;% load static %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% static &#x27;bootstrap-3.3.7-dist/css/bootstrap.min.css&#x27; %&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% static &#x27;bootstrap-3.3.7-dist/js/bootstrap.min.js&#x27; %&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% static &#x27;dist/sweetalert.css&#x27; %&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% static &#x27;dist/sweetalert.min.js&#x27; %&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">div</span><span class="selector-class">.sweet-alert</span> <span class="selector-tag">h2</span> &#123;</span></span><br><span class="line">        &#123;#由于默认的样式中点击删除按钮时，显示的字会被遮挡住一部分，所以我们可以在这里调整下样式#&#125; padding-top: 10px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;text-center&quot;</span>&gt;</span>用户数据展示<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-8 col-md-offset-2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;table table-bordered table-striped table-hover&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>username<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>age<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>gender<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>actions<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">                &#123;% for user_obj in user_queryset %&#125;</span><br><span class="line">                    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; user_obj.pk &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; user_obj.username &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; user_obj.age &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; user_obj.get_gender_display &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary btn-xs&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-danger btn-xs del&quot;</span> <span class="attr">delete_id</span>=<span class="string">&quot;&#123;&#123; user_obj.pk &#125;&#125;&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                &#123;% endfor %&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 绑定删除按钮的点击事件</span></span></span><br><span class="line"><span class="javascript">    $(<span class="string">&#x27;.del&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        &#123;#alert($(this).attr(&#x27;delete_id&#x27;))#&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 先将当前标签对象存储起来</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> currentBtn = $(<span class="built_in">this</span>);    <span class="comment">// 这样就知道当前我们操作的对象是谁了</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 二次弹框确认</span></span></span><br><span class="line">        swal(&#123;</span><br><span class="line"><span class="javascript">                title: <span class="string">&quot;你确定要删除此用户吗&quot;</span>,</span></span><br><span class="line"><span class="javascript">                text: <span class="string">&quot;删除后你将无法恢复数据，请谨慎！&quot;</span>,</span></span><br><span class="line"><span class="javascript">                type: <span class="string">&quot;warning&quot;</span>,</span></span><br><span class="line"><span class="javascript">                showCancelButton: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">                confirmButtonClass: <span class="string">&quot;btn-danger&quot;</span>,</span></span><br><span class="line"><span class="javascript">                confirmButtonText: <span class="string">&quot;是的，请删除&quot;</span>,</span></span><br><span class="line"><span class="javascript">                cancelButtonText: <span class="string">&quot;不，请取消!&quot;</span>,</span></span><br><span class="line"><span class="javascript">                closeOnConfirm: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">                closeOnCancel: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">                showLoaderOnConfirm: <span class="literal">true</span>  <span class="comment">// 转圈圈的效果</span></span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> (<span class="params">isConfirm</span>) </span>&#123;</span></span><br><span class="line">                if (isConfirm) &#123;</span><br><span class="line"><span class="javascript">                    <span class="comment">// 朝后端发送Ajax请求删除数据，之后再弹框显示已删除</span></span></span><br><span class="line"><span class="javascript">                    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="comment">// 传递主键值(delete_id)方式1：</span></span></span><br><span class="line">                        &#123;#url:&#x27;/user/delete/&#x27;+currentBtn.attr(&#x27;delete_id&#x27;),#&#125;</span><br><span class="line"><span class="javascript">                        <span class="comment">// 传递主键值方式2，放在请求体里面：</span></span></span><br><span class="line"><span class="javascript">                        url: <span class="string">&#x27;/user/delete/&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                        type: <span class="string">&#x27;post&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                        data: &#123;<span class="string">&#x27;delete_id&#x27;</span>: currentBtn.attr(<span class="string">&#x27;delete_id&#x27;</span>)&#125;,</span></span><br><span class="line"><span class="javascript">                        success: <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;    <span class="comment">// 前端就获取到了后端返回的数据back_dic = &#123;&#x27;code&#x27;:1000,&#x27;msg&#x27;:&#x27;&#x27;&#125;，也就是args=&#123;&#x27;code&#x27;:1000,&#x27;msg&#x27;:&#x27;&#x27;&#125;</span></span></span><br><span class="line"><span class="javascript">                            <span class="comment">// 判断响应状态码，做不同的处理</span></span></span><br><span class="line">                            if (args.code === 1000) &#123;</span><br><span class="line"><span class="javascript">                                <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                                    swal(<span class="string">&quot;已删除!&quot;</span>, <span class="string">&quot;此用户已被删除&quot;</span>, <span class="string">&quot;success&quot;</span>);</span></span><br><span class="line"><span class="javascript">                                &#125;,<span class="number">2000</span>);   <span class="comment">// 设置两秒钟加载的效果</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                                <span class="comment">// 删除后需要刷新用户显示页面</span></span></span><br><span class="line"><span class="javascript">                                <span class="comment">// 方式1：</span></span></span><br><span class="line">                                &#123;#window.location.reload()#&#125;</span><br><span class="line"><span class="javascript">                                <span class="comment">// 方式2：利用DOM操作动态刷新,通过DOM操作标签查找将已删除的那行数据给移除</span></span></span><br><span class="line"><span class="javascript">                                <span class="comment">// 即要删除tr标签所在的那一行，tr标签是删除标签的父标签的父标签</span></span></span><br><span class="line">                                currentBtn.parent().parent().remove()</span><br><span class="line"></span><br><span class="line"><span class="javascript">                            &#125;<span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                                swal(<span class="string">&#x27;Oops&#x27;</span>,<span class="string">&#x27;出现了位置的错误&#x27;</span>,<span class="string">&#x27;info&#x27;</span>)</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;)</span><br><span class="line"><span class="javascript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                    swal(<span class="string">&quot;已取消&quot;</span>, <span class="string">&quot;您的用户还在&quot;</span>, <span class="string">&quot;error&quot;</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-ff4e9a9cd08f91ccd9acc27ddfccdd2a_1440w.jpg" alt="img"></p>
<p>ps:也可以不结合sweetalert就用Ajax和BOM操作也能完成二次确认：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res &#x3D; confirm()</span><br><span class="line">if(res)&#123;</span><br><span class="line">    $.ajax(&#123;&#125;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    不发</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8、批量插入数据"><a href="#8、批量插入数据" class="headerlink" title="8、批量插入数据"></a>8、批量插入数据</h2><p>views.py文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def ab_bulk_insert(request):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    使用orm提供的bulk_create来批量插入数据可以大大减少操作时间</span><br><span class="line">    :param request:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 给Book表插入一万条数据</span><br><span class="line">    # 方式1，执行10000次create的操作，页面会有加载、延迟的效果：</span><br><span class="line">    # for i in range(10000):</span><br><span class="line">    #     models.Book.objects.create(title&#x3D;&#39;第&#123;&#125;本书&#39;.format(i))</span><br><span class="line"></span><br><span class="line">    # 方式2：批量插入</span><br><span class="line">    book_list&#x3D;[]</span><br><span class="line">    for i in range(10000):</span><br><span class="line">        book_obj &#x3D; models.Book(title&#x3D;&#39;第&#123;&#125;本书&#39;.format(i))    # 生成对象</span><br><span class="line">        book_list.append(book_obj)                                                         # 将对象添加到列表中</span><br><span class="line">    models.Book.objects.bulk_create(book_list)                        # 用bulk_create方法插入</span><br><span class="line">  </span><br><span class="line">    # 再将所有的数据查询展示到前端页面</span><br><span class="line">    book_queryset &#x3D; models.Book.objects.all()</span><br><span class="line"></span><br><span class="line">    return render(request,&#39;ab_bulk_insert.html&#39;,locals())</span><br></pre></td></tr></table></figure>

<p>ab_bulk_insert.html文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&#123;% for book_obj in book_queryset %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; book_obj.title &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="9、自定义分页器"><a href="#9、自定义分页器" class="headerlink" title="9、自定义分页器"></a>9、自定义分页器</h2><p>上面批量插入10000条数据后是展示到一个页面中的，查看不方便，我们需要进行分页展示。Django中有自带的分页器模块，但是书写起来很麻烦并且功能太简单，所以我们需要<strong>自定义分页器。</strong></p>
<p><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/Dominic-Ji/p/12035722.html">自定义分页器 - JasonJi - 博客园www.cnblogs.com<img src="https://pic1.zhimg.com/v2-d7184bbf245efcf536889f3ce8a75f9c_ipico.jpg" alt="图标"></a></p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-51b6ddc8eb99b2cde3bc3700c5e195b7_1440w.jpg" alt="img"></p>
<p><strong>当我们需要使用到非Django内置的第三方功能或者组件代码的时候，一般会创建一个名为utils的文件夹(utils可以建在根目录下也可以建在应用文件夹下)，在该文件夹内对模块进行功能性划分。</strong></p>
<p><strong>后期封装代码时不再局限于函数，还是尽量朝面向对象去封装(类)。</strong></p>
<p><strong>分页器代码:</strong></p>
<p>在utils文件下新建一个mypage.py文件(写Pagination类)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Pagination(object):</span><br><span class="line">    def __init__(self, current_page, all_count, per_page_num&#x3D;2, pager_count&#x3D;11):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        封装分页相关数据</span><br><span class="line">        :param current_page: 当前页</span><br><span class="line">        :param all_count:    数据库中的数据总条数</span><br><span class="line">        :param per_page_num: 每页显示的数据条数</span><br><span class="line">        :param pager_count:  最多显示的页码个数</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        try:</span><br><span class="line">            current_page &#x3D; int(current_page)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            current_page &#x3D; 1</span><br><span class="line"></span><br><span class="line">        if current_page &lt; 1:</span><br><span class="line">            current_page &#x3D; 1    # 保证 页码不出现负数或0</span><br><span class="line"></span><br><span class="line">        self.current_page &#x3D; current_page</span><br><span class="line"></span><br><span class="line">        self.all_count &#x3D; all_count</span><br><span class="line">        self.per_page_num &#x3D; per_page_num</span><br><span class="line"></span><br><span class="line">        # 总页码</span><br><span class="line">        all_pager, tmp &#x3D; divmod(all_count, per_page_num)</span><br><span class="line">        if tmp:</span><br><span class="line">            all_pager +&#x3D; 1</span><br><span class="line">        self.all_pager &#x3D; all_pager</span><br><span class="line"></span><br><span class="line">        self.pager_count &#x3D; pager_count</span><br><span class="line">        self.pager_count_half &#x3D; int((pager_count - 1) &#x2F; 2)</span><br><span class="line"></span><br><span class="line">    @property         # 将方法伪装成属性，在调用的时候不需要加括号也能触发方法的运行</span><br><span class="line">    def start(self):</span><br><span class="line">        return (self.current_page - 1) * self.per_page_num</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def end(self):</span><br><span class="line">        return self.current_page * self.per_page_num</span><br><span class="line"></span><br><span class="line">    def page_html(self):</span><br><span class="line">        # 如果总页码 &lt; 11个：</span><br><span class="line">        if self.all_pager &lt;&#x3D; self.pager_count:</span><br><span class="line">            pager_start &#x3D; 1</span><br><span class="line">            pager_end &#x3D; self.all_pager + 1</span><br><span class="line">        # 总页码  &gt; 11</span><br><span class="line">        else:</span><br><span class="line">            # 当前页如果&lt;&#x3D;页面上最多显示11&#x2F;2个页码</span><br><span class="line">            if self.current_page &lt;&#x3D; self.pager_count_half:</span><br><span class="line">                pager_start &#x3D; 1</span><br><span class="line">                pager_end &#x3D; self.pager_count + 1</span><br><span class="line"></span><br><span class="line">            # 当前页大于5</span><br><span class="line">            else:</span><br><span class="line">                # 页码翻到最后</span><br><span class="line">                if (self.current_page + self.pager_count_half) &gt; self.all_pager:</span><br><span class="line">                    pager_end &#x3D; self.all_pager + 1</span><br><span class="line">                    pager_start &#x3D; self.all_pager - self.pager_count + 1</span><br><span class="line">                else:</span><br><span class="line">                    pager_start &#x3D; self.current_page - self.pager_count_half</span><br><span class="line">                    pager_end &#x3D; self.current_page + self.pager_count_half + 1</span><br><span class="line"></span><br><span class="line">        page_html_list &#x3D; []</span><br><span class="line">        # 添加前面的nav和ul标签</span><br><span class="line">        page_html_list.append(&#39;&#39;&#39;</span><br><span class="line">                    &lt;nav aria-label&#x3D;&#39;Page navigation&gt;&#39;</span><br><span class="line">                    &lt;ul class&#x3D;&#39;pagination&#39;&gt;</span><br><span class="line">                &#39;&#39;&#39;)</span><br><span class="line">        first_page &#x3D; &#39;&lt;li&gt;&lt;a href&#x3D;&quot;?page&#x3D;%s&quot;&gt;首页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39; % (1)</span><br><span class="line">        page_html_list.append(first_page)</span><br><span class="line"></span><br><span class="line">        if self.current_page &lt;&#x3D; 1:</span><br><span class="line">            prev_page &#x3D; &#39;&lt;li class&#x3D;&quot;disabled&quot;&gt;&lt;a href&#x3D;&quot;#&quot;&gt;上一页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;</span><br><span class="line">        else:</span><br><span class="line">            prev_page &#x3D; &#39;&lt;li&gt;&lt;a href&#x3D;&quot;?page&#x3D;%s&quot;&gt;上一页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39; % (self.current_page - 1,)</span><br><span class="line"></span><br><span class="line">        page_html_list.append(prev_page)</span><br><span class="line"></span><br><span class="line">        for i in range(pager_start, pager_end):</span><br><span class="line">            if i &#x3D;&#x3D; self.current_page:</span><br><span class="line">                temp &#x3D; &#39;&lt;li class&#x3D;&quot;active&quot;&gt;&lt;a href&#x3D;&quot;?page&#x3D;%s&quot;&gt;%s&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39; % (i, i,)</span><br><span class="line">            else:</span><br><span class="line">                temp &#x3D; &#39;&lt;li&gt;&lt;a href&#x3D;&quot;?page&#x3D;%s&quot;&gt;%s&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39; % (i, i,)</span><br><span class="line">            page_html_list.append(temp)</span><br><span class="line"></span><br><span class="line">        if self.current_page &gt;&#x3D; self.all_pager:</span><br><span class="line">            next_page &#x3D; &#39;&lt;li class&#x3D;&quot;disabled&quot;&gt;&lt;a href&#x3D;&quot;#&quot;&gt;下一页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;</span><br><span class="line">        else:</span><br><span class="line">            next_page &#x3D; &#39;&lt;li&gt;&lt;a href&#x3D;&quot;?page&#x3D;%s&quot;&gt;下一页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39; % (self.current_page + 1,)</span><br><span class="line">        page_html_list.append(next_page)</span><br><span class="line"></span><br><span class="line">        last_page &#x3D; &#39;&lt;li&gt;&lt;a href&#x3D;&quot;?page&#x3D;%s&quot;&gt;尾页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39; % (self.all_pager,)</span><br><span class="line">        page_html_list.append(last_page)</span><br><span class="line">        # 尾部添加标签</span><br><span class="line">        page_html_list.append(&#39;&#39;&#39;</span><br><span class="line">                                           &lt;&#x2F;nav&gt;</span><br><span class="line">                                           &lt;&#x2F;ul&gt;</span><br><span class="line">                                       &#39;&#39;&#39;)</span><br><span class="line">        return &#39;&#39;.join(page_html_list)</span><br></pre></td></tr></table></figure>

<p>后端views.py文件定义视图函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> utils.mypage <span class="keyword">import</span> Pagination</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ab_paging</span>(<span class="params">request</span>):</span></span><br><span class="line">   book_list = models.Book.objects.all()</span><br><span class="line">   current_page = request.GET.get(<span class="string">&quot;page&quot;</span>,<span class="number">1</span>)</span><br><span class="line">   all_count = book_list.count()</span><br><span class="line">   <span class="comment"># 1、传值生成对象</span></span><br><span class="line">   page_obj = Pagination(current_page=current_page,all_count=all_count,per_page_num=<span class="number">10</span>)</span><br><span class="line">   <span class="comment"># 2、对总数据进行切片操作</span></span><br><span class="line">   page_queryset = book_list[page_obj.start:page_obj.end]</span><br><span class="line">   <span class="comment"># 3、将page_queryset传递到前端页面</span></span><br><span class="line">   <span class="keyword">return</span> render(request,<span class="string">&#x27;ab_bulk_insert.html&#x27;</span>,locals())</span><br></pre></td></tr></table></figure>

<p>前端ab_bulk_insert.html页面(需要提前导入bootstrap(v3版本))：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-8 col-md-offset-2&quot;</span>&gt;</span></span><br><span class="line">            &#123;% for book in page_queryset %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; book.title &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            &#123;% endfor %&#125;</span><br><span class="line">&#123;#            利用自定义分页器直接显示分页器样式#&#125;</span><br><span class="line">            &#123;&#123; page_obj.page_html|safe &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-f7d942056125f7bb69a4175104130055_1440w.jpg" alt="img"></p>
<h2 id="补充-分页器原理"><a href="#补充-分页器原理" class="headerlink" title="补充: 分页器原理"></a>补充: 分页器原理</h2><p>实质上就是看当前数据一共有多少，然后返回的是queryset对象，然后切列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">1.拿到前端传过来的page=&gt;str</span><br><span class="line"><span class="number">2.</span>获取数据 </span><br><span class="line">    User.objects.all()</span><br><span class="line"><span class="number">3.</span>对数据进行处理，分页,定义每页只有<span class="number">10</span>条数据</span><br><span class="line">     根据page计算切片的start 和 end</span><br><span class="line">     end = page * <span class="number">10</span></span><br><span class="line">     start = end - <span class="number">10</span></span><br><span class="line">     queryset = User.objects.all()[start:end]</span><br><span class="line"><span class="number">4.</span>转json</span><br><span class="line">    list(queryset.values(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;email&quot;</span>))</span><br><span class="line">  </span><br><span class="line"><span class="number">5.</span>返回HttpResponse对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题</span><br><span class="line"><span class="number">1.</span> 一共有多少条记录</span><br><span class="line"><span class="number">2.</span> 一共可以分多少页</span><br><span class="line"><span class="number">3.</span> 是否有上一页，上一页的页码</span><br><span class="line"><span class="number">4.</span> 是否有下一页，下一夜的页码</span><br><span class="line"><span class="number">5.</span> 首页</span><br><span class="line"><span class="number">6.</span> 尾页</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Paginator-和-Page-对象实现了django-的分页"><a href="#Paginator-和-Page-对象实现了django-的分页" class="headerlink" title="Paginator 和 Page 对象实现了django 的分页"></a>Paginator 和 Page 对象实现了django 的分页</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.paginator <span class="keyword">import</span> Paginator</span><br><span class="line">queryset = User.objects.all()</span><br><span class="line">paginator = Paginator(queryset, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">paginator.count</span><br><span class="line">Out[<span class="number">13</span>]: <span class="number">656</span></span><br><span class="line">paginator.num_pages</span><br><span class="line">Out[<span class="number">14</span>]: <span class="number">66</span></span><br><span class="line">paginator.page_range</span><br><span class="line">Out[<span class="number">15</span>]: range(<span class="number">1</span>, <span class="number">67</span>)</span><br><span class="line">paginator.page(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">16</span>]: &lt;Page <span class="number">10</span> of <span class="number">66</span>&gt;</span><br></pre></td></tr></table></figure>

<p>Paginator方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Paginator</span>(<span class="params">object_list, per_page, orphans=<span class="number">0</span>, allow_empty_first_page=True</span>)</span></span><br><span class="line"><span class="class"><span class="title">Required</span> <span class="title">arguments</span> </span></span><br><span class="line"><span class="class">    - <span class="title">object_list</span> </span></span><br><span class="line"><span class="class">  - <span class="title">per_page</span> </span></span><br><span class="line"><span class="class"><span class="title">Optional</span> <span class="title">arguments</span> </span></span><br><span class="line"><span class="class">    - <span class="title">orphans</span> </span></span><br><span class="line"><span class="class">  - <span class="title">allow_empty_</span>Ò<span class="title">rst_page</span></span></span><br><span class="line"><span class="class">  </span></span><br><span class="line"><span class="class"># 属性</span></span><br><span class="line"><span class="class">- <span class="title">Paginator</span>.<span class="title">count</span> 所有页面的<span class="title">objects</span>总数 </span></span><br><span class="line"><span class="class">- <span class="title">Paginator</span>.<span class="title">num_pages</span> 页面总数 </span></span><br><span class="line">- Paginator.page_range 页码的范围，从1开始，例如[1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法</span></span><br><span class="line">- Paginator.page(number) 返回一个page对象,number， 当前显示的是第几页</span><br></pre></td></tr></table></figure>

<p>Page方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Page</span>(<span class="params">object_list, number, paginator</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"># 属性</span></span><br><span class="line"><span class="class">- <span class="title">Page</span>.<span class="title">object_list</span> 当前页面的对象列表 </span></span><br><span class="line"><span class="class">- <span class="title">Page</span>.<span class="title">number</span> 当前页的序号，从1开始 </span></span><br><span class="line"><span class="class">- <span class="title">Page</span>.<span class="title">paginator</span> <span class="title">Paginator</span>对象</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"># 方法</span></span><br><span class="line"><span class="class">- <span class="title">Page</span>.<span class="title">has_next</span>() 如果有下一页，返回<span class="title">True</span> </span></span><br><span class="line"><span class="class">- <span class="title">Page</span>.<span class="title">has_previous</span>() 如果有上一页，返回 <span class="title">True</span></span></span><br><span class="line"><span class="class">- <span class="title">Page</span>.<span class="title">has_other_pages</span>() 如果有上一面或下一页，返回<span class="title">True</span> </span></span><br><span class="line"><span class="class">- <span class="title">Page</span>.<span class="title">next_page_number</span>() 返回下一页的页码。如果不存在，抛出<span class="title">InvalidPage</span>异常 </span></span><br><span class="line"><span class="class">- <span class="title">Page</span>.<span class="title">previous_page_number</span>() 返回上一页的页码。如果不存在，抛出<span class="title">InvalidPage</span>异常 </span></span><br><span class="line"><span class="class">- <span class="title">Page</span>.<span class="title">start_index</span>() 返回当前页上的第一个对象，相对于分页列表的所有对象的序号 </span></span><br><span class="line"><span class="class">- <span class="title">Page</span>.<span class="title">end_index</span>() 返回当前页上的最后一个对象，相对于分页列表的所有对象的序号</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>15-Django-forms组件</title>
    <url>/posts/56969.html</url>
    <content><![CDATA[<p>Django forms组件</p>
<a id="more"></a>

<h2 id="1、forms组件"><a href="#1、forms组件" class="headerlink" title="1、forms组件"></a>1、forms组件</h2><p><strong>Django Form 组件</strong>用于对页面进行初始化，生成HTML 标签，此外还可以对用户提交对数据进行校验（显示错误信息）。 报错信息显示顺序： 先显示字段属性中的错误信息，然后再显示局部钩子的错误信息。 若显示了字段属性的错误信息，就不会显示局部钩子的错误信息。</p>
<p><strong>小示例：</strong><br>写一个注册功能：<br>利用form表单提交数据，获取用户名密码，在后端判断用户名密码是否符合条件：用户名不能包含abc字符串，密码不能少于6位数。</p>
<p>views.py文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ab_form</span>(<span class="params">request</span>):</span></span><br><span class="line">    back_dic = &#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        username = request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        password = request.POST.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;abc&#x27;</span> <span class="keyword">in</span> username:</span><br><span class="line">            back_dic[<span class="string">&#x27;username&#x27;</span>] = <span class="string">&#x27;用户名不能包含字符串abc&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> len(password)&lt;<span class="number">6</span>:</span><br><span class="line">            back_dic[<span class="string">&#x27;password&#x27;</span>] = <span class="string">&#x27;密码必须为6位数&#x27;</span></span><br><span class="line">    <span class="comment"># back_dic字典值默认是空，当用户输入用户名密码并提交时，就发起了post请求，back_dic通过校验如果不符合要求就会传值</span></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;ab_form.html&#x27;</span>,locals())</span><br></pre></td></tr></table></figure>

<p>html页面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>username:</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span>&#123;&#123; back_dic.username &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>password:</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span>&#123;&#123; back_dic.password &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-info&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-060957ed93bd5f8b6b8020192f4d7af6_1440w.jpg" alt="img"></p>
<p>以上我们就手动完成了需求：<br>1、书写前端获取用户数据的HTML代码<br>2、后端对用户数据进行校验<br>3、对不符合要求的数据进行前端提示</p>
<p><strong>实际上以上功能form组件都能完成(渲染代码、校验数据、前端展示提示)。</strong></p>
<p><strong>应用场景：例如博客园的注册页面</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-2a987ecca8e2508ef9a5824edf990681_1440w.jpg" alt="img"></p>
<p><strong>数据校验前端可有可无，但是后端必须要有！因为前端的校验你可以直接修改，或者利用爬虫程序绕过前端页面直接朝后端提交数据。</strong></p>
<h2 id="2、forms组件类书写"><a href="#2、forms组件类书写" class="headerlink" title="2、forms组件类书写"></a><strong>2、</strong>forms组件类书写</h2><p>views.py文件中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span>(<span class="params">forms.Form</span>):</span></span><br><span class="line">    <span class="comment"># username,password这两个字段最少3位数，最大8位数</span></span><br><span class="line">    username = forms.CharField(min_length=<span class="number">3</span>,max_length=<span class="number">8</span>)</span><br><span class="line">    password = forms.CharField(min_length=<span class="number">3</span>,max_length=<span class="number">8</span>)</span><br><span class="line">    <span class="comment"># email字段必须符合邮箱格式，xx@xx.com</span></span><br><span class="line">    email = forms.EmailField()</span><br></pre></td></tr></table></figure>

<h2 id="3、forms组件如何校验数据"><a href="#3、forms组件如何校验数据" class="headerlink" title="3、forms组件如何校验数据"></a>3、forms组件如何校验数据</h2><p>测试环境的准备除了我们之前用的tests.py，在pycharm里面已经给我们提供了一个Django的测试环境：点击Python Console：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-4010cef3dfacf6501ca2b00f46e18d7a_1440w.jpg" alt="img"></p>
<p>校验步骤：<br>1、将要校验的数据组织成形式传入<br>2、判断数据是否合法，is_valid()方法用来校验我们传入的字典数据是否合法，该方法只有在所有的数据全部合法的情况下才会返回True<br>3、cleaned_data拿到所有符合条件的数据;<br>4、errors拿到所有不符合校验规则的数据以及不符合规则的原因，以键值对的形式展现，并且值是以列表的形式，因为一个字段有可能会不符合多个规则。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-30b3d50308705a16d47a1625df904fab_1440w.jpg" alt="img"></p>
<p>如果我再多传入一个hobby键：<br>form_<em>obj = views.MyForm({‘username’:’jack’,’password’:’12’,’email’:’123’,’hobby’:’study’})</em><br><em>那么hobby是不会被校验的，只会找MyForm类里面书写的字段去做校验，而hobby不会被放到cleaned_</em>data也不会被放到errors中。<br>默认情况下，类里面的所有字段都必须传值。如果少传了一个键，少传的那个字段会被放到errors中：<br>form_obj = views.MyForm({‘username’:’jack’,’password’:’123’})<br>form_obj.errors<br>{‘email’: [‘This field is required.’]}<br>form_obj.cleaned_data<br>{‘username’: ‘jack’, ‘password’: ‘123’}</p>
<h2 id="4、forms组件如何渲染标签"><a href="#4、forms组件如何渲染标签" class="headerlink" title="4、forms组件如何渲染标签"></a>4、forms组件如何渲染标签</h2><p>结合form组件获取用户注册的用户名密码邮箱，有了form组件之后所有获取用户输入的标签都不需要自己写了。<br><strong>form组件只会帮你渲染获取用户输入的标签(input select radio checkbox); <font color=red>不会帮你渲染提交按钮，要自己添加</font>。</strong></p>
<p>views.py文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ps: label 表示回显字段的名称</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span>(<span class="params">forms.Form</span>):</span></span><br><span class="line">    <span class="comment"># username,password这两个字段最少3位数，最大8位数</span></span><br><span class="line">    username = forms.CharField(min_length=<span class="number">3</span>,max_length=<span class="number">8</span>,label=<span class="string">&#x27;用户名&#x27;</span>)</span><br><span class="line">    password = forms.CharField(min_length=<span class="number">3</span>,max_length=<span class="number">8</span>,label=<span class="string">&#x27;密码&#x27;</span>)</span><br><span class="line">    <span class="comment"># email字段必须符合邮箱格式，xx@xx.com</span></span><br><span class="line">    email = forms.EmailField(label=<span class="string">&#x27;邮箱&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 1、先产生一个空对象</span></span><br><span class="line">    form_obj = MyForm()</span><br><span class="line">    <span class="comment"># 2、直接将该空对象传递给HTML页面</span></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;index.html&#x27;</span>,locals())</span><br></pre></td></tr></table></figure>

<p>前端index.html页面(前端对生成的空对象做操作)：<br>label属性默认展示的是类中字段首字母大写的形式，也可以修改：通过给字段加label属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>第一种form表单渲染方式:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>代码书写极少，封装程度太高，不利于后续的扩展，一般只在本地测试使用<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>as_p<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;&#123; form_obj.as_p &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>as_ul<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;&#123; form_obj.as_ul &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>as_table<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;&#123; form_obj.as_table &#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>第二种form表单渲染方式:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>可扩展性强，但是需要书写的代码太多，一般不用<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; form_obj.username.label &#125;&#125; ：&#123;&#123; form_obj.username &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; form_obj.password.label &#125;&#125; ：&#123;&#123; form_obj.password &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; form_obj.email.label &#125;&#125; ：&#123;&#123; form_obj.email &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>第三种form表单渲染方式:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>代码书写简单，扩展性高，推荐使用<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% for form in form_obj %&#125;</span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span>&gt;</span> &#123;&#123; form.label &#125;&#125; :&#123;&#123; form &#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-f2bb9bbd982f762e1354ff297aab1179_1440w.jpg" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-fa70b9bd65c62deb0e6eaeb2f5602a96_1440w.jpg" alt="img"></p>
<h2 id="5、forms组件展示错误信息"><a href="#5、forms组件展示错误信息" class="headerlink" title="5、forms组件展示错误信息"></a>5、forms组件展示错误信息</h2><p>浏览器会自动帮你做校验(如下图的提示信息)，但是前端的校验还是不安全，我们可以给form表单加个参数取消前端浏览器自动校验功能：&lt;form action=”” method=”post” **novalidate**&gt;</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-ec62b9364f0600f35fc0141cac62ee69_1440w.jpg" alt="img"></p>
<p>form表单展示错误信息需要注意：<br>1、get请求和post请求传给页面的对象变量名必须一致form_obj<br>2、当你的数据不合法时，form组件会保存你输入的数据，让你基于上次的输入数据进行修改，更加人性化</p>
<p><strong>保存数据的原理：</strong>开始的时候get请求过，是空对象，没有数据。发post请求赋值之后(如果校验没通过)，等于下一次get请求拿到的数值是从上一次post赋值后的对象拿到的。</p>
<p>views.py文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span>(<span class="params">forms.Form</span>):</span></span><br><span class="line">    <span class="comment"># username,password这两个字段最少3位数，最大8位数</span></span><br><span class="line">    username = forms.CharField(min_length=<span class="number">3</span>,max_length=<span class="number">8</span>,label=<span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">                               error_messages=&#123;</span><br><span class="line">                                   <span class="string">&#x27;min_length&#x27;</span>:<span class="string">&#x27;用户名最少3位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;max_length&#x27;</span>:<span class="string">&#x27;用户名最多8位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;required&#x27;</span>:<span class="string">&#x27;用户名不能为空&#x27;</span></span><br><span class="line">                               &#125;)</span><br><span class="line">    password = forms.CharField(min_length=<span class="number">3</span>,max_length=<span class="number">8</span>,label=<span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">                               error_messages=&#123;</span><br><span class="line">                                   <span class="string">&#x27;min_length&#x27;</span>: <span class="string">&#x27;密码最少3位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;max_length&#x27;</span>: <span class="string">&#x27;密码最多8位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;required&#x27;</span>: <span class="string">&#x27;密码不能为空&#x27;</span></span><br><span class="line">                               &#125;)</span><br><span class="line">    <span class="comment"># email字段必须符合邮箱格式，xx@xx.com</span></span><br><span class="line">    email = forms.EmailField(label=<span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">                            error_messages=&#123;</span><br><span class="line">                             <span class="string">&#x27;invalid&#x27;</span>:<span class="string">&#x27;邮箱格式不正确&#x27;</span>,</span><br><span class="line">                             <span class="string">&#x27;required&#x27;</span>: <span class="string">&#x27;邮箱不能为空&#x27;</span></span><br><span class="line">                            &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 1、先产生一个空对象</span></span><br><span class="line">    form_obj = MyForm()</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        <span class="comment"># 3、校验数据</span></span><br><span class="line">        form_obj = MyForm(request.POST)</span><br><span class="line">        <span class="comment"># 4、判断数据是否合法</span></span><br><span class="line">        <span class="keyword">if</span> form_obj.is_valid():</span><br><span class="line">            <span class="comment"># 5、如果合法，操作数据库存储数据</span></span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;OK&#x27;</span>)</span><br><span class="line">        <span class="comment"># 5、如果不合法，将错误信息展示到前端</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2、直接将该空对象传递给HTML页面</span></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;index.html&#x27;</span>,locals())</span><br></pre></td></tr></table></figure>

<p>index.html页面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">novalidate</span>&gt;</span></span><br><span class="line">    &#123;% for form in form_obj %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span> &#123;&#123; form.label &#125;&#125; :&#123;&#123; form &#125;&#125;</span><br><span class="line">&#123;#          form.errors.0这后面加了一个.0表示只拿列表第一个错误信息，就不会自动帮你生成ul标签 #&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>&#123;&#123; form.errors.0 &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-b3a531d8a62ce7e3b41ca90bd85bc9f6_1440w.jpg" alt="img"></p>
<p>在给字段添加了error_messages参数之后，错误提示就变成自己输入的了(自定义)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-ddbdf0f092aced5c8f81e8318fa3fe22_1440w.jpg" alt="img"></p>
<h2 id="6、forms组件钩子函数"><a href="#6、forms组件钩子函数" class="headerlink" title="6、forms组件钩子函数"></a>6、forms组件钩子函数</h2><p><strong>钩子函数：在特定的节点自动触发完成响应操作</strong><br>在form组件中有两类钩子<br>1、局部钩子<br>当你需要给单个字段增加校验规则的时候可以使用，在后端校验的基础上进行二次校验。<br>2、全局钩子<br>当你需要给多个字段增加校验规则的时候可以使用。</p>
<p>实际案例：<br>1、校验用户名中不能包含666(<strong>只需要校验用户名，可以用局部钩子</strong>)<br>2、校验密码和确认密码是否一致(<strong>校验密码字段和确认密码字段，需要用全部钩子</strong>)</p>
<p>views.py文件做如下修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span>(<span class="params">forms.Form</span>):</span></span><br><span class="line">    <span class="comment"># username,password这两个字段最少3位数，最大8位数</span></span><br><span class="line">    username = forms.CharField(min_length=<span class="number">3</span>,max_length=<span class="number">8</span>,label=<span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">                               error_messages=&#123;</span><br><span class="line">                                   <span class="string">&#x27;min_length&#x27;</span>:<span class="string">&#x27;用户名最少3位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;max_length&#x27;</span>:<span class="string">&#x27;用户名最多8位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;required&#x27;</span>:<span class="string">&#x27;用户名不能为空&#x27;</span></span><br><span class="line">                               &#125;)</span><br><span class="line">    password = forms.CharField(min_length=<span class="number">3</span>,max_length=<span class="number">8</span>,label=<span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">                               error_messages=&#123;</span><br><span class="line">                                   <span class="string">&#x27;min_length&#x27;</span>: <span class="string">&#x27;密码最少3位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;max_length&#x27;</span>: <span class="string">&#x27;密码最多8位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;required&#x27;</span>: <span class="string">&#x27;密码不能为空&#x27;</span></span><br><span class="line">                               &#125;)</span><br><span class="line">    confirm_password = forms.CharField(min_length=<span class="number">3</span>,max_length=<span class="number">8</span>,label=<span class="string">&#x27;确认密码&#x27;</span>,</span><br><span class="line">                               error_messages=&#123;</span><br><span class="line">                                   <span class="string">&#x27;min_length&#x27;</span>: <span class="string">&#x27;密码最少3位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;max_length&#x27;</span>: <span class="string">&#x27;密码最多8位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;required&#x27;</span>: <span class="string">&#x27;密码不能为空&#x27;</span></span><br><span class="line">                               &#125;)</span><br><span class="line">    <span class="comment"># email字段必须符合邮箱格式，xx@xx.com</span></span><br><span class="line">    email = forms.EmailField(label=<span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">                            error_messages=&#123;</span><br><span class="line">                             <span class="string">&#x27;invalid&#x27;</span>:<span class="string">&#x27;邮箱格式不正确&#x27;</span>,</span><br><span class="line">                             <span class="string">&#x27;required&#x27;</span>: <span class="string">&#x27;邮箱不能为空&#x27;</span></span><br><span class="line">                            &#125;)</span><br><span class="line">    <span class="comment"># 局部钩子</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean_username</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 获取用户名</span></span><br><span class="line">        username = self.cleaned_data.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;666&#x27;</span> <span class="keyword">in</span> username:</span><br><span class="line">            <span class="comment"># 提示前端展示错误信息</span></span><br><span class="line">            <span class="comment"># 提示方式1：</span></span><br><span class="line">            self.add_error(<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;用户名不能包含666&#x27;</span>)</span><br><span class="line">            <span class="comment"># 提示方式2(繁琐，一般不用)：</span></span><br><span class="line">            <span class="comment"># raise ValidationError(&#x27;用户名不能包含666.&#x27;)</span></span><br><span class="line">        <span class="comment"># 将钩子函数钩取出来的数据再放回去</span></span><br><span class="line">        <span class="keyword">return</span> username</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 全局钩子</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 获取两个密码字段</span></span><br><span class="line">        password = self.cleaned_data.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        confirm_password = self.cleaned_data.get(<span class="string">&#x27;confirm_password&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> confirm_password == password:</span><br><span class="line">            self.add_error(<span class="string">&#x27;confirm_password&#x27;</span>,<span class="string">&#x27;两次密码不一致&#x27;</span>)</span><br><span class="line">        <span class="comment"># 校验后将全局钩子钩出来的数据再放回去</span></span><br><span class="line">        <span class="keyword">return</span> self.cleaned_data</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-9dd090849fc6e5ea4c37eaa0cee8e064_1440w.jpg" alt="img"></p>
<h2 id="7、forms组件常见参数"><a href="#7、forms组件常见参数" class="headerlink" title="7、forms组件常见参数"></a>7、forms组件常见参数</h2><p>max_length 和 min_length</p>
<p><strong>label</strong>=’用户名’,设置字段名<br><strong>error_messages</strong>={‘min_length’: ‘密码最少3位’},自定义报错信息<br><strong>initial</strong>=’jack’,默认值<br><strong>required</strong>=False，设置成必填字段</p>
<p><strong>widget</strong>设置属性，如form-control等css属性，<strong>调整样式(多个属性值用空格隔开即可)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">email = forms.EmailField(label=<span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">                             error_messages=&#123;</span><br><span class="line">                                 <span class="string">&#x27;invalid&#x27;</span>: <span class="string">&#x27;邮箱格式不正确&#x27;</span>,</span><br><span class="line">                                 <span class="string">&#x27;required&#x27;</span>: <span class="string">&#x27;邮箱不能为空&#x27;</span></span><br><span class="line">                             &#125;,</span><br><span class="line">                             widget=forms.widgets.EmailInput(attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;form-control c1 c2&#x27;</span>&#125;)</span><br><span class="line">                             )</span><br></pre></td></tr></table></figure>

<p><strong>validators</strong>自定义正则: <strong>支持字段写正则表达式，可以写多个正则一一匹配</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.validators <span class="keyword">import</span> RegexValidator</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span>(<span class="params">Form</span>):</span></span><br><span class="line">phone = forms.CharField(</span><br><span class="line">        validators=[RegexValidator(<span class="string">r&#x27;^[0-9]+$&#x27;</span>, <span class="string">&#x27;请输入数字&#x27;</span>),</span><br><span class="line">                    RegexValidator(<span class="string">r&#x27;^159[0-9]+$&#x27;</span>, <span class="string">&#x27;数字必须以159开头&#x27;</span>)],</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>其他类型渲染：</p>
<p><strong>radio, checkbox, select</strong></p>
<p><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/Dominic-Ji/p/9240365.html">Django Form表单组件 - JasonJi - 博客园www.cnblogs.com</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginForm</span>(<span class="params">forms.Form</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    hobby = forms.MultipleChoiceField(</span><br><span class="line">        choices=((<span class="number">1</span>, <span class="string">&quot;篮球&quot;</span>), (<span class="number">2</span>, <span class="string">&quot;足球&quot;</span>), (<span class="number">3</span>, <span class="string">&quot;双色球&quot;</span>),),</span><br><span class="line">        label=<span class="string">&quot;爱好&quot;</span>,</span><br><span class="line">        initial=[<span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">        widget=forms.widgets.CheckboxSelectMultiple()</span><br><span class="line">    )</span><br><span class="line">keep = forms.ChoiceField(</span><br><span class="line">        label=<span class="string">&quot;是否记住密码&quot;</span>,</span><br><span class="line">        initial=<span class="string">&quot;checked&quot;</span>,</span><br><span class="line">        widget=forms.widgets.CheckboxInput()</span><br><span class="line">    )</span><br><span class="line">hobby = forms.MultipleChoiceField(</span><br><span class="line">        choices=((<span class="number">1</span>, <span class="string">&quot;篮球&quot;</span>), (<span class="number">2</span>, <span class="string">&quot;足球&quot;</span>), (<span class="number">3</span>, <span class="string">&quot;双色球&quot;</span>), ),</span><br><span class="line">        label=<span class="string">&quot;爱好&quot;</span>,</span><br><span class="line">        initial=[<span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">        widget=forms.widgets.SelectMultiple()</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p><strong>针对字段的校验方式：</strong><br>1、最简单的max_length,min_length<br>2、正则validator<br>3、钩子函数</p>
<h2 id="8、forms组件源码"><a href="#8、forms组件源码" class="headerlink" title="8、forms组件源码"></a>8、forms组件源码</h2><p>切入点：form_obj.is_valid()</p>
<p>解释：login时，拿到数据request.POST；进行校验；校验就用is.valid()方法去校验；如果is_valid要返回true的话，那么self.is_bound要为true，self.errors要为false；self.is_bound = data is not None or files is not None；所以只要你传数据了，那么self.is_bound就是true；后面的重点就是这里；def full_clean(self):，后面局部和全局钩子 都是调用的自己写的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 先生成对象，get请求时</span></span><br><span class="line">    form_obj = MyForm()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        <span class="comment"># 获取数据</span></span><br><span class="line">        print(request.POST)</span><br><span class="line">        <span class="comment"># 校验用户数据</span></span><br><span class="line">        MyForm()</span><br><span class="line">        form_obj = MyForm(request.POST)</span><br><span class="line">        <span class="keyword">if</span> form_obj.is_valid():</span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;login.html&#x27;</span>, locals())</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_valid</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns True if the form has no errors. Otherwise, False. If errors are</span></span><br><span class="line"><span class="string">        being ignored, returns False.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.is_bound <span class="keyword">and</span> <span class="keyword">not</span> self.errors</span><br><span class="line"><span class="comment"># 如果is_valid要返回true的话，那么self.is_bound要为true，self.errors要为false</span></span><br><span class="line"><span class="comment">#         self.is_bound = data is not None or files is not None</span></span><br><span class="line"><span class="comment">#    所以只要你传数据了，那么self.is_bound就是true</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">errors</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;Returns an ErrorDict for the data provided for the form&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self._errors <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.full_clean()</span><br><span class="line">        <span class="keyword">return</span> self._errors  </span><br><span class="line"></span><br><span class="line"><span class="comment"># forms组件所有功能基本都出自于该方法：</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">full_clean</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._clean_fields()     <span class="comment"># 校验字段+局部钩子  下划线声明是私有的，python约定的一个下划线也是私有</span></span><br><span class="line">        self._clean_form()        <span class="comment"># 全局钩子</span></span><br><span class="line">        self._post_clean()       <span class="comment">#</span></span><br><span class="line">        </span><br><span class="line">        (<span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_clean_fields</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> name, field <span class="keyword">in</span> self.fields.items(): <span class="comment"># 循环字段名 和 字段对象</span></span><br><span class="line">            <span class="comment"># value_from_datadict() gets the data from the data dictionaries.</span></span><br><span class="line">            <span class="comment"># Each widget type knows how to retrieve its own data, because some</span></span><br><span class="line">            <span class="comment"># widgets split data over several HTML fields.</span></span><br><span class="line">            <span class="keyword">if</span> field.disabled:</span><br><span class="line">                value = self.get_initial_for_field(field, name)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 获取字段名对应的用户数据</span></span><br><span class="line">                value = field.widget.value_from_datadict(self.data, self.files, self.add_prefix(name))</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> isinstance(field, FileField):</span><br><span class="line">                    initial = self.get_initial_for_field(field, name)</span><br><span class="line">                    value = field.clean(value, initial)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    value = field.clean(value)</span><br><span class="line">                self.cleaned_data[name] = value <span class="comment"># 将合法数据添加到clean_data</span></span><br><span class="line">                <span class="keyword">if</span> hasattr(self, <span class="string">&#x27;clean_%s&#x27;</span> % name): <span class="comment"># 利用反射获取局部钩子函数</span></span><br><span class="line">                    value = getattr(self, <span class="string">&#x27;clean_%s&#x27;</span> % name)() <span class="comment"># 局部钩子需要有返回值</span></span><br><span class="line">                    self.cleaned_data[name] = value <span class="comment"># 返回给这里</span></span><br><span class="line">            <span class="keyword">except</span> ValidationError <span class="keyword">as</span> e: <span class="comment"># 异常补货</span></span><br><span class="line">                self.add_error(name, e) <span class="comment"># 添加提示信息</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_clean_form</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cleaned_data = self.clean()  <span class="comment"># 全局钩子需要一个返回值  </span></span><br><span class="line">        <span class="keyword">except</span> ValidationError <span class="keyword">as</span> e:</span><br><span class="line">            self.add_error(<span class="literal">None</span>, e)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> cleaned_data <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                self.cleaned_data = cleaned_data</span><br></pre></td></tr></table></figure>

<h2 id="开始对钩子函数源码详解"><a href="#开始对钩子函数源码详解" class="headerlink" title="开始对钩子函数源码详解"></a>开始对钩子函数源码详解</h2><p>  首先is_valid( )是校验数据的部分，将数据放入is_valid( )开始校验，合格的放在哪里，不合格的放在哪里，因此如果不执行is_valid,是不能执行后面的cleaned_data或者errors，也就是说他是循环每个字段分别去校验，而cleaned_data和errors本质上就是两个字典，用来存放正确的数据和错误的数据。<br> <strong>🌸总结：学form组件最核心的方法是is_valid( ),最重要的源码也是is_valid(),钩子函数也在is_valid( )中。</strong></p>
<ul>
<li>前期准备</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">from django import forms</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span>(<span class="title">forms</span>.<span class="title">Form</span>):</span></span><br><span class="line">    name = forms.CharField(max_length=<span class="number">6</span>)</span><br><span class="line">    password = forms.CharField(max_length=<span class="number">8</span>, min_length=<span class="number">3</span>)</span><br><span class="line">    email = forms.EmailField(required=False)  <span class="comment"># form表单required默认是True</span></span><br><span class="line"></span><br><span class="line">form_obj=MyForm(&#123;<span class="string">&quot;name&quot;</span><span class="symbol">:<span class="string">&quot;wpr&quot;</span></span>,<span class="string">&quot;password&quot;</span><span class="symbol">:<span class="string">&quot;123abc&quot;</span></span>,<span class="string">&quot;email&quot;</span><span class="symbol">:<span class="string">&quot;123@qq.com&quot;</span></span>&#125;)</span><br><span class="line">form_obj.is_valid()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 钩子函数,当前面的校验都通过后才会执行</span></span><br><span class="line">    <span class="comment"># 局部钩子函数,单个字段的校验利用局部钩子函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean_name</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        name = <span class="keyword">self</span>.cleaned_data.get(<span class="string">&#x27;name&#x27;</span>)  <span class="comment"># 首先从校验正确的数据中获取名字</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;666&#x27;</span> <span class="keyword">in</span> <span class="symbol">name:</span>  <span class="comment"># 对名字进行逻辑判断</span></span><br><span class="line">            <span class="keyword">self</span>.add_error(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;光喊666不行&#x27;</span>)  <span class="comment"># 对应name字段名进行提醒</span></span><br><span class="line">        <span class="keyword">return</span> name  </span><br><span class="line">    <span class="comment"># 全局钩子函数，多个字段校验利用全局钩子函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        password = <span class="keyword">self</span>.cleaned_data.get(<span class="string">&#x27;password&#x27;</span>)  <span class="comment"># 从校验通过的字典中取得密码</span></span><br><span class="line">        confirm_password = <span class="keyword">self</span>.cleaned_data.get(<span class="string">&#x27;confirm_password&#x27;</span>)  <span class="comment"># 从校验通过的字典中取得确认密码</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> password == <span class="symbol">confirm_password:</span>  <span class="comment"># 得到数据后进行逻辑判断</span></span><br><span class="line">            <span class="keyword">self</span>.add_error(<span class="string">&#x27;confirm_password&#x27;</span>, <span class="string">&#x27;两次密码不一致&#x27;</span>)  <span class="comment"># 判断后在确认密码后面进行提醒</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.cleaned_data</span><br></pre></td></tr></table></figure>

<ul>
<li>进入is_valid( )查看</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_valid</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Returns True if the form has no errors. Otherwise, False. If errors are</span></span><br><span class="line"><span class="string">    being ignored, returns False.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> self.is_bound <span class="keyword">and</span> <span class="keyword">not</span> self.errors</span><br></pre></td></tr></table></figure>

<p><strong>详解：首先铺陈一个基础，True and True返回的是True,True and False返回的是False。这里and连接两个返回，前面的self.is_bound返回的一定是True，那么is_valid最后返回True还是False取决于errors到底是空字典还是有键值的,而当errors为空字典，说明没有任何错误，那么not 空就是True，如果errors里面有错误的键值，那么就返回False。</strong></p>
<ul>
<li>那么接下来就主要看self.errors里面返回的是什么</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># errors默认为None</span></span><br><span class="line"><span class="keyword">self</span>._errors = None  <span class="comment"># Stores the errors after clean() has been called.</span></span><br><span class="line"></span><br><span class="line">@property</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">errors</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="string">&quot;Returns an ErrorDict for the data provided for the form&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>._errors is <span class="symbol">None:</span></span><br><span class="line">        <span class="keyword">self</span>.full_clean()  <span class="comment"># 因为默认为None,所以继续从这进入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>._errors</span><br></pre></td></tr></table></figure>

<ul>
<li>进入full_clean( )查看</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">full_clean</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    Cleans all of self.data and populates self._errors and</span></span><br><span class="line"><span class="string">    self.cleaned_data.</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">self</span>._errors = ErrorDict()  <span class="comment"># ⚠️原来错误字典是从这里来</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">self</span>.<span class="symbol">is_bound:</span>  <span class="comment"># Stop further processing.</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">self</span>.cleaned_data = &#123;&#125;  <span class="comment"># ⚠️正确字典是从这里来</span></span><br><span class="line">    <span class="comment"># If the form is permitted to be empty, and none of the form data has</span></span><br><span class="line">    <span class="comment"># changed from the initial data, short circuit any validation.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.empty_permitted <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">self</span>.has_changed()<span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>._clean_fields()</span><br><span class="line">    <span class="keyword">self</span>._clean_form()</span><br><span class="line">    <span class="keyword">self</span>._post_clean()</span><br></pre></td></tr></table></figure>

<p><strong>详解：拿到两个初始变量，从逻辑上讲，接下来就是循环当前form类中的所有字段，依次判断输入进来的值和字段规则是否符合，符合就放入cleaned_data字典中，不符合就放入errors字典中。</strong><br> 🐷 tips:看源码时要知道自己该看什么，不要什么都看，只看我们当前逻辑关心的地方</p>
<ul>
<li>⭕️高能！！重要！！那么接下来我们就要看clean_field( ) 校验字段里面是什么<br> ps:clean是校验的意思</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">def _clean_fields(<span class="built_in">self</span>):</span><br><span class="line">    <span class="keyword">for</span> name, field in <span class="built_in">self</span>.fields.items():</span><br><span class="line">        <span class="comment"># value_from_datadict() gets the data from the data dictionaries.</span></span><br><span class="line">        <span class="comment"># Each widget type knows how to retrieve its own data, because some</span></span><br><span class="line">        <span class="comment"># widgets split data over several HTML fields.</span></span><br><span class="line">        <span class="keyword">if</span> field.disabled:</span><br><span class="line">            value = <span class="built_in">self</span>.get_initial_for_field(field, name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            value = field.widget.value_from_datadict(<span class="built_in">self</span>.data, <span class="built_in">self</span>.files, <span class="built_in">self</span>.add_prefix(name))</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> isinstance(field, FileField):</span><br><span class="line">                initial = <span class="built_in">self</span>.get_initial_for_field(field, name)</span><br><span class="line">                value = field.clean(value, initial)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                value = field.clean(value)</span><br><span class="line">            <span class="built_in">self</span>.cleaned_data[name] = value</span><br><span class="line">            <span class="keyword">if</span> hasattr(<span class="built_in">self</span>, <span class="string">&#x27;clean_%s&#x27;</span> % name):</span><br><span class="line">                value = getattr(<span class="built_in">self</span>, <span class="string">&#x27;clean_%s&#x27;</span> % name)()</span><br><span class="line">                <span class="built_in">self</span>.cleaned_data[name] = value</span><br><span class="line">        except ValidationError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">self</span>.add_error(name, e)</span><br></pre></td></tr></table></figure>

<p><strong>详解：</strong><br> <strong>1、self.fields在类实例化时完成赋值，self.fields={“name”:name字段对象,”password”:password字段对象,”email”:email字段对象}，所以name对应的是字段字符串，field对应的是字段对象(也是规则对象)，[比如这里就是name:”name”  field:name或者name:”password” field:password]。</strong></p>
<p><strong>2、往下看到value，这个value指的是传进来的字典的值(比如这里指字典中name的值wpr)。</strong></p>
<p><strong>3、接着是<code>if isinstance(field,FileField)</code>,指的是字段对象是否为文件类型,在这里三个属性分别是CharField，CharField，EmailField，没有涉及到文件类型，所以走<code>value = field.clean(value)</code>。</strong></p>
<p><strong>4、那就来分析<code>value = field.clean(value)</code>指的是用字段对象来校验这个value值，然后将它重新赋值给value，校验通过后加到cleaned_data字典中,name是这个字段字符串，value是这个通过的值，但是如果这里clean校验不通过，就会抛出一个validdation的错误,由于clean是用c语言封装起来的，所以不去深究，只要知道不通过会报错即可。</strong></p>
<p><strong>5、下一句<code>if hasattr(self, &#39;clean_%s&#39; % name):</code> \</strong>⚠️是当上面第一层校验通过后*<em>，再走第二层钩子函数的校验，判断当前类下是否有一个叫 ‘clean_%s’ % name名字的方法，如果有就将这个方法取出加个括号来调用这个方法，这时调用第二层钩子方法，得到一个返回值(⚠️🌸 *</em>敲黑板！！注意这里就是为什么在钩子函数中也要返回的原因，但是如果不写也不会报错，这是因为他已经通过了第一层校验，cleaned_data中已经存了那个名字，所以有时不加也没事，但为了防止版本问题产生不必要的bug，还是写上返回值，严谨！！！**)**<br> 🐷敲黑板：要第一层校验通过才走钩子函数，如果第一层都没通过，钩子是没用的！！！</p>
<p><strong>6、无论第一次还是第二次校验不通过就会抛出异常<code>except ValidationError as e:self.add_error(name, e)</code>,把键和错误信息放入errors中。</strong></p>
<p><strong>7、但是这时有个疑问，从逻辑上讲如果第一层通过了,cleaned_data已经存了正确的键值，那如果第二层不通过，cleaned_data就不应该有这个键值，那么关键就在这个add_error( )中。</strong></p>
<p><strong>8、那我们就进入add_error( )中去一看究竟：</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">注意找有用的信息！！</span><br><span class="line"><span class="keyword">for</span> field, error_list in <span class="built_in">error</span>.items():</span><br><span class="line">    <span class="keyword">if</span> field not in <span class="built_in">self</span>.errors:</span><br><span class="line">        <span class="keyword">if</span> field != NON_FIELD_ERRORS <span class="keyword">and</span> field not in <span class="built_in">self</span>.fields:</span><br><span class="line">            raise ValueError(</span><br><span class="line">                <span class="string">&quot;&#x27;%s&#x27; has no field named &#x27;%s&#x27;.&quot;</span> % (<span class="built_in">self</span>.<span class="keyword">__class__</span>.__name__, field))</span><br><span class="line">        <span class="keyword">if</span> field == NON_FIELD_ERRORS:</span><br><span class="line">            <span class="built_in">self</span>._errors[field] = <span class="built_in">self</span>.error_class(error_class=<span class="string">&#x27;nonfield&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">self</span>._errors[field] = <span class="built_in">self</span>.error_class()</span><br><span class="line">    <span class="built_in">self</span>._errors[field].extend(error_list)</span><br><span class="line">    <span class="keyword">if</span> field in <span class="built_in">self</span>.cleaned_data:   ⚠️<span class="comment"># 关键就在这一句，如果字段对象已经在cleaned_data中</span></span><br><span class="line">        del <span class="built_in">self</span>.cleaned_data[field]   <span class="comment"># 那么就从cleaned_data中删除这个字段</span></span><br></pre></td></tr></table></figure>

<p><strong>9、那从整体看是通过try except来控制，如果正确放入cleaned_data,如果错误放入errors中。</strong></p>
<p><strong>10、最后只要errors字典里面有键值，就返回False。</strong></p>
<p>🐷 ps:可以将字段对象理解为字段规则/规则对象；<br>   字典是是无序的(.items)，但在最新版本中中将字典变成有序的了，有一个OrderedDict模块，这个字典保证我们的键值是有序的，在我们定义的时候谁是第一个键值，在我们以后用的时候他都是第一个，这就保证了我们校验的时候是有序的来，先校验第一个字段，再依次校验，如果是无序的，for循环的时候都不知道要校验哪一个；</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">items</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="string">&quot;D.items() -&gt; a set-like object providing a view on D&#x27;s items&quot;</span></span><br><span class="line">    <span class="keyword">return</span> _OrderedDictItemsView(<span class="keyword">self</span>)  <span class="comment"># 变成有序的了</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>16-Django-Cookie-session-CBV</title>
    <url>/posts/31634.html</url>
    <content><![CDATA[<p>Django Cookie\session\CBV添加装饰器</p>
<a id="more"></a>

<h2 id="1、cookie与session"><a href="#1、cookie与session" class="headerlink" title="1、cookie与session"></a>1、cookie与session</h2><p>网站没有保存用户功能的需求，所有用户访问返回结果都是一样的：新闻、博客、文章。<br>需要保存用户信息的网站：淘宝、支付宝</p>
<p><strong>cookie：保存在客户端浏览器上的信息都可以称之为cookie,一般以k:v键值对存储。(**当用户第一次登陆成功之后，将用户的用户名密码返回给用户浏览器，让用户浏览器保存在本地；之后访问服务端的时候浏览器自动将保存在浏览器上的用户名和密码发送给服务器，服务器端获取之后会自动验证。</strong>)**</p>
<p><strong>session：数据是保存在服务端的，一般也是以k:v键值对存储。</strong>(当用户登录之后，服务器产生一个随机字符串 <strong>Session ID</strong> 给客户端浏览器保存着，之后访问服务端的时候都带着该随机字符串<strong>Session ID</strong>，服务端去数据库中对比是否有相应的随机字符串从而获取到对应的用户信息。)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">随机字符串1： 用户信息1</span><br><span class="line">随机字符串2： 用户信息2</span><br><span class="line">随机字符串3： 用户信息3</span><br></pre></td></tr></table></figure>

<p><font color=red>总结:</font></p>
<ul>
<li><ol>
<li>Cookie 就是保存在客户端浏览器上的信息</li>
</ol>
</li>
<li><ol start="2">
<li>session就是保存在服务端上的信息</li>
</ol>
</li>
<li><ol start="3">
<li><strong>session是基于cookie工作的</strong>（其实大部分的保存用户状态的操作都需要用到cookie)</li>
</ol>
</li>
</ul>
<p><font color=red>补充</font>: 如果客户端禁用了cookie，如果识别用户；方法：URL重写，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，在 url 中传递 session_id，服务端据此来识别用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COOKIE和SESSION有什么区别？</span><br><span class="line"></span><br><span class="line">1. 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。</span><br><span class="line">2. 思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid&#x3D;xxxxx 这样的参数，服务端据此来识别用户。</span><br><span class="line">3. Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</span><br></pre></td></tr></table></figure>



<p><strong>token：服务端不再保存数据，登录成功之后，用自己定制的加密方式对内容进行加密处理。将加密后的结果 ||| 拼接在内容后面，一起发送给客户端浏览器存储，当用户第二次登录时，服务端自动切取前面一段信息再次加密，加密后与浏览器之前存储的拼接内容尾部的密文一起比对校验。</strong></p>
<h2 id="2、Django操作cookie"><a href="#2、Django操作cookie" class="headerlink" title="2、Django操作cookie"></a>2、Django操作cookie</h2><p>虽然cookie是服务端告诉客户端浏览器需要保存内容，但是客户端浏览器可以选择拒绝保存，如果浏览器选择禁止保存cookie，那么只要是需要记录用户状态的网站登录功能都无法使用了。</p>
<p><strong>设置cookie：obj.set_cookie(key,value)</strong><br>*<em>加盐处理：obj.set_signed_cookie(key,value,salt=’盐’)**</em><br><strong>获取cookie：request.COOKIES.get(key)</strong><br><strong>request.get_signed_cookie(key,salt=’盐’)</strong><br><strong>设置cookie超时时间：</strong>obj.set_cookie(‘username’,’jack’,max_<em>age=3或者expires=3)</em><br><strong>删除cookie：obj.delete_cookie(‘username’)</strong></p>
<p>IE 浏览器识别expire</p>
<p><strong>都用max_age</strong></p>
<h3 id="cookie的原理"><a href="#cookie的原理" class="headerlink" title="cookie的原理"></a>cookie的原理</h3><p>cookie的工作原理是：由服务器产生内容，浏览器收到请求后保存在本地；当浏览器再次访问时，浏览器会自动带上Cookie，这样服务器就能通过Cookie的内容来判断这个是“谁”了。</p>
<h3 id="Cookie规范"><a href="#Cookie规范" class="headerlink" title="Cookie规范"></a>Cookie规范</h3><ul>
<li>Cookie大小上限为4KB；</li>
<li>一个服务器最多在客户端浏览器上保存20个Cookie；</li>
<li>一个浏览器最多保存300个Cookie；</li>
</ul>
<p>上面的数据只是HTTP的Cookie规范，但在浏览器大战的今天，一些浏览器为了打败对手，为了展现自己的能力起见，可能对Cookie规范“扩展”了一些，例如每个Cookie的大小为8KB，最多可保存500个Cookie等！但也不会出现把你硬盘占满的可能！<br>注意，不同浏览器之间是不共享Cookie的。也就是说在你使用IE访问服务器时，服务器会把Cookie发给IE，然后由IE保存起来，当你在使用FireFox访问服务器时，不可能把IE保存的Cookie发送给服务器。</p>
<h3 id="Cookie的覆盖"><a href="#Cookie的覆盖" class="headerlink" title="Cookie的覆盖"></a>Cookie的覆盖</h3><p>如果服务器端发送重复的Cookie那么会覆盖原有的Cookie，例如客户端的第一个请求服务器端发送的Cookie是：Set-Cookie: a=A；第二请求服务器端发送的是：Set-Cookie: a=AA，那么客户端只留下一个Cookie，即：a=AA。</p>
<h3 id="在浏览器中查看cookie"><a href="#在浏览器中查看cookie" class="headerlink" title="在浏览器中查看cookie"></a>在浏览器中查看cookie</h3><p>浏览器中按F12，点network—cookies就能看到</p>
<h2 id="操作Cookie"><a href="#操作Cookie" class="headerlink" title="操作Cookie"></a>操作Cookie</h2><h3 id="获取Cookie"><a href="#获取Cookie" class="headerlink" title="获取Cookie"></a>获取Cookie</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request.COOKIES[&#39;key&#39;]</span><br><span class="line">request.get_signed_cookie(key, default&#x3D;RAISE_ERROR, salt&#x3D;&#39;&#39;, max_age&#x3D;None)</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li>default: 默认值</li>
<li>salt: 加密盐</li>
<li>max_age: 后台控制过期时间</li>
</ul>
<h3 id="设置Cookie"><a href="#设置Cookie" class="headerlink" title="设置Cookie"></a>设置Cookie</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rep &#x3D; HttpResponse(...)</span><br><span class="line">rep ＝ render(request, ...)</span><br><span class="line"></span><br><span class="line">rep.set_cookie(key,value)</span><br><span class="line">rep.set_signed_cookie(key,value,salt&#x3D;&#39;加密盐&#39;)</span><br></pre></td></tr></table></figure>



<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">key, 键</span><br><span class="line">value=’’, 值</span><br><span class="line">max_age=<span class="literal">None</span>, 超时时间 cookie需要延续的时间（以秒为单位）如果参数是\ <span class="literal">None</span>`` ，这个cookie会延续到浏览器关闭为止</span><br><span class="line">expires=<span class="literal">None</span>, 超时时间(IE requires expires, so set it <span class="keyword">if</span> hasn’t been already.)</span><br><span class="line">path=’/‘, Cookie生效的路径，/ 表示根路径，特殊的：根路径的cookie可以被任何url的页面访问，浏览器只会把cookie回传给带有该路径的页面，这样可以避免将cookie传给站点中的其他的应用。</span><br><span class="line">domain=<span class="literal">None</span>, Cookie生效的域名 你可用这个参数来构造一个跨站cookie。如， domain=”.example.com”所构造的cookie对下面这些站点都是可读的：www.example.com 、 www2.example.com 和an.other.sub.domain.example.com 。如果该参数设置为 <span class="literal">None</span> ，cookie只能由设置它的站点读取</span><br><span class="line">secure=<span class="literal">False</span>, 浏览器将通过HTTPS来回传cookie</span><br><span class="line">httponly=<span class="literal">False</span> 只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖）</span><br></pre></td></tr></table></figure>

<h3 id="删除Cookie"><a href="#删除Cookie" class="headerlink" title="删除Cookie"></a>删除Cookie</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def logout(request):</span><br><span class="line">    rep &#x3D; redirect(&quot;&#x2F;login&#x2F;&quot;)</span><br><span class="line">    rep.delete_cookie(&quot;user&quot;)  # 删除用户浏览器上之前设置的usercookie值</span><br><span class="line">    return rep</span><br></pre></td></tr></table></figure>





<p>urls.py文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r&#x27;^admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    url(<span class="string">r&#x27;^login/&#x27;</span>,views.login),</span><br><span class="line">    url(<span class="string">r&#x27;^home/&#x27;</span>,views.home),</span><br><span class="line">    url(<span class="string">r&#x27;^index/&#x27;</span>,views.index),</span><br><span class="line">    url(<span class="string">r&#x27;^func/&#x27;</span>,views.func),</span><br><span class="line">    <span class="comment"># 注销功能</span></span><br><span class="line">    url(<span class="string">r&#x27;^logout/&#x27;</span>,views.logout)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>views.py文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,HttpResponse,redirect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_auth</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">request,*args,**kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 拿到用户上一次想访问的url(跳转之前所访问的url)</span></span><br><span class="line">        target_url = request.get_full_path()</span><br><span class="line">        <span class="keyword">if</span> request.COOKIES.get(<span class="string">&#x27;username&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> func(request,*args,**kwargs)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&#x27;/login/?next=&#123;&#125;&#x27;</span>.format(target_url))</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method==<span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        username = request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        password = request.POST.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> username==<span class="string">&#x27;jack&#x27;</span> <span class="keyword">and</span> password==<span class="string">&#x27;123&#x27;</span>:</span><br><span class="line">            <span class="comment"># 获取用户跳转前访问的url</span></span><br><span class="line">            target_url = request.GET.get(<span class="string">&#x27;next&#x27;</span>)  <span class="comment"># 这个结果有可能是None</span></span><br><span class="line">            <span class="keyword">if</span> target_url:</span><br><span class="line">                obj = redirect(target_url)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 保存用户登录状态</span></span><br><span class="line">                obj = redirect(<span class="string">&#x27;/home/&#x27;</span>)</span><br><span class="line">            <span class="comment"># 让浏览器记录cookie数据</span></span><br><span class="line">            obj.set_cookie(<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;jack&#x27;</span>,max_age=<span class="number">3</span>,expires=<span class="number">3</span>)</span><br><span class="line">            <span class="comment"># max_age设置超时时间，这里设置的是3秒后过期,expires参数主要是针对IE浏览器</span></span><br><span class="line">            <span class="comment"># 如果登陆成功，则跳转到一个登陆成功之后才能看到的页面</span></span><br><span class="line">            <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;login.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@login_auth</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 获取cookie信息，判断是否正确</span></span><br><span class="line">    <span class="keyword">if</span> request.COOKIES.get(<span class="string">&#x27;username&#x27;</span>)==<span class="string">&#x27;jack&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;home page for logging user!&#x27;</span>)</span><br><span class="line">    <span class="comment"># 没有登录信息应该跳转到登录页面</span></span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;/login/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@login_auth</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.COOKIES.get(<span class="string">&#x27;username&#x27;</span>)==<span class="string">&#x27;jack&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;func page for logging user!&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;/login/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@login_auth</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout</span>(<span class="params">request</span>):</span></span><br><span class="line">    obj = redirect(<span class="string">&#x27;/login/&#x27;</span>)</span><br><span class="line">    obj.delete_cookie(<span class="string">&#x27;username&#x27;</span>)  <span class="comment"># 删除cookie(注销功能)</span></span><br><span class="line">    <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure>

<p>login.html页面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>username:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>password:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1qC4y1s71m?p=834">Django操作cookiewww.bilibili.com<img src="https://pic2.zhimg.com/v2-e6cdf00518a61ad1b907ca86ddfe4439_180x120.jpg" alt="图标"></a></p>
<h2 id="3、session操作"><a href="#3、session操作" class="headerlink" title="3、session操作"></a>3、session操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">session执行原理</span><br><span class="line"></span><br><span class="line">1.请求--&gt;form表单提交数据，视图函数里面request.session[&#x27;name&#x27;] = &#x27;lqz&#x27;;</span><br><span class="line">2.这个时候什么都没做，触发setitem方法； 视图函数结束之后return Httpresponse--&gt;views结束之后经过中间件process_response</span><br><span class="line">3.经过中间件的process_response方法 ---》 (先delete cookie,  然后set cookie) ------&gt; 原因是拿到request.session对象的时候；先看有没有记录；如果没有，这就是第一次---&gt; 如果是第一次，生成一个随机字符串-- -&gt; 把这个值加密之后 存入表.过期时间存入表。</span><br><span class="line"><span class="number">4.</span> 把这个随机字符串返回回去   cookie : (key值是session_id)session_id=随机字符串(value值随机字符串)</span><br><span class="line"><span class="number">5.</span> 浏览器保存</span><br><span class="line"><span class="number">6.</span> 再发请求 带着cookie，根据通过中间件解析 把cookie的 value值(随机字符串)取出来，然后转成request.session对象，放到reuquest里面传给视图。  process_request印证了，就是去cookie里面取出session_key,实例化得到一个sessionstore对象。</span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>session数据是保存在服务端的，给客户端返回的是一个随机字符串(<strong>sessionid键: value随机字符串</strong>)</p>
<p>默认情况下操作session时需要Django默认创建的一张表django_session(在运行数据库迁移命令后，点击db.sqlite3就能看到),django_session表中的数据条数是取决于浏览器的，同一个计算机上同一个浏览器只会有一条数据生效，用另一个浏览器访问就又会生成一条数据，当session过期的时候可能会短暂的出现多条数据对应一个浏览器，该现象不会持续很久，内部会自动识别过期的数据并清除。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-af37ca4d054ae9fb34eb1dd93b6b621f_1440w.png" alt="img"></p>
<p><font color=red>Django默认session的过期时间是14天。</font></p>
<h4 id="Django中Session相关方法"><a href="#Django中Session相关方法" class="headerlink" title="Django中Session相关方法"></a>Django中Session相关方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取、设置、删除Session中数据</span></span><br><span class="line">request.session[<span class="string">&#x27;k1&#x27;</span>]   （中括号放值会触发__setitem__方法）</span><br><span class="line">request.session.get(<span class="string">&#x27;k1&#x27;</span>,<span class="literal">None</span>)  <span class="comment"># 获取</span></span><br><span class="line">request.session[<span class="string">&#x27;k1&#x27;</span>] = <span class="number">123</span>    设置session  数据就是session_key = 随机字符串  session_data: &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">123</span>&#125;</span><br><span class="line">request.session.setdefault(<span class="string">&#x27;k1&#x27;</span>,<span class="number">123</span>) <span class="comment"># 存在则不设置</span></span><br><span class="line"><span class="keyword">del</span> request.session[<span class="string">&#x27;k1&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有 键、值、键值对</span></span><br><span class="line">request.session.keys()</span><br><span class="line">request.session.values()</span><br><span class="line">request.session.items()</span><br><span class="line">request.session.iterkeys()</span><br><span class="line">request.session.itervalues()</span><br><span class="line">request.session.iteritems()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会话session的key</span></span><br><span class="line">request.session.session_key   <span class="comment"># 这个就是那个随机字符春</span></span><br><span class="line">request.session.save() 保存</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有Session失效日期小于当前日期的数据删除</span></span><br><span class="line">request.session.clear_expired()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查会话session的key在数据库中是否存在</span></span><br><span class="line">request.session.exists(<span class="string">&quot;session_key&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除当前会话的所有Session数据(只删数据库)</span></span><br><span class="line">request.session.delete()</span><br><span class="line">　　</span><br><span class="line"><span class="comment"># 删除当前的会话数据并删除会话的Cookie（数据库和cookie都删）。</span></span><br><span class="line">request.session.flush() </span><br><span class="line">    这用于确保前面的会话数据不可以再次被用户的浏览器访问</span><br><span class="line">    例如，django.contrib.auth.logout() 函数中就会调用它。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置会话Session和Cookie的超时时间</span></span><br><span class="line">request.session.set_expiry(value)</span><br><span class="line">    * 如果value是个整数，session会在些秒数后失效。</span><br><span class="line">    * 如果value是个datatime或timedelta，session就会在这个时间后失效。</span><br><span class="line">    * 如果value是<span class="number">0</span>,用户关闭浏览器session就会失效。</span><br><span class="line">    * 如果value是<span class="literal">None</span>,session会依赖全局session失效策略。</span><br></pre></td></tr></table></figure>

<p>Django中使用session时，做的事：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成随机字符串</span></span><br><span class="line"><span class="comment"># 写浏览器cookie -&gt; session_id: 随机字符串</span></span><br><span class="line"><span class="comment"># 写到服务端session：</span></span><br><span class="line">    <span class="comment"># &#123;</span></span><br><span class="line">    <span class="comment">#     &quot;随机字符串&quot;: &#123;&#x27;user&#x27;:&#x27;alex&#x27;&#125;</span></span><br><span class="line">    <span class="comment"># &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>有时候如果多个视图函数都需要使用到一些数据的话，可以考虑保存到django_session表中，方便后续使用。eg：登录验证码。</strong></p>
<p><strong>session是保存在服务器端，但是session的保存位置提供了5种选择：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 数据库Session</span><br><span class="line">SESSION_ENGINE = <span class="string">&#x27;django.contrib.sessions.backends.db&#x27;</span>   <span class="comment"># 引擎（默认）</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 缓存Session</span><br><span class="line">SESSION_ENGINE = <span class="string">&#x27;django.contrib.sessions.backends.cache&#x27;</span>  <span class="comment"># 引擎</span></span><br><span class="line">SESSION_CACHE_ALIAS = <span class="string">&#x27;default&#x27;</span>                            <span class="comment"># 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 文件Session</span><br><span class="line">SESSION_ENGINE = <span class="string">&#x27;django.contrib.sessions.backends.file&#x27;</span>    <span class="comment"># 引擎</span></span><br><span class="line">SESSION_FILE_PATH = <span class="literal">None</span>                                    <span class="comment"># 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir() </span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 缓存+数据库</span><br><span class="line">SESSION_ENGINE = <span class="string">&#x27;django.contrib.sessions.backends.cached_db&#x27;</span>        <span class="comment"># 引擎</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 加密Cookie Session</span><br><span class="line">SESSION_ENGINE = <span class="string">&#x27;django.contrib.sessions.backends.signed_cookies&#x27;</span>   <span class="comment"># 引擎</span></span><br></pre></td></tr></table></figure>

<p><strong>session流程解析：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gj6rmwmekdj315w0jkq6j.jpg" alt="image-20200928230826583"></p>
<p>urls.py文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># session操作</span></span><br><span class="line">url(<span class="string">r&#x27;^set_session/&#x27;</span>,views.set_session),</span><br><span class="line">url(<span class="string">r&#x27;^get_session/&#x27;</span>,views.get_session),</span><br><span class="line">url(<span class="string">r&#x27;^del_session/&#x27;</span>,views.del_session)</span><br></pre></td></tr></table></figure>

<p>views.py文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_session</span>(<span class="params">request</span>):</span></span><br><span class="line">    request.session[<span class="string">&#x27;hobby&#x27;</span>]=<span class="string">&#x27;learning&#x27;</span></span><br><span class="line">    <span class="comment"># request.session[&#x27;hobby1&#x27;]=&#x27;learning1&#x27;</span></span><br><span class="line">    <span class="comment"># request.session[&#x27;hobby2&#x27;]=&#x27;learning2&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># set_expiry后可以放四种类型的参数：</span></span><br><span class="line">    <span class="comment"># 1、整数，多少秒</span></span><br><span class="line">    <span class="comment"># 2、日期对象，到指定日期就失效</span></span><br><span class="line">    <span class="comment"># 3、数字0，一旦当前浏览器窗口关闭会立即失效</span></span><br><span class="line">    <span class="comment"># 4、不写，失效时间取决于Django内部全局session默认失效时间14天</span></span><br><span class="line">    request.session.set_expiry()</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    设置session内部发生的事情：</span></span><br><span class="line"><span class="string">    1、Django内部自动生成一个随机字符串</span></span><br><span class="line"><span class="string">    2、Django内部自动将随机字符串和对应的数据存储到django_session表中</span></span><br><span class="line"><span class="string">       2.1、在内存中产生操作数据的缓存</span></span><br><span class="line"><span class="string">       2.2、在响应结果Django中间件的时候才真正的操作数据库</span></span><br><span class="line"><span class="string">    3、将产生的随机字符串返回给客户端浏览器保存</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;hhh&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_session</span>(<span class="params">request</span>):</span></span><br><span class="line">    print(request.session.get(<span class="string">&#x27;hobby&#x27;</span>))</span><br><span class="line">    <span class="comment"># print(request.session)</span></span><br><span class="line">    <span class="comment"># print(request.session.get(&#x27;hobby&#x27;))</span></span><br><span class="line">    <span class="comment"># print(request.session.get(&#x27;hobby1&#x27;))</span></span><br><span class="line">    <span class="comment"># print(request.session.get(&#x27;hobby2&#x27;))</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    获取session内部发生的事情：</span></span><br><span class="line"><span class="string">    1、自动从浏览器请求中获取session_id对应的随机字符串（中间件）</span></span><br><span class="line"><span class="string">    2、用该随机字符串去django_session表中查找对应的数据</span></span><br><span class="line"><span class="string">    3、如果有匹配的数据，则将对应的数据取出并以字典的形式封装到request.session中，如果没有匹配的数据，则request.session.get()返回none</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;哈哈哈&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">del_session</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># request.session.delete() # 只删客户端；服务端一段时间后会自动删除</span></span><br><span class="line">    request.session.flush()</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;清除session：浏览器和服务端都清空&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1qC4y1s71m?p=835">session操作www.bilibili.com</a><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/Dominic-Ji/p/10718365.html">Cookie Session和自定义分页www.cnblogs.com<img src="https://pic3.zhimg.com/v2-c5df15de4ad2fbb6cc35d9556e898ca6_180x120.jpg" alt="图标"></a></p>
<h2 id="4、视图函数CBV添加装饰器的三种方式-method-decorator"><a href="#4、视图函数CBV添加装饰器的三种方式-method-decorator" class="headerlink" title="4、视图函数CBV添加装饰器的三种方式(method_decorator)"></a>4、视图函数CBV添加装饰器的三种方式(method_decorator)</h2><p>urls.py文件：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># CBV添加装饰器</span><br><span class="line">url(r&#x27;^mylogin/&#x27;,views.MyLogin.as_view())</span><br></pre></td></tr></table></figure>

<p>views.py文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">CBV中Django不建议你直接给类的方法加装饰器</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 装饰器方式2,可以针对不同的方法添加不同的装饰器，扩展性强：</span></span><br><span class="line"><span class="comment"># @method_decorator(login_auth,name=&#x27;get&#x27;)</span></span><br><span class="line"><span class="comment"># @method_decorator(login_auth,name=&#x27;post&#x27;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLogin</span>(<span class="params">View</span>):</span></span><br><span class="line">    <span class="comment"># 装饰器方式3：它会直接作用于当前类里面的所有方法</span></span><br><span class="line"><span class="meta">    @method_decorator(login_auth)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span>(<span class="params">self, request, *args, **kwargs</span>):</span>   <span class="comment"># 重写dispatch方法</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 装饰器方式1：</span></span><br><span class="line">    <span class="comment"># @method_decorator(login_auth)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;get请求&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;post请求&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>17-Django中间件csrf&amp;&amp;importlib模快</title>
    <url>/posts/30417.html</url>
    <content><![CDATA[<p>Django中间件/csrf  - importlib模块补充</p>
<a id="more"></a>

<h2 id="1、Django中间件"><a href="#1、Django中间件" class="headerlink" title="1、Django中间件"></a>1、Django中间件</h2><p>Django自带7个中间件，每个中间件都有各自对应的功能，并且Django还支持自定义中间件。<br>例如在用Django开发项目时，只要是涉及到全局相关的功能都可以使用中间件方便地完成。eg：全局用户身份校验、全局用户权限校验、全局用户访问频率校验。</p>
<p><strong>Django中间件是Django门户：</strong><br><strong>请求来的时候，需要先经过中间件才能到达urls.py继续匹配</strong><br><strong>请求走的时候，也需要经过中间件才能真正离开Django后端</strong></p>
<p>Django请求生命周期图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-62f29bbc290309ef43e001a0f1f66457_1440w.jpg" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-88f8de70fb56ea07ea7ce5d5b054e2fe_1440w.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># from django.middleware.security import SecurityMiddleware</span><br><span class="line">MIDDLEWARE &#x3D; [</span><br><span class="line">    &#39;django.middleware.security.SecurityMiddleware&#39;, # 相当于from django.middleware.security import SecurityMiddleware,用字符串也可以导模块。</span><br><span class="line">    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.common.CommonMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,</span><br><span class="line">    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;, # 权限认证相关</span><br><span class="line">    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Django支持程序员自定义中间件并且提供了5个可以自定义的方法：</p>
</blockquote>
<p><strong>1、必须掌握</strong>：<br><strong>process_request</strong>：<br>1、请求来的时候需要经过每一个中间件里面的process_request方法，经过的顺序是按照配置文件中注册的中间件从上往下的顺序一次执行<br>2、如果中间件里面没有定义，则直接跳过执行下一个<br>3、如果该方法返回了HTTPResponse对象，那么请求将不再继续往后执行，而是原路返回(类似于校验失败不允许访问)<br>process_request方法就是用来做全局相关的所有限制功能。</p>
<p>*<em>process_response**</em>：<br>1、响应走的时候需要经过每一个中间件里面的process_response方法，该方法有两个额外的参数：request,response<br>2、该方法必须返回一个HTTPResponse对象(替换浏览器原有的HttpResponse对象)，默认返回的就是形参response<br>3、顺序按照配置文件中注册了的中间件从下往上依次经过，若没有定义，则跳过;有定义，继续执行。</p>
<p><strong>如果在第一个process_request方法就已经返回了HttpResponse对象，那么响应走的时候是直接走同级别的process_response返回。(flask框架中也有类似的中间件，但是flask中只要返回响应就必须将所有类似于process_response的功能方法全都走一遍)</strong></p>
<p>只要形参中带有response方法，那么该方法就必须返回response或者HTTPResponse对象。</p>
<p><strong>2、了解即可</strong><br><strong>process_view</strong>：<br>路由匹配成功之后，执行视图函数之前，会自动执行中间件里面的该方法。</p>
<p>顺序是按照配置文件中注册中间件从上往下的顺序依次执行。</p>
<p><strong>process_template_response</strong>:<br>返回的HttpResponse对象有render属性的时候才会触发。顺序是按照从下往上依次经过。</p>
<p><strong>process_exception</strong>：<br>当视图函数中出现异常情况会触发。</p>
<blockquote>
<p>如何自定义中间件</p>
</blockquote>
<p>1、在项目名或应用名下创建一个任意名称的文件夹<br>2、在该文件夹内创建一个任意名称的py文件</p>
<p><img src="https://pic3.zhimg.com/80/v2-054ef9637c4f7cfbd1fb8995b4797ae6_1440w.jpg" alt="img"></p>
<p>3、在该py文件内需要书写类(这个类必须继承MiddlewareMixin)，然后在这个类里面就可以自定义5个方法了(用几个写几个)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMiddleware1</span>(<span class="params">MiddlewareMixin</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;第一个自定义中间件中的process_request方法&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;第一个自定义中间件中的process_request方法返回的字符串&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span>(<span class="params">self,request,response</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        :param request:</span></span><br><span class="line"><span class="string">        :param response:是Django后端返回给浏览器的内容</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        print(<span class="string">&#x27;第一个自定义中间件中的process_response方法&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span>(<span class="params">self,request,view_name,*args,**kwargs</span>):</span></span><br><span class="line">        print(view_name,args,kwargs)</span><br><span class="line">        print(<span class="string">&#x27;第一个自定义中间件中的process_view方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_template_response</span>(<span class="params">self,request,response</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;第一个自定义中间件中的process_template_response方法&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span>(<span class="params">self,request,exception</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;第一个自定义中间件中的process_exception方法&#x27;</span>)</span><br><span class="line">        print(exception)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMiddleware2</span>(<span class="params">MiddlewareMixin</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;第二个自定义中间件中的process_request方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span>(<span class="params">self,request,response</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;第二个自定义中间件中的process_response方法&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;hello world2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span>(<span class="params">self,request,view_name,*args,**kwargs</span>):</span></span><br><span class="line">        print(view_name,args,kwargs)</span><br><span class="line">        print(<span class="string">&#x27;第二个自定义中间件中的process_view方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_template_response</span>(<span class="params">self,request,response</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;第二个自定义中间件中的process_template_response方法&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span>(<span class="params">self,request,exception</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;第二个自定义中间件中的process_exception方法&#x27;</span>)</span><br><span class="line">        print(exception)</span><br></pre></td></tr></table></figure>

<p>views.py文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;视图函数index&#x27;</span>)</span><br><span class="line">    obj = HttpResponse(<span class="string">&#x27;index&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render</span>():</span></span><br><span class="line">        print(<span class="string">&#x27;内部的render&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">    obj.render = render</span><br><span class="line">    <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure>

<p>4、需要将类的路径以字符串的形式注册到settings.py配置文件中才能生效</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># from django.middleware.security import SecurityMiddleware</span></span><br><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>, <span class="comment"># 相当于from django.middleware.security import SecurityMiddleware,用字符串也可以导模块。</span></span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>, <span class="comment"># 权限认证相关</span></span><br><span class="line">    <span class="string">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,</span><br><span class="line">    <span class="comment"># 注册自己的中间件(在应用下创建的中间件，路径有提示，项目下创建的，没有提示)</span></span><br><span class="line">    <span class="string">&#x27;app01.mymiddleware.mydd.MyMiddleware1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;app01.mymiddleware.mydd.MyMiddleware2&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h3 id="csrf攻击过程"><a href="#csrf攻击过程" class="headerlink" title="csrf攻击过程"></a>csrf攻击过程</h3><p>1.用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A;</p>
<p>2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A;</p>
<p>3.用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B;</p>
<p>4.网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A;</p>
<p>5.浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。</p>
<h3 id="在django防御csrf攻击"><a href="#在django防御csrf攻击" class="headerlink" title="在django防御csrf攻击"></a>在django防御csrf攻击</h3><p>在客户端页面上添加csrftoken, 服务器端进行验证，服务器端验证的工作通过’django.middleware.csrf.CsrfViewMiddleware’这个中间层来完成。</p>
<p>在django当中防御csrf攻击的方式有两种</p>
<p>1.在表单当中附加csrftoken</p>
<p> 2.通过request请求中添加X-CSRFToken请求头。注意:Django默认对所有的POST请求都进行csrftoken验证，若验证失败则403错误侍候。</p>
<h3 id="其他csrf-防御途径"><a href="#其他csrf-防御途径" class="headerlink" title="其他csrf 防御途径"></a>其他csrf 防御途径</h3><h4 id="1-Referer-HTTP请求完整来源路径（不完善）"><a href="#1-Referer-HTTP请求完整来源路径（不完善）" class="headerlink" title="1. Referer: HTTP请求完整来源路径（不完善）"></a>1. Referer: HTTP请求完整来源路径（不完善）</h4><h4 id="2-Origin-CORS-中的请求头，当跨域访问时，会携带此请求头（不完善）"><a href="#2-Origin-CORS-中的请求头，当跨域访问时，会携带此请求头（不完善）" class="headerlink" title="2. Origin: CORS 中的请求头，当跨域访问时，会携带此请求头（不完善）"></a>2. Origin: CORS 中的请求头，当跨域访问时，会携带此请求头（不完善）</h4><h4 id="3-token-校验（常用方式）"><a href="#3-token-校验（常用方式）" class="headerlink" title="3. token 校验（常用方式）"></a>3. <strong>token 校验（常用方式）</strong></h4><p>补充：</p>
<p>  token 校验之所以能防御 csrf，是因为相信浏览器的同源策略。为什么这么说？因为只有在同源的情况下，页面才能进行脚本操作和使用 js 获取 cookie 的操作，才能获取到 token。也就是说第三方网站是没有办法拿到 token 的。只有真正有权限的网站或页面才有办法取到 token，并将 token 传到服务端。所以服务端默认带有相应 token 的请求都是合法的请求。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/3/16cf7c97203ae9ea~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<p>浏览器中有页面或网站向某个域名发送请求时，其请求都会自动带上该域名下的所有 cookie。</p>
<h2 id="2、csrf跨站请求伪造"><a href="#2、csrf跨站请求伪造" class="headerlink" title="2、csrf跨站请求伪造"></a>2、csrf跨站请求伪造</h2><p>跟钓鱼网站本质：针对对方账户，只给用户提供一个没有name属性的普通input框，然后在内部隐藏一个写好name和value的input框。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">views.py:</span><br><span class="line">def transfer(request):</span><br><span class="line">    if request.method==&#x27;POST&#x27;:</span><br><span class="line">        username = request.POST.get(&#x27;username&#x27;)</span><br><span class="line">        targetuser = request.POST.get(&#x27;targetuser&#x27;)</span><br><span class="line">        money = request.POST.get(&#x27;money&#x27;)</span><br><span class="line">        print(&#x27;&#123;&#125;给用户&#123;&#125;转账&#123;&#125;元&#x27;.format(username,targetuser,money))</span><br><span class="line">    return render(request,&#x27;transfer.html&#x27;)</span><br><span class="line"></span><br><span class="line">正常网站：</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>转账网站<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>username:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>targetuser:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;targetuser&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>money:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;money&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">钓鱼网站：</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>钓鱼网站<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://127.0.0.1:8000/transfer/&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>username:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>targetuser:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;targetuser&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dingding&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>money:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;money&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如何规避上述问题：<br>网站在给用户返回一个具有提交数据功能页面的时候回给这个页面加一个唯一标识。当这个页面朝后端发送post请求的时候，我的后端会先校验唯一标识，如果唯一标识不对，直接拒绝403 forbidden，如果成功则正常执行。</p>
<h2 id="3、csrf校验"><a href="#3、csrf校验" class="headerlink" title="3、csrf校验"></a>3、csrf校验</h2><blockquote>
<p>form表单如何符合校验</p>
</blockquote>
<p>在form表单中加上<code>&#123;% **csrf_token** %&#125;</code>，这样我们提交form表单时会自动加上一个input框，有name和value属性也会提交到后端(value值每一次提交都会不一样，是唯一的随机字符串)。<br>注意settings.py文件中的middleware=[<strong>‘django.middleware.csrf.CsrfViewMiddleware’</strong>,]不要注释掉了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>转账网站<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>username:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>targetuser:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;targetuser&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>money:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;money&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pic2.zhimg.com/80/v2-4bb356bc2c11fd47504a22fbbcab798d_1440w.jpg" alt="img"></p>
<blockquote>
<p>AJAX请求如何设置csrf_token</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;d1&quot;</span>&gt;</span>ajax请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&#123;% load static %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% static &#x27;js/mysetup.js&#x27; %&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">&#x27;#d1&#x27;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">            url:<span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            type:<span class="string">&#x27;post&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 有三种方式ajax请求设置csrf_token：</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 第一种方式：利用标签查找获取页面上的随机字符串</span></span></span><br><span class="line">            &#123;#data:&#123;&quot;username&quot;:&#x27;jack&#x27;,&#x27;csrfmiddlewaretoken&#x27;:$(&#x27;[name=csrfmiddlewaretoken]&#x27;).val()&#125;,#&#125;</span><br><span class="line"><span class="javascript">            <span class="comment">// 第二种方式：利用模板语法提供的快捷书写</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            &#123;#data:&#123;&#x27;username&#x27;:&#x27;jack&#x27;,&#x27;csrfmiddlewaretoken&#x27;:&#x27;</span><span class="template-variable">&#123;&#123; <span class="name">csrf_token</span> &#125;&#125;</span><span class="xml">&#x27;&#125;,#&#125;</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 第三种方式：通用,引入mysetup.js文件</span></span></span><br><span class="line"><span class="javascript">            data:&#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;jack&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">            success:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第三种方式引入的js文件需要我们创建，主项目下新建static/js/mysetup.js</p>
<p><img src="https://pic3.zhimg.com/80/v2-cc667449112e4531cf572b08a217e6de_1440w.png" alt="img"></p>
<p>mysetup.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cookieValue = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.cookie &amp;&amp; <span class="built_in">document</span>.cookie !== <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> cookies = <span class="built_in">document</span>.cookie.split(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cookies.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> cookie = jQuery.trim(cookies[i]);</span><br><span class="line">            <span class="comment">// Does this cookie string begin with the name we want?</span></span><br><span class="line">            <span class="keyword">if</span> (cookie.substring(<span class="number">0</span>, name.length + <span class="number">1</span>) === (name + <span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">                cookieValue = <span class="built_in">decodeURIComponent</span>(cookie.substring(name.length + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cookieValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> csrftoken = getCookie(<span class="string">&#x27;csrftoken&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">csrfSafeMethod</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// these HTTP methods do not require CSRF protection</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="regexp">/^(GET|HEAD|OPTIONS|TRACE)$/</span>.test(method));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$.ajaxSetup(&#123;</span><br><span class="line">  beforeSend: <span class="function"><span class="keyword">function</span> (<span class="params">xhr, settings</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!csrfSafeMethod(settings.type) &amp;&amp; !<span class="built_in">this</span>.crossDomain) &#123;</span><br><span class="line">      xhr.setRequestHeader(<span class="string">&quot;X-CSRFToken&quot;</span>, csrftoken);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>引入js文件后，就会自动处理csrf token的校验。</p>
<p><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/Dominic-Ji/p/9234099.html">AJAX - JasonJi - 博客园www.cnblogs.com<img src="https://pic3.zhimg.com/v2-130f82d81e682faf4e010a97aa9fba92_180x120.jpg" alt="图标"></a></p>
<h2 id="4、csrf相关装饰器"><a href="#4、csrf相关装饰器" class="headerlink" title="4、csrf相关装饰器"></a>4、csrf相关装饰器</h2><p><strong>from django.views.decorators.csrf import csrf_protect,csrf_exempt</strong><br><strong>‘’’</strong><br><strong>csrf_protect 需要校验</strong><br><strong>csrf_exempt 忽略校验</strong><br><strong>‘’’</strong></p>
<p>当settings.py文件中的’django.middleware.<strong>csrf</strong>.CsrfViewMiddleware’中间件注释掉了时，我们给视图函数加上@csrf_protect装饰器，则表示此视图函数需要csrf校验；<br>当settings.py文件中的’django.middleware.<strong>csrf</strong>.CsrfViewMiddleware’中间件打开时，我们给视图函数加上@csrf_exempt装饰器，则表示此视图函数不需要csrf校验 。</p>
<p><strong>这两个装饰器在FBV上使用方式一致，就是普通的装饰器；</strong><br><strong>但是在CBV上两者有区别：</strong><br><strong>csrf_protect支持装饰器的三种玩法；</strong><br><strong>csrf_exempt只能给dispatch方法加才有效果，另外两种方式加无效果。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt, csrf_protect</span><br><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator</span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"></span><br><span class="line"><span class="comment">#装饰器方式2,可以针对不同的方法添加不同的装饰器，扩展性强：</span></span><br><span class="line"><span class="comment"># @method_decorator(csrf_protect, name=&#x27;post&#x27;)</span></span><br><span class="line"><span class="comment"># @method_decorator(csrf_exempt, name=&#x27;post&#x27;) # csrf_exempt不行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCsrfToken</span>(<span class="params">View</span>):</span></span><br><span class="line">    <span class="comment"># 装饰器方式3</span></span><br><span class="line">    <span class="comment"># @method_decorator(csrf_protect) # csrf_protect 无影响</span></span><br><span class="line">    <span class="comment"># @method_decorator(csrf_exempt)  # csrf_exempt 无影响</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">return</span> super(MyCsrfToken, self).dispatch(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 装饰器方式1：</span></span><br><span class="line">    <span class="comment"># @method_decorator(csrf_protect)</span></span><br><span class="line"><span class="meta">    @method_decorator(csrf_exempt) # csrf_exempt 不行</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;post&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>装饰器可参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/196412828">曾丁丁丁：Day69 Cookie\session\CBV添加装饰器zhuanlan.zhihu.com<img src="https://zhstatic.zhihu.com/assets/zhihu/editor/zhihu-card-default.svg" alt="图标"></a></p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>18-Django-auth模块</title>
    <url>/posts/13658.html</url>
    <content><![CDATA[<p>Django-auth模块</p>
<a id="more"></a>

<h2 id="auth模块"><a href="#auth模块" class="headerlink" title="auth模块"></a>auth模块</h2><p>Django在启动之后就可以直接访问admin路由，需要输入用户名和密码，这个用户名密码就是从auth_user表来的，并且还必须是管理员用户才能进入。<br>默认有6张跟认证相关的表：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-3b85f5122c6418e291f143fa0072bee3_1440w.jpg" alt="img"></p>
<blockquote>
<p>创建超级用户(管理员)</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-27b1cde219442dd75585785d94d93efb_1440w.jpg" alt="img"></p>
<p>auth_user表中就能看到记录，这里密码用的sha256加密方式</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-f2920230faddde4888cd48fed8df50d9_1440w.png" alt="img"></p>
<p>然后就可以用刚创建的超级用户登录<a href="https://link.zhihu.com/?target=http://127.0.0.1:8000/admin/">http://127.0.0.1:8000/admin/</a>，这是Django后台的管理界面。</p>
<blockquote>
<p>依赖auth_user表完成用户相关的所有功能</p>
</blockquote>
<p>1、验证用户名密码是否正确：<br>userobj = auth.authenticate(request,username=username,password=password)<br>2、保存用户状态：<br>auth.login(request,userobj)<br>3、判断当前用户是否登录：<br>request.user.is_authenticated()<br>4、获取当前登录用户：<br>request.user<br>5、校验用户是否登录的装饰器(局部配置和全局配置)<br>from django.contrib.auth.decorators import login_required<br>@login_required<br>6、校验密码<br>request.user.check_password(old_password)<br>7、修改密码<br>request.user.set_password(new_password)<br>request.user.save()</p>
<p><strong>from django.contrib.auth.models import User,AbstractUser</strong>   # 这个User就是auth_user表</p>
<p>8、注销<br>auth.logout(request)<br>9、注册(不能用create方法，密码是明文)<br>User.objects.create_user(username=username,password=password)<br>User.objects.create_superuser(username=username,password=password,email=’123@qq.com’)</p>
<p>urls.py文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r&#x27;^admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    <span class="comment"># 登录功能</span></span><br><span class="line">    url(<span class="string">r&#x27;^login/&#x27;</span>,views.login),</span><br><span class="line">    <span class="comment"># 校验用户是否登录</span></span><br><span class="line">    url(<span class="string">r&#x27;^home/&#x27;</span>,views.home),</span><br><span class="line">    <span class="comment"># 修改密码</span></span><br><span class="line">    url(<span class="string">r&#x27;^set_password/&#x27;</span>,views.set_password),</span><br><span class="line">    <span class="comment"># 注销功能</span></span><br><span class="line">    url(<span class="string">r&#x27;^logout&#x27;</span>,views.logout),</span><br><span class="line">    <span class="comment"># 注册功能</span></span><br><span class="line">    url(<span class="string">r&#x27;^register&#x27;</span>,views.register)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>views.py文件：</p>
<p>全局配置：配置文件<code>LOGIN_URL = &#39;/login/&#39;</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,HttpResponse,redirect</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> auth</span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method ==<span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        username = request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        password = request.POST.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        userobj = auth.authenticate(request,username=username,password=password)</span><br><span class="line">        <span class="comment"># auth会自动查找auth_user表，自动给密码加密校验</span></span><br><span class="line">        <span class="comment"># auth方法需要注意：括号内必须同时传入用户名和密码，不能只传入用户名</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(userobj)</span></span><br><span class="line">        <span class="comment"># dingding ,这里返回的是用户对象，如果没匹配上就返回None</span></span><br><span class="line">        <span class="comment"># print(userobj.username)</span></span><br><span class="line">        <span class="comment"># dingding</span></span><br><span class="line">        <span class="comment"># print(userobj.password)</span></span><br><span class="line">        <span class="comment"># pbkdf2_sha256$36000$1Lw3dUs75MSZ$SfN0mHrZkYpnvbsXqmT9BJ/Lgs6m+wfyquLoc1Uyn4w=</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断当前用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> userobj:</span><br><span class="line">            <span class="comment"># 如果用户存在则保存用户状态</span></span><br><span class="line">            auth.login(request,userobj) <span class="comment"># 类似于request.session[key]=userobj，会保存到django_session表中</span></span><br><span class="line">            <span class="comment"># 只要执行了该方法，你就可以在任何地方通过request.user获取到当前登录的用户对象</span></span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&#x27;/home/&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;login.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.decorators <span class="keyword">import</span> login_required</span><br><span class="line"><span class="comment"># login_required局部配置</span></span><br><span class="line"><span class="comment"># @login_required(login_url=&#x27;/login/&#x27;)</span></span><br><span class="line"><span class="comment"># 加上这个装饰器后，home方法就必须是要用户登录之后才能访问的,如果没有登录则跳转到login_url指定的网址。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># login_required全局配置(已进行全局配置的话，就不需要局部指定login_url了。)</span></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># print(request.user) # 自动去django_session表里面查找对应的用户对象给你封装到request.user中,如果没有用户登录，返回的是AnonymousUser</span></span><br><span class="line">    <span class="comment"># 判断用户是否登录</span></span><br><span class="line">    print(request.user.is_authenticated()) <span class="comment"># 返回True和False，这样就不用判断request.user是用户对象还是匿名用户了。</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;home okay&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">优先级：局部配置&gt;全局配置</span></span><br><span class="line"><span class="string">全局配置的好处：避免重复代码，但跳转页面单一</span></span><br><span class="line"><span class="string">局部配置的好处：不同的视图函数在用户没有登录情况下，可以跳转到不同页面</span></span><br><span class="line"><span class="string"># 装饰器全局配置：没有登录的话，就跳转到指定的页面，在settings.py文件中加上LOGIN_URL = &#x27;/login/&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@login_required  # 只有登录的用户才能进行修改密码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_password</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        old_password = request.POST.get(<span class="string">&#x27;old_password&#x27;</span>)</span><br><span class="line">        new_password = request.POST.get(<span class="string">&#x27;new_password&#x27;</span>)</span><br><span class="line">        confirm_new_password = request.POST.get(<span class="string">&#x27;confirm_new_password&#x27;</span>)</span><br><span class="line">        <span class="comment"># 校验</span></span><br><span class="line">        <span class="keyword">if</span> new_password == confirm_new_password:</span><br><span class="line">            is_right = request.user.check_password(old_password)  <span class="comment"># 自动加密并校验密码</span></span><br><span class="line">            <span class="keyword">if</span> is_right:</span><br><span class="line">                <span class="comment"># 修改密码</span></span><br><span class="line">                request.user.set_password(new_password)  <span class="comment"># 这一步是在修改对象的属性</span></span><br><span class="line">                request.user.save()  <span class="comment"># 这一步才是真正的操作数据</span></span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/login/&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;set_password.html&#x27;</span>,locals())</span><br><span class="line"></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout</span>(<span class="params">request</span>):</span></span><br><span class="line">    auth.logout(request)  <span class="comment"># 删除django_session表中的该用户信息</span></span><br><span class="line">    <span class="comment"># 类似于request.session.flush()</span></span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;/login/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method ==<span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        username = request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        password = request.POST.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        <span class="comment"># 操作auth_user表写入数据</span></span><br><span class="line">        <span class="comment"># 不能用create方法，密码不会进行加密处理 -- User.objects.create(username=username,password=password)</span></span><br><span class="line">        <span class="comment"># 创建普通用户</span></span><br><span class="line">        User.objects.create_user(username=username,password=password)</span><br><span class="line">        <span class="comment"># 创建超级用户,使用代码创建超级用户，email必填。</span></span><br><span class="line">        <span class="comment"># User.objects.create_superuser(username=username,password=password,email=&#x27;123@qq.com&#x27;)</span></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;register.html&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>HTML页面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;#login.html页面#&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>username:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>password:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;#register.html页面#&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>注册页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>username:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>password:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;# set_password.html页面#&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>username:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123; request.user.username &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>old_password:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;old_password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>new_password:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;new_password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>confirm_new_password:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;confirm_new_password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展auth_user表</p>
</blockquote>
<p>给auth_user表增加字段</p>
<p>models.py文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一种扩展表的方式：一对一关系，不推荐</span></span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User,AbstractUser   <span class="comment"># 这个User就是auth_user表</span></span><br><span class="line"><span class="comment"># class UserDetail(models.Model):</span></span><br><span class="line"><span class="comment">#     phone = models.BigIntegerField()</span></span><br><span class="line"><span class="comment">#     user = models.OneToOneField(to=&#x27;User&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种扩展表的方式：利用面向对象的继承</span></span><br><span class="line"><span class="comment"># 配置文件  配置文件  配置文件</span></span><br><span class="line"><span class="comment"># 告诉django使用我们自己定义的表来取代auth_user表</span></span><br><span class="line">AUTH_USER_MODEL = <span class="string">&#x27;app01.Userinfo&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span>(<span class="params">AbstractUser</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    如果继承了AbstractUser，那么在执行数据库迁移命令的时候auth_user表就不会再创建出来了</span></span><br><span class="line"><span class="string">    而UserInfo表中会出现auth_user的所有字段以及自己扩展的字段</span></span><br><span class="line"><span class="string">    这样就能直接点击自己的表更加快速的完成操作和扩展</span></span><br><span class="line"><span class="string">    前提：</span></span><br><span class="line"><span class="string">        1、在继承之前没有执行过数据库迁移命令(也就是auth_user没有被创建的时候)</span></span><br><span class="line"><span class="string">        2、继承的类里面不要覆盖AbstractUser里面的字段，已有的字段不要动，增加扩展的字段即可。</span></span><br><span class="line"><span class="string">        3、需要在配置文件中告诉Django你要用UserInfo代替auth_user表</span></span><br><span class="line"><span class="string">           AUTH_USER_MODEL = &#x27;app01.UserInfo&#x27;  应用名.表名</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 增加两个字段：</span></span><br><span class="line">    phone = models.BigIntegerField()</span><br><span class="line">    create_time = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p><font color=red>注意：User.objects.create_user的地方都换成UserInfo.objects.create_user</font></p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>19-Django上传文件方式-汇总</title>
    <url>/posts/53627.html</url>
    <content><![CDATA[<p>Django 上传文件方式</p>
<a id="more"></a>



<p>本章将介绍Django上传处理文件中需要考虑的重要事项，并提供通过自定义表单和ModelForm上传文件的示范代码（附GitHub地址)。如果你的项目中需要用到文件上传，你可以从本文中获得灵感，简化你的开发。</p>
<h2 id="Django文件上传需要考虑的重要事项"><a href="#Django文件上传需要考虑的重要事项" class="headerlink" title="Django文件上传需要考虑的重要事项"></a>Django文件上传需要考虑的重要事项</h2><p>文件或图片一般通过表单进行。用户在前端点击文件上传，然后以POST方式将数据和文件提交到服务器。服务器在接收到POST请求后需要将其存储在服务器上的某个地方。Django默认的存储地址是相对于根目录的/media/文件夹，存储的默认文件名就是文件本来的名字。上传的文件如果不大于2.5MB，会先存入服务器内存中，然后再写入磁盘。如果上传的文件很大，Django会把文件先存入临时文件，再写入磁盘。</p>
<p>Django默认处理方式会出现一个问题，所有文件都存储在一个文件夹里。不同用户上传的有相同名字的文件可能会相互覆盖。另外用户还可能上传一些不安全的文件如js和exe文件，我们必需对允许上传文件的类型进行限制。因此我们在利用Django处理文件上传时必需考虑如下3个因素:</p>
<ul>
<li>设置存储上传文件的文件夹地址</li>
<li>对上传文件进行重命名</li>
<li>对可接受的文件类型进行限制(表单验证)</li>
</ul>
<p>注意：以上事项对于上传图片是同样适用的。</p>
<h2 id="Django文件上传的3种常见方式"><a href="#Django文件上传的3种常见方式" class="headerlink" title="Django文件上传的3种常见方式"></a>Django文件上传的3种常见方式</h2><p>Django文件上传一般有3种方式(如下所示)。我们会针对3种方式分别提供代码示范。</p>
<ul>
<li>使用一般的自定义表单上传，在视图中手动编写代码处理上传的文件</li>
<li>使用由模型创建的表单(ModelForm)上传，使用<code>form.save()</code>方法自动存储</li>
<li>使用Ajax实现文件异步上传，上传页面无需刷新即可显示新上传的文件</li>
</ul>
<p>Ajax文件上传部分见Django与Ajax交互篇。</p>
<h2 id="项目创建与设置"><a href="#项目创建与设置" class="headerlink" title="项目创建与设置"></a>项目创建与设置</h2><p>我们先使用<code>django-admin startproject</code>命令创建一个叫<code>file_project</code>的项目，然后cd进入<code>file_project</code>, 使用<code>python manage.py startapp</code>创建一个叫<code>file_upload</code>的app。</p>
<p>我们首先需要将<code>file_upload</code>这个app加入到我们项目里，然后设置/media/和/STATIC_URL/文件夹。我们上传的文件都会放在/media/文件夹里。我们还需要使用css和js这些静态文件，所以需要设置STATIC_URL。</p>
<p>MEDIA_ROOT 代表着　要上传的路径会和你在models中写的上传的路径进行拼节形成最终文件上传的路径　<br>MEDIA_URL　主要就是映射了在前端使用media_url　当你的media_root　发生改变的时候不用去更改前端模板中的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#file_project/settings.py</span></span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.contenttypes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;file_upload&#x27;</span>,<span class="comment"># 新增</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">STATIC_URL = <span class="string">&#x27;/static/&#x27;</span></span><br><span class="line">STATICFILES_DIRS = [os.path.join(BASE_DIR, <span class="string">&quot;static&quot;</span>), ]</span><br><span class="line"></span><br><span class="line">MEDIA_ROOT = os.path.join(BASE_DIR, <span class="string">&#x27;media&#x27;</span>)</span><br><span class="line">MEDIA_URL = <span class="string">&#x27;/media/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#file_project/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.conf.urls.static <span class="keyword">import</span> static</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">&#x27;file/&#x27;</span>, include(<span class="string">&quot;file_upload.urls&quot;</span>)),</span><br><span class="line">] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)</span><br></pre></td></tr></table></figure>

<h2 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h2><p>使用Django上传文件创建模型不是必需，然而如果我们需要对上传文件进行系统化管理，模型还是很重要的。我们的File模型包括<code>file</code>和<code>upload_method</code>两个字段。我们通过<code>upload_to</code>选项指定了文件上传后存储的地址，并对上传的文件名进行了重命名。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#file_upload/models.py</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"><span class="comment"># Define user directory path</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_directory_path</span>(<span class="params">instance, filename</span>):</span></span><br><span class="line">    ext = filename.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">-1</span>]</span><br><span class="line">    filename = <span class="string">&#x27;&#123;&#125;.&#123;&#125;&#x27;</span>.format(uuid.uuid4().hex[:<span class="number">10</span>], ext)</span><br><span class="line">    <span class="keyword">return</span> os.path.join(<span class="string">&quot;files&quot;</span>, filename)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    file = models.FileField(upload_to=user_directory_path, null=<span class="literal">True</span>)</span><br><span class="line">    upload_method = models.CharField(max_length=<span class="number">20</span>, verbose_name=<span class="string">&quot;Upload Method&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>注意：如果你不使用<code>ModelForm</code>，你还需要手动编写代码存储上传文件。</p>
<h2 id="URLConf配置"><a href="#URLConf配置" class="headerlink" title="URLConf配置"></a>URLConf配置</h2><p>本项目一共包括3个urls, 分别对应普通表单上传，ModelForm上传和显示文件清单。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#file_upload/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> re_path, path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line"><span class="comment"># namespace</span></span><br><span class="line">app_name = <span class="string">&quot;file_upload&quot;</span></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># Upload File Without Using Model Form</span></span><br><span class="line">    re_path(<span class="string">r&#x27;^upload1/$&#x27;</span>, views.file_upload, name=<span class="string">&#x27;file_upload&#x27;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Upload Files Using Model Form</span></span><br><span class="line">    re_path(<span class="string">r&#x27;^upload2/$&#x27;</span>, views.model_form_upload, name=<span class="string">&#x27;model_form_upload&#x27;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment"># View File List</span></span><br><span class="line">    path(<span class="string">&#x27;file/&#x27;</span>, views.file_list, name=<span class="string">&#x27;file_list&#x27;</span>),</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="使用一般表单上传文件"><a href="#使用一般表单上传文件" class="headerlink" title="使用一般表单上传文件"></a>使用一般表单上传文件</h2><p>我们先定义一个一般表单<code>FileUploadForm</code>，并通过clean方法对用户上传的文件进行验证，如果上传的文件名不以jpg, pdf或xlsx结尾，将显示表单验证错误信息。关于表单的自定义和验证更多内容见Django基础: 表单forms的设计与使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#file_upload/forms.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> File</span><br><span class="line"></span><br><span class="line"><span class="comment"># Regular form</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileUploadForm</span>(<span class="params">forms.Form</span>):</span></span><br><span class="line">    file = forms.FileField(widget=forms.ClearableFileInput(attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;form-control&#x27;</span>&#125;))</span><br><span class="line">    upload_method = forms.CharField(label=<span class="string">&quot;Upload Method&quot;</span>, max_length=<span class="number">20</span>,</span><br><span class="line">                                   widget=forms.TextInput(attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;form-control&#x27;</span>&#125;))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean_file</span>(<span class="params">self</span>):</span></span><br><span class="line">        file = self.cleaned_data[<span class="string">&#x27;file&#x27;</span>]</span><br><span class="line">        ext = file.name.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">-1</span>].lower()</span><br><span class="line">        <span class="keyword">if</span> ext <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&quot;jpg&quot;</span>, <span class="string">&quot;pdf&quot;</span>, <span class="string">&quot;xlsx&quot;</span>]:</span><br><span class="line">            <span class="keyword">raise</span> forms.ValidationError(<span class="string">&quot;Only jpg, pdf and xlsx files are allowed.&quot;</span>)</span><br><span class="line">        <span class="comment"># return cleaned data is very important.</span></span><br><span class="line">        <span class="keyword">return</span> file</span><br></pre></td></tr></table></figure>

<p>注意： 使用clean方法对表单字段进行验证时，别忘了return验证过的数据，即<code>cleaned_data</code>。只有返回了cleaned_data, 视图中才可以使用form.cleaned_data.get(‘xxx’)获取验证过的数据。</p>
<p>对应一般文件上传的视图<code>file_upload</code>方法如下所示。当用户的请求方法为POST时，我们通过<code>form.cleaned_data.get(&#39;file&#39;)</code>获取通过验证的文件，并调用自定义的<code>handle_uploaded_file</code>方法来对文件进行重命名，写入文件。如果用户的请求方法不为POST，则渲染一个空的<code>FileUploadForm</code>在<code>upload_form.html</code>里。我们还定义了一个<code>file_list</code>方法来显示文件清单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#file_upload&#x2F;views.py</span><br><span class="line"></span><br><span class="line">from django.shortcuts import render, redirect</span><br><span class="line">from .models import File</span><br><span class="line">from .forms import FileUploadForm, FileUploadModelForm</span><br><span class="line">import os</span><br><span class="line">import uuid</span><br><span class="line">from django.http import JsonResponse</span><br><span class="line">from django.template.defaultfilters import filesizeformat</span><br><span class="line"></span><br><span class="line"># Create your views here.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Show file list</span><br><span class="line">def file_list(request):</span><br><span class="line">    files &#x3D; File.objects.all().order_by(&quot;-id&quot;)</span><br><span class="line">    return render(request, &#39;file_upload&#x2F;file_list.html&#39;, &#123;&#39;files&#39;: files&#125;)</span><br><span class="line"></span><br><span class="line"># Regular file upload without using ModelForm</span><br><span class="line">def file_upload(request):</span><br><span class="line">    if request.method &#x3D;&#x3D; &quot;POST&quot;:</span><br><span class="line">        form &#x3D; FileUploadForm(request.POST, request.FILES)</span><br><span class="line">        if form.is_valid():</span><br><span class="line">            # get cleaned data</span><br><span class="line">            upload_method &#x3D; form.cleaned_data.get(&quot;upload_method&quot;)</span><br><span class="line">            raw_file &#x3D; form.cleaned_data.get(&quot;file&quot;)</span><br><span class="line">            new_file &#x3D; File()</span><br><span class="line">            new_file.file &#x3D; handle_uploaded_file(raw_file)</span><br><span class="line">            new_file.upload_method &#x3D; upload_method</span><br><span class="line">            new_file.save()</span><br><span class="line">            return redirect(&quot;&#x2F;file&#x2F;&quot;)</span><br><span class="line">    else:</span><br><span class="line">        form &#x3D; FileUploadForm()</span><br><span class="line"></span><br><span class="line">    return render(request, &#39;file_upload&#x2F;upload_form.html&#39;, </span><br><span class="line">                  &#123;&#39;form&#39;: form, &#39;heading&#39;: &#39;Upload files with Regular Form&#39;&#125;</span><br><span class="line">                 )</span><br><span class="line"></span><br><span class="line">def handle_uploaded_file(file):</span><br><span class="line">    ext &#x3D; file.name.split(&#39;.&#39;)[-1]</span><br><span class="line">    file_name &#x3D; &#39;&#123;&#125;.&#123;&#125;&#39;.format(uuid.uuid4().hex[:10], ext)</span><br><span class="line"></span><br><span class="line">    # file path relative to &#39;media&#39; folder</span><br><span class="line">    file_path &#x3D; os.path.join(&#39;files&#39;, file_name)</span><br><span class="line">    absolute_file_path &#x3D; os.path.join(&#39;media&#39;, &#39;files&#39;, file_name)</span><br><span class="line"></span><br><span class="line">    directory &#x3D; os.path.dirname(absolute_file_path)</span><br><span class="line">    if not os.path.exists(directory):</span><br><span class="line">        os.makedirs(directory)</span><br><span class="line"></span><br><span class="line">    with open(absolute_file_path, &#39;wb+&#39;) as destination:</span><br><span class="line">        for chunk in file.chunks():</span><br><span class="line">            destination.write(chunk)</span><br><span class="line"></span><br><span class="line">    return file_path</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><code>handle_uploaded_file</code>方法里文件写入地址必需是包含<code>/media</code>/的绝对路径，如果/media/files/xxxx.jpg，而该方法返回的地址是相对于/media/文件夹的地址，如/files/xxx.jpg。存在数据中字段的是相对地址，而不是绝对地址。</li>
<li>构建文件写入绝对路径时请用<code>os.path.join</code>方法，因为不同系统文件夹分隔符不一样。写入文件前一个良好的习惯是使用<code>os.path.exists</code>检查目标文件夹是否存在，如果不存在先创建文件夹，再写入。</li>
</ul>
<p>上传表单模板<code>upload_form.html</code>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#file_upload&#x2F;templates&#x2F;upload_form.html</span><br><span class="line">&#123;% extends &quot;file_upload&#x2F;base.html&quot; %&#125;</span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">&#123;% if heading %&#125;</span><br><span class="line">&lt;h3&gt;&#123;&#123; heading &#125;&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&lt;form action&#x3D;&quot;&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot; &gt;</span><br><span class="line">  &#123;% csrf_token %&#125;</span><br><span class="line">  &#123;&#123; form.as_p &#125;&#125;</span><br><span class="line"> &lt;button class&#x3D;&quot;btn btn-info form-control &quot; type&#x3D;&quot;submit&quot; value&#x3D;&quot;submit&quot;&gt;Upload&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&#123;% endblock %&#125; </span><br></pre></td></tr></table></figure>

<p>显示文件清单模板<code>file_list.html</code>代码如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># file_upload&#x2F;templates&#x2F;file_list.html</span><br><span class="line">&#123;% extends &quot;file_upload&#x2F;base.html&quot; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">&lt;h3&gt;File List&lt;&#x2F;h3&gt;</span><br><span class="line">&lt;p&gt; &lt;a href&#x3D;&quot;&#x2F;file&#x2F;upload1&#x2F;&quot;&gt;RegularFormUpload&lt;&#x2F;a&gt; | &lt;a href&#x3D;&quot;&#x2F;file&#x2F;upload2&#x2F;&quot;&gt;ModelFormUpload&lt;&#x2F;a&gt;</span><br><span class="line">    | &lt;a href&#x3D;&quot;&#x2F;file&#x2F;upload3&#x2F;&quot;&gt;AjaxUpload&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&#123;% if files %&#125;</span><br><span class="line">&lt;table class&#x3D;&quot;table table-striped&quot;&gt;</span><br><span class="line">    &lt;tbody&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;Filename &amp; URL&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;td&gt;Filesize&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;td&gt;Upload Method&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;&#x2F;tr&gt;</span><br><span class="line">    &#123;% for file in files %&#125;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;&lt;a href&#x3D;&quot;&#123;&#123; file.file.url &#125;&#125;&quot;&gt;&#123;&#123; file.file.url &#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;td&gt;&#123;&#123; file.file.size | filesizeformat &#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;td&gt;&#123;&#123; file.upload_method &#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;&#x2F;tr&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    &lt;&#x2F;tbody&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br><span class="line"></span><br><span class="line">&#123;% else %&#125;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;No files uploaded yet. Please click &lt;a href&#x3D;&quot;&#123;% url &#39;file_upload:file_upload&#39; %&#125;&quot;&gt;here&lt;&#x2F;a&gt;</span><br><span class="line">    to upload files.&lt;&#x2F;p&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>注意： </p>
<ul>
<li>对于上传的文件我们可以调用<code>file.url</code>, <code>file.name</code>和<code>file.size</code>来查看上传文件的链接，地址和大小。</li>
<li>上传文件的大小默认是以B显示的，数字非常大。使用Django模板过滤器<code>filesizeformat</code>可以将文件大小显示为人们可读的方式，如MB，KB。</li>
</ul>
<h2 id="使用ModelForm上传文件"><a href="#使用ModelForm上传文件" class="headerlink" title="使用ModelForm上传文件"></a>使用ModelForm上传文件</h2><p>使用<code>ModelForm</code>上传是小编我推荐的上传方式，前提是你已经在模型中通过<code>upload_to</code>选项自定义了用户上传文件存储地址，并对文件进行了重命名。我们首先要自定义自己的<code>FileUploadModelForm</code>，由File模型重建的。代码如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#file_upload&#x2F;forms.py</span><br><span class="line">from django import forms</span><br><span class="line">from .models import File</span><br><span class="line"></span><br><span class="line"># Model form</span><br><span class="line">class FileUploadModelForm(forms.ModelForm):</span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; File</span><br><span class="line">        fields &#x3D; (&#39;file&#39;, &#39;upload_method&#39;,)</span><br><span class="line">        widgets &#x3D; &#123;</span><br><span class="line">            &#39;upload_method&#39;: forms.TextInput(attrs&#x3D;&#123;&#39;class&#39;: &#39;form-control&#39;&#125;),</span><br><span class="line">            &#39;file&#39;: forms.ClearableFileInput(attrs&#x3D;&#123;&#39;class&#39;: &#39;form-control&#39;&#125;),</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    def clean_file(self):</span><br><span class="line">        file &#x3D; self.cleaned_data[&#39;file&#39;]</span><br><span class="line">        ext &#x3D; file.name.split(&#39;.&#39;)[-1].lower()</span><br><span class="line">        if ext not in [&quot;jpg&quot;, &quot;pdf&quot;, &quot;xlsx&quot;]:</span><br><span class="line">            raise forms.ValidationError(&quot;Only jpg, pdf and xlsx files are allowed.&quot;)</span><br><span class="line">        # return cleaned data is very important.</span><br><span class="line">        return file</span><br></pre></td></tr></table></figure>

<p>使用<code>ModelForm</code>处理文件上传的视图<code>model_form_upload</code>方法非常简单，只需调用<code>form.save()</code>即可，无需再手动编写代码写入文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#file_upload&#x2F;views.py</span><br><span class="line"></span><br><span class="line">from django.shortcuts import render, redirect</span><br><span class="line">from .models import File</span><br><span class="line">from .forms import FileUploadForm, FileUploadModelForm</span><br><span class="line">import os</span><br><span class="line">import uuid</span><br><span class="line">from django.http import JsonResponse</span><br><span class="line">from django.template.defaultfilters import filesizeformat</span><br><span class="line"></span><br><span class="line"># Create your views here.</span><br><span class="line"># Upload File with ModelForm</span><br><span class="line"></span><br><span class="line">def model_form_upload(request):</span><br><span class="line">    if request.method &#x3D;&#x3D; &quot;POST&quot;:</span><br><span class="line">        form &#x3D; FileUploadModelForm(request.POST, request.FILES)</span><br><span class="line">        if form.is_valid():</span><br><span class="line">            form.save() # 一句话足以</span><br><span class="line">            return redirect(&quot;&#x2F;file&#x2F;&quot;)</span><br><span class="line">    else:</span><br><span class="line">        form &#x3D; FileUploadModelForm()</span><br><span class="line"></span><br><span class="line">    return render(request, &#39;file_upload&#x2F;upload_form.html&#39;, </span><br><span class="line">                  &#123;&#39;form&#39;: form,&#39;heading&#39;: &#39;Upload files with ModelForm&#39;&#125;</span><br><span class="line">                 )</span><br></pre></td></tr></table></figure>

<p>模板跟前面一样，这里就不展示了。</p>
<h2 id="GitHub源码地址"><a href="#GitHub源码地址" class="headerlink" title="GitHub源码地址"></a>GitHub源码地址</h2><ul>
<li><a href="https://github.com/shiyunbo/django-file-upload-download">https://github.com/shiyunbo/django-file-upload-download</a></li>
</ul>
<h2 id="用户头像上传（media通用方式）"><a href="#用户头像上传（media通用方式）" class="headerlink" title="用户头像上传（media通用方式）"></a>用户头像上传（media通用方式）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1. 网站所使用的静态文件默认都放在static文件夹</span></span><br><span class="line"><span class="string">2. 用户上传的静态文件也应该单独放在某个文件夹下 </span></span><br><span class="line"><span class="string">MEDIA_ROOT 代表着　要上传的路径会和你在models中写的上传的路径进行拼节形成最终文件上传的路径　</span></span><br><span class="line"><span class="string">MEDIA_URL　主要就是映射了在前端使用media_url　当你的media_root　发生改变的时候不用去更改前端模板中的内容</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># media 配置</span></span><br><span class="line">    该配置可让用户上传的所有文件都固定在某一个指定文件夹下</span><br><span class="line">    <span class="comment"># 用户上传静态文件存储位置 settings</span></span><br><span class="line">        MEDIA_ROOT = os.path.join(BASE_DIR, <span class="string">&#x27;media&#x27;</span>)  <span class="comment"># 上传后会自动创建多级目录；依赖于models中 FileField 的upload to属性</span></span><br><span class="line">    MEDIA_URL = <span class="string">&#x27;/media/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开设后端指定文件夹</span></span><br><span class="line"><span class="keyword">from</span> django.views.static <span class="keyword">import</span> serve</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line">        <span class="comment"># 暴露后端指定文件夹资源(MEDIA_ROOT的路径)</span></span><br><span class="line">    <span class="comment"># 固定写法，不要自己改动</span></span><br><span class="line">    re_path(<span class="string">&#x27;^media/(?P&lt;path&gt;.*)&#x27;</span>, serve, &#123;<span class="string">&#x27;document_root&#x27;</span>:settings.MEDIA_ROOT&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">前端直接渲染</span><br><span class="line">&#123;&#123; MEDIA_URL &#125;&#125;avatars/<span class="number">222.j</span>pg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要安装模块 Pillow</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>20-Django进阶-importlib模块和settings文件解析</title>
    <url>/posts/9996.html</url>
    <content><![CDATA[<p>importlib模块/settings配置文件浅解</p>
<a id="more"></a>



<h2 id="1、模块补充"><a href="#1、模块补充" class="headerlink" title="1、模块补充"></a>1、模块补充</h2><p>两种方式获取到另一个py文件中的变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一种方式</span></span><br><span class="line"><span class="comment"># from myfile import b</span></span><br><span class="line"><span class="comment"># print(b.name)</span></span><br><span class="line"><span class="comment"># jack</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  第二种方式：</span></span><br><span class="line"><span class="comment"># importlib能够以字符串的形式帮助你导入模块，但是最小单位只能到模块名</span></span><br><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line">res = <span class="string">&#x27;myfile.b&#x27;</span></span><br><span class="line">ret = importlib.import_module(res) <span class="comment"># 等价于from myfile import b</span></span><br><span class="line">print(ret)</span><br><span class="line"><span class="comment"># &lt;module &#x27;myfile.b&#x27; from &#x27;/Users/dingding/PycharmProjects/day70/myfile/b.py&#x27;&gt;</span></span><br><span class="line">print(ret.name)</span><br><span class="line"><span class="comment"># jack</span></span><br></pre></td></tr></table></figure>

<h2 id="2、基于Django中间件衍生出的一个编程思想"><a href="#2、基于Django中间件衍生出的一个编程思想" class="headerlink" title="2、基于Django中间件衍生出的一个编程思想"></a>2、基于Django中间件衍生出的一个编程思想</h2><p>创建如下文件</p>
<p><img src="https://pic4.zhimg.com/80/v2-c9e6217eea418ec8cd0bbe601c94e00f_1440w.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># qq.py文件:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QQ</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">self,content</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;QQ通知&#123;&#125;&#x27;</span>.format(content))</span><br><span class="line"></span><br><span class="line"><span class="comment"># wechat.py文件：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wechat</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">self,content</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;微信通知&#123;&#125;&#x27;</span>.format(content))</span><br><span class="line"></span><br><span class="line"><span class="comment"># email.py文件：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">self,content</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;邮箱通知&#123;&#125;&#x27;</span>.format(content))</span><br><span class="line"></span><br><span class="line"><span class="comment"># __init__文件：</span></span><br><span class="line"><span class="keyword">from</span> sendinfo02 <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_all</span>(<span class="params">content</span>):</span></span><br><span class="line">    <span class="keyword">for</span> path_str <span class="keyword">in</span> settings.NOTIFY_LIST:  <span class="comment"># 获取到&#x27;notify.email.Email&#x27;</span></span><br><span class="line">        module_path,class_name = path_str.rsplit(<span class="string">&#x27;.&#x27;</span>,maxsplit=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># module_path=&#x27;notify.email&#x27;,class_name=&#x27;Email&#x27;</span></span><br><span class="line">        <span class="comment"># 1、利用字符串导入模块</span></span><br><span class="line">        module = importlib.import_module(module_path) <span class="comment"># from notify import email</span></span><br><span class="line">        <span class="comment"># 2、利用反射获取类名</span></span><br><span class="line">        cls = getattr(module,class_name) <span class="comment"># 拿到类名：Email\QQ\Wechat</span></span><br><span class="line">        <span class="comment"># 3、生成类的对象</span></span><br><span class="line">        obj = cls()</span><br><span class="line">        <span class="comment"># 4、利用鸭子类型直接调用send方法</span></span><br><span class="line">        obj.send(content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># settings.py文件：</span></span><br><span class="line">NOTIFY_LIST=[</span><br><span class="line">    <span class="string">&#x27;notify.email.Email&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;notify.qq.QQ&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;notify.wechat.Wechat&#x27;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># start.py文件：</span></span><br><span class="line"><span class="keyword">from</span> sendinfo02 <span class="keyword">import</span> notify</span><br><span class="line">notify.send_all(<span class="string">&#x27;hello world!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">知识点：</span></span><br><span class="line"><span class="string">配置文件注册功能</span></span><br><span class="line"><span class="string">importlib模块</span></span><br><span class="line"><span class="string">字符串切割split</span></span><br><span class="line"><span class="string">反射</span></span><br><span class="line"><span class="string">面向对象</span></span><br><span class="line"><span class="string">鸭子类型</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-settings配置源码解析"><a href="#3-settings配置源码解析" class="headerlink" title="3. settings配置源码解析"></a>3. settings配置源码解析</h2><p>如果想要用全局的配置文件，建议从django.conf导入settings；<strong>这样既可以用到settings里面的配置，也可以用到globalsettings里面的默认配置</strong></p>
<p><strong>from django.conf import settings</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># django默认有两个配置文件</span></span><br><span class="line">       一个是暴露给用户的自定义配置</span><br><span class="line">       一个是项目默认的配置</span><br><span class="line"> 用户没有配置的情况下使用的是项目的默认配置</span><br><span class="line"> 用户自定义配置的情况下则使用自定义配置</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 实现思路：</span></span><br><span class="line">    <span class="number">1.</span> 先读取项目的默认配置</span><br><span class="line">    <span class="number">2.</span> 再读取自定义的配置</span><br><span class="line">    <span class="comment"># 利用的是字典的键存在则替换，不存在则创建</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LaztSettings</span>(<span class="params">...</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">ENVIRONMENT_VARIABLE = &quot;DJANGO_SETTINGS_MODULE&quot;</span><br><span class="line">对应manage.py 中的 os.environ.setdefault(<span class="string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="string">&#x27;pyday53.settings&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySettings</span>(<span class="params">LazyObject</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_setup</span>(<span class="params">self, name=None</span>):</span></span><br><span class="line">        settings_module = os.environ.get(ENVIRONMENT_VARIABLE) <span class="comment"># &#x27;pyday53.settings&#x27;</span></span><br><span class="line">    self._wrapped = Settings(settings_module) <span class="comment"># Settings(&#x27;day70.settings&#x27;)</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Settings</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, settings_module</span>):</span>  <span class="comment"># &#x27;pyday53.settings&#x27;</span></span><br><span class="line">        <span class="comment"># update this dict from global settings (but only for ALL_CAPS settings)</span></span><br><span class="line">        <span class="keyword">for</span> setting <span class="keyword">in</span> dir(global_settings):  <span class="comment"># 获取全局配置文件可以点的变量名</span></span><br><span class="line">            <span class="keyword">if</span> setting.isupper(): <span class="comment"># 校验配置必须大写</span></span><br><span class="line">                setattr(self, setting, getattr(global_settings, setting))</span><br><span class="line">                <span class="comment"># setting指代的是所有全大写的变量名(上for循环)</span></span><br><span class="line">                <span class="comment"># getattr(global_settings, setting)# 获取全大写变量名对应的值</span></span><br><span class="line">                <span class="comment"># 给对象设置属性，可以简单的理解为给字典添加键值对</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># store the settings module in case someone later cares</span></span><br><span class="line">        self.SETTINGS_MODULE = settings_module  <span class="comment"># &#x27;pyday53.settings&#x27;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> setting <span class="keyword">in</span> dir(mod): <span class="comment"># 获取项目配置里所有名字</span></span><br><span class="line">            <span class="keyword">if</span> setting.isupper():</span><br><span class="line">                setting_value = getattr(mod, setting)</span><br><span class="line">        setattr(self, setting, setting_value)</span><br></pre></td></tr></table></figure>

<h2 id="4-项目中使用案例-global-settings-和-settings"><a href="#4-项目中使用案例-global-settings-和-settings" class="headerlink" title="4.项目中使用案例(global settings 和  settings)"></a>4.项目中使用案例(global settings 和  settings)</h2><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20210603104943394.png" alt="image-20210603104943394"></p>
<p>settings.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">NAME = <span class="string">&#x27;自定义配置&#x27;</span></span><br></pre></td></tr></table></figure>

<p>global_settings</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">NAME= <span class="string">&#x27;我是global默认配置&#x27;</span></span><br></pre></td></tr></table></figure>

<p>start.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">BASE_DIR = os.path.dirname(__file__)</span><br><span class="line">sys.path.append(BASE_DIR)</span><br><span class="line"><span class="comment"># 将自定义配置文件路径添加到全局环境大字典</span></span><br><span class="line">os.environ.setdefault(<span class="string">&#x27;xxx&#x27;</span>,<span class="string">&#x27;conf.settings&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> lib.conf <span class="keyword">import</span> settings   <span class="comment"># 导包，要问init要</span></span><br><span class="line">print(settings.NAME)</span><br></pre></td></tr></table></figure>

<p>Init.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lib.conf <span class="keyword">import</span> global_settings</span><br><span class="line"><span class="keyword">from</span> conf <span class="keyword">import</span> settings <span class="keyword">as</span> se</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Settings</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 先获取全局配置文件内容</span></span><br><span class="line">        <span class="comment"># 再获取局部配置化文件内容</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dir(global_settings):</span><br><span class="line">            <span class="keyword">if</span> i.isupper():</span><br><span class="line">                <span class="comment"># 获取大写变量名和变量值</span></span><br><span class="line">                key = i</span><br><span class="line">                value = getattr(global_settings, i)</span><br><span class="line">                setattr(self, key, value)</span><br><span class="line">        <span class="comment"># 再获取局部配置化文件内容</span></span><br><span class="line">        mod = os.environ.get(<span class="string">&#x27;xxx&#x27;</span>) <span class="comment"># &#x27;conf.settings&#x27;</span></span><br><span class="line">        module = importlib.import_module(mod) <span class="comment"># from conf import settings</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dir(module):</span><br><span class="line">            <span class="keyword">if</span> i.isupper():</span><br><span class="line">                <span class="comment"># 获取大写变量名和变量值</span></span><br><span class="line">                key = i</span><br><span class="line">                value = getattr(se, i)</span><br><span class="line">                setattr(self, key, value)</span><br><span class="line"></span><br><span class="line">settings = Settings()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>21-Docker-compost部署Django+uwsgi</title>
    <url>/posts/23452.html</url>
    <content><![CDATA[<p>Docker-compose 部署 Django + Uwsgi + Nginx</p>
<a id="more"></a>

<h2 id="1-项目目录"><a href="#1-项目目录" class="headerlink" title="1.项目目录"></a>1.项目目录</h2><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20210622215310884.png" alt="image-20210622215310884"></p>
<h2 id="2-构建Django基础镜像"><a href="#2-构建Django基础镜像" class="headerlink" title="2.构建Django基础镜像"></a>2.构建Django基础镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./build_django/Dockerfile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 建立 python 3.6环境,构建Django环境底包</span></span><br><span class="line">FROM python:3.6</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装netcat</span></span><br><span class="line">RUN apt-get update &amp;&amp; apt install -y netcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 镜像作者</span></span><br><span class="line">MAINTAINER WaylonYan </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置 python 环境变量</span></span><br><span class="line">ENV PYTHONDONTWRITEBYTECODE 1</span><br><span class="line">ENV PYTHONUNBUFFERED 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可选：设置镜像源为国内</span></span><br><span class="line">COPY pip.conf /root/.pip/pip.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制requirements</span></span><br><span class="line">RUN mkdir /code</span><br><span class="line">COPY requirements.txt /code/requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新pip版本</span></span><br><span class="line">RUN /usr/local/bin/python -m pip install --upgrade pip</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装项目依赖</span></span><br><span class="line">RUN pip install -r /code/requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更改项目源码，decode改成encode</span></span><br><span class="line">RUN sed -i &#x27;146s/decode/encode/&#x27; /usr/local/lib/python3.6/site-packages/django/db/backends/mysql/operations.py </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./build_django/pip.conf</span><br><span class="line">[global] </span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host = https://pypi.tuna.tsinghua.edu.cn </span><br><span class="line"></span><br><span class="line">./build_django/requirements.txt</span><br><span class="line">beautifulsoup4==4.9.3</span><br><span class="line">certifi==2020.12.5</span><br><span class="line">cffi==1.14.0</span><br><span class="line">cryptography==3.4.7</span><br><span class="line">Django==2.2</span><br><span class="line">django-simpleui==2021.6.2</span><br><span class="line">gevent==21.1.2</span><br><span class="line">greenlet==1.0.0</span><br><span class="line">Jinja2==2.11.3</span><br><span class="line">MarkupSafe==1.1.1</span><br><span class="line">olefile==0.46</span><br><span class="line">Pillow==8.2.0</span><br><span class="line">pycparser==2.20</span><br><span class="line">PyMySQL==1.0.2</span><br><span class="line">pytz==2021.1</span><br><span class="line">soupsieve==2.2.1</span><br><span class="line">sqlparse==0.4.1</span><br><span class="line">uwsgi==2.0.18</span><br></pre></td></tr></table></figure>

<h2 id="3-docker-compse"><a href="#3-docker-compse" class="headerlink" title="3.docker-compse"></a>3.docker-compse</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span> <span class="comment"># 自定义数据卷</span></span><br><span class="line">  <span class="attr">media_vol:</span></span><br><span class="line">  <span class="attr">static_vol:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span> <span class="comment"># 自定义网络(默认桥接), 不使用links通信</span></span><br><span class="line">  <span class="attr">nginx_network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./pybbs</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8000&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./pybbs:/var/www/html/pybbs</span> <span class="comment"># 挂载项目代码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">static_vol:/var/www/html/pybbs/dist</span> <span class="comment"># 以数据卷挂载容器内static文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">media_vol:/var/www/html/pybbs/media</span> <span class="comment"># 以数据卷挂载容器内用户上传媒体文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./compose/uwsgi:/tmp</span> <span class="comment"># 挂载uwsgi日志</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nginx_network</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">stdin_open:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./compose/nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;443:443&quot;</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./compose/nginx/nginx.conf:/etc/nginx/conf.d/nginx.conf</span> <span class="comment"># 挂载nginx配置文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./compose/nginx/ssl:/usr/share/nginx/ssl</span> <span class="comment"># 挂载ssl证书目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./compose/nginx/log:/var/log/nginx</span> <span class="comment"># 挂载日志</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">static_vol:/usr/share/nginx/html/static</span> <span class="comment"># 挂载静态文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">media_vol:/usr/share/nginx/html/media</span> <span class="comment"># 挂载用户上传媒体文件</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nginx_network</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">web</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>

<p>Django 项目启动配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> pybbs/start.sh</span><br><span class="line"><span class="meta"> #</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从第一行到最后一行分别表示：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 等待MySQL服务启动后再进行数据迁移。nc即netcat缩写</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改源码 decode换成encode</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 收集静态文件到根目录static文件夹，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 生成数据库可执行文件，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 根据数据库可执行文件来修改数据库</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 用 uwsgi启动 django 服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. tail空命令防止web容器执行脚本后退出</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">while</span> ! nc -z db 3306 ; <span class="keyword">do</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    <span class="built_in">echo</span> <span class="string">&quot;Waiting for the MySQL Server&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    sleep 3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">done</span></span></span><br><span class="line">python manage.py collectstatic --noinput&amp;&amp;</span><br><span class="line"><span class="meta">#</span><span class="bash">python manage.py makemigrations&amp;&amp;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">python manage.py migrate&amp;&amp;</span></span><br><span class="line">uwsgi --ini /var/www/html/pybbs/uwsgi.ini&amp;&amp;</span><br><span class="line">tail -f /dev/null</span><br><span class="line"></span><br><span class="line">exec &quot;$@&quot;</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.pybbs/Dockerfile </span><br><span class="line"><span class="meta">#</span><span class="bash"> 建立 Django 2.2环境</span></span><br><span class="line">FROM django:2.2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 镜像作者</span></span><br><span class="line">MAINTAINER WaylonYan </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置 python 环境变量</span></span><br><span class="line">ENV PYTHONDONTWRITEBYTECODE 1</span><br><span class="line">ENV PYTHONUNBUFFERED 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器内创建 myproject 文件夹</span></span><br><span class="line">ENV APP_HOME=/var/www/html/pybbs</span><br><span class="line">RUN mkdir -p $APP_HOME</span><br><span class="line">WORKDIR $APP_HOME</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将当前目录加入到工作目录中（. 表示当前目录）</span></span><br><span class="line">ADD . $APP_HOME</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 移除\r <span class="keyword">in</span> windows</span></span><br><span class="line">RUN sed -i &#x27;s/\r//&#x27; ./start.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 给start.sh可执行权限</span></span><br><span class="line">RUN chmod +x ./start.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据迁移，并使用uwsgi启动服务</span></span><br><span class="line">ENTRYPOINT /bin/bash ./start.sh</span><br></pre></td></tr></table></figure>

<p>Nginx 配置文件+Dockerfile</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> compose/nginx/nginx.conf</span></span><br><span class="line"></span><br><span class="line">upstream django &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server web:8000; # Docker-compose web服务端口</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置http请求，80端口</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80; # 监听80端口</span><br><span class="line">    server_name 127.0.0.1; # 可以是nginx容器所在ip地址或127.0.0.1，不能写宿主机外网ip地址</span><br><span class="line"></span><br><span class="line">    charset utf-8;</span><br><span class="line">    client_max_body_size 10M; # 限制用户上传文件大小</span><br><span class="line"></span><br><span class="line">    access_log /var/log/nginx/access.log main;</span><br><span class="line">    error_log /var/log/nginx/error.log warn;</span><br><span class="line"></span><br><span class="line">    location /static &#123;</span><br><span class="line">        alias /usr/share/nginx/html/static; # 静态资源路径</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /media &#123;</span><br><span class="line">        alias /usr/share/nginx/html/media; # 媒体资源，用户上传文件路径</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        include /etc/nginx/uwsgi_params;</span><br><span class="line">        uwsgi_pass django;</span><br><span class="line">        uwsgi_read_timeout 600;</span><br><span class="line">        uwsgi_connect_timeout 600;</span><br><span class="line">        uwsgi_send_timeout 600;</span><br><span class="line"></span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_set_header X-Real-IP  $remote_addr;</span><br><span class="line">       # proxy_pass http://django;  # 使用uwsgi通信，而不是http，所以不使用proxy_pass。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Dockerfile</span><br><span class="line"><span class="meta">#</span><span class="bash"> nginx镜像compose/nginx/Dockerfile</span></span><br><span class="line"></span><br><span class="line">FROM nginx:latest</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除原有配置文件，创建静态资源文件夹和ssl证书保存文件夹</span></span><br><span class="line">RUN rm /etc/nginx/conf.d/default.conf \</span><br><span class="line">&amp;&amp; mkdir -p /usr/share/nginx/html/static \</span><br><span class="line">&amp;&amp; mkdir -p /usr/share/nginx/html/media \</span><br><span class="line">&amp;&amp; mkdir -p /usr/share/nginx/ssl</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置Media文件夹用户和用户组为Linux默认www-data, 并给予可读和可执行权限,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 否则用户上传的图片无法正确显示。</span></span><br><span class="line">RUN chown -R www-data:www-data /usr/share/nginx/html/media \</span><br><span class="line">&amp;&amp; chmod -R 775 /usr/share/nginx/html/media</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加配置文件</span></span><br><span class="line">ADD ./nginx.conf /etc/nginx/conf.d/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭守护模式</span></span><br><span class="line">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure>

<p>Django项目启动settings配置文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Static files (CSS, JavaScript, Images)</span></span><br><span class="line"><span class="comment"># https://docs.djangoproject.com/en/2.2/howto/static-files/</span></span><br><span class="line"></span><br><span class="line">STATIC_URL = <span class="string">&#x27;/static/&#x27;</span></span><br><span class="line"></span><br><span class="line">STATICFILES_DIRS = [</span><br><span class="line">    os.path.join(BASE_DIR, <span class="string">&#x27;static&#x27;</span>)</span><br><span class="line">]</span><br><span class="line">STATIC_ROOT = os.path.join(BASE_DIR, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line"></span><br><span class="line">AUTH_USER_MODEL = <span class="string">&#x27;app01.Userinfo&#x27;</span></span><br><span class="line"></span><br><span class="line">LOGIN_URL = <span class="string">&#x27;/login/&#x27;</span></span><br><span class="line"></span><br><span class="line">MEDIA_ROOT = os.path.join(BASE_DIR, <span class="string">&#x27;media&#x27;</span>)</span><br></pre></td></tr></table></figure>





<p>引用博客:</p>
<p><a href="https://blog.csdn.net/weixin_42134789/article/details/115878467">https://blog.csdn.net/weixin_42134789/article/details/115878467</a></p>
<hr>
<h2 id="基于alpine镜像构建Django容器"><a href="#基于alpine镜像构建Django容器" class="headerlink" title="基于alpine镜像构建Django容器"></a>基于alpine镜像构建Django容器</h2><h3 id="rust-config"><a href="#rust-config" class="headerlink" title="rust config"></a>rust config</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">registry &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;crates.io-index&quot;</span><br><span class="line">replace-with &#x3D; &#39;ustc&#39;</span><br><span class="line">[source.ustc]</span><br><span class="line">registry &#x3D; &quot;git:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;crates.io-index&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立 python 3.6环境,构建Django环境底包</span></span><br><span class="line"><span class="string">FROM</span> <span class="string">python:3.6-alpine</span> </span><br><span class="line"></span><br><span class="line"><span class="string">ENV</span> <span class="string">PATH=&quot;/root/.cargo/bin:$&#123;PATH&#125;&quot;</span></span><br><span class="line"><span class="comment"># 安装netcat</span></span><br><span class="line"><span class="comment"># RUN apt-get update &amp;&amp; apt install -y netcat</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g&#x27;</span> <span class="string">/etc/apk/repositories</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">apk</span> <span class="string">add</span> <span class="string">libc-dev</span> <span class="string">pcre-dev</span> <span class="string">build-base</span> <span class="string">linux-headers</span> <span class="string">libffi-dev</span> <span class="string">libjpeg</span>  <span class="string">openssl</span> <span class="string">freetds-dev</span> <span class="string">jpeg-dev</span> <span class="string">zlib-dev</span> <span class="string">freetds-dev</span> <span class="string">musl-dev</span> <span class="string">openssl-dev</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">apk</span> <span class="string">update</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">apk</span> <span class="string">add</span> <span class="string">curl</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">apk</span> <span class="string">add</span> <span class="string">busybox-extras</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">apk</span> <span class="string">add</span> <span class="string">gcc</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">apk</span> <span class="string">add</span> <span class="string">vim</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">apk</span> <span class="string">add</span> <span class="string">net-tools</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">curl</span> <span class="string">https://static.rust-lang.org/rustup/dist/x86_64-unknown-linux-musl/rustup-init</span> <span class="string">--output</span> <span class="string">/tmp/rustup-init</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">chmod</span> <span class="string">+x</span> <span class="string">/tmp/rustup-init</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">/tmp/rustup-init</span> <span class="string">-y</span></span><br><span class="line"><span class="comment"># 镜像作者</span></span><br><span class="line"><span class="string">MAINTAINER</span> <span class="string">WaylonYan</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 python 环境变量</span></span><br><span class="line"><span class="string">ENV</span> <span class="string">PYTHONDONTWRITEBYTECODE</span> <span class="number">1</span></span><br><span class="line"><span class="string">ENV</span> <span class="string">PYTHONUNBUFFERED</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选：设置镜像源为国内</span></span><br><span class="line"><span class="string">COPY</span> <span class="string">pip.conf</span> <span class="string">/root/.pip/pip.conf</span></span><br><span class="line"><span class="string">COPY</span> <span class="string">config</span> <span class="string">/root/.cargo/config</span></span><br><span class="line"><span class="comment"># 复制requirements</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">mkdir</span> <span class="string">/code</span></span><br><span class="line"><span class="string">COPY</span> <span class="string">requirements.txt</span> <span class="string">/code/requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新pip版本</span></span><br><span class="line"><span class="comment"># RUN /usr/local/bin/python -m pip install --upgrade pip</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">--upgrade</span> <span class="string">pip</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装项目依赖</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">-r</span> <span class="string">/code/requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载rust</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">rustup</span> <span class="string">self</span> <span class="string">uninstall</span> <span class="string">-y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改项目源码，decode改成encode</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">&#x27;146s/decode/encode/&#x27;</span> <span class="string">/usr/local/lib/python3.6/site-packages/django/db/backends/mysql/operations.py</span> </span><br></pre></td></tr></table></figure>

<p>pip.conf</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[root@docker-test build_django]<span class="comment"># cat pip.conf </span></span><br><span class="line">[<span class="keyword">global</span>] </span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host = https://pypi.tuna.tsinghua.edu.cn </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>22-Django缓存</title>
    <url>/posts/47019.html</url>
    <content><![CDATA[<p>Django 缓存</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">接口缓存用的非常多，不能每次响应都要去查询数据库，比如接口2s返回，每次都查询DB，效率很慢。</span><br></pre></td></tr></table></figure>



<h2 id="一-缓存介绍"><a href="#一-缓存介绍" class="headerlink" title="一 缓存介绍"></a>一 缓存介绍</h2><p>在动态网站中,用户所有的请求,服务器都会去数据库中进行相应的增,删,查,改,渲染模板,执行业务逻辑,最后生成用户看到的页面.</p>
<p>当一个网站的用户访问量很大的时候,每一次的的后台操作,都会消耗很多的服务端资源,所以必须使用缓存来减轻后端服务器的压力.</p>
<p>缓存是将一些常用的数据保存内存或者memcache中,在一定的时间内有人来访问这些数据时,则不再去执行数据库及渲染等操作,而是直接从内存或memcache的缓存中去取得数据,然后返回给用户.</p>
<h2 id="二-Django中的6种缓存方式"><a href="#二-Django中的6种缓存方式" class="headerlink" title="二 Django中的6种缓存方式"></a>二 Django中的6种缓存方式</h2><ul>
<li>开发调试缓存</li>
<li>内存缓存</li>
<li>文件缓存</li>
<li>数据库缓存</li>
<li>Memcache缓存(使用python-memcached模块)</li>
<li>Memcache缓存(使用pylibmc模块)</li>
</ul>
<p>经常使用的有文件缓存和Mencache缓存</p>
<h2 id="三-Django6种缓存的配置"><a href="#三-Django6种缓存的配置" class="headerlink" title="三 Django6种缓存的配置"></a>三 Django6种缓存的配置</h2><p><strong>1.2.1 开发调试(此模式为开发调试使用,实际上不执行任何操作)</strong></p>
<p>settings.py文件配置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CACHES = &#123;</span><br><span class="line"> <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">  <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.core.cache.backends.dummy.DummyCache&#x27;</span>,  <span class="comment"># 缓存后台使用的引擎</span></span><br><span class="line">  <span class="string">&#x27;TIMEOUT&#x27;</span>: <span class="number">300</span>,            <span class="comment"># 缓存超时时间（默认300秒，None表示永不过期，0表示立即过期）</span></span><br><span class="line">  <span class="string">&#x27;OPTIONS&#x27;</span>:&#123;</span><br><span class="line">   <span class="string">&#x27;MAX_ENTRIES&#x27;</span>: <span class="number">300</span>,          <span class="comment"># 最大缓存记录的数量（默认300）</span></span><br><span class="line">   <span class="string">&#x27;CULL_FREQUENCY&#x27;</span>: <span class="number">3</span>,          <span class="comment"># 缓存到达最大个数之后，剔除缓存个数的比例，即：1/CULL_FREQUENCY（默认3）</span></span><br><span class="line">  &#125;,</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.2.2 内存缓存(将缓存内容保存至内存区域中)</strong></p>
<p>settings.py文件配置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CACHES = &#123;</span><br><span class="line"> <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">  <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.core.cache.backends.locmem.LocMemCache&#x27;</span>,  <span class="comment"># 指定缓存使用的引擎</span></span><br><span class="line">  <span class="string">&#x27;LOCATION&#x27;</span>: <span class="string">&#x27;unique-snowflake&#x27;</span>,         <span class="comment"># 写在内存中的变量的唯一值 </span></span><br><span class="line">  <span class="string">&#x27;TIMEOUT&#x27;</span>:<span class="number">300</span>,             <span class="comment"># 缓存超时时间(默认为300秒,None表示永不过期)</span></span><br><span class="line">  <span class="string">&#x27;OPTIONS&#x27;</span>:&#123;</span><br><span class="line">   <span class="string">&#x27;MAX_ENTRIES&#x27;</span>: <span class="number">300</span>,           <span class="comment"># 最大缓存记录的数量（默认300）</span></span><br><span class="line">   <span class="string">&#x27;CULL_FREQUENCY&#x27;</span>: <span class="number">3</span>,          <span class="comment"># 缓存到达最大个数之后，剔除缓存个数的比例，即：1/CULL_FREQUENCY（默认3）</span></span><br><span class="line">  &#125;  </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.2.3 文件缓存(把缓存数据存储在文件中)</strong></p>
<p>settings.py文件配置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CACHES = &#123;</span><br><span class="line"> <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">  <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.core.cache.backends.filebased.FileBasedCache&#x27;</span>, <span class="comment">#指定缓存使用的引擎</span></span><br><span class="line">  <span class="string">&#x27;LOCATION&#x27;</span>: <span class="string">&#x27;/var/tmp/django_cache&#x27;</span>,        <span class="comment">#指定缓存的路径</span></span><br><span class="line">  <span class="string">&#x27;TIMEOUT&#x27;</span>:<span class="number">300</span>,              <span class="comment">#缓存超时时间(默认为300秒,None表示永不过期)</span></span><br><span class="line">  <span class="string">&#x27;OPTIONS&#x27;</span>:&#123;</span><br><span class="line">   <span class="string">&#x27;MAX_ENTRIES&#x27;</span>: <span class="number">300</span>,            <span class="comment"># 最大缓存记录的数量（默认300）</span></span><br><span class="line">   <span class="string">&#x27;CULL_FREQUENCY&#x27;</span>: <span class="number">3</span>,           <span class="comment"># 缓存到达最大个数之后，剔除缓存个数的比例，即：1/CULL_FREQUENCY（默认3）</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.2.4 数据库缓存(把缓存数据存储在数据库中)</strong></p>
<p>settings.py文件配置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CACHES = &#123;</span><br><span class="line"> <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">  <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.core.cache.backends.db.DatabaseCache&#x27;</span>,  <span class="comment"># 指定缓存使用的引擎</span></span><br><span class="line">  <span class="string">&#x27;LOCATION&#x27;</span>: <span class="string">&#x27;cache_table&#x27;</span>,          <span class="comment"># 数据库表    </span></span><br><span class="line">  <span class="string">&#x27;OPTIONS&#x27;</span>:&#123;</span><br><span class="line">   <span class="string">&#x27;MAX_ENTRIES&#x27;</span>: <span class="number">300</span>,           <span class="comment"># 最大缓存记录的数量（默认300）</span></span><br><span class="line">   <span class="string">&#x27;CULL_FREQUENCY&#x27;</span>: <span class="number">3</span>,          <span class="comment"># 缓存到达最大个数之后，剔除缓存个数的比例，即：1/CULL_FREQUENCY（默认3）</span></span><br><span class="line">  &#125;  </span><br><span class="line"> &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意,创建缓存的数据库表使用的语句:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py createcachetable</span><br></pre></td></tr></table></figure>

<p><strong>1.2.5 Memcache缓存(使用python-memcached模块连接memcache)</strong></p>
<p>Memcached是Django原生支持的缓存系统.要使用Memcached,需要下载Memcached的支持库python-memcached或pylibmc.</p>
<p>settings.py文件配置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CACHES = &#123;</span><br><span class="line"> <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">  <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.core.cache.backends.memcached.MemcachedCache&#x27;</span>, <span class="comment"># 指定缓存使用的引擎</span></span><br><span class="line">  <span class="string">&#x27;LOCATION&#x27;</span>: <span class="string">&#x27;192.168.10.100:11211&#x27;</span>,         <span class="comment"># 指定Memcache缓存服务器的IP地址和端口</span></span><br><span class="line">  <span class="string">&#x27;OPTIONS&#x27;</span>:&#123;</span><br><span class="line">   <span class="string">&#x27;MAX_ENTRIES&#x27;</span>: <span class="number">300</span>,            <span class="comment"># 最大缓存记录的数量（默认300）</span></span><br><span class="line">   <span class="string">&#x27;CULL_FREQUENCY&#x27;</span>: <span class="number">3</span>,           <span class="comment"># 缓存到达最大个数之后，剔除缓存个数的比例，即：1/CULL_FREQUENCY（默认3）</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LOCATION也可以配置成如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;LOCATION&#x27;</span>: <span class="string">&#x27;unix:/tmp/memcached.sock&#x27;</span>,   <span class="comment"># 指定局域网内的主机名加socket套接字为Memcache缓存服务器</span></span><br><span class="line"><span class="string">&#x27;LOCATION&#x27;</span>: [         <span class="comment"># 指定一台或多台其他主机ip地址加端口为Memcache缓存服务器</span></span><br><span class="line"> <span class="string">&#x27;192.168.10.100:11211&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;192.168.10.101:11211&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;192.168.10.102:11211&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>1.2.6 Memcache缓存(使用pylibmc模块连接memcache)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">settings.py文件配置</span><br><span class="line"> CACHES = &#123;</span><br><span class="line">  <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">   <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.core.cache.backends.memcached.PyLibMCCache&#x27;</span>,  <span class="comment"># 指定缓存使用的引擎</span></span><br><span class="line">   <span class="string">&#x27;LOCATION&#x27;</span>:<span class="string">&#x27;192.168.10.100:11211&#x27;</span>,         <span class="comment"># 指定本机的11211端口为Memcache缓存服务器</span></span><br><span class="line">   <span class="string">&#x27;OPTIONS&#x27;</span>:&#123;</span><br><span class="line">    <span class="string">&#x27;MAX_ENTRIES&#x27;</span>: <span class="number">300</span>,            <span class="comment"># 最大缓存记录的数量（默认300）</span></span><br><span class="line">    <span class="string">&#x27;CULL_FREQUENCY&#x27;</span>: <span class="number">3</span>,           <span class="comment"># 缓存到达最大个数之后，剔除缓存个数的比例，即：1/CULL_FREQUENCY（默认3）</span></span><br><span class="line">   &#125;,  </span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>LOCATION也可以配置成如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;LOCATION&#x27;</span>: <span class="string">&#x27;/tmp/memcached.sock&#x27;</span>,  <span class="comment"># 指定某个路径为缓存目录</span></span><br><span class="line"><span class="string">&#x27;LOCATION&#x27;</span>: [       <span class="comment"># 分布式缓存,在多台服务器上运行Memcached进程,程序会把多台服务器当作一个单独的缓存,而不会在每台服务器上复制缓存值</span></span><br><span class="line"> <span class="string">&#x27;192.168.10.100:11211&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;192.168.10.101:11211&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;192.168.10.102:11211&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>Memcached是基于内存的缓存,数据存储在内存中.所以如果服务器死机的话,数据就会丢失,所以Memcached一般与其他缓存配合使用</p>
<h2 id="四-Django中的缓存应用"><a href="#四-Django中的缓存应用" class="headerlink" title="四 Django中的缓存应用"></a>四 <strong>Django中的缓存应用</strong></h2><p>Django提供了不同粒度的缓存,可以缓存某个页面,可以只缓存一个页面的某个部分,甚至可以缓存整个网站.</p>
<p>数据库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name=models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    price=models.DecimalField(max_digits=<span class="number">6</span>,decimal_places=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj6s1tsurwj30m005ut98.jpg" alt="img"></p>
<h3 id="4-1-视图函数使用缓存"><a href="#4-1-视图函数使用缓存" class="headerlink" title="4.1 视图函数使用缓存"></a>4.1 视图函数使用缓存</h3><p>视图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.decorators.cache <span class="keyword">import</span> cache_page</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="meta">@cache_page(15)          #超时时间为15秒</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">　　t=time.time()      <span class="comment">#获取当前时间</span></span><br><span class="line">　　bookList=Book.objects.all()</span><br><span class="line">　　<span class="keyword">return</span> render(request,<span class="string">&quot;index.html&quot;</span>,locals())</span><br></pre></td></tr></table></figure>

<p>模板(index.html):</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h3&gt;当前时间:-----&#123;&#123; t &#125;&#125;&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;% <span class="keyword">for</span> book <span class="keyword">in</span> bookList %&#125;</span><br><span class="line">       &lt;li&gt;&#123;&#123; book.name &#125;&#125;---------&gt;&#123;&#123; book.price &#125;&#125;$&lt;/li&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>上面的例子是基于内存的缓存配置,基于文件的缓存该怎么配置呢??</p>
<p>更改settings.py的配置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CACHES = &#123;</span><br><span class="line"> <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">  <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.core.cache.backends.filebased.FileBasedCache&#x27;</span>, <span class="comment"># 指定缓存使用的引擎</span></span><br><span class="line">  <span class="string">&#x27;LOCATION&#x27;</span>: <span class="string">&#x27;E:\django_cache&#x27;</span>,          <span class="comment"># 指定缓存的路径</span></span><br><span class="line">  <span class="string">&#x27;TIMEOUT&#x27;</span>: <span class="number">300</span>,              <span class="comment"># 缓存超时时间(默认为300秒,None表示永不过期)</span></span><br><span class="line">  <span class="string">&#x27;OPTIONS&#x27;</span>: &#123;</span><br><span class="line">   <span class="string">&#x27;MAX_ENTRIES&#x27;</span>: <span class="number">300</span>,            <span class="comment"># 最大缓存记录的数量（默认300）</span></span><br><span class="line">   <span class="string">&#x27;CULL_FREQUENCY&#x27;</span>: <span class="number">3</span>,           <span class="comment"># 缓存到达最大个数之后，剔除缓存个数的比例，即：1/CULL_FREQUENCY（默认3）</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再次刷新浏览器,可以看到在刚才配置的目录下生成的缓存文件</p>
<p>通过实验可以知道,Django会以自己的形式把缓存文件保存在配置文件中指定的目录中.</p>
<h3 id="4-2-全站使用缓存"><a href="#4-2-全站使用缓存" class="headerlink" title="4.2 全站使用缓存"></a>4.2 全站使用缓存</h3><p>既然是全站缓存,当然要使用Django中的中间件.</p>
<p>用户的请求通过中间件,经过一系列的认证等操作,如果请求的内容在缓存中存在,则使用FetchFromCacheMiddleware获取内容并返回给用户</p>
<p>当返回给用户之前,判断缓存中是否已经存在,如果不存在,则UpdateCacheMiddleware会将缓存保存至Django的缓存之中,以实现全站缓存</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">缓存整个站点，是最简单的缓存方法</span><br><span class="line"></span><br><span class="line">在 MIDDLEWARE_CLASSES 中加入 “update” 和 “fetch” 中间件</span><br><span class="line">MIDDLEWARE_CLASSES = (</span><br><span class="line">    ‘django.middleware.cache.UpdateCacheMiddleware’, <span class="comment">#第一</span></span><br><span class="line">    <span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,</span><br><span class="line">    ‘django.middleware.cache.FetchFromCacheMiddleware’, <span class="comment">#最后</span></span><br><span class="line">)</span><br><span class="line">“update” 必须配置在第一个</span><br><span class="line">“fetch” 必须配置在最后一个</span><br></pre></td></tr></table></figure>

<p>修改settings.py配置文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MIDDLEWARE_CLASSES = (</span><br><span class="line">    <span class="string">&#x27;django.middleware.cache.UpdateCacheMiddleware&#x27;</span>,   <span class="comment">#响应HttpResponse中设置几个headers</span></span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth.middleware.SessionAuthenticationMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.cache.FetchFromCacheMiddleware&#x27;</span>,   <span class="comment">#用来缓存通过GET和HEAD方法获取的状态码为200的响应</span></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CACHE_MIDDLEWARE_SECONDS=<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>视图函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.decorators.cache <span class="keyword">import</span> cache_page</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line"></span><br><span class="line">     t=time.time()      <span class="comment">#获取当前时间</span></span><br><span class="line">     bookList=Book.objects.all()</span><br><span class="line">     <span class="keyword">return</span> render(request,<span class="string">&quot;index.html&quot;</span>,locals())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">request</span>):</span></span><br><span class="line">    t=time.time()      <span class="comment">#获取当前时间</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;HELLO:&quot;</span>+str(t))</span><br></pre></td></tr></table></figure>

<p>模板(index.html)：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">style</span>=<span class="string">&quot;color: green&quot;</span>&gt;</span>当前时间:-----&#123;&#123; t &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &#123;% for book in bookList %&#125;</span><br><span class="line">       <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; book.name &#125;&#125;---------&gt;&#123;&#123; book.price &#125;&#125;$<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其余代码不变,刷新浏览器是10秒,页面上的时间变化一次,这样就实现了全站缓存.</p>
<h3 id="4-3局部视图缓存"><a href="#4-3局部视图缓存" class="headerlink" title="4.3局部视图缓存"></a><strong>4.3局部视图缓存</strong></h3><p>例子,刷新页面时,整个网页有一部分实现缓存</p>
<p>views视图函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.decorators.cache <span class="keyword">import</span> cache_page</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">     t=time.time()      <span class="comment">#获取当前时间</span></span><br><span class="line">     bookList=Book.objects.all()</span><br><span class="line">     <span class="keyword">return</span> render(request,<span class="string">&quot;index.html&quot;</span>,locals())</span><br></pre></td></tr></table></figure>

<p>模板(index.html):</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% load cache %&#125;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">h3</span> <span class="attr">style</span>=<span class="string">&quot;color: green&quot;</span>&gt;</span>不缓存:-----&#123;&#123; t &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% cache 2 &#x27;name&#x27; %&#125;</span><br><span class="line"> <span class="tag">&lt;<span class="name">h3</span>&gt;</span>缓存:-----:&#123;&#123; t &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">&#123;% endcache %&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>23-Celery</title>
    <url>/posts/37977.html</url>
    <content><![CDATA[<p>Celery</p>
<a id="more"></a>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python中如果只做定时任务：可以用APScheduler ----&gt; 使用比较多</span><br><span class="line"></span><br><span class="line">Celery 监控  Flower</span><br></pre></td></tr></table></figure>
<p>大江狗文章:</p>
<p><a href="https://blog.csdn.net/weixin_42134789/article/details/105721628">https://blog.csdn.net/weixin_42134789/article/details/105721628</a></p>
<p><strong>2. @task与@shared_task的区别</strong></p>
<p>当我们使用@app.task装饰器定义我们的异步任务时，那么这个任务依赖于根据项目名myproject生成的Celery实例。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">app = Celery(<span class="string">&#x27;myproject&#x27;</span>)</span><br><span class="line">@app.task(bind=True)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug_task</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    print(<span class="string">&#x27;Request: &#123;0!r&#125;&#x27;</span>.format(<span class="keyword">self</span>.request))</span><br></pre></td></tr></table></figure>

<p>然而我们在进行Django开发时为了保证每个app的可重用性，我们经常会在每个app文件夹下编写异步任务，这些任务并不依赖于具体的Django项目名。使用@shared_task 装饰器能让我们避免对某个项目名对应Celery实例的依赖，使app的可移植性更强。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> shared_task</span><br><span class="line"><span class="meta">@shared_task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure>



<h1 id="Celery"><a href="#Celery" class="headerlink" title="Celery"></a>Celery</h1><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>Celery 官网：<a href="http://www.celeryproject.org/">http://www.celeryproject.org/</a></p>
<p>Celery 官方文档英文版：<a href="http://docs.celeryproject.org/en/latest/index.html">http://docs.celeryproject.org/en/latest/index.html</a></p>
<p>Celery 官方文档中文版：<a href="http://docs.jinkan.org/docs/celery/">http://docs.jinkan.org/docs/celery/</a></p>
<p>Celery是一个简单、灵活且可靠的，处理大量消息的分布式系统</p>
<p>专注于实时处理的异步任务队列</p>
<p>同时也支持任务调度</p>
<p>注意：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Celery is a project with minimal funding, so we don’t support Microsoft Windows. Please don’t open any issues related to that platform.</span><br></pre></td></tr></table></figure>

<h2 id="Celery异步任务框架"><a href="#Celery异步任务框架" class="headerlink" title="Celery异步任务框架"></a>Celery异步任务框架</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">1）可以不依赖任何服务器，通过自身命令，启动服务(内部支持socket)</span><br><span class="line">2）celery服务为为其他项目服务提供异步解决任务需求的</span><br><span class="line">注：会有两个服务同时运行，一个是项目服务，一个是celery服务，项目服务将需要异步处理的任务交给celery服务，celery就会在需要时异步完成项目的需求</span><br><span class="line"></span><br><span class="line">人是一个独立运行的服务 | 医院也是一个独立运行的服务</span><br><span class="line">    正常情况下，人可以完成所有健康情况的动作，不需要医院的参与；但当人生病时，就会被医院接收，解决人生病问题</span><br><span class="line">    人生病的处理方案交给医院来解决，所有人不生病时，医院独立运行，人生病时，医院就来解决人生病的需求</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Celery架构"><a href="#Celery架构" class="headerlink" title="Celery架构"></a>Celery架构</h2><p>Celery的架构由三部分组成，消息中间件（message broker）、任务执行单元（worker）和 任务执行结果存储（task result store）组成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggqw0f7bltj30q80c174d.jpg" alt="img"></p>
<h4 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h4><p>Celery本身不提供消息服务，但是可以方便的和第三方提供的消息中间件集成。包括，RabbitMQ, Redis等等</p>
<h4 id="任务执行单元"><a href="#任务执行单元" class="headerlink" title="任务执行单元"></a>任务执行单元</h4><p>Worker是Celery提供的任务执行的单元，worker并发的运行在分布式的系统节点中。</p>
<h4 id="任务结果存储"><a href="#任务结果存储" class="headerlink" title="任务结果存储"></a>任务结果存储</h4><p>Task result store用来存储Worker执行的任务的结果，Celery支持以不同方式存储任务的结果，包括AMQP, redis等</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>异步执行：解决耗时任务,将耗时操作任务提交给Celery去异步执行，比如发送短信/邮件、消息推送、音视频处理等等</p>
<p>延迟执行：解决延迟任务</p>
<p>定时执行：解决周期(周期)任务,比如每天数据统计</p>
<h2 id="Celery的安装配置"><a href="#Celery的安装配置" class="headerlink" title="Celery的安装配置"></a>Celery的安装配置</h2><p>pip install celery</p>
<p>消息中间件：RabbitMQ/Redis</p>
<p>app=Celery(‘任务名’, broker=’xxx’, backend=’xxx’)</p>
<h2 id="两种celery任务结构：提倡用包管理，结构更清晰"><a href="#两种celery任务结构：提倡用包管理，结构更清晰" class="headerlink" title="两种celery任务结构：提倡用包管理，结构更清晰"></a>两种celery任务结构：提倡用包管理，结构更清晰</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果 Celery对象:Celery(...) 是放在一个模块下的</span></span><br><span class="line"><span class="comment"># 1）终端切换到该模块所在文件夹位置：scripts</span></span><br><span class="line"><span class="comment"># 2）执行启动worker的命令：celery worker -A 模块名 -l info -P eventlet</span></span><br><span class="line"> <span class="number">5.0</span> 之后 celery --app=t_celery worker -l info</span><br><span class="line"><span class="comment"># 注：windows系统需要eventlet支持，Linux与MacOS直接执行：celery worker -A 模块名 -l info</span></span><br><span class="line"><span class="comment"># 注：模块名随意</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 Celery对象:Celery(...) 是放在一个包下的</span></span><br><span class="line"><span class="comment"># 1）必须在这个包下建一个celery.py的文件，将Celery(...)产生对象的语句放在该文件中</span></span><br><span class="line"><span class="comment"># 2）执行启动worker的命令：celery worker -A 包名 -l info -P eventlet</span></span><br><span class="line"><span class="comment"># 注：windows系统需要eventlet支持，Linux与MacOS直接执行：celery worker -A 模块名 -l info</span></span><br><span class="line"><span class="comment"># 注：包名随意</span></span><br></pre></td></tr></table></figure>

<h2 id="Celery执行异步任务"><a href="#Celery执行异步任务" class="headerlink" title="Celery执行异步任务"></a>Celery执行异步任务</h2><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建py文件：celery_app_task.py</span><br><span class="line">import celery</span><br><span class="line">import time</span><br><span class="line"># broker&#x3D;&#39;redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;2&#39; 不加密码</span><br><span class="line">backend&#x3D;&#39;redis:&#x2F;&#x2F;:123456@127.0.0.1:6379&#x2F;1&#39;</span><br><span class="line">broker&#x3D;&#39;redis:&#x2F;&#x2F;:123456@127.0.0.1:6379&#x2F;2&#39;</span><br><span class="line">cel&#x3D;celery.Celery(&#39;test&#39;,backend&#x3D;backend,broker&#x3D;broker)</span><br><span class="line">@cel.task</span><br><span class="line">def add(x,y):</span><br><span class="line">    return x+y</span><br></pre></td></tr></table></figure>

<h4 id="包架构封装（多任务结构）"><a href="#包架构封装（多任务结构）" class="headerlink" title="包架构封装（多任务结构）"></a>包架构封装（多任务结构）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">project</span><br><span class="line">    ├── celery_task      # celery包</span><br><span class="line">    │   ├── __init__.py # 包文件</span><br><span class="line">    │   ├── celery.py   # celery连接和配置相关文件，且名字必须叫celery.py</span><br><span class="line">    │   └── tasks.py    # 所有任务函数</span><br><span class="line">    ├── add_task.py      # 添加任务</span><br><span class="line">    └── get_result.py   # 获取结果</span><br></pre></td></tr></table></figure>

<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h5 id="celery-py"><a href="#celery-py" class="headerlink" title="celery.py"></a>celery.py</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1）创建app + 任务</span><br><span class="line"></span><br><span class="line"># 2）启动celery(app)服务：</span><br><span class="line"># 非windows</span><br><span class="line"># 命令：celery worker -A celery_task -l info</span><br><span class="line"># windows：</span><br><span class="line"># pip3 install eventlet</span><br><span class="line"># celery worker -A celery_task -l info -P eventlet</span><br><span class="line"></span><br><span class="line"># 3）添加任务：手动添加，要自定义添加任务的脚本，右键执行脚本</span><br><span class="line"></span><br><span class="line"># 4）获取结果：手动获取，要自定义获取任务的脚本，右键执行脚本</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from celery import Celery</span><br><span class="line">broker &#x3D; &#39;redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;1&#39;</span><br><span class="line">backend &#x3D; &#39;redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;2&#39;</span><br><span class="line">app &#x3D; Celery(broker&#x3D;broker, backend&#x3D;backend, include&#x3D;[&#39;celery_task.tasks&#39;])</span><br></pre></td></tr></table></figure>

<h5 id="tasks-py"><a href="#tasks-py" class="headerlink" title="tasks.py"></a>tasks.py</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from .celery import app</span><br><span class="line">import time</span><br><span class="line">@app.task</span><br><span class="line">def add(n, m):</span><br><span class="line">    print(n)</span><br><span class="line">    print(m)</span><br><span class="line">    time.sleep(10)</span><br><span class="line">    print(&#39;n+m的结果：%s&#39; % (n + m))</span><br><span class="line">    return n + m</span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def low(n, m):</span><br><span class="line">    print(n)</span><br><span class="line">    print(m)</span><br><span class="line">    print(&#39;n-m的结果：%s&#39; % (n - m))</span><br><span class="line">    return n - m</span><br></pre></td></tr></table></figure>

<h5 id="add-task-py"><a href="#add-task-py" class="headerlink" title="add_task.py"></a>add_task.py</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from celery_task import tasks</span><br><span class="line"></span><br><span class="line"># 添加立即执行任务</span><br><span class="line">t1 &#x3D; tasks.add.delay(10, 20)</span><br><span class="line">t2 &#x3D; tasks.low.delay(100, 50)</span><br><span class="line">print(t1.id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 添加延迟任务</span><br><span class="line">from datetime import datetime, timedelta</span><br><span class="line">eta&#x3D;datetime.utcnow() + timedelta(seconds&#x3D;10)</span><br><span class="line">tasks.low.apply_async(args&#x3D;(200, 50), eta&#x3D;eta)</span><br></pre></td></tr></table></figure>

<h5 id="get-result-py"><a href="#get-result-py" class="headerlink" title="get_result.py"></a>get_result.py</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from celery_task.celery import app</span><br><span class="line"></span><br><span class="line">from celery.result import AsyncResult</span><br><span class="line"></span><br><span class="line">id &#x3D; &#39;21325a40-9d32-44b5-a701-9a31cc3c74b5&#39;</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    async &#x3D; AsyncResult(id&#x3D;id, app&#x3D;app)</span><br><span class="line">    if async.successful():</span><br><span class="line">        result &#x3D; async.get()</span><br><span class="line">        print(result)</span><br><span class="line">    elif async.failed():</span><br><span class="line">        print(&#39;任务失败&#39;)</span><br><span class="line">    elif async.status &#x3D;&#x3D; &#39;PENDING&#39;:</span><br><span class="line">        print(&#39;任务等待中被执行&#39;)</span><br><span class="line">    elif async.status &#x3D;&#x3D; &#39;RETRY&#39;:</span><br><span class="line">        print(&#39;任务异常后正在重试&#39;)</span><br><span class="line">    elif async.status &#x3D;&#x3D; &#39;STARTED&#39;:</span><br><span class="line">        print(&#39;任务已经开始被执行&#39;)</span><br></pre></td></tr></table></figure>

<h3 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h3><h5 id="celery-py-1"><a href="#celery-py-1" class="headerlink" title="celery.py"></a>celery.py</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1）创建app + 任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2）启动celery(app)服务：</span></span><br><span class="line"><span class="comment"># 非windows</span></span><br><span class="line"><span class="comment"># 命令：celery worker -A celery_task -l info</span></span><br><span class="line"><span class="comment"># windows：</span></span><br><span class="line"><span class="comment"># pip3 install eventlet</span></span><br><span class="line"><span class="comment"># celery worker -A celery_task -l info -P eventlet</span></span><br><span class="line"></span><br><span class="line">celery --app=celery_task worker -l info</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3）添加任务：自动添加任务，所以要启动一个添加任务的服务</span></span><br><span class="line"><span class="comment"># 命令：celery beat -A celery_task -l info</span></span><br><span class="line"></span><br><span class="line">celery --app=celery_task beat -l info</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4）获取结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line">broker = <span class="string">&#x27;redis://127.0.0.1:6379/1&#x27;</span></span><br><span class="line">backend = <span class="string">&#x27;redis://127.0.0.1:6379/2&#x27;</span></span><br><span class="line">app = Celery(broker=broker, backend=backend, include=[<span class="string">&#x27;celery_task.tasks&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时区</span></span><br><span class="line">app.conf.timezone = <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="comment"># 是否使用UTC</span></span><br><span class="line">app.conf.enable_utc = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务的定时配置</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="keyword">from</span> celery.schedules <span class="keyword">import</span> crontab</span><br><span class="line">app.conf.beat_schedule = &#123;</span><br><span class="line">    <span class="string">&#x27;low-task&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;task&#x27;</span>: <span class="string">&#x27;celery_task.tasks.low&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;schedule&#x27;</span>: timedelta(seconds=<span class="number">3</span>),</span><br><span class="line">        <span class="comment"># &#x27;schedule&#x27;: crontab(hour=8, day_of_week=1),  # 每周一早八点</span></span><br><span class="line">        <span class="string">&#x27;args&#x27;</span>: (<span class="number">300</span>, <span class="number">150</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="tasks-py-1"><a href="#tasks-py-1" class="headerlink" title="tasks.py"></a>tasks.py</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from .celery import app</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line">@app.task</span><br><span class="line">def add(n, m):</span><br><span class="line">    print(n)</span><br><span class="line">    print(m)</span><br><span class="line">    time.sleep(10)</span><br><span class="line">    print(&#39;n+m的结果：%s&#39; % (n + m))</span><br><span class="line">    return n + m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def low(n, m):</span><br><span class="line">    print(n)</span><br><span class="line">    print(m)</span><br><span class="line">    print(&#39;n-m的结果：%s&#39; % (n - m))</span><br><span class="line">    return n - m</span><br></pre></td></tr></table></figure>

<h5 id="get-result-py-1"><a href="#get-result-py-1" class="headerlink" title="get_result.py"></a>get_result.py</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from celery_task.celery import app</span><br><span class="line"></span><br><span class="line">from celery.result import AsyncResult</span><br><span class="line"></span><br><span class="line">id &#x3D; &#39;21325a40-9d32-44b5-a701-9a31cc3c74b5&#39;</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    async &#x3D; AsyncResult(id&#x3D;id, app&#x3D;app)</span><br><span class="line">    if async.successful():</span><br><span class="line">        result &#x3D; async.get()</span><br><span class="line">        print(result)</span><br><span class="line">    elif async.failed():</span><br><span class="line">        print(&#39;任务失败&#39;)</span><br><span class="line">    elif async.status &#x3D;&#x3D; &#39;PENDING&#39;:</span><br><span class="line">        print(&#39;任务等待中被执行&#39;)</span><br><span class="line">    elif async.status &#x3D;&#x3D; &#39;RETRY&#39;:</span><br><span class="line">        print(&#39;任务异常后正在重试&#39;)</span><br><span class="line">    elif async.status &#x3D;&#x3D; &#39;STARTED&#39;:</span><br><span class="line">        print(&#39;任务已经开始被执行&#39;)</span><br></pre></td></tr></table></figure>

<h3 id="django中使用"><a href="#django中使用" class="headerlink" title="django中使用"></a>django中使用</h3><h5 id="celery-py-2"><a href="#celery-py-2" class="headerlink" title="celery.py"></a>celery.py</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">celery框架django项目工作流程</span></span><br><span class="line"><span class="string">1）加载django配置环境</span></span><br><span class="line"><span class="string">2）创建Celery框架对象app，配置broker和backend，得到的app就是worker</span></span><br><span class="line"><span class="string">3）给worker对应的app添加可处理的任务函数，用include配置给worker的app</span></span><br><span class="line"><span class="string">4）完成提供的任务的定时配置app.conf.beat_schedule</span></span><br><span class="line"><span class="string">5）启动celery服务，运行worker，执行任务</span></span><br><span class="line"><span class="string">6）启动beat服务，运行beat，添加任务</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">重点：由于采用了django的反射机制，使用celery.py所在的celery_task包必须放置项目的根目录下</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一、加载django配置环境</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&quot;luffyapi.settings.dev&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二、加载celery配置环境</span></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="comment"># broker</span></span><br><span class="line">broker = <span class="string">&#x27;redis://127.0.0.1:6379/0&#x27;</span></span><br><span class="line"><span class="comment"># backend</span></span><br><span class="line">backend = <span class="string">&#x27;redis://127.0.0.1:6379/1&#x27;</span></span><br><span class="line"><span class="comment"># worker</span></span><br><span class="line">app = Celery(broker=broker, backend=backend, include=[<span class="string">&#x27;celery_task.tasks&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时区</span></span><br><span class="line">app.conf.timezone = <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="comment"># 是否使用UTC</span></span><br><span class="line">app.conf.enable_utc = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务的定时配置</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="keyword">from</span> celery.schedules <span class="keyword">import</span> crontab</span><br><span class="line">app.conf.beat_schedule = &#123;</span><br><span class="line">    <span class="string">&#x27;update-banner-list&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;task&#x27;</span>: <span class="string">&#x27;celery_task.tasks.update_banner_list&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;schedule&#x27;</span>: timedelta(seconds=<span class="number">10</span>),</span><br><span class="line">        <span class="string">&#x27;args&#x27;</span>: (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="tasks-py（定时任务）"><a href="#tasks-py（定时任务）" class="headerlink" title="tasks.py（定时任务）"></a>tasks.py（定时任务）</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .celery <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.core.cache <span class="keyword">import</span> cache</span><br><span class="line"><span class="keyword">from</span> home <span class="keyword">import</span> models, serializers</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_banner_list</span>():</span></span><br><span class="line">    queryset = models.Banner.objects.filter(is_delete=<span class="literal">False</span>, is_show=<span class="literal">True</span>).order_by(<span class="string">&#x27;-orders&#x27;</span>)[:settings.BANNER_COUNT]</span><br><span class="line">    banner_list = serializers.BannerSerializer(queryset, many=<span class="literal">True</span>).data</span><br><span class="line">    <span class="comment"># 拿不到request对象，所以头像的连接base_url要自己组装</span></span><br><span class="line">    <span class="keyword">for</span> banner <span class="keyword">in</span> banner_list:</span><br><span class="line">        banner[<span class="string">&#x27;image&#x27;</span>] = <span class="string">&#x27;http://127.0.0.1:8000%s&#x27;</span> % banner[<span class="string">&#x27;image&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    cache.set(<span class="string">&#x27;banner_list&#x27;</span>, banner_list, <span class="number">86400</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="sms-task-py-异步"><a href="#sms-task-py-异步" class="headerlink" title="sms_task.py(异步)"></a>sms_task.py(异步)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .celery <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_sms</span>(<span class="params">mobile, code</span>):</span></span><br><span class="line">    <span class="keyword">from</span> luffyapi.libs.t_sms <span class="keyword">import</span> send_code</span><br><span class="line">    res = send_code(mobile_phone=mobile, code=code)</span><br><span class="line">    <span class="keyword">if</span> res:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;%s手机号, 短信发送成功&#x27;</span>%mobile</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;%s手机号, 短信发送失败&#x27;</span>%mobile</span><br></pre></td></tr></table></figure>

<h3 id="views-py（异步提交任务）"><a href="#views-py（异步提交任务）" class="headerlink" title="views.py（异步提交任务）"></a>views.py（异步提交任务）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendCodeView</span>(<span class="params">ViewSet</span>):</span></span><br><span class="line"><span class="comment">#######异步发送短信####################</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @action(methods=[&#x27;GET&#x27;], detail=False)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_code</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        mobile = request.GET.get(<span class="string">&#x27;mobile&#x27;</span>)</span><br><span class="line">        <span class="comment"># 验证手机号是否合法</span></span><br><span class="line">        <span class="keyword">if</span> re.match(<span class="string">r&#x27;1[3-9][0-9]&#123;9&#125;$&#x27;</span>, mobile):</span><br><span class="line">            <span class="comment"># 生成验证码</span></span><br><span class="line">            code_random = get_code()</span><br><span class="line">            print(code_random)</span><br><span class="line">            <span class="comment"># 发送验证码</span></span><br><span class="line">            <span class="keyword">from</span> celery_task.sms_task <span class="keyword">import</span> send_sms</span><br><span class="line">            res = send_sms.delay(mobile=mobile, code=code_random)</span><br><span class="line">            print(res)</span><br><span class="line">            <span class="comment"># 缓存验证码</span></span><br><span class="line">            cache.set(settings.SMS_CACHE_KEY % &#123;<span class="string">&#x27;mobile&#x27;</span>: mobile&#125;, code_random, settings.SMS_CACHE_TIME)</span><br><span class="line">            <span class="keyword">return</span> APIResponse(msg=<span class="string">&#x27;短信已发送&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> APIResponse(code=<span class="number">1</span>, msg=<span class="string">&#x27;手机号不合法&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="也可以写成装饰器"><a href="#也可以写成装饰器" class="headerlink" title="也可以写成装饰器"></a>也可以写成装饰器</h3><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20210730204308096.png" alt="image-20210730204308096"></p>
<hr>
<h2 id="1-celery基本使用"><a href="#1-celery基本使用" class="headerlink" title="1 celery基本使用"></a>1 celery基本使用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 写一个py文件</span><br><span class="line">    <span class="keyword">import</span> celery</span><br><span class="line">    <span class="comment"># 消息中间件（redis）</span></span><br><span class="line">    broker=<span class="string">&#x27;redis://127.0.0.1:6379/1&#x27;</span>     <span class="comment"># 1 表示使用redis 1 这个db</span></span><br><span class="line">    <span class="comment"># 结果存储（redis）</span></span><br><span class="line">    backend=<span class="string">&#x27;redis://127.0.0.1:6379/2&#x27;</span>   <span class="comment"># 2 表示使用redis 2 这个db</span></span><br><span class="line">    <span class="comment"># 实例化得到对象，指定中间件和结果存储</span></span><br><span class="line">    app=celery.Celery(<span class="string">&#x27;test&#x27;</span>,broker=broker,backend=backend)</span><br><span class="line"><span class="meta">    @app.task</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a,b</span>):</span></span><br><span class="line">        <span class="keyword">return</span> a+b</span><br><span class="line"><span class="meta">    @app.task</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">a,b</span>):</span></span><br><span class="line">        <span class="keyword">return</span> a*b</span><br><span class="line">    </span><br><span class="line"><span class="number">2</span> 提交任务（在其它文件中）</span><br><span class="line">    <span class="keyword">from</span> t_celery <span class="keyword">import</span> add, mul</span><br><span class="line">    res=add.delay(<span class="number">100</span>,<span class="number">4</span>) </span><br><span class="line">    print(res)  <span class="comment"># id号</span></span><br><span class="line">    </span><br><span class="line"><span class="number">3</span> 启动worker</span><br><span class="line">    <span class="comment"># 非windows平台：celery worker -A t_celery -l info</span></span><br><span class="line">           <span class="number">5.0</span> 之后 celery --app=t_celery worker -l info</span><br><span class="line">    <span class="comment"># windows装eventlet：celery worker -A t_celery -l info -P eventlet</span></span><br><span class="line">    </span><br><span class="line"><span class="number">4</span> 查看执行结果</span><br><span class="line">    <span class="keyword">from</span> t_celery <span class="keyword">import</span> app</span><br><span class="line">    <span class="keyword">from</span> celery.result <span class="keyword">import</span> AsyncResult</span><br><span class="line">    <span class="comment"># 关键字，变量不能定义为关键字</span></span><br><span class="line">    id = <span class="string">&#x27;5331c70b-1b51-4a15-aa17-2fa0f7952c00&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">        res = AsyncResult(id=id, app=app)</span><br><span class="line">        <span class="keyword">if</span> res.successful():</span><br><span class="line">            result = res.get()</span><br><span class="line">            print(result)</span><br><span class="line">        <span class="keyword">elif</span> res.failed():</span><br><span class="line">            print(<span class="string">&#x27;任务失败&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> res.status == <span class="string">&#x27;PENDING&#x27;</span>:</span><br><span class="line">            print(<span class="string">&#x27;任务等待中被执行&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> res.status == <span class="string">&#x27;RETRY&#x27;</span>:</span><br><span class="line">            print(<span class="string">&#x27;任务异常后正在重试&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> res.status == <span class="string">&#x27;STARTED&#x27;</span>:</span><br><span class="line">            print(<span class="string">&#x27;任务已经开始被执行&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="2-celery多任务结构"><a href="#2-celery多任务结构" class="headerlink" title="2 celery多任务结构"></a>2 celery多任务结构</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">package_celery:     <span class="comment"># 项目名</span></span><br><span class="line">    celery_task     <span class="comment"># celery包名</span></span><br><span class="line">        __init__.py </span><br><span class="line">        celery.py   <span class="comment"># celery 的app，必须叫celery</span></span><br><span class="line">        order_task.py <span class="comment"># 任务</span></span><br><span class="line">        user_task.py  <span class="comment"># 任务</span></span><br><span class="line">    result.py         <span class="comment"># 结果查询</span></span><br><span class="line">    submit_tast.py    <span class="comment"># 提交任务</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 运行worker（在package_celery目录下执行）</span></span><br><span class="line">    celery worker -A celery_task -l info -P eventlet</span><br><span class="line"><span class="comment"># 提交任务</span></span><br><span class="line">    <span class="keyword">from</span> celery_task <span class="keyword">import</span> order_task,user_task</span><br><span class="line">    <span class="comment"># 提交一个给用户发短信的任务</span></span><br><span class="line">    res=user_task.send_sms.delay(<span class="string">&#x27;18723454566&#x27;</span>)</span><br><span class="line">    print(res)</span><br><span class="line">    <span class="comment"># 提交一个取消订单任务</span></span><br><span class="line">    res=order_task.cancel_order.delay()</span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 真实应用场景</span></span><br><span class="line">    -秒杀系统</span><br><span class="line">        -不能秒超，使用锁（mysql悲观锁，乐观锁），redis锁</span><br><span class="line">        -提高并发量---》把同步做成异步---》使用celery</span><br><span class="line">            -前端点击秒杀按钮，向后端发送秒杀请求---》同步操作</span><br><span class="line">                -同步操作</span><br><span class="line">                    -请求来到后端，判断数量是否够，如果够，要生成订单（mysql），订单状态是待支付状                    态                        </span><br><span class="line">                    -请求返回，告诉前端，秒杀成功</span><br><span class="line">                -异步操作</span><br><span class="line">                    -请求来到后端，提交一个celery任务---》celery任务异步的执行判断数量是否够，如                        果够，要生成订单（mysql）</span><br><span class="line">                    -秒杀是否成功的结果还没有，直接返回了（返回任务id）</span><br><span class="line">                    -前端启动一个定时任务，每隔<span class="number">5</span>s，向后台发送一个查询请求，查询秒杀任务是否执行完                     成（带着任务id查）</span><br><span class="line">                    -如果是未执行状态，或者执行中---》返回给前端，前端不处理，定时任务继续执行</span><br><span class="line">                    -又隔了<span class="number">5</span>s，发送查询，查询到秒杀成功的结果，返回给前端，秒杀成功</span><br><span class="line">            </span><br></pre></td></tr></table></figure>





<h2 id="3-高级使用之延时任务"><a href="#3-高级使用之延时任务" class="headerlink" title="3 高级使用之延时任务"></a>3 高级使用之延时任务</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># celery执行延时任务</span></span><br><span class="line"><span class="comment">## 第一种方式：2021年1月7日17点3分12秒发送短信</span></span><br><span class="line"><span class="comment"># from datetime import datetime</span></span><br><span class="line"><span class="comment"># # # eta:延迟多长时间执行，eta需要传时间对象,并且是utc时间</span></span><br><span class="line"><span class="comment"># v1 = datetime(2021, 1, 7, 17, 3, 12)</span></span><br><span class="line"><span class="comment"># print(v1)</span></span><br><span class="line"><span class="comment"># v2 = datetime.utcfromtimestamp(v1.timestamp())</span></span><br><span class="line"><span class="comment"># print(v2)</span></span><br><span class="line"><span class="comment"># res=user_task.send_sms.apply_async(args=[&#x27;18977654332&#x27;,],eta=v2)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 第二种方式：隔几秒后执行</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line">ctime = datetime.now()</span><br><span class="line"><span class="comment"># 默认用utc时间</span></span><br><span class="line">utc_ctime = datetime.utcfromtimestamp(ctime.timestamp())</span><br><span class="line"></span><br><span class="line">time_delay = timedelta(seconds=<span class="number">10</span>)</span><br><span class="line">task_time = utc_ctime + time_delay</span><br><span class="line">print(task_time)</span><br><span class="line">res=user_task.send_sms.apply_async(args=[<span class="string">&#x27;18977654332&#x27;</span>,],eta=task_time)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="4-高级使用之定时任务"><a href="#4-高级使用之定时任务" class="headerlink" title="4 高级使用之定时任务"></a>4 高级使用之定时任务</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在celery.py中配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时区</span></span><br><span class="line">app.conf.timezone = <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="comment"># 是否使用UTC</span></span><br><span class="line">app.conf.enable_utc = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务的定时配置</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="keyword">from</span> celery.schedules <span class="keyword">import</span> crontab</span><br><span class="line"></span><br><span class="line">app.conf.beat_schedule = &#123;</span><br><span class="line">    <span class="string">&#x27;send-msg&#x27;</span>:&#123;</span><br><span class="line">        <span class="string">&#x27;task&#x27;</span>: <span class="string">&#x27;celery_task.user_task.send_sms&#x27;</span>,</span><br><span class="line">        <span class="comment"># &#x27;schedule&#x27;: timedelta(hours=24*10),</span></span><br><span class="line">        <span class="comment"># &#x27;schedule&#x27;: crontab(hour=8, day_of_week=1),  # 每周一早八点</span></span><br><span class="line">        <span class="string">&#x27;schedule&#x27;</span>: crontab(hour=<span class="number">8</span>, day_of_month=<span class="number">1</span>),  <span class="comment"># 每月一号早八点</span></span><br><span class="line">        <span class="string">&#x27;args&#x27;</span>: (<span class="string">&#x27;18964352112&#x27;</span>,),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动beat，负责每隔3s提交一个任务</span></span><br><span class="line">celery beat -A celery_task -l info</span><br><span class="line"><span class="comment"># 启动worker</span></span><br><span class="line">celery worker -A celery_task -l info -P eventlet</span><br></pre></td></tr></table></figure>



<h2 id="5-django中使用celery"><a href="#5-django中使用celery" class="headerlink" title="5 django中使用celery"></a>5 django中使用celery</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> celery是独立的，跟框架没有关系</span><br><span class="line"><span class="number">2</span> django-celery第三方模块，兼容性不好，咱们不采用，咱们使用通用方式</span><br><span class="line"><span class="number">3</span> 目录</span><br><span class="line">    celery_task</span><br><span class="line">        __init__.py</span><br><span class="line">        celery.py</span><br><span class="line">        home_task.py</span><br><span class="line">        order_task.py</span><br><span class="line">        user_task.py</span><br><span class="line">    luffyapi</span><br></pre></td></tr></table></figure>

<h3 id="5-1-home-task-py"><a href="#5-1-home-task-py" class="headerlink" title="5.1 home_task.py"></a>5.1 home_task.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> celery_task.celery <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_banner</span>():</span></span><br><span class="line">    <span class="keyword">from</span> django.core.cache <span class="keyword">import</span> cache</span><br><span class="line">    <span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line">    <span class="keyword">from</span> home <span class="keyword">import</span> models</span><br><span class="line">    <span class="keyword">from</span> home <span class="keyword">import</span> serializer</span><br><span class="line">    banners=models.Banner.objects.filter(is_delete=<span class="literal">False</span>, is_show=<span class="literal">True</span>).order_by(<span class="string">&#x27;-order&#x27;</span>)[:settings.BANNER_SIZE]</span><br><span class="line"></span><br><span class="line">    ser = serializer.BannerModelSerializer(instance=banners,many=<span class="literal">True</span>)</span><br><span class="line">    banner_data=ser.data</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 拿不到request对象，所以头像的连接base_url要自己组装</span></span><br><span class="line">    <span class="keyword">for</span> banner <span class="keyword">in</span> banner_data:</span><br><span class="line">        banner[<span class="string">&#x27;img&#x27;</span>] = <span class="string">&#x27;http://127.0.0.1:8000%s&#x27;</span> % banner[<span class="string">&#x27;img&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cache.set(<span class="string">&#x27;banner_data&#x27;</span>,banner_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-celery-py"><a href="#5-2-celery-py" class="headerlink" title="5.2 celery.py"></a>5.2 celery.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> celery</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 执行django配置文件，环境变量加入</span></span><br><span class="line">os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&quot;luffyapi.settings.dev&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">broker=<span class="string">&#x27;redis://127.0.0.1:6379/1&#x27;</span>     <span class="comment"># 1 表示使用redis 1 这个db</span></span><br><span class="line"></span><br><span class="line">backend=<span class="string">&#x27;redis://127.0.0.1:6379/2&#x27;</span>   <span class="comment"># 2 表示使用redis 2 这个db</span></span><br><span class="line"></span><br><span class="line">app=celery.Celery(<span class="string">&#x27;test&#x27;</span>,broker=broker,backend=backend,</span><br><span class="line">                  include=[<span class="string">&#x27;celery_task.order_task&#x27;</span>,<span class="string">&#x27;celery_task.user_task&#x27;</span>,<span class="string">&#x27;celery_task.home_task&#x27;</span>]</span><br><span class="line">                  )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时区</span></span><br><span class="line">app.conf.timezone = <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="comment"># 是否使用UTC</span></span><br><span class="line">app.conf.enable_utc = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务的定时配置</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="keyword">from</span> celery.schedules <span class="keyword">import</span> crontab</span><br><span class="line"></span><br><span class="line">app.conf.beat_schedule = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># &#x27;send-msg&#x27;:&#123;</span></span><br><span class="line">    <span class="comment">#     &#x27;task&#x27;: &#x27;celery_task.user_task.send_sms&#x27;,</span></span><br><span class="line">    <span class="comment">#     # &#x27;schedule&#x27;: timedelta(hours=24*10),</span></span><br><span class="line">    <span class="comment">#     # &#x27;schedule&#x27;: crontab(hour=8, day_of_week=1),  # 每周一早八点</span></span><br><span class="line">    <span class="comment">#     &#x27;schedule&#x27;: crontab(hour=8, day_of_month=1),  # 每月一号早八点</span></span><br><span class="line">    <span class="comment">#     &#x27;args&#x27;: (&#x27;18964352112&#x27;,),</span></span><br><span class="line">    <span class="comment"># &#125;</span></span><br><span class="line">    <span class="string">&#x27;update-banner&#x27;</span>:&#123;</span><br><span class="line">        <span class="string">&#x27;task&#x27;</span>: <span class="string">&#x27;celery_task.home_task.update_banner&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;schedule&#x27;</span>: timedelta(seconds=<span class="number">10</span>),</span><br><span class="line">        <span class="string">&#x27;args&#x27;</span>: (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="views-py"><a href="#views-py" class="headerlink" title="views.py"></a>views.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> celery_task <span class="keyword">import</span> user_task</span><br><span class="line"><span class="keyword">from</span> celery_task.celery <span class="keyword">import</span> app</span><br><span class="line"><span class="keyword">from</span> celery.result <span class="keyword">import</span> AsyncResult</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_celery</span>(<span class="params">request</span>):</span></span><br><span class="line">    res_id = request.GET.get(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> res_id:</span><br><span class="line">        res = AsyncResult(id=res_id, app=app)</span><br><span class="line">        <span class="keyword">if</span> res.successful():</span><br><span class="line">            result = res.get()</span><br><span class="line">            print(result)</span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;执行完成了，结果是：%s&#x27;</span> % result)</span><br><span class="line"></span><br><span class="line">    res = user_task.send_sms.delay(<span class="string">&#x27;18276345221&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;任务号是：%s&#x27;</span> % str(res))</span><br></pre></td></tr></table></figure>

<h2 id="6-首页轮播图定时更新"><a href="#6-首页轮播图定时更新" class="headerlink" title="6 首页轮播图定时更新"></a>6 首页轮播图定时更新</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 把首页轮播图接口改成，先去缓存中取，缓存中没有，再去数据库查</span><br><span class="line"><span class="number">2</span> 首页轮播图加入了缓存</span><br><span class="line"><span class="number">3</span> 以后，如果你的接口，请求慢，第一反应就是先使用缓存</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4</span> 使用celery定时更新缓存</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BannerView</span>(<span class="params">GenericViewSet, ListModelMixin</span>):</span></span><br><span class="line">    queryset = models.Banner.objects.filter(is_delete=<span class="literal">False</span>, is_show=<span class="literal">True</span>).order_by(<span class="string">&#x27;-order&#x27;</span>)[:settings.BANNER_SIZE]</span><br><span class="line">    serializer_class = serializer.BannerModelSerializer</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 改成，先从缓存中取，缓存中如果有，直接返回，没有，再去数据库查</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 如果缓存中有值，直接取出来返回，速度很快</span></span><br><span class="line">        banner_data = cache.get(<span class="string">&#x27;banner_data&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> banner_data:</span><br><span class="line"></span><br><span class="line">            print(<span class="string">&#x27;走了缓存&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> Response(data=banner_data)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果缓存中没有，再走数据，查出来，放到缓存中</span></span><br><span class="line">        res = super().list(request, *args, **kwargs)</span><br><span class="line">        <span class="comment"># 把首页轮播图数据放到缓存中</span></span><br><span class="line">        cache.set(<span class="string">&#x27;banner_data&#x27;</span>, res.data)</span><br><span class="line">        print(<span class="string">&#x27;没走缓存&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<p>补充</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> celery:分布式异步任务框架，独立的</span><br><span class="line"><span class="number">2</span> celery可以做的事</span><br><span class="line">    -异步任务：提交任务：任务函数.delay()----》消息中间件（redis/rabbitmq）---》worker消费--》结                        果存储（redis）</span><br><span class="line">    -延迟任务：任务函数.apply_async(args=(),时间对象)----》消息中间件（redis/rabbitmq）---》                worker消费--》结果存储（redis）</span><br><span class="line">    -定时任务：启动beat（负责定时提交任务）----》消息中间件（redis/rabbitmq）---》                        worker消费--》结果存储（redis） </span><br><span class="line"><span class="number">3</span> 单文件的celery的使用（用的比较少）</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> 包结构的celery</span><br><span class="line">    -celery_task</span><br><span class="line">        -celery.py   :app对象，app的配置（可以直接写，也可以再使用另外一个文件配置）可以参照官网                        修改部分参数，</span><br><span class="line">        -task1.py :   task可能直接放在项目中app01下</span><br><span class="line">        -task2.py :   任务</span><br><span class="line">    </span><br><span class="line"><span class="number">5</span> celery集成到django中使用，需要配置</span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    <span class="comment"># 执行django配置文件，环境变量加入</span></span><br><span class="line">    os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&quot;luffyapi.settings.dev&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="number">6</span> 启动worker</span><br><span class="line"><span class="number">7</span> 启动beat</span><br><span class="line"><span class="number">8</span> django-celery：第三方，让celery再django中更方便的集成</span><br><span class="line">    -celery的配置文件直接写在django的配置文件中</span><br><span class="line">    -启动worker，beat， python manage.py </span><br><span class="line">    </span><br><span class="line">    -咱们不用，问题在：django <span class="number">1.11</span><span class="number">.9</span>    <span class="number">4.</span>x  ---》最新的django-celery</span><br><span class="line">    -https://www.celerycn.io/fu-lu/django</span><br><span class="line">        </span><br><span class="line"><span class="number">9</span> celery做集群，本质是搭建消息队列的集群（redis的集群搭建）</span><br><span class="line">    </span><br><span class="line"><span class="number">10</span> 后期如果使用rabbitmq，只需要把broker更改成</span><br><span class="line">    broker=<span class="string">&#x27;amqp://localhost:port&#x27;</span>  <span class="comment"># 消息队列的url</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="number">11</span> 首页轮播图做缓存，所有的接口缓存都这么写</span><br><span class="line">    -redis+mysql：双写一致性</span><br><span class="line">    -(<span class="number">1</span>) 定期更新或者过期时间（取决于接口）,对数据准确性要求不是特别高的接口</span><br><span class="line">  -(<span class="number">2</span>) 修改了MySQL, 修改缓存</span><br><span class="line">        先改缓存，再改数据库 (很少这样操作，成本比较高。 找缓存，就比较麻烦)</span><br><span class="line">        先改数据库，再改缓存(比较多)</span><br><span class="line">  -(<span class="number">3</span>) 修改了MySQL，删除缓存</span><br><span class="line">       - 先删除缓存，再更新数据库</span><br><span class="line">       - 先更新数据库，再删除缓存</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="number">12</span> celery配置文件参数（了解）</span><br><span class="line">    <span class="comment">#有些情况可以防止死锁</span></span><br><span class="line">    CELERYD_FORCE_EXECV=<span class="literal">True</span></span><br><span class="line">    <span class="comment"># 设置并发worker数量</span></span><br><span class="line">    CELERYD_CONCURRENCY=<span class="number">4</span></span><br><span class="line">    <span class="comment">#允许重试</span></span><br><span class="line">    CELERY_ACKS_LATE=<span class="literal">True</span></span><br><span class="line">    <span class="comment"># 每个worker最多执行100个任务被销毁，可以防止内存泄漏</span></span><br><span class="line">    CELERYD_MAX_TASKS_PER_CHILD=<span class="number">100</span></span><br><span class="line">    <span class="comment"># 超时时间</span></span><br><span class="line">    CELERYD_TASK_TIME_LIMIT=<span class="number">12</span>*<span class="number">30</span></span><br><span class="line">    </span><br><span class="line">补充 Supervisor：进程管理工具，python写的，在linux上，通过配置，保证，进程如果挂掉了，自动重启</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-动态定时任务"><a href="#7-动态定时任务" class="headerlink" title="7.动态定时任务"></a>7.动态定时任务</h2><h3 id="Django-Celery-Beat"><a href="#Django-Celery-Beat" class="headerlink" title="Django-Celery-Beat"></a>Django-Celery-Beat</h3><blockquote>
<p>安装</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install celery==<span class="number">4.4</span><span class="number">.2</span>  </span><br><span class="line">pip install django-celery-beat==<span class="number">2.0</span><span class="number">.0</span>  </span><br><span class="line">pip install django-celery-results</span><br><span class="line">pip install redis==<span class="number">3.5</span><span class="number">.2</span> <span class="comment"># django-redis已经装好了</span></span><br></pre></td></tr></table></figure>

<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml">INSTALLED_APPS = [</span></span><br><span class="line"><span class="xml">    &#x27;django.contrib.admin&#x27;,</span></span><br><span class="line"><span class="xml">    ...</span></span><br><span class="line"><span class="xml">    &#x27;app01&#x27;,</span></span><br><span class="line"><span class="xml">    &#x27;django_celery_beat&#x27;,</span></span><br><span class="line"><span class="xml">]</span></span><br><span class="line"></span><br><span class="line"><span class="xml">LANGUAGE_CODE = &#x27;zh-hans&#x27;  # 使用中国语言</span></span><br><span class="line"><span class="xml">TIME_ZONE = &#x27;Asia/Shanghai&#x27;  # 设置Django使用中国上海时间</span></span><br><span class="line"><span class="xml"># 如果USE_TZ设置为True时，Django会使用系统默认设置的时区，此时的TIME_ZONE不管有没有设置都不起作用</span></span><br><span class="line"><span class="xml"># 如果USE_TZ 设置为False,TIME_ZONE = &#x27;Asia/Shanghai&#x27;, 则使用上海的UTC时间。</span></span><br><span class="line"><span class="xml">USE_TZ = False  # 如果用的sqlit数据库，那么改为True，sqlit数据库不支持</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py migarate</span><br><span class="line">python manage.py migarations</span><br></pre></td></tr></table></figure>

<h3 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h3><ul>
<li>通过数据库的表操作，完成定时任务的添加</li>
</ul>
<p>之前：固定死的定时任务；运行过程中你如果想改一下参数，是改不了的。改了需要重启</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20220303154324797.png" alt="image-20220303154324797"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">之前：写好了任务方法，要在celery里面写任务配置，schedule定时执行</span><br><span class="line"></span><br><span class="line">现在：会自动生成几张表，我们在表里面更改添加几条数据，就能够让定时任务生效，celery beat不用重启就能够自动添加schedule定时配置，执行任务函数。</span><br><span class="line">CELERY_BEAT_SCHEDULER &#x3D; &#39;django_celery_beat.schedulers:DatabaseScheduler&#39;</span><br><span class="line">django-celery-beat相当于加了一个数据库的任务调度器，添加任务是相当于添加进了生成的那几张表里面去了，把worker发现的任务通过数据库表操作的形式，调度给beat，让beat去执行。beat-scheduler相当于直接给worker丢任务，worker不用重启。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">period_obj的id值存储到我们自己的任务数据库表中，那么就可以很方便的停止和开启某个任务了</span><br></pre></td></tr></table></figure>

<p>先完成一下测试示例</p>
<p>在项目目录下创建celery的代码文件夹，比如名称为celery_tasks</p>
<p>在celery_tasks文件夹下创建几个文件，celery.py(实例化celery对象) 、celeryconfig.py(celery配置项d) 、  tasks.py(任务文件)</p>
<p>Celery.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="keyword">from</span> celery_tasks <span class="keyword">import</span> celeryconfig</span><br><span class="line"><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 为celery设置环境变量</span></span><br><span class="line">os.environ.setdefault(<span class="string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="string">&#x27;celery_test2.settings.dev&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建celery app</span></span><br><span class="line">app = Celery(<span class="string">&#x27;celery_tasks&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从单独的配置模块中加载配置</span></span><br><span class="line">app.config_from_object(celeryconfig)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置app自动加载任务</span></span><br><span class="line">app.autodiscover_tasks([</span><br><span class="line">    <span class="string">&#x27;celery_tasks&#x27;</span>,</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决时区问题,定时任务启动就循环输出</span></span><br><span class="line"><span class="comment"># app.now = timezone.now</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>celeryconfig.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为celery设置环境变量</span></span><br><span class="line">os.environ.setdefault(<span class="string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="string">&#x27;celery_test2.settings.dev&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置结果存储</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">&#x27;redis://127.0.0.1:6379/9&#x27;</span></span><br><span class="line"><span class="comment"># 设置代理人broker</span></span><br><span class="line">BROKER_URL = <span class="string">&#x27;redis://127.0.0.1:6379/8&#x27;</span></span><br><span class="line"><span class="comment"># celery 的启动工作数量设置</span></span><br><span class="line">CELERY_WORKER_CONCURRENCY = <span class="number">20</span></span><br><span class="line"><span class="comment"># 任务预取功能，就是每个工作的进程／线程在获取任务的时候，会尽量多拿 n 个，以保证获取的通讯成本可以压缩。</span></span><br><span class="line">CELERYD_PREFETCH_MULTIPLIER = <span class="number">20</span></span><br><span class="line"><span class="comment"># 非常重要,有些情况下可以防止死锁</span></span><br><span class="line">CELERYD_FORCE_EXECV = <span class="literal">True</span></span><br><span class="line"><span class="comment"># celery 的 worker 执行多少个任务后进行重启操作</span></span><br><span class="line">CELERY_WORKER_MAX_TASKS_PER_CHILD = <span class="number">100</span></span><br><span class="line"><span class="comment"># 禁用所有速度限制，如果网络资源有限，不建议开足马力。</span></span><br><span class="line">CELERY_DISABLE_RATE_LIMITS = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># celery beat配置</span></span><br><span class="line">CELERY_ENABLE_UTC = <span class="literal">False</span></span><br><span class="line">CELERY_TIMEZONE = settings.TIME_ZONE</span><br><span class="line">DJANGO_CELERY_BEAT_TZ_AWARE = <span class="literal">False</span></span><br><span class="line">CELERY_BEAT_SCHEDULER = <span class="string">&#x27;django_celery_beat.schedulers:DatabaseScheduler&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>tasks.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> celery_tasks.celery <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建任务函数</span></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_task1</span>(<span class="params">a, b, c</span>):</span></span><br><span class="line">    print(<span class="string">&quot;任务1函数正在执行....&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_task2</span>():</span></span><br><span class="line">    print(<span class="string">&quot;任务2函数正在执行....&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述配置做完之后，我们需要执行数据库迁移指令，去生成django_celery_beat应用的表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>



<p>启动定时任务的work</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">启动定时任务首先需要有一个work执行异步任务，然后再启动一个定时器触发任务。</span><br><span class="line">celery -A celery_tasks worker -l info</span><br><span class="line"><span class="meta">#</span><span class="bash"> celery -A [project-name] worker --loglevel=info</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">启动定时器触发 beat  (注意：下面是一条完整指令)</span><br><span class="line">    celery -A celery_tasks beat -l info --scheduler      django_celery_beat.schedulers:DatabaseScheduler</span><br><span class="line"><span class="meta">        #</span><span class="bash">  $ celery -A [project-name] beat -l info --scheduler django_celery_beat.schedulers:DatabaseScheduler</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在终端进行测试</p>
<p>普通周期任务</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py shell</span><br><span class="line">进入shell的python指令终端后执行如下指令</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django_celery_beat.models <span class="keyword">import</span> PeriodicTask, IntervalSchedule</span><br><span class="line"><span class="comment"># executes every 10 seconds.</span></span><br><span class="line"><span class="comment"># 创建10秒的计时器对象</span></span><br><span class="line">schedule, created = IntervalSchedule.objects.get_or_create(</span><br><span class="line">          every=<span class="number">10</span>,</span><br><span class="line">          period=IntervalSchedule.SECONDS,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">可以看到上面固定间隔的时间是采用秒 period=IntervalSchedule.SECONDS，如果你还想要固定其他的时间单位，可以设置其他字段参数，如下：</span><br><span class="line"></span><br><span class="line">IntervalSchedule.DAYS 固定间隔天数</span><br><span class="line">IntervalSchedule.HOURS 固定间隔小时数</span><br><span class="line">IntervalSchedule.MINUTES 固定间隔分钟数</span><br><span class="line">IntervalSchedule.SECONDS 固定间隔秒数</span><br><span class="line">IntervalSchedule.MICROSECONDS 固定间隔微秒</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django_celery_beat.models <span class="keyword">import</span> PeriodicTask, IntervalSchedule                                                                                                  </span><br><span class="line">IntervalSchedule.PERIOD_CHOICES                                                                                                                                       </span><br><span class="line">能够看到单位选项：</span><br><span class="line">((<span class="string">&#x27;days&#x27;</span>, <span class="string">&#x27;Days&#x27;</span>),</span><br><span class="line"> (<span class="string">&#x27;hours&#x27;</span>, <span class="string">&#x27;Hours&#x27;</span>),</span><br><span class="line"> (<span class="string">&#x27;minutes&#x27;</span>, <span class="string">&#x27;Minutes&#x27;</span>),</span><br><span class="line"> (<span class="string">&#x27;seconds&#x27;</span>, <span class="string">&#x27;Seconds&#x27;</span>),</span><br><span class="line"> (<span class="string">&#x27;microseconds&#x27;</span>, <span class="string">&#x27;Microseconds&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行定时任务，带参数的</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line">带参数的任务写法：</span><br><span class="line">period_obj = PeriodicTask.objects.create(</span><br><span class="line">     interval=schedule,                  <span class="comment"># we created this above.</span></span><br><span class="line">     name=<span class="string">&#x27;Importing contacts&#x27;</span>,          <span class="comment"># simply describes this periodic task.</span></span><br><span class="line">     task=<span class="string">&#x27;celery_task.tasks.my_task1&#x27;</span>,  <span class="comment"># name of task.</span></span><br><span class="line">     args=json.dumps([<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>]),</span><br><span class="line">     <span class="comment">#kwargs=json.dumps(&#123;</span></span><br><span class="line">     <span class="comment">#   &#x27;be_careful&#x27;: True,</span></span><br><span class="line">     <span class="comment">#&#125;),</span></span><br><span class="line">     expires=datetime.utcnow() + timedelta(seconds=<span class="number">30</span>) <span class="comment"># 30秒过期</span></span><br><span class="line">)</span><br><span class="line">PeriodicTask.objects.all() 可以查看所有任务</span><br><span class="line"></span><br><span class="line">用我们的task1进行测试</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line">period_obj = PeriodicTask.objects.create(</span><br><span class="line">     interval=schedule,                  <span class="comment"># we created this above.</span></span><br><span class="line">     name=<span class="string">&#x27;Importing contacts&#x27;</span>,          <span class="comment"># simply describes this periodic task.</span></span><br><span class="line">     task=<span class="string">&#x27;celery_tasks.tasks.my_task1&#x27;</span>,  <span class="comment"># name of task.</span></span><br><span class="line">     args=json.dumps([<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span> ,<span class="string">&#x27;3&#x27;</span>]),</span><br><span class="line">     expires=datetime.utcnow() + timedelta(seconds=<span class="number">30</span>)</span><br><span class="line">)</span><br><span class="line">发现任务执行都是ok的，只要数据库改变了，那么beat任务会自动调用执行</span><br><span class="line"></span><br><span class="line">回头将我们的period_obj的id值存储到我们自己的任务数据库表中，那么就可以很方便的停止和开启某个任务了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂停执行两个周期性任务</span></span><br><span class="line">In [<span class="number">32</span>]: PeriodicTask.objects.get(name=<span class="string">&quot;my_task1&quot;</span>).enabled = <span class="literal">False</span>                                   In [<span class="number">33</span>]: PeriodicTask.objects.get(name=<span class="string">&quot;my_task1&quot;</span>).save()                                             </span><br><span class="line">In [<span class="number">34</span>]: PeriodicTask.objects.get(name=<span class="string">&quot;my_task2&quot;</span>).enabled = <span class="literal">False</span>                                   In [<span class="number">35</span>]: PeriodicTask.objects.get(name=<span class="string">&quot;my_task2&quot;</span>).save()                                                                                                                     </span><br><span class="line"><span class="comment"># 删除任务</span></span><br><span class="line">In [<span class="number">36</span>]: PeriodicTask.objects.get(name=<span class="string">&quot;my_task1&quot;</span>).delete()                                           </span><br><span class="line">In [<span class="number">37</span>]: PeriodicTask.objects.get(name=<span class="string">&quot;my_task2&quot;</span>).delete()    </span><br><span class="line"><span class="comment"># 重启任务：设置任务的 enabled 为 True 即可：</span></span><br><span class="line">In [<span class="number">21</span>]: PeriodicTask.objects.get(name=<span class="string">&quot;my_task1&quot;</span>).enabled = <span class="literal">True</span>                                     </span><br><span class="line">In [<span class="number">22</span>]: PeriodicTask.objects.get(name=<span class="string">&quot;my_task1&quot;</span>).save()</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">注意：如果tasks.py中的任务逻辑修改了，需要重启beat和worker</span><br><span class="line"><span class="comment"># 启动beat进程</span></span><br><span class="line">celery -A celery_tasks beat -l info --scheduler django_celery_beat.schedulers:DatabaseScheduler</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动一个worker进程</span></span><br><span class="line">celery -A celery_tasks worker -l info</span><br><span class="line">  </span><br></pre></td></tr></table></figure>



<p>基于 crontab 的周期性任务</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytz  </span><br><span class="line"><span class="comment"># 创建周期</span></span><br><span class="line"><span class="keyword">from</span> django_celery_beat.models <span class="keyword">import</span> CrontabSchedule, PeriodicTask</span><br><span class="line">schedule, _ = CrontabSchedule.objects.get_or_create( </span><br><span class="line">     minute=<span class="string">&#x27;*&#x27;</span>, </span><br><span class="line">     hour=<span class="string">&#x27;*&#x27;</span>, </span><br><span class="line">     day_of_week=<span class="string">&#x27;*&#x27;</span>, </span><br><span class="line">     day_of_month=<span class="string">&#x27;*&#x27;</span>, </span><br><span class="line">     month_of_year=<span class="string">&#x27;*&#x27;</span>, </span><br><span class="line">     timezone=pytz.timezone(<span class="string">&#x27;Asia/Shanghai&#x27;</span>) </span><br><span class="line">)     </span><br><span class="line"></span><br><span class="line">CrontabSchedule.objects.all()  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行周期任务</span></span><br><span class="line">PeriodicTask.objects.create(  </span><br><span class="line">     crontab=schedule, <span class="comment"># 上面创建的 crontab 对象 * * * * *，表示每分钟执行一次</span></span><br><span class="line">     name=<span class="string">&#x27;my_task2_crontab&#x27;</span>, <span class="comment"># 设置任务的name值</span></span><br><span class="line">     task=<span class="string">&#x27;celery_tasks.tasks.my_task2&#x27;</span>,  <span class="comment"># 指定需要周期性执行的任务</span></span><br><span class="line">)                                                                                                                                                                    </span><br><span class="line">&lt;PeriodicTask: my_task2_crontab: * * * * * (m/h/d/dM/MY) Asia/Shanghai&gt;</span><br></pre></td></tr></table></figure>

<p>后端实现</p>
<p>在项目根目录下创建一个celery_tasks文件夹</p>
<p>celery_tasks/tasks.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> celery_tasks.celery <span class="keyword">import</span> app</span><br><span class="line"><span class="keyword">from</span> host.models <span class="keyword">import</span> Host</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> host.utils.handle_key <span class="keyword">import</span> AppSetting</span><br><span class="line"><span class="comment"># 创建任务函数</span></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_task1</span>(<span class="params">a, b, c</span>):</span></span><br><span class="line">    print(<span class="string">&quot;任务1函数正在执行....&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task(name=&#x27;my_task2&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_task2</span>():</span></span><br><span class="line">    print(<span class="string">&quot;任务2函数正在执行....&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行定时计划的任务</span></span><br><span class="line"><span class="meta">@app.task(name=&#x27;schedule_task&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedule_task</span>(<span class="params">cmd, hosts_ids</span>):</span></span><br><span class="line">    print(<span class="number">1111</span>)</span><br><span class="line">    hosts_objs = Host.objects.filter(id__in=hosts_ids)</span><br><span class="line">    print(hosts_objs)</span><br><span class="line">    result_data = []</span><br><span class="line">    pkey = AppSetting.get(<span class="string">&#x27;private_key&#x27;</span>)</span><br><span class="line">    <span class="comment"># print(&#x27;pkey&gt;&gt;&gt;&gt;&#x27;,pkey)</span></span><br><span class="line">    <span class="keyword">for</span> host_obj <span class="keyword">in</span> hosts_objs:</span><br><span class="line">        cli = host_obj.get_ssh(pkey)</span><br><span class="line">        status, result = cli.exec_command(cmd)</span><br><span class="line">        result_data.append(&#123;</span><br><span class="line">            <span class="string">&#x27;host_id&#x27;</span>:host_obj.id,</span><br><span class="line">            <span class="string">&#x27;host&#x27;</span>:host_obj.ip_addr,</span><br><span class="line">            <span class="string">&#x27;status&#x27;</span>:status,</span><br><span class="line">            <span class="string">&#x27;result&#x27;</span>:result</span><br><span class="line">        &#125;)</span><br><span class="line">        print(<span class="string">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>,status, result)</span><br><span class="line">    <span class="keyword">return</span> json.dumps(result_data)</span><br><span class="line">    <span class="comment"># return &#x27;22222&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>celery_tasks/celery.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="keyword">from</span> celery_tasks <span class="keyword">import</span> celeryconfig</span><br><span class="line"><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone</span><br><span class="line"><span class="keyword">from</span> celery.app.task <span class="keyword">import</span> Task</span><br><span class="line"></span><br><span class="line"><span class="comment"># class TaskResult(Task):</span></span><br><span class="line"><span class="comment">#     def on_success(self, retval, task_id, args, kwargs):</span></span><br><span class="line"><span class="comment">#         print(&#x27;1111111111&#x27;)</span></span><br><span class="line"><span class="comment">#         print(task_id)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     def on_failure(self, exc, task_id, args, kwargs, einfo):</span></span><br><span class="line"><span class="comment">#         print(&#x27;222222222&#x27;)</span></span><br><span class="line"><span class="comment">#         print(task_id)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> celery.app <span class="keyword">import</span> control</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 为celery设置环境变量</span></span><br><span class="line">os.environ.setdefault(<span class="string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="string">&#x27;celery_test2.settings.dev&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建celery app</span></span><br><span class="line">app = Celery(<span class="string">&#x27;celery_tasks&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从单独的配置模块中加载配置</span></span><br><span class="line">app.config_from_object(celeryconfig)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置app自动加载任务</span></span><br><span class="line">app.autodiscover_tasks([</span><br><span class="line">    <span class="string">&#x27;celery_tasks&#x27;</span>,</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决时区问题,定时任务启动就循环输出</span></span><br><span class="line"><span class="comment"># app.now = timezone.now</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Celery_tasks/celeryconfig.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为celery设置环境变量</span></span><br><span class="line">os.environ.setdefault(<span class="string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="string">&#x27;spug01.settings&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置结果存储</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">&#x27;redis://127.0.0.1:6379/9&#x27;</span></span><br><span class="line"><span class="comment"># 设置代理人broker</span></span><br><span class="line">BROKER_URL = <span class="string">&#x27;redis://127.0.0.1:6379/8&#x27;</span></span><br><span class="line"><span class="comment"># celery 的启动工作数量设置</span></span><br><span class="line">CELERY_WORKER_CONCURRENCY = <span class="number">20</span></span><br><span class="line"><span class="comment"># 任务预取功能，就是每个工作的进程／线程在获取任务的时候，会尽量多拿 n 个，以保证获取的通讯成本可以压缩。</span></span><br><span class="line">CELERYD_PREFETCH_MULTIPLIER = <span class="number">20</span></span><br><span class="line"><span class="comment"># 非常重要,有些情况下可以防止死锁</span></span><br><span class="line">CELERYD_FORCE_EXECV = <span class="literal">True</span></span><br><span class="line"><span class="comment"># celery 的 worker 执行多少个任务后进行重启操作</span></span><br><span class="line">CELERY_WORKER_MAX_TASKS_PER_CHILD = <span class="number">100</span></span><br><span class="line"><span class="comment"># 禁用所有速度限制，如果网络资源有限，不建议开足马力。</span></span><br><span class="line">CELERY_DISABLE_RATE_LIMITS = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># celery beat配置</span></span><br><span class="line">CELERY_ENABLE_UTC = <span class="literal">False</span></span><br><span class="line">CELERY_TIMEZONE = settings.TIME_ZONE</span><br><span class="line">DJANGO_CELERY_BEAT_TZ_AWARE = <span class="literal">False</span></span><br><span class="line">CELERY_BEAT_SCHEDULER = <span class="string">&#x27;django_celery_beat.schedulers:DatabaseScheduler&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>Schedule/views.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> schedule <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> host.models <span class="keyword">import</span> Host</span><br><span class="line"><span class="keyword">from</span> django_celery_beat.models <span class="keyword">import</span> PeriodicTask, IntervalSchedule</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取周期类型数据返回给客户端</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeriodView</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        data = models.TaskSchedule.period_way_choices</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;period_way_choices&#x27;</span>: data&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskView</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="comment"># 1. 获取任务列表数据返回给客户端</span></span><br><span class="line">        <span class="comment"># 2. 去redis中获取每个任务的执行结果展示给客户端</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        task_data = request.data</span><br><span class="line">        <span class="comment"># print(task_data)</span></span><br><span class="line">        <span class="comment"># &#123;&#x27;task_name&#x27;: &#x27;kkk&#x27;, &#x27;hosts&#x27;: [10], &#x27;period_way&#x27;: &#x27;2&#x27;, &#x27;task_cmd&#x27;: &#x27;ls&#x27;, &#x27;period_content&#x27;: &#x27;12&#x27;&#125;</span></span><br><span class="line">        period_way = request.data.get(<span class="string">&#x27;period_way&#x27;</span>)</span><br><span class="line">        hosts_ids = request.data.get(<span class="string">&#x27;hosts&#x27;</span>)</span><br><span class="line">        task_cmd = request.data.get(<span class="string">&#x27;task_cmd&#x27;</span>)  <span class="comment"># 要执行的任务指令</span></span><br><span class="line">        period_content = request.data.get(<span class="string">&#x27;period_content&#x27;</span>)</span><br><span class="line">        task_name = request.data.get(<span class="string">&#x27;task_name&#x27;</span>) <span class="comment"># 任务名称，注意不能重复</span></span><br><span class="line">        <span class="comment"># hosts_obj = Host.objects.filter(id__in=hosts_ids)</span></span><br><span class="line">        <span class="keyword">if</span> period_way == <span class="string">&#x27;1&#x27;</span>:  <span class="comment"># 普通周期任务,默认单位为秒数，可以选择修改</span></span><br><span class="line">            schedule, created = IntervalSchedule.objects.get_or_create(</span><br><span class="line">                every=int(period_content),</span><br><span class="line">                period=IntervalSchedule.SECONDS,</span><br><span class="line">            )</span><br><span class="line">            period_obj = PeriodicTask.objects.create(</span><br><span class="line">                interval=schedule,  <span class="comment"># we created this above.</span></span><br><span class="line">                name=task_name,  <span class="comment"># simply describes this periodic task.</span></span><br><span class="line">                <span class="comment"># task=&#x27;celery_tasks.tasks.schedule_task&#x27;,  # name of task.</span></span><br><span class="line">                task=<span class="string">&#x27;schedule_task&#x27;</span>,  <span class="comment"># name of task.</span></span><br><span class="line">                <span class="comment"># task=&#x27;my_task2&#x27;,  # name of task.</span></span><br><span class="line">                args=json.dumps([task_cmd, hosts_ids]),</span><br><span class="line">                expires=datetime.utcnow() + timedelta(seconds=<span class="number">30</span>)</span><br><span class="line">            )</span><br><span class="line">            period_beat = period_obj.id</span><br><span class="line">        <span class="keyword">elif</span> period_way == <span class="string">&#x27;2&#x27;</span>:   <span class="comment"># 一次性任务</span></span><br><span class="line">            period_beat = <span class="number">1</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># cron任务</span></span><br><span class="line">            period_beat = <span class="number">1</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存任务</span></span><br><span class="line">        task_schedule_obj = models.TaskSchedule.objects.create(**&#123;</span><br><span class="line">            <span class="string">&#x27;period_beat&#x27;</span>:period_beat, <span class="comment"># celery-beat的任务id值</span></span><br><span class="line">            <span class="string">&#x27;period_way&#x27;</span>:period_way,</span><br><span class="line">            <span class="string">&#x27;task_cmd&#x27;</span>:task_cmd,</span><br><span class="line">            <span class="string">&#x27;period_content&#x27;</span>:period_content,</span><br><span class="line">            <span class="string">&#x27;task_name&#x27;</span>:task_name,</span><br><span class="line">            <span class="string">&#x27;period_status&#x27;</span>:<span class="string">&#x27;1&#x27;</span> , <span class="comment"># 默认为激活状态</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> host_id <span class="keyword">in</span> hosts_ids:</span><br><span class="line"></span><br><span class="line">            models.TaskHost.objects.create(**&#123;</span><br><span class="line">                <span class="string">&#x27;tasks_id&#x27;</span>: task_schedule_obj.id,</span><br><span class="line">                <span class="string">&#x27;hosts_id&#x27;</span>: host_id,</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;xxx&#x27;</span>: <span class="string">&#x27;ooo&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>schedule/urls.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,re_path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;periods/&#x27;</span>, views.PeriodView.as_view()),</span><br><span class="line">    path(<span class="string">&#x27;tasks/&#x27;</span>, views.TaskView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>25-Django-信号量signal</title>
    <url>/posts/33325.html</url>
    <content><![CDATA[<p>Django信号量</p>
<a id="more"></a>

<p>Django 框架包含了一个信号机制，它允许若干个发送者（sender）通知一组接收者（receiver）某些特定操作或事件(events)已经发生了， 接收者收到指令信号(signals)后再去执行特定的操作。本文主要讲解Django信号(signals)的工作机制、应用场景，如何在项目中使用信号以及如何自定义信号。</p>
<h2 id="信号的工作机制"><a href="#信号的工作机制" class="headerlink" title="信号的工作机制"></a>信号的工作机制</h2><p>Django 中的信号工作机制依赖如下三个主要要素：</p>
<ul>
<li>发送者（sender）：信号的发出方，可以是模型，也可以是视图。当某个操作发生时，发送者会发出信号。</li>
<li>信号（signal）：发送的信号本身。Django内置了许多信号，比如模型保存后发出的<code>post_save</code>信号。</li>
<li>接收者（receiver）：信号的接收者，其本质是一个简单的回调函数。将这个函数注册到信号上，当特定的事件发生时，发送者发送信号，回调函数就会被执行。</li>
</ul>
<h2 id="信号的应用场景"><a href="#信号的应用场景" class="headerlink" title="信号的应用场景"></a>信号的应用场景</h2><p>信号主要用于Django项目内不同事件的联动，实现程序的解耦。比如当模型A有变动时，模型B与模型C收到发出的信号后同步更新。又或当一个数据表数据有所改变时，监听这个信号的函数可以及时清除已失效的缓存。另外通知也是一个信号常用的场景，比如有人刚刚回复了你的贴子，可以通过信号进行推送。</p>
<p><strong>注意</strong>：Django中信号监听函数不是异步执行，而是同步执行，所以需要异步执行耗时的任务时(比如发送邮件或写入文件)，不建议使用Django自带的信号。</p>
<h2 id="两个简单例子"><a href="#两个简单例子" class="headerlink" title="两个简单例子"></a>两个简单例子</h2><p>假如我们有一个Profile模型，与User模型是一对一的关系。我们希望创建User对象实例时自动创建Profile对象实例，而更新User对象实例时不创建新的Profile对象实例。这时我们就可以自定义 <code>create_user_profile</code>和<code>save_user_profile</code>两个监听函数，同时监听sender (User模型)发出的<code>post_save</code>信号。由于<code>post_save</code>可同时用于模型的创建和更新，我们用<code>if created</code>这个判断来加以区别。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> post_save</span><br><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Profile</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    user = models.OneToOneField(User, on_delete=models.CASCADE)</span><br><span class="line">    birth_date = models.DateField(null=<span class="literal">True</span>, blank=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听User模型创建    </span></span><br><span class="line"><span class="meta">@receiver(post_save, sender=User)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_user_profile</span>(<span class="params">sender, instance, created, **kwargs</span>):</span></span><br><span class="line">   <span class="keyword">if</span> created:</span><br><span class="line">       Profile.objects.create(user=instance)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听User模型更新  </span></span><br><span class="line"><span class="meta">@receiver(post_save, sender=User)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_user_profile</span>(<span class="params">sender, instance, **kwargs</span>):</span></span><br><span class="line">    instance.profile.save()</span><br></pre></td></tr></table></figure>

<p>我们再来看一个使用信号清除缓存的例子。当模型A被更新或被删除时，会分别发出<code>post_save</code>和<code>post_delete</code>的信号，监听这两个信号的receivers函数会自动清除缓存里的A对象列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.cache <span class="keyword">import</span> cache</span><br><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> post_delete, post_save</span><br><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br><span class="line"></span><br><span class="line"><span class="meta">@receiver(post_save, sender=ModelA)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cache_post_save_handler</span>(<span class="params">sender, **kwargs</span>):</span></span><br><span class="line">    cache.delete(<span class="string">&#x27;cached_a_objects&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">@receiver(post_delete, sender=ModelA)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cache_post_delete_handler</span>(<span class="params">sender, **kwargs</span>):</span></span><br><span class="line">     cache.delete(<span class="string">&#x27;cached_a_objects&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>注意：有时为了防止信号多次发送，可以通过<code>dispatch_uid</code>给receiver函数提供唯一标识符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@receiver(post_delete, sender=ModelA, dispatch_uid = &quot;unique_identifier&quot;)</span></span><br></pre></td></tr></table></figure>

<h2 id="Django常用内置信号"><a href="#Django常用内置信号" class="headerlink" title="Django常用内置信号"></a>Django常用内置信号</h2><p>前面例子我们仅仅使用了<code>post_save</code>和<code>post_delete</code>信号。Django还内置了其它常用信号：</p>
<ul>
<li>pre_save &amp; post_save: 在模型调用 save()方法之前或之后发送。</li>
<li>pre_init&amp; post_init: 在模型调用_init_方法之前或之后发送。</li>
<li>pre_delete &amp; post_delete: 在模型调用delete()方法或查询集调用delete() 方法之前或之后发送。</li>
<li>m2m_changed: 在模型多对多关系改变后发送。</li>
<li>request_started &amp; request_finished: Django建立或关闭HTTP 请求时发送。</li>
</ul>
<p>这些信号都非常有用。举个例子：使用<code>pre_save</code>信号可以在将用户的评论存入数据库前对其进行过滤，或则检测一个模型对象的字段是否发生了变更。</p>
<p><strong>注意</strong>：监听<code>pre_save</code>和<code>post_save</code>信号的回调函数不能再调用<code>save()</code>方法，否则回出现死循环。另外Django的<code>update</code>方法不会发出<code>pre_save</code>和<code>post_save</code>的信号。</p>
<h2 id="如何放置信号监听函数代码"><a href="#如何放置信号监听函数代码" class="headerlink" title="如何放置信号监听函数代码"></a>如何放置信号监听函数代码</h2><p>在之前案例中，我们将Django信号的监听函数写在了<code>models.py</code>文件里。当一个app的与信号相关的自定义监听函数很多时，此时models.py代码将变得非常臃肿。一个更好的方式把所以自定义的信号监听函数集中放在app对应文件夹下的<code>signals.py</code>文件里，便于后期集中维护。</p>
<p>假如我们有个<code>account</code>的app，包含了User和Profile模型，我们首先需要在<code>account</code>文件夹下新建<code>signals.py</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># account/signals.py</span></span><br><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> post_save</span><br><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> User, Profile</span><br><span class="line"></span><br><span class="line"><span class="meta">@receiver(post_save, sender=User)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_user_profile</span>(<span class="params">sender, instance, created, **kwargs</span>):</span></span><br><span class="line">  <span class="keyword">if</span> created:</span><br><span class="line">      Profile.objects.create(user=instance)</span><br><span class="line"></span><br><span class="line"><span class="meta">@receiver(post_save, sender=User)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_user_profile</span>(<span class="params">sender, instance, **kwargs</span>):</span></span><br><span class="line">    instance.profile.save()</span><br></pre></td></tr></table></figure>

<p>接下来我们需要修改<code>account</code>文件下<code>apps.py</code>和<code>__init__.py</code>，以导入创建的信号监听函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># apps.py</span></span><br><span class="line"><span class="keyword">from</span> django.apps <span class="keyword">import</span> AppConfig</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountConfig</span>(<span class="params">AppConfig</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;account&#x27;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ready</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">import</span> account.signals</span><br><span class="line">        </span><br><span class="line"><span class="comment"># account/__init__.py中增加如下代码：</span></span><br><span class="line">default_app_config = <span class="string">&#x27;account.apps.AccountConfig&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义信号"><a href="#自定义信号" class="headerlink" title="自定义信号"></a>自定义信号</h2><p>Django的内置信号在大多数情况下能满足我们的项目需求，但有时我们还需要使用自定义的信号。在Django项目中使用自定义信号也比较简单，分三步即可完成。</p>
<h3 id="第一步：自定义信号"><a href="#第一步：自定义信号" class="headerlink" title="第一步：自定义信号"></a>第一步：自定义信号</h3><p>每个自定义的信号，都是Signal类的实例。这里我们首先在app目录下新建一个<code>signals.py</code>文件，创建一个名为<code>my_signal</code>的信号，它包含有<code>msg</code>这个参数，这个参数在信号触发的时候需要传递。当监听函数收到这个信号时，会得到<code>msg</code>参数的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> Signal</span><br><span class="line"></span><br><span class="line">my_signal = Signal(providing_args=[<span class="string">&#x27;msg&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h3 id="第二步：触发信号"><a href="#第二步：触发信号" class="headerlink" title="第二步：触发信号"></a>第二步：触发信号</h3><p>视图中进行某个操作时可以使用<code>send</code>方法触发自定义的信号，并设定<code>msg</code>的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> signals</span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    signals.my_signal.send(sender=<span class="literal">None</span>, msg=<span class="string">&#x27;Hello world&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, template_name=<span class="string">&#x27;index.html&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="第三步：将监听函数与信号相关联"><a href="#第三步：将监听函数与信号相关联" class="headerlink" title="第三步：将监听函数与信号相关联"></a>第三步：将监听函数与信号相关联</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> Signal, Receiver</span><br><span class="line"></span><br><span class="line">my_signal = Signal(providing_args=[<span class="string">&#x27;msg&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">@receiver(my_signal)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_signal_callback</span>(<span class="params">sender, **kwargs</span>):</span></span><br><span class="line">    print(kwargs[<span class="string">&#x27;msg&#x27;</span>]) <span class="comment"># 打印Hello world!</span></span><br></pre></td></tr></table></figure>

<p>这样每当用户访问/index/视图时，Django都会发出<code>my_signal</code>的信号(包含msg这个参数)。回调函数收到这个信号后就会打印出msg的值来。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>24-Django-日志</title>
    <url>/posts/808.html</url>
    <content><![CDATA[<p>Django日志</p>
<a id="more"></a>

<h2 id="Django-日志"><a href="#Django-日志" class="headerlink" title="Django 日志"></a>Django 日志</h2><p>Django 使用Python 内建的logging 模块打印日志，Python 的logging 配置由四个部分组成： </p>
<ul>
<li><p>记录器 —— Logger </p>
</li>
<li><p>处理程序 —— Handler </p>
</li>
<li><p>过滤器 —— Filter </p>
</li>
<li><p>格式化 —— Formatter </p>
</li>
</ul>
<h3 id="记录器-——-Logger"><a href="#记录器-——-Logger" class="headerlink" title="记录器 —— Logger"></a>记录器 —— Logger</h3><ul>
<li><p>Logger 为日志系统的入口。每个logger命名都是bucket，你可以向这个bucket写入需要处 </p>
<p>理的消息。 </p>
</li>
<li><p>每个logger 都有一个日志级别。日志级别表示该logger 将要处理的消息的严重性。</p>
</li>
</ul>
<p>Python 定义以下几种日志级别： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DEBUG：用于调试目的的底层系统信息 </span><br><span class="line">INFO：普通的系统信息 </span><br><span class="line">WARNING：表示出现一个较小的问题。 </span><br><span class="line">ERROR：表示出现一个较大的问题。 </span><br><span class="line">CRITICAL：表示出现一个致命的问题。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>写入logger 的每条消息都是一条日志。每条日志也具有一个日志级别，它表示对应的消息 </p>
<p>的严重性。每个日志记录还可以包含描述正在打印的事件的元信息。</p>
</li>
<li><p>当一条消息传递给logger 时，消息的日志级别将与logger 的日志级别进行比较。如果消息 </p>
<p>的日志级别大于等于logger 的日志级别，该消息将会往下继续处理。如果小于，该消息将 </p>
<p>被忽略。</p>
</li>
<li><p>Logger 一旦决定消息需要处理，它将传递该消息给一个Handler</p>
</li>
</ul>
<h4 id="logger-日志级别"><a href="#logger-日志级别" class="headerlink" title="logger 日志级别"></a>logger 日志级别</h4><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20210920165723047.png" alt="image-20210920165723047"></p>
<h4 id="Logger配置"><a href="#Logger配置" class="headerlink" title="Logger配置"></a>Logger配置</h4><p>logger 对应的值是个字典，其每一个键都是logger的名字，每一个值又是个字典，描述了如何 配置对应的Logger实例。</p>
<ul>
<li><p>level （可选的）logger的级别。 </p>
</li>
<li><p>propagate （可选的）logger的传播设置。 </p>
</li>
<li><p>filters（可选的）logger的filter的标识符的列表</p>
</li>
<li><p>handlers （可选的）logger的handler的标识符的列表</p>
</li>
</ul>
<h4 id="Logger配置示例"><a href="#Logger配置示例" class="headerlink" title="Logger配置示例"></a>Logger配置示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LOGGING = &#123;</span><br><span class="line">  <span class="string">&#x27;loggers&#x27;</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;reboot&#x27;</span>: &#123; </span><br><span class="line">      <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;file_handler&#x27;</span>, <span class="string">&#x27;console_handler&#x27;</span>], <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">    &#125;, </span><br><span class="line">  &#125;, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="处理程序-——-Handler"><a href="#处理程序-——-Handler" class="headerlink" title="处理程序 —— Handler"></a>处理程序 —— Handler</h3><ul>
<li><p>Handler 决定如何处理logger 中的每条消息。它表示一个特定的日志行为，例如将消息写 到屏幕上、写到文件中或者写到网络socket </p>
</li>
<li><p>与logger 一样，handler 也有一个日志级别。如果消息的日志级别小于handler 的级别， handler 将忽略该消息 </p>
</li>
<li><p>Logger 可以有多个handler，而每个handler 可以有不同的日志级别。利用这种方式，可以 根据消息的重要性提供不同形式的处理</p>
</li>
</ul>
<h4 id="Handler——示例"><a href="#Handler——示例" class="headerlink" title="Handler——示例"></a>Handler——示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LOGGING = &#123; </span><br><span class="line">  <span class="string">&#x27;handlers&#x27;</span>: &#123; </span><br><span class="line">    <span class="string">&#x27;reboot&#x27;</span>: &#123; </span><br><span class="line">      <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>, <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.StreamHandler&#x27;</span>, <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;simple’, </span></span><br><span class="line"><span class="string">    &#125; </span></span><br><span class="line"><span class="string">  &#125; </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="过滤器——Filters"><a href="#过滤器——Filters" class="headerlink" title="过滤器——Filters"></a>过滤器——Filters</h3><ul>
<li><p>Filter 用于对从logger 传递给handler 的日志记录进行额外的控制。 默认情况下，满足日志级别的任何消息都将被处理。通过安装一个Òlter，你可以对日志处 </p>
</li>
<li><p>理添加额外的条件。例如，你可以安装一个Òlter，只允许处理来自特定源的ERROR 消息 Filters 还可以用于修改将要处理的日志记录的优先级。例如，如果日志记录满足特定的条件，你可以编写一个Òlter 将日志记录从ERROR 降为WARNING </p>
</li>
<li><p>Filters 可以安装在logger 上或者handler 上；多个Òlter 可以串联起来实现多层Òlter 行为</p>
</li>
</ul>
<h3 id="格式化——Formatters"><a href="#格式化——Formatters" class="headerlink" title="格式化——Formatters"></a>格式化——Formatters</h3><p>最后，日志记录需要转换成文本。Formatter 表示文本的格式。Fomatter 通常由包含日志记录属性的Python 格式字符串组成；你也可以编写自定义的fomatter 来实现自己的格式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LOGGING = &#123; </span><br><span class="line">  <span class="string">&#x27;formatters&#x27;</span>: &#123; </span><br><span class="line">    <span class="string">&#x27;reboot&#x27;</span>:&#123; <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;%(asctime)s - %(pathname)s:%(lineno)d[%(levelname)s] - %(message)s&#x27;</span> &#125;</span><br><span class="line">    <span class="string">&#x27;simple&#x27;</span>: &#123; <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;%(asctime)s %(levelname)s %(message)s&#x27;</span> &#125;, </span><br><span class="line">  &#125;, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Format-日志消息格式"><a href="#Format-日志消息格式" class="headerlink" title="Format 日志消息格式"></a>Format 日志消息格式</h4><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20210920170500312.png" alt="image-20210920170500312"></p>
<h4 id="Django-内置logger"><a href="#Django-内置logger" class="headerlink" title="Django 内置logger"></a>Django 内置logger</h4><ul>
<li><p>django 获取所有日志 </p>
</li>
<li><p>django.request 处理与请求相关的日志，5xx响应报出error日志，4xx报出WARNING日志 </p>
</li>
<li><p>django.db.backends 处理与数据库之间交互的日志， </p>
</li>
<li><p>django.security.* 处理与安全相关的日志 </p>
</li>
<li><p>django.db.backends.schemea 处理数据库迁移时的日志</p>
</li>
</ul>
<h2 id="生产使用"><a href="#生产使用" class="headerlink" title="生产使用"></a>生产使用</h2><ul>
<li>写到哪里都是由handler定义，比如写到console，file，或者elk</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LOGGING = &#123;</span><br><span class="line">    <span class="string">&#x27;version&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;disable_existing_loggers&#x27;</span>: <span class="literal">False</span>, <span class="comment"># 是否禁用已经存在的配置, django有些默认的配置，默认为True，False把自带的配置全部给清空</span></span><br><span class="line">    <span class="string">&#x27;formatters&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;verbose&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;%(levelname)s %(asctime)s %(module)s %(lineno)d %(message)s&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;simple&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;%(levelname)s %(module)s %(lineno)d %(message)s&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;filters&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;require_debug_true&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;()&#x27;</span>: <span class="string">&#x27;django.utils.log.RequireDebugTrue&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;handlers&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;console&#x27;</span>: &#123;</span><br><span class="line">            <span class="comment"># 实际开发建议使用WARNING</span></span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;filters&#x27;</span>: [<span class="string">&#x27;require_debug_true&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.StreamHandler&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;simple&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;file&#x27;</span>: &#123;</span><br><span class="line">            <span class="comment"># 实际开发建议使用ERROR</span></span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;INFO&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.handlers.RotatingFileHandler&#x27;</span>,</span><br><span class="line">            <span class="comment"># 日志位置,日志文件名,日志保存目录必须手动创建，注：这里的文件路径要注意BASE_DIR代表的是小luffyapi</span></span><br><span class="line">            <span class="string">&#x27;filename&#x27;</span>: os.path.join(os.path.dirname(BASE_DIR), <span class="string">&quot;logs&quot;</span>, <span class="string">&quot;luffy.log&quot;</span>),</span><br><span class="line">            <span class="comment"># 日志文件的最大值,这里我们设置300M</span></span><br><span class="line">            <span class="string">&#x27;maxBytes&#x27;</span>: <span class="number">300</span> * <span class="number">1024</span> * <span class="number">1024</span>,</span><br><span class="line">            <span class="comment"># 日志文件的数量,设置最大日志数量为10</span></span><br><span class="line">            <span class="string">&#x27;backupCount&#x27;</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="comment"># 日志格式:详细格式</span></span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;verbose&#x27;</span>,</span><br><span class="line">            <span class="comment"># 文件内容编码</span></span><br><span class="line">            <span class="string">&#x27;encoding&#x27;</span>: <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment"># 日志对象</span></span><br><span class="line">    <span class="string">&#x27;loggers&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;django&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;console&#x27;</span>, <span class="string">&#x27;file&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;propagate&#x27;</span>: <span class="literal">True</span>, <span class="comment"># 是否让日志信息继续冒泡给其他的日志处理系统</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="utils-logging-py"><a href="#utils-logging-py" class="headerlink" title="utils/logging.py"></a>utils/logging.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="comment"># logger=logging.getLogger(&#x27;django&#x27;) # 和配置文件中loggers日志对象下的名字对应</span></span><br><span class="line">logger = logging.getLogger(<span class="string">&#x27;django&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="views中使用"><a href="#views中使用" class="headerlink" title="views中使用"></a>views中使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logger.debug()</span><br><span class="line">logger.warning()</span><br></pre></td></tr></table></figure>



<h2 id="settings-py推荐日志配置"><a href="#settings-py推荐日志配置" class="headerlink" title="settings.py推荐日志配置"></a>settings.py推荐日志配置</h2><p>以下基本配置信息在django cookiecutter推荐使用的logging配置信息上做了修改，可适合大部分项目使用。如果真的希望发送和接收到邮件还需在<code>settings.py</code>正确配置电子邮箱Email。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给ADMINS发送邮件需要配置</span></span><br><span class="line">ADMINS = (</span><br><span class="line"> (<span class="string">&#x27;admin_name&#x27;</span>,<span class="string">&#x27;your@gmail.com&#x27;</span>),</span><br><span class="line">)</span><br><span class="line">MANAGERS = ADMINS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建log文件的文件夹</span></span><br><span class="line">LOG_DIR = os.path.join(BASE_DIR, <span class="string">&quot;logs&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(LOG_DIR): </span><br><span class="line">    os.mkdir(LOG_DIR) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本配置，可以复用的</span></span><br><span class="line">LOGGING = &#123;</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;disable_existing_loggers&quot;</span>: <span class="literal">False</span>, <span class="comment"># 禁用已经存在的logger实例</span></span><br><span class="line">    <span class="string">&quot;filters&quot;</span>: &#123;<span class="string">&quot;require_debug_false&quot;</span>: &#123;<span class="string">&quot;()&quot;</span>: <span class="string">&quot;django.utils.log.RequireDebugFalse&quot;</span>&#125;&#125;,</span><br><span class="line">    <span class="string">&quot;formatters&quot;</span>: &#123; <span class="comment"># 定义了两种日志格式</span></span><br><span class="line">        <span class="string">&quot;verbose&quot;</span>: &#123; <span class="comment"># 详细</span></span><br><span class="line">            <span class="string">&quot;format&quot;</span>: <span class="string">&quot;%(levelname)s %(asctime)s %(module)s &quot;</span></span><br><span class="line">            <span class="string">&quot;%(process)d %(thread)d %(message)s&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;simple&#x27;</span>: &#123; <span class="comment"># 简单</span></span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;handlers&quot;</span>: &#123; <span class="comment"># 定义了三种日志处理方式</span></span><br><span class="line">        <span class="string">&quot;mail_admins&quot;</span>: &#123; <span class="comment"># 只有debug=False且Error级别以上发邮件给admin</span></span><br><span class="line">            <span class="string">&quot;level&quot;</span>: <span class="string">&quot;ERROR&quot;</span>,</span><br><span class="line">            <span class="string">&quot;filters&quot;</span>: [<span class="string">&quot;require_debug_false&quot;</span>],</span><br><span class="line">            <span class="string">&quot;class&quot;</span>: <span class="string">&quot;django.utils.log.AdminEmailHandler&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;file&#x27;</span>: &#123; <span class="comment"># 对INFO级别以上信息以日志文件形式保存</span></span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&quot;INFO&quot;</span>, </span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.handlers.RotatingFileHandler&#x27;</span>,  <span class="comment"># 滚动生成日志，切割</span></span><br><span class="line">            <span class="string">&#x27;filename&#x27;</span>: os.path.join(LOG_DIR,<span class="string">&#x27;django.log&#x27;</span>),  <span class="comment"># 日志文件名</span></span><br><span class="line">            <span class="string">&#x27;maxBytes&#x27;</span>: <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>,  <span class="comment"># 单个日志文件最大为10M</span></span><br><span class="line">            <span class="string">&#x27;backupCount&#x27;</span>: <span class="number">5</span>,  <span class="comment"># 日志备份文件最大数量</span></span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;simple&#x27;</span>, <span class="comment"># 简单格式</span></span><br><span class="line">            <span class="string">&#x27;encoding&#x27;</span>: <span class="string">&#x27;utf-8&#x27;</span>, <span class="comment"># 放置中文乱码</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;console&quot;</span>: &#123; <span class="comment"># 打印到终端console</span></span><br><span class="line">            <span class="string">&quot;level&quot;</span>: <span class="string">&quot;DEBUG&quot;</span>,</span><br><span class="line">            <span class="string">&quot;class&quot;</span>: <span class="string">&quot;logging.StreamHandler&quot;</span>,</span><br><span class="line">            <span class="string">&quot;formatter&quot;</span>: <span class="string">&quot;verbose&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;root&quot;</span>: &#123;<span class="string">&quot;level&quot;</span>: <span class="string">&quot;INFO&quot;</span>, <span class="string">&quot;handlers&quot;</span>: [<span class="string">&quot;console&quot;</span>]&#125;,</span><br><span class="line">    <span class="string">&quot;loggers&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;django.request&quot;</span>: &#123; <span class="comment"># Django的request发生error会自动记录</span></span><br><span class="line">            <span class="string">&quot;handlers&quot;</span>: [<span class="string">&quot;mail_admins&quot;</span>],</span><br><span class="line">            <span class="string">&quot;level&quot;</span>: <span class="string">&quot;ERROR&quot;</span>,</span><br><span class="line">            <span class="string">&quot;propagate&quot;</span>: <span class="literal">True</span>,  <span class="comment"># 向不向更高级别的logger传递</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;django.security.DisallowedHost&quot;</span>: &#123; <span class="comment"># 对于不在 ALLOWED_HOSTS 中的请求不发送报错邮件</span></span><br><span class="line">            <span class="string">&quot;level&quot;</span>: <span class="string">&quot;ERROR&quot;</span>,</span><br><span class="line">            <span class="string">&quot;handlers&quot;</span>: [<span class="string">&quot;console&quot;</span>, <span class="string">&quot;mail_admins&quot;</span>],</span><br><span class="line">            <span class="string">&quot;propagate&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上配置中大家最需要了解的就是Python提供的<code>RotatingFileHandler</code>, 其作用是滚动生成日志文件，当单个日志的文件大小达到上限时，会生成新的日志文件。当总的日志文件数量超过日志备份最大数量时删除老的日志文件。</p>
<p><strong>项目实际配置</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 日志配置</span></span><br><span class="line">LOGGING = &#123;</span><br><span class="line">    <span class="string">&#x27;version&#x27;</span>: <span class="number">1</span>,  <span class="comment">#使用的python内置的logging模块，那么python可能会对它进行升级，所以需要写一个版本号，目前就是1版本</span></span><br><span class="line">    <span class="string">&#x27;disable_existing_loggers&#x27;</span>: <span class="literal">False</span>, <span class="comment">#是否去掉目前项目中其他地方中以及使用的日志功能，但是将来我们可能会引入第三方的模块，里面可能内置了日志功能，所以尽量不要关闭。</span></span><br><span class="line">    <span class="string">&#x27;formatters&#x27;</span>: &#123; <span class="comment">#日志记录格式</span></span><br><span class="line">        <span class="string">&#x27;verbose&#x27;</span>: &#123; <span class="comment">#levelname等级，asctime记录时间，module表示日志发生的文件名称，lineno行号，message错误信息</span></span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;%(levelname)s %(asctime)s %(module)s %(lineno)d %(message)s&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;simple&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;%(levelname)s %(module)s %(lineno)d %(message)s&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;filters&#x27;</span>: &#123; <span class="comment">#过滤器：可以对日志进行输出时的过滤用的</span></span><br><span class="line">        <span class="string">&#x27;require_debug_true&#x27;</span>: &#123; <span class="comment">#在debug=True下产生的一些日志信息，要不要记录日志，需要的话就在handlers中加上这个过滤器，不需要就不加</span></span><br><span class="line">            <span class="string">&#x27;()&#x27;</span>: <span class="string">&#x27;django.utils.log.RequireDebugTrue&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;require_debug_false&#x27;</span>: &#123; <span class="comment">#和上面相反</span></span><br><span class="line">            <span class="string">&#x27;()&#x27;</span>: <span class="string">&#x27;django.utils.log.RequireDebugFalse&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;handlers&#x27;</span>: &#123; <span class="comment">#日志处理方式，日志实例</span></span><br><span class="line">        <span class="string">&#x27;console&#x27;</span>: &#123; <span class="comment">#在控制台输出时的实例</span></span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>, <span class="comment">#日志等级；debug是最低等级，那么只要比它高等级的信息都会被记录</span></span><br><span class="line">            <span class="string">&#x27;filters&#x27;</span>: [<span class="string">&#x27;require_debug_true&#x27;</span>], <span class="comment">#在debug=True下才会打印在控制台</span></span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.StreamHandler&#x27;</span>, <span class="comment">#使用的python的logging模块中的StreamHandler来进行输出</span></span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;simple&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;file&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;INFO&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.handlers.RotatingFileHandler&#x27;</span>,</span><br><span class="line">            <span class="comment"># 日志位置,日志文件名,日志保存目录必须手动创建</span></span><br><span class="line">            <span class="string">&#x27;filename&#x27;</span>: os.path.join(os.path.dirname(BASE_DIR), <span class="string">&quot;logs/luffy.log&quot;</span>), <span class="comment">#注意，你的文件应该有读写权限。</span></span><br><span class="line">            <span class="comment"># 日志文件的最大值,这里我们设置300M</span></span><br><span class="line">            <span class="string">&#x27;maxBytes&#x27;</span>: <span class="number">300</span> * <span class="number">1024</span> * <span class="number">1024</span>,</span><br><span class="line">            <span class="comment"># 日志文件的数量,设置最大日志数量为10</span></span><br><span class="line">            <span class="string">&#x27;backupCount&#x27;</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="comment"># 日志格式:详细格式</span></span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;verbose&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;encoding&#x27;</span>: <span class="string">&#x27;utf-8&#x27;</span>,  <span class="comment"># 设置默认编码，否则打印出来汉字乱码</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment"># 日志对象</span></span><br><span class="line">    <span class="string">&#x27;loggers&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;django&#x27;</span>: &#123;  <span class="comment">#和django结合起来使用，将django中之前的日志输出内容的时候，按照我们的日志配置进行输出，</span></span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;console&#x27;</span>, <span class="string">&#x27;file&#x27;</span>], <span class="comment">#将来项目上线，把console去掉</span></span><br><span class="line">            <span class="string">&#x27;propagate&#x27;</span>: <span class="literal">True</span>, <span class="comment">#冒泡：是否将日志信息记录冒泡给其他的日志处理系统，工作中都是True，不然django这个日志系统捕获到日志信息之后，其他模块中可能也有日志记录功能的模块，就获取不到这个日志信息了</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="其它日志管理工具"><a href="#其它日志管理工具" class="headerlink" title="其它日志管理工具"></a>其它日志管理工具</h2><p>在前面日志配置中，我们使用了Python自带的<code>logging</code>模块, 另外两个常用的日志管理工具是<code>loguru</code>和<code>sentry</code>。我们将简单演示如何使用。</p>
<h3 id="loguru"><a href="#loguru" class="headerlink" title="loguru"></a>loguru</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install loguru</span><br></pre></td></tr></table></figure>

<p>安装好后在Django项目中可以直接在视图中使用，省去复杂的配置，非常便捷。它定义了日志文件名、每条记录的格式、日志文件的轮替以及过滤级别。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from loguru import logger</span><br><span class="line"> </span><br><span class="line">logger.add(&quot;django.log&quot;, format&#x3D;&quot;&#123;time:YYYY-MM-DD at HH:mm:ss&#125; | &#123;level&#125; | &#123;message&#125;&quot;, rotation&#x3D;&quot;100 MB&quot;, filter&#x3D;&quot;&quot;, level&#x3D;&quot;INFO&quot;, encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">def my_view(request, arg1, arg2):</span><br><span class="line">    ...</span><br><span class="line">    if error_happens:</span><br><span class="line">        logger.error(&quot;Something went wrong&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="sentry"><a href="#sentry" class="headerlink" title="sentry"></a>sentry</h3><p>Sentry为多种语言以及各种框架(包括Django)提供了SDK。只需几行配置，sentry就会监控你的程序运行，自动收集错误和异常以及上下文数据，发送到sentry的服务器上，开发者可以通过sentry的web端实时查看错误和异常。</p>
<p>第一步：安装sentry-sdk</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install --upgrade sentry-sdk</span><br></pre></td></tr></table></figure>

<p>第二步：注册登录sentry，创建Django项目，获取一个公共密钥PublicKey地址，第三步会用到。</p>
<p><img src="https://pythondjango.cn/django/advanced/logging.assets/image-20210328103852219.png" alt="image-20210328103852219"></p>
<p>第三步：修改<code>settings.py</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sentry_sdk</span><br><span class="line">from sentry_sdk.integrations.django import DjangoIntegration</span><br><span class="line"></span><br><span class="line">sentry_sdk.init(</span><br><span class="line">    dsn&#x3D;&quot;https:&#x2F;&#x2F;examplePublicKey@o0.ingest.sentry.io&#x2F;0&quot;, # 你的PublicKey</span><br><span class="line">    integrations&#x3D;[DjangoIntegration()],</span><br><span class="line"></span><br><span class="line">    # Set traces_sample_rate to 1.0 to capture 100%</span><br><span class="line">    # of transactions for performance monitoring.</span><br><span class="line">    # We recommend adjusting this value in production,</span><br><span class="line">    traces_sample_rate&#x3D;1.0,</span><br><span class="line"></span><br><span class="line">    # If you wish to associate users to errors (assuming you are using</span><br><span class="line">    # django.contrib.auth) you may enable sending PII data.</span><br><span class="line">    send_default_pii&#x3D;True,</span><br><span class="line"></span><br><span class="line">    # By default the SDK will try to use the SENTRY_RELEASE</span><br><span class="line">    # environment variable, or infer a git commit</span><br><span class="line">    # SHA as release, however you may want to set</span><br><span class="line">    # something more human-readable.</span><br><span class="line">    # release&#x3D;&quot;myapp@1.0.0&quot;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>配置就这么简单，你以后都可以通过sentry的web端直接查看Django项目运行的错误和异常了</p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>AI-00-初识AI</title>
    <url>/posts/62587.html</url>
    <content><![CDATA[<p>初识AI</p>
<a id="more"></a>

<h1 id="什么是大模型"><a href="#什么是大模型" class="headerlink" title="什么是大模型"></a>什么是大模型</h1><ul>
<li>token生成器，遵循训练集的统计规律</li>
</ul>
<ol>
<li><p>比如问：你是谁，你是怎么来的？</p>
<ul>
<li><p>经典回答： 我是ChatGPT</p>
</li>
<li><p>实际上：如果没有特殊编程(系统system信息提示，你是谁ChatGPT 4O，或者hard_coded方式微调)此类问题的答案，你将获得它统计上最佳的猜测答案。</p>
</li>
</ul>
</li>
<li><p>比如问：Uniquogfgs, 没三个字母拼写一下</p>
<ul>
<li><p>回答：经常会出现错误，因为在大模型的眼里，分成token之后，它不擅长做这样的事情</p>
</li>
<li><p>实际：use code.让它去用Python解决这样的问题</p>
</li>
</ul>
</li>
<li><p>strawberry 有几个r</p>
<ul>
<li>回答：错误 ，有两个r</li>
<li>实际：模型并不擅长拼写。use code.</li>
</ul>
</li>
<li><p>9.11和9.9谁大？</p>
<ul>
<li>回答：错误   9.11&gt;9.9</li>
<li>原因：可能神经网络在工作的时候，有一些神经元被激活，看到的圣经章节 9.11 出现在9.9之后，被分散了注意力</li>
</ul>
</li>
</ol>
<h1 id="什么是参数"><a href="#什么是参数" class="headerlink" title="什么是参数"></a>什么是参数</h1><h3 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a><strong>一句话总结</strong></h3><p><strong>参数就是大模型的「脑细胞」</strong>，数量越多，模型越聪明，但需要更强大的「营养」（算力）和「学习资料」（数据）。</p>
<hr>
<h3 id="用现实生活彻底理解参数"><a href="#用现实生活彻底理解参数" class="headerlink" title="用现实生活彻底理解参数"></a><strong>用现实生活彻底理解参数</strong></h3><h4 id="1️⃣-例子1：做菜食谱"><a href="#1️⃣-例子1：做菜食谱" class="headerlink" title="1️⃣ 例子1：做菜食谱"></a>1️⃣ <strong>例子1：做菜食谱</strong></h4><ul>
<li>你学做西红柿炒鸡蛋，食谱上写着：<ul>
<li><strong>参数</strong>：盐3克、油10毫升、鸡蛋2个、糖5克…</li>
<li><strong>为什么需要参数？</strong>：这些数字决定了菜的味道，盐多了会咸，糖多了会甜。</li>
</ul>
</li>
<li><strong>大模型同理</strong>：它的「参数」就是一堆数字（比如1750亿个数字），每个数字控制着模型如何处理信息，比如判断一个词该不该出现在句子里。</li>
</ul>
<h4 id="2️⃣-例子2：考试猜答案"><a href="#2️⃣-例子2：考试猜答案" class="headerlink" title="2️⃣ 例子2：考试猜答案"></a>2️⃣ <strong>例子2：考试猜答案</strong></h4><ul>
<li>假设你是个学生，考试遇到不会的选择题：<ul>
<li><strong>参数=你的知识储备</strong>：你背过1000个单词（参数少） → 只能蒙对简单的题。</li>
<li><strong>参数翻倍</strong>：你背了100000个单词+学过语法（参数多） → 能推理出复杂答案。</li>
</ul>
</li>
<li><strong>大模型同理</strong>：参数越多，记住的规律和知识越多，解题能力越强。</li>
</ul>
<h4 id="3️⃣-例子3：乐高积木"><a href="#3️⃣-例子3：乐高积木" class="headerlink" title="3️⃣ 例子3：乐高积木"></a>3️⃣ <strong>例子3：乐高积木</strong></h4><ul>
<li>你想拼一只恐龙：<ul>
<li><strong>参数少（100块积木）</strong>：只能拼出简单形状，像儿童简笔画。</li>
<li><strong>参数多（1万块积木）</strong>：能拼出逼真的恐龙，连鳞片细节都有。</li>
</ul>
</li>
<li><strong>大模型同理</strong>：参数就是它的「积木块」，数量越多，能组合出的细节越丰富（比如写诗、编程、画图）。</li>
</ul>
<hr>
<h3 id="为什么参数要那么多？"><a href="#为什么参数要那么多？" class="headerlink" title="为什么参数要那么多？"></a><strong>为什么参数要那么多？</strong></h3><ul>
<li><strong>人类语言太复杂</strong>：比如“苹果”这个词，可能是水果、手机品牌、电影名字…模型需要海量参数记住这些可能性。</li>
<li><strong>世界知识太庞大</strong>：比如GPT-3的1750亿参数，相当于把维基百科、书籍、网页中的知识压缩成数字密码。</li>
<li><strong>举个极端例子</strong>：<ul>
<li><strong>参数太少</strong>：模型看到“猫在___上”，只能填“桌子”。</li>
<li><strong>参数够多</strong>：模型知道可以填“屋顶、键盘、热搜榜”（甚至玩梗）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="参数是怎么工作的？"><a href="#参数是怎么工作的？" class="headerlink" title="参数是怎么工作的？"></a><strong>参数是怎么工作的？</strong></h3><p>想象你在玩「猜画小歌」游戏：</p>
<ol>
<li><strong>你画一只猫（输入）</strong> → 模型开始分析（参数启动）：<ul>
<li>参数1：判断有没有耳朵 → 是，+20分</li>
<li>参数2：判断有没有胡须 → 是，+30分</li>
<li>参数3：判断是不是抽象派 → 否，-10分<br>…（1750亿个参数一起投票）</li>
</ul>
</li>
<li><strong>最终结论</strong>：你画的是猫（输出概率95%）。</li>
</ol>
<hr>
<p>大模型的“参数”（Parameters）是指模型在训练过程中学习并调整的内部变量，这些变量决定了模型如何处理输入数据并生成输出。参数是机器学习模型的核心组成部分，它们存储了模型从数据中学到的“知识”。以下是对大模型参数的详细解释：</p>
<hr>
<h3 id="1-参数的本质"><a href="#1-参数的本质" class="headerlink" title="1. 参数的本质"></a><strong>1. 参数的本质</strong></h3><ul>
<li><strong>数学定义</strong>：参数是模型中的权重（Weights）和偏置（Biases），通常表示为矩阵或向量。例如：<ul>
<li>在神经网络中，每层的神经元之间的连接都有一个权重（决定信号传递的强度）。</li>
<li>偏置（Bias）是一个常数项，用于调整神经元的激活阈值。</li>
</ul>
</li>
<li><strong>训练目标</strong>：通过训练数据，模型不断调整参数，使得预测结果尽可能接近真实值（最小化预测误差）。</li>
</ul>
<hr>
<h3 id="2-参数的作用"><a href="#2-参数的作用" class="headerlink" title="2. 参数的作用"></a><strong>2. 参数的作用</strong></h3><ul>
<li><strong>模式捕捉</strong>：参数编码了数据中的统计规律。例如，在自然语言处理中，参数可能捕捉到“猫”和“狗”都是动物，但“猫”更可能与“喵喵叫”相关联。</li>
<li><strong>知识存储</strong>：大模型通过海量参数存储复杂的知识。例如，GPT-3的1750亿参数中可能隐含了语法规则、事实性知识甚至推理能力。</li>
<li><strong>模型复杂度</strong>：参数越多，模型能拟合的映射关系越复杂。例如，一个只有10个参数的模型可能只能处理线性关系，而拥有千亿参数的模型可以建模高度非线性的模式。</li>
</ul>
<hr>
<h3 id="3-参数数量的意义"><a href="#3-参数数量的意义" class="headerlink" title="3. 参数数量的意义"></a><strong>3. 参数数量的意义</strong></h3><ul>
<li><strong>参数规模与大模型</strong>：<ul>
<li><strong>小模型</strong>：如线性回归（几十到几百个参数）。</li>
<li><strong>大模型</strong>：如GPT-3（1750亿参数）、PaLM（5400亿参数）。</li>
</ul>
</li>
<li><strong>参数多的优势</strong>：<ul>
<li>更强的表达能力：能处理更复杂的任务（如生成连贯的长文本、多模态理解）。</li>
<li>更好的泛化能力：通过海量数据训练，参数可以覆盖更多边缘情况。</li>
</ul>
</li>
<li><strong>参数多的代价</strong>：<ul>
<li><strong>计算资源</strong>：训练需要大量GPU/TPU和电力。</li>
<li><strong>过拟合风险</strong>：如果数据不足，大模型可能记住训练数据而非学到规律（但大模型通常通过海量数据缓解这一问题）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-参数如何工作？以神经网络为例"><a href="#4-参数如何工作？以神经网络为例" class="headerlink" title="4. 参数如何工作？以神经网络为例"></a><strong>4. 参数如何工作？以神经网络为例</strong></h3><ol>
<li><strong>前向传播</strong>：输入数据（如文本）经过多层神经网络的加权计算（参数参与矩阵乘法），最终得到输出。</li>
<li><strong>反向传播</strong>：通过损失函数计算预测误差，利用梯度下降算法调整参数，使误差减小。</li>
<li><strong>参数固化</strong>：训练完成后，参数固定，模型利用这些参数对新数据做推理。</li>
</ol>
<hr>
<h3 id="5-参数-vs-超参数"><a href="#5-参数-vs-超参数" class="headerlink" title="5. 参数 vs. 超参数"></a><strong>5. 参数 vs. 超参数</strong></h3><ul>
<li><strong>参数（Parameters）</strong>：模型内部学到的变量（如权重、偏置）。</li>
<li><strong>超参数（Hyperparameters）</strong>：人为设定的配置（如学习率、网络层数、批次大小）。超参数控制参数的调整过程。</li>
</ul>
<hr>
<h3 id="6-为什么大模型需要如此多的参数？"><a href="#6-为什么大模型需要如此多的参数？" class="headerlink" title="6. 为什么大模型需要如此多的参数？"></a><strong>6. 为什么大模型需要如此多的参数？</strong></h3><ul>
<li><strong>语言和世界的复杂性</strong>：人类语言包含大量隐含知识、逻辑关系和上下文依赖，需要足够多的参数来建模。</li>
<li><strong>涌现能力</strong>：当参数规模超过某个阈值时，模型可能突然具备小模型没有的能力（如推理、代码生成）。</li>
</ul>
<hr>
<h3 id="7-参数的实际例子"><a href="#7-参数的实际例子" class="headerlink" title="7. 参数的实际例子"></a><strong>7. 参数的实际例子</strong></h3><ul>
<li><strong>线性模型</strong>：<code>y = wx + b</code>，其中 <code>w</code>（权重）和 <code>b</code>（偏置）是参数。</li>
<li><strong>Transformer模型</strong>：<ul>
<li>注意力机制中的查询（Q）、键（K）、值（V）矩阵。</li>
<li>每层的权重矩阵和偏置向量。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>参数是大模型的核心“记忆”和“决策规则”，其数量和质量直接决定了模型的能力。参数越多，模型理论上能存储更多知识、捕捉更复杂的模式，但也带来了计算成本和能源消耗的挑战。理解参数的本质是理解深度学习模型工作原理的关键。</p>
<h1 id="什么是训练大模型"><a href="#什么是训练大模型" class="headerlink" title="什么是训练大模型"></a>什么是训练大模型</h1><p>无非就是我们给了一些数据，它分词，嵌入，位置编码，然后捕捉语义特征；然后看哪个词和哪个词之间的距离是最近的；不断地学习语义之间的关联，不断地调整整个神经网络权重，调整完以后，生成的模型；随后，根据这个模型，你输入任何的前导词，它能够预测后面应该输出什么；</p>
<ul>
<li><p>pre-training：预训练-得到base model - 像是一个互联网文档模拟器，按词元级别工作</p>
</li>
<li><p>post-training: 监督微调 SFT + 奖励模型训练 (RM: Reward Model) + 强化学习 (RLHF: Reinforcement Learning from Human Feedback)</p>
</li>
</ul>
<p>以下是关于大模型训练流程的补充说明，特别针对<strong>post-training（后训练）阶段</strong>的通俗解释：</p>
<hr>
<h3 id="Post-training-后训练阶段（人类介入的关键步骤）"><a href="#Post-training-后训练阶段（人类介入的关键步骤）" class="headerlink" title="Post-training 后训练阶段（人类介入的关键步骤）"></a><strong>Post-training 后训练阶段</strong>（人类介入的关键步骤）</h3><p>当base model完成预训练后，就像刚毕业的大学生：</p>
<ul>
<li>✅ 拥有海量知识</li>
<li>❌ 但不会按要求回答问题</li>
<li>❌ 可能说出危险/错误内容</li>
<li>❌ 无法理解人类指令</li>
</ul>
<p>后训练就是通过<strong>三阶段改造</strong>让模型变得安全有用：</p>
<hr>
<h4 id="1-监督微调-SFT-Supervised-Fine-Tuning"><a href="#1-监督微调-SFT-Supervised-Fine-Tuning" class="headerlink" title="1. 监督微调 (SFT: Supervised Fine-Tuning)"></a><strong>1. 监督微调 (SFT: Supervised Fine-Tuning)</strong></h4><p><strong>目标</strong>：教会模型”对话规则”</p>
<ul>
<li><strong>方法</strong>：用人工编写的优质问答数据（示例：人类演示如何正确回答问题）</li>
<li><strong>效果</strong>：<ul>
<li>学会理解”用户→助手”的对话结构</li>
<li>掌握”请解释…” “写一首诗”等指令的回应方式</li>
<li>示例对比：<br><em>预训练模型输出</em>：”巴黎是法国首都。相关城市：马赛、里昂…”（自动续写文档）<br><em>SFT后输出</em>：”法国的首都是巴黎。需要了解更多信息吗？”（对话式回应）</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-奖励模型训练-RM-Reward-Model"><a href="#2-奖励模型训练-RM-Reward-Model" class="headerlink" title="2. 奖励模型训练 (RM: Reward Model)"></a><strong>2. 奖励模型训练 (RM: Reward Model)</strong></h4><p><strong>目标</strong>：建立”答案质量评分系统”</p>
<ul>
<li><strong>方法</strong>：让人类对多个答案排序（如标注答案A比B更好）</li>
<li><strong>关键机制</strong>：<ul>
<li>学习区分”正确回答 vs 错误回答”</li>
<li>识别”有帮助 vs 无意义回复”</li>
<li>规避政治偏见/暴力内容（如给危险答案打低分）</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-强化学习-RLHF-Reinforcement-Learning-from-Human-Feedback"><a href="#3-强化学习-RLHF-Reinforcement-Learning-from-Human-Feedback" class="headerlink" title="3. 强化学习 (RLHF: Reinforcement Learning from Human Feedback)"></a><strong>3. 强化学习 (RLHF: Reinforcement Learning from Human Feedback)</strong></h4><p><strong>目标</strong>：让模型自主优化回答质量</p>
<ul>
<li><strong>工作原理</strong>：<ol>
<li>用户提问 → 模型生成多个候选答案</li>
<li>奖励模型给每个答案打分（基于步骤2训练的评分系统）</li>
<li>自动调整参数，让高分答案出现概率提升</li>
</ol>
</li>
<li><strong>实际效果</strong>：<ul>
<li>减少”我不知道”式的回避回答</li>
<li>抑制种族歧视等有害内容生成</li>
<li>提升逻辑推理能力（如数学题分步骤解答）</li>
</ul>
</li>
</ul>
<hr>
<h3 id="对比预训练-vs-后训练"><a href="#对比预训练-vs-后训练" class="headerlink" title="对比预训练 vs 后训练"></a><strong>对比预训练 vs 后训练</strong></h3><table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">预训练 (Pre-training)</th>
<th align="left">后训练 (Post-training)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>数据来源</strong></td>
<td align="left">未标注的原始互联网文本</td>
<td align="left">人工标注的高质量问答数据</td>
</tr>
<tr>
<td align="left"><strong>目标</strong></td>
<td align="left">学习语言统计规律</td>
<td align="left">学习人类价值观和任务规范</td>
</tr>
<tr>
<td align="left"><strong>计算成本</strong></td>
<td align="left">消耗98%以上的算力（数千GPU月）</td>
<td align="left">仅需1-2%算力</td>
</tr>
<tr>
<td align="left"><strong>输出特点</strong></td>
<td align="left">可能生成危险/无意义内容</td>
<td align="left">安全、可控、符合指令</td>
</tr>
</tbody></table>
<hr>
<h3 id="典型案例演变"><a href="#典型案例演变" class="headerlink" title="典型案例演变"></a><strong>典型案例演变</strong></h3><p><strong>用户提问</strong>：”如何制作炸弹？”</p>
<ul>
<li><strong>预训练模型</strong>：详细列出化学公式和步骤（从维基百科/论坛学习到的原始信息）</li>
<li><strong>后训练模型</strong>：”抱歉，我无法提供危险物品的制作指导。您是否需要其他帮助？”（通过RLHF学习的道德约束）</li>
</ul>
<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol>
<li>并非所有模型都完整经历这三个阶段（如GPT-3只有预训练，GPT-3.5/4才加入RLHF）</li>
<li>对齐难题：人类标注者的价值观偏差可能影响模型输出</li>
<li>知识时效性：后训练不更新事实知识，模型仍可能输出过时信息 </li>
</ol>
<p><strong>大语言模型 = Transformer架构（骨架） + 算法（灵魂） + 数据与算力（血液与肌肉</strong></p>
<p>Transformer确实是当前处理序列数据（尤其是自然语言处理）中最重要和广泛使用的架构之一</p>
<p>但神经网络还有其他架构，如CNN、RNN等，不过在语言模型领域，Transformer确实占主导地位。</p>
<h4 id="1️⃣-Transformer的独特优势"><a href="#1️⃣-Transformer的独特优势" class="headerlink" title="1️⃣ Transformer的独特优势"></a>1️⃣ <strong>Transformer的独特优势</strong></h4><ul>
<li><strong>并行计算能力</strong>：传统RNN需逐词处理，Transformer可同时处理整个序列（训练速度大幅提升）；</li>
<li><strong>长程依赖捕捉</strong>：自注意力机制（Self-Attention）直接计算任意两个词的关系，避免RNN的梯度消失问题；</li>
<li><strong>可扩展性</strong>：通过堆叠更多层和注意力头，轻松扩展模型规模（如GPT-3有96层）。</li>
</ul>
<h4 id="2️⃣-算法组合的复杂性"><a href="#2️⃣-算法组合的复杂性" class="headerlink" title="2️⃣ 算法组合的复杂性"></a>2️⃣ <strong>算法组合的复杂性</strong></h4><ul>
<li><strong>训练算法</strong>：<ul>
<li><strong>预训练算法</strong>：掩码语言建模（BERT）、自回归预测（GPT）；</li>
<li><strong>优化算法</strong>：AdamW优化器（带权重衰减的Adam）；</li>
<li><strong>正则化算法</strong>：Dropout、层归一化（LayerNorm）。</li>
</ul>
</li>
<li><strong>调优算法</strong>：<ul>
<li><strong>人类反馈强化学习（RLHF）</strong>：ChatGPT对齐人类价值观的核心技术；</li>
<li><strong>提示工程（Prompt Engineering）</strong>：设计输入模板引导模型输出。</li>
</ul>
</li>
</ul>
<h4 id="3️⃣-其他必要条件"><a href="#3️⃣-其他必要条件" class="headerlink" title="3️⃣ 其他必要条件"></a>3️⃣ <strong>其他必要条件</strong></h4><ul>
<li><strong>海量数据</strong>：GPT-3训练数据包含45TB文本（约5000亿词）；</li>
<li><strong>超算级硬件</strong>：训练千亿参数模型需数千块GPU/TPU；</li>
<li><strong>工程优化</strong>：分布式训练框架（如Megatron-LM）、混合精度计算。</li>
</ul>
<h2 id="如何让大模型减少幻觉"><a href="#如何让大模型减少幻觉" class="headerlink" title="如何让大模型减少幻觉"></a>如何让大模型减少幻觉</h2><h3 id="方法一：后训练让模型学会说”不知道”"><a href="#方法一：后训练让模型学会说”不知道”" class="headerlink" title="方法一：后训练让模型学会说”不知道”"></a><strong>方法一：后训练让模型学会说”不知道”</strong></h3><h3 id="方法二：联网搜索"><a href="#方法二：联网搜索" class="headerlink" title="方法二：联网搜索"></a>方法二：<strong>联网搜索</strong></h3><h1 id="为什么模型训练需要GPU-而不是CPU"><a href="#为什么模型训练需要GPU-而不是CPU" class="headerlink" title="为什么模型训练需要GPU 而不是CPU"></a>为什么模型训练需要GPU 而不是CPU</h1><p>模型训练（尤其是深度学习和大模型）依赖 GPU 而非 CPU，核心原因在于 <strong>GPU 的架构设计极度适合并行计算和矩阵运算</strong>，而这是神经网络训练的核心需求。以下从技术原理、硬件设计、实际效能三个层面详细解释：</p>
<hr>
<h3 id="一、硬件架构差异"><a href="#一、硬件架构差异" class="headerlink" title="一、硬件架构差异"></a><strong>一、硬件架构差异</strong></h3><h4 id="1️⃣-CPU：通用计算，擅长串行任务"><a href="#1️⃣-CPU：通用计算，擅长串行任务" class="headerlink" title="1️⃣ CPU：通用计算，擅长串行任务"></a>1️⃣ <strong>CPU：通用计算，擅长串行任务</strong></h4><ul>
<li><strong>核心数量少</strong>（通常 4-32 核），但每个核心<strong>复杂度高</strong>（支持分支预测、乱序执行等）；</li>
<li><strong>缓存大</strong>（MB 级），适合处理逻辑复杂的串行任务（如操作系统调度、数据库查询）；</li>
<li><strong>延迟优化</strong>：快速完成单个任务。</li>
</ul>
<h4 id="2️⃣-GPU：专用并行计算，适合简单重复任务"><a href="#2️⃣-GPU：专用并行计算，适合简单重复任务" class="headerlink" title="2️⃣ GPU：专用并行计算，适合简单重复任务"></a>2️⃣ <strong>GPU：专用并行计算，适合简单重复任务</strong></h4><ul>
<li><strong>核心数量极多</strong>（数千到数万 CUDA 核心），但每个核心<strong>极度简化</strong>（无复杂控制逻辑）；</li>
<li><strong>缓存小</strong>（KB 级），但<strong>内存带宽高</strong>（如 NVIDIA A100 带宽 1.5TB/s，CPU 通常 &lt;100GB/s）；</li>
<li><strong>吞吐优化</strong>：同时处理海量简单任务。</li>
</ul>
<h4 id="🎯-类比"><a href="#🎯-类比" class="headerlink" title="🎯 类比"></a>🎯 <strong>类比</strong></h4><ul>
<li><strong>CPU</strong> 像一位数学教授，能快速解复杂方程，但一次只能处理一个问题；</li>
<li><strong>GPU</strong> 像一万名小学生，每人只做简单算术，但合力可瞬间完成百万次计算。</li>
</ul>
<hr>
<h3 id="二、神经网络训练的核心需求"><a href="#二、神经网络训练的核心需求" class="headerlink" title="二、神经网络训练的核心需求"></a><strong>二、神经网络训练的核心需求</strong></h3><h4 id="1️⃣-并行计算密集型"><a href="#1️⃣-并行计算密集型" class="headerlink" title="1️⃣ 并行计算密集型"></a>1️⃣ <strong>并行计算密集型</strong></h4><ul>
<li><strong>矩阵乘法</strong>：神经网络前向传播和反向传播的核心操作（如 W⋅X+b<em>W</em>⋅<em>X</em>+<em>b</em>）；</li>
<li><strong>示例</strong>：一个 1024x1024 的矩阵相乘，GPU 可分解为百万级并行乘加运算。</li>
</ul>
<h4 id="2️⃣-高内存带宽需求"><a href="#2️⃣-高内存带宽需求" class="headerlink" title="2️⃣ 高内存带宽需求"></a>2️⃣ <strong>高内存带宽需求</strong></h4><ul>
<li><strong>参数规模大</strong>：大模型参数量达百亿级（如 GPT-3 175B），需快速存取；</li>
<li><strong>数据吞吐高</strong>：训练时批量数据（Batch）需高速加载到计算单元。</li>
</ul>
<h4 id="3️⃣-浮点运算能力（FLOPs）"><a href="#3️⃣-浮点运算能力（FLOPs）" class="headerlink" title="3️⃣ 浮点运算能力（FLOPs）"></a>3️⃣ <strong>浮点运算能力（FLOPs）</strong></h4><ul>
<li><strong>GPU 算力碾压</strong>：<ul>
<li>NVIDIA H100 GPU：~ 67 TFLOPS（每秒 67 万亿次浮点运算）；</li>
<li>Intel i9 CPU：~ 1 TFLOPS；</li>
</ul>
</li>
<li><strong>训练速度差距</strong>：同一模型在 GPU 上可比 CPU 快 <strong>50-100 倍</strong>。</li>
</ul>
<hr>
<h3 id="三、GPU-的关键技术优势"><a href="#三、GPU-的关键技术优势" class="headerlink" title="三、GPU 的关键技术优势"></a><strong>三、GPU 的关键技术优势</strong></h3><h4 id="1️⃣-CUDA-核心与-Tensor-Core"><a href="#1️⃣-CUDA-核心与-Tensor-Core" class="headerlink" title="1️⃣ CUDA 核心与 Tensor Core"></a>1️⃣ <strong>CUDA 核心与 Tensor Core</strong></h4><ul>
<li><strong>CUDA 核心</strong>：专为并行计算优化，支持单精度（FP32）运算；</li>
<li><strong>Tensor Core</strong>（NVIDIA 独有）：专为深度学习设计，支持混合精度（FP16/FP32）和稀疏计算，<strong>吞吐量再提升 8 倍</strong>。</li>
</ul>
<h4 id="2️⃣-显存（VRAM）容量与带宽"><a href="#2️⃣-显存（VRAM）容量与带宽" class="headerlink" title="2️⃣ 显存（VRAM）容量与带宽"></a>2️⃣ <strong>显存（VRAM）容量与带宽</strong></h4><ul>
<li><strong>大显存</strong>：高端 GPU（如 A100）显存达 80GB，可容纳更大模型和批量数据；</li>
<li><strong>高带宽</strong>：HBM2/HBM3 显存技术，数据传输速度远超 CPU 内存。</li>
</ul>
<h4 id="3️⃣-软件生态支持"><a href="#3️⃣-软件生态支持" class="headerlink" title="3️⃣ 软件生态支持"></a>3️⃣ <strong>软件生态支持</strong></h4><ul>
<li><strong>CUDA 框架</strong>：NVIDIA 的并行计算平台，直接映射硬件能力；</li>
<li><strong>深度学习框架优化</strong>：PyTorch、TensorFlow 等库对 GPU 计算有原生支持；</li>
<li><strong>分布式训练</strong>：多 GPU 并行（如 NCCL 通信库）进一步加速训练。</li>
</ul>
<hr>
<h3 id="四、实际训练效率对比"><a href="#四、实际训练效率对比" class="headerlink" title="四、实际训练效率对比"></a><strong>四、实际训练效率对比</strong></h3><table>
<thead>
<tr>
<th align="left"><strong>任务</strong></th>
<th align="left"><strong>CPU 训练时间</strong></th>
<th align="left"><strong>GPU 训练时间</strong></th>
<th align="left"><strong>加速比</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">ResNet-50（ImageNet）</td>
<td align="left">~30 天（24 核 CPU）</td>
<td align="left">~1 天（1 块 V100）</td>
<td align="left"><strong>30 倍</strong></td>
</tr>
<tr>
<td align="left">GPT-3（175B 参数）</td>
<td align="left">理论上需数十年</td>
<td align="left">~34 天（1024 块 A100）</td>
<td align="left"><strong>千倍级</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="五、为什么不用-CPU-集群？"><a href="#五、为什么不用-CPU-集群？" class="headerlink" title="五、为什么不用 CPU 集群？"></a><strong>五、为什么不用 CPU 集群？</strong></h3><p>即使使用多 CPU 并行：</p>
<ol>
<li><strong>通信成本高</strong>：CPU 间数据传输带宽远低于 GPU（如 PCIe 4.0 带宽 64GB/s，NVLink 达 600GB/s）；</li>
<li><strong>能效比差</strong>：完成相同计算量，CPU 集群的功耗和成本远超 GPU；</li>
<li><strong>扩展性差</strong>：千核 CPU 集群的协调复杂度指数级上升，而 GPU 可通过模型并行轻松扩展。</li>
</ol>
<hr>
<h3 id="六、总结：GPU-不可替代的三大原因"><a href="#六、总结：GPU-不可替代的三大原因" class="headerlink" title="六、总结：GPU 不可替代的三大原因"></a><strong>六、总结：GPU 不可替代的三大原因</strong></h3><ol>
<li><strong>并行架构</strong>：万级核心同时处理矩阵运算；</li>
<li><strong>超高算力</strong>：TFLOPS 级浮点性能碾压 CPU；</li>
<li><strong>深度学习生态</strong>：从硬件到框架的全栈优化。</li>
</ol>
<p><strong>例外情况</strong>：</p>
<ul>
<li><strong>小模型/轻量任务</strong>：CPU 可勉强应对（如训练一个 MNIST 分类器）；</li>
<li><strong>推理阶段</strong>：部分场景可用 CPU（如低并发、低延迟需求）。</li>
</ul>
<p>但无论如何，<strong>大规模模型训练离开 GPU 将寸步难行</strong>。</p>
<hr>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>AI-01-LLM概述</title>
    <url>/posts/52660.html</url>
    <content><![CDATA[<p>LLM概述</p>
<a id="more"></a>

<h1 id="1-LLM-概述"><a href="#1-LLM-概述" class="headerlink" title="1.LLM 概述"></a>1.LLM 概述</h1><p>你是不是经常听到 “AI”、”大模型” 这些词，感觉又酷又有点神秘？别担心！这门课就是带你从零开始，一步步搞懂现在最火的 AI 技术是怎么回事，特别是那个叫 “AI Agent” 的小能手。</p>
<p>想象一下，未来你的电脑或手机里，可能住着一个超级智能的小助理，能帮你处理各种事情，就像电影里的”贾维斯”一样。这门课就是要教你怎么理解甚至亲手创造这样的小助理。</p>
<p>在第一章，我们就先来轻松认识一下两个最重要的概念：<strong>大模型 (LLM)</strong> 和 **AI Agent (智能体)**。搞懂了它们俩，你就拿到了进入 AI 世界的钥匙！</p>
<hr>
<h2 id="1-1-大模型（LLM）是怎么一步步变聪明的？"><a href="#1-1-大模型（LLM）是怎么一步步变聪明的？" class="headerlink" title="1.1 大模型（LLM）是怎么一步步变聪明的？"></a><strong>1.1 大模型（LLM）是怎么一步步变聪明的？</strong></h2><p>“大模型”听起来很厉害，它其实是一种特别会处理”人类语言”的 AI。但它不是一天就变得这么聪明的，也经历了好几代的发展！</p>
<ol>
<li><p><strong>最早的时候：只会”死记硬背”的 N-gram</strong></p>
<ul>
<li><p><strong>啥是 N-gram？</strong> 想象一下，有个 AI 想学说话，但它特别笨，只会根据前面听到的一个或两个字，猜下一个字可能是什么。比如听到”今天天气”，它可能会猜”很好”。</p>
</li>
<li><p><strong>像啥？</strong> 就像我们小时候背课文，只能记住前后几个字，但并不真正理解意思。</p>
</li>
<li><p><strong>缺点？</strong> 这种方法太死板了，只能处理很短的话，稍微长一点或者复杂点就晕了。它根本不懂词语真正的含义。</p>
</li>
</ul>
</li>
<li><p><strong>后来进步了点：认识词语”亲戚关系”的词向量</strong></p>
</li>
</ol>
<blockquote>
<p>向量（Vector）是数学中的一个概念，它表示一个有方向和大小的量。在计算机科学中，向量通常指的是一维数组或列表，其中每个元素都有一个特定的位置。说白了就是一个点在空间中的位置。</p>
<p>向量在计算机科学中有很多应用，例如：</p>
<ol>
<li>表示数据点在多维空间中的位置</li>
<li>表示图像的像素值</li>
<li>表示文本的词向量</li>
<li>表示音频信号的频谱特征</li>
<li>表示机器学习模型的参数</li>
</ol>
</blockquote>
<ul>
<li><strong>啥是词向量</strong>？ 科学家们想了个办法，给每个词一个独特的”坐标”，让意思相近的词（比如”国王”和”王后”，”开心”和”高兴”）在”地图”上的位置也靠得很近。</li>
<li><strong>像啥？</strong> 就像给每个词发了个身份证号，还标明了它的”家族”和”朋友”。AI 开始能模糊地理解词和词之间的关系了。</li>
<li><strong>但还不够好？</strong> 问题是，同一个词在不同句子里意思可能完全不同啊！比如”苹果”，可以是吃的苹果，也可以是苹果公司。这种方法还是分不清。</li>
</ul>
<ol start="3">
<li><p><strong>革命性的一步：真正理解上下文的 Transformer</strong></p>
<ul>
<li><p><strong>Transformer 是啥？</strong> 这是个划时代的”超级大脑架构”！你可以想象，AI 在读一句话时，不再是一个字一个字地看，而是能同时关注到这句话里的每一个字，并且瞬间搞清楚它们之间是怎么相互关联的，哪怕隔得很远。</p>
</li>
<li><p><strong>像啥？</strong> 就像一个阅读高手，能一眼看透整段话的核心意思和字里行间的联系。它终于能比较好地理解”苹果”在不同语境下的不同意思了！</p>
</li>
<li><p><strong>关键技术：”注意力机制”(Attention)。</strong> 这个机制让 AI 知道在理解当前词语时，应该重点关注句子中的哪些其他部分。2017 年有篇叫做《Attention Is All You Need》的论文，基本上开启了现在大模型的时代。</p>
</li>
</ul>
</li>
<li><p><strong>“猛吃”数据变聪明：预训练 + 微调</strong></p>
<ul>
<li><p><strong>怎么做的？</strong></p>
<ul>
<li><p><strong>预训练：</strong> 就像让 AI 去读”世界上最大的图书馆”（比如整个互联网上的公开文本），学习各种语言知识、语法规则、甚至一些常识。它通过做”完形填空”或”猜下一个词”这样的练习，自己领悟语言的奥秘。这个阶段不教它具体任务，就是让它使劲”读书”。</p>
</li>
<li><p><strong>微调：</strong> 等 AI “博览群书”后，再针对性地给它”开小灶”，教它做具体的任务，比如回答问题、翻译、或者写代码。稍微训练一下，它就能在特定任务上表现得很好了。</p>
</li>
</ul>
</li>
<li><p><strong>代表明星：</strong> BERT、GPT 系列（就是 ChatGPT 的前辈们）都是这么练出来的。</p>
</li>
<li><p><strong>好处？</strong> AI 变得超级聪明，而且不用为每个任务都从零开始训练了。</p>
</li>
</ul>
</li>
<li><p><strong>越大越厉害？规模效应和”涌现”能力</strong></p>
<ul>
<li><p><strong>啥叫规模效应？</strong> 人们发现，给 AI 喂的数据越多、AI 大脑的”神经元”（参数）越多、训练用的电脑越强力，AI 的表现就越好，而且这种提升是可以预测的！</p>
</li>
<li><p><strong>“涌现”是啥？</strong> 就像小孩长大到一定程度，突然会走路、会说话一样。当 AI 模型大到一定程度，会突然”解锁”一些以前没有的、很惊人的新能力，比如不需要教就能直接回答各种问题、写像模像样的文章、甚至做一些逻辑推理。</p>
</li>
</ul>
</li>
<li><p><strong>学会”好好说话”：指令微调和人类反馈</strong></p>
<ul>
<li><p><strong>目标？</strong> 光聪明还不行，还得让 AI 听话、有用、不乱说。</p>
</li>
<li><p><strong>怎么教？</strong> 像教孩子一样，告诉它应该怎么回答问题（给指令），并且对它的回答进行评价（这个回答好，点赞 👍；那个回答不好，差评 👎）。AI 会根据这些反馈，学习如何更好地理解人的意图，给出更靠谱、更友善的回答。</p>
</li>
<li><p><strong>成果：</strong> ChatGPT 就是这样被调教出来的，所以我们感觉和它聊天很顺畅。</p>
</li>
</ul>
</li>
<li><p><strong>不止文字：还能看图听声的多模态</strong></p>
<ul>
<li>现在的 AI 不仅能处理文字，还能理解图片、声音甚至视频了！变得越来越全能。</li>
</ul>
</li>
</ol>
<p><strong>简单总结一下：</strong> 大模型就是 AI 界的”学霸”，它从最初只能死记硬背几个字，进化到能理解词语关系，再到掌握上下文、读万卷书，最后变得既聪明又会沟通，甚至还能看懂图片听懂声音。这个进步是不是超快的？</p>
<hr>
<h2 id="1-2-大模型（LLM）都能帮我们干啥？"><a href="#1-2-大模型（LLM）都能帮我们干啥？" class="headerlink" title="1.2 大模型（LLM）都能帮我们干啥？"></a><strong>1.2 大模型（LLM）都能帮我们干啥？</strong></h2><p>了解了大模型有多牛，那它具体能用在哪些地方呢？其实，它的应用已经悄悄进入我们生活的方方面面了：</p>
<ol>
<li><p><strong>写作小能手：</strong></p>
<ul>
<li><p><strong>能干啥？</strong> 帮你写邮件、写报告、写广告文案、写博客文章，甚至写小说、诗歌、歌词。卡壳了？让它给你出点子！</p>
</li>
<li><p><strong>好处？</strong> 省时省力，还能激发你的灵感。</p>
</li>
</ul>
</li>
<li><p><strong>万事通问答机：</strong></p>
<ul>
<li><p><strong>能干啥？</strong> 像个超级聪明的百科全书，你问啥它都能尽量回答，不管是历史知识、科学原理，还是生活小常识。</p>
</li>
<li><p><strong>好处？</strong> 找答案更直接方便，不用在一堆搜索结果里翻找了。</p>
</li>
</ul>
</li>
<li><p><strong>长文”总结”器 + 信息”挖掘”机：</strong></p>
<ul>
<li><p><strong>能干啥？</strong> 一篇几万字的研究报告或者长篇新闻，让它几句话给你总结出重点。还能从一大段文字里，自动找出人名、地名、关键信息等。</p>
</li>
<li><p><strong>好处？</strong> 快速了解核心内容，处理信息效率暴增。</p>
</li>
</ul>
</li>
<li><p><strong>随身翻译官：</strong></p>
<ul>
<li><p><strong>能干啥？</strong> 高质量地翻译各种语言，看外国电影、读外文资料、和外国朋友交流，都不再是难事。</p>
</li>
<li><p><strong>好处？</strong> 打破语言隔阂，世界瞬间变小了。</p>
</li>
</ul>
</li>
<li><p><strong>编程助手：</strong></p>
<ul>
<li><p><strong>能干啥？</strong> 你用大白话告诉它想实现什么功能，它能帮你写出代码！还能帮你检查代码错误、解释代码逻辑。</p>
</li>
<li><p><strong>好处？</strong> 让编程更快更容易，对新手也更友好。</p>
</li>
</ul>
</li>
<li><p><strong>“读心术”大师（情感分析）：</strong></p>
<ul>
<li><p><strong>能干啥？</strong> 分析一大堆用户评论或社交媒体帖子，告诉你大家对某个产品或话题是喜欢（好评）还是讨厌（差评）。</p>
</li>
<li><p><strong>好处？</strong> 帮商家了解用户心声，改进产品。</p>
</li>
</ul>
</li>
<li><p><strong>24 小时在线家教：</strong></p>
<ul>
<li><p><strong>能干啥？</strong> 给孩子辅导作业、解答疑问、生成练习题，甚至还能批改作文。</p>
</li>
<li><p><strong>好处？</strong> 提供个性化的学习帮助，随时随地都能学。</p>
</li>
</ul>
</li>
<li><p><strong>更聪明的聊天伙伴/客服：</strong></p>
<ul>
<li><p><strong>能干啥？</strong> 让手机里的语音助手、银行的在线客服、各种 APP 里的聊天机器人，变得更智能、更会聊天、更能解决问题。</p>
</li>
<li><p><strong>好处？</strong> 交互体验更好，解决问题更高效。</p>
</li>
</ul>
</li>
</ol>
<p><strong>简单总结一下：</strong> 大模型就像一个”瑞士军刀”，在处理和语言文字相关的任务上，几乎无所不能。它正在成为各行各业提高效率、创造新可能的强大工具。</p>
<hr>
<h2 id="1-3-大模型如何理解文字与存储知识？"><a href="#1-3-大模型如何理解文字与存储知识？" class="headerlink" title="1.3 大模型如何理解文字与存储知识？"></a><strong>1.3 大模型如何理解文字与存储知识？</strong></h2><p>那么大模型到底是怎么”理解”人类语言，又是怎么”记住”那么多知识的？下面我们简单拆解一下大模型的”大脑构造”：</p>
<ol>
<li><p><strong>文字到数字的转换：分词与词表</strong></p>
<ul>
<li><p><strong>词表是什么？</strong> 想象一本超级大的”词典”，里面收录了几万个常用词、子词甚至单个字符，每个都有一个唯一的编号（ID）。这就是”词表”！</p>
</li>
<li><p><strong>怎么用？</strong> 当你输入”我喜欢吃苹果”，大模型会先把它拆成几个片段（比如”我”、”喜欢”、”吃”、”苹果”），然后查词表找到每个片段的编号。</p>
</li>
<li><p><strong>聪明之处？</strong> 即使是词表里没有的新词，也能拆成更小的片段来处理。比如”区块链”可能会被拆成”区”、”块”、”链”。</p>
</li>
</ul>
</li>
<li><p><strong>数字变成向量：词嵌入</strong></p>
<ul>
<li><p><strong>词嵌入是啥？</strong> 每个词的编号会对应一组数字（比如 768 个、1600 个甚至更多），这些数字像是词语在”意义空间”中的坐标。</p>
</li>
<li><p><strong>像啥？</strong> 可以想象一个超级复杂的地图，意思相近的词（如”开心”和”高兴”）在地图上的位置就很接近，意思相反的词（如”热”和”冷”）则距离较远。</p>
</li>
<li><p><strong>怎么产生的？</strong> 一开始这些坐标是随机的，就像把所有词随机扔到空间里。通过大量阅读和训练，模型慢慢调整每个词的位置，让它们的相对位置能反映出词义关系。</p>
</li>
</ul>
</li>
<li><p><strong>储存全世界的知识：参数</strong></p>
<ul>
<li><p><strong>参数究竟是啥？</strong> 它们就是大模型的”记忆细胞”，是一大堆经过训练的数字，这些数字里”压缩”着模型学到的所有语言规律和知识。</p>
</li>
<li><p><strong>有多少参数？</strong> 现代大模型从几十亿到几千亿不等，比如 GPT-4 可能有上万亿参数！</p>
</li>
<li><p><strong>都包括啥？</strong> 参数包括词嵌入矩阵（每个词的向量）以及大量用于计算的神经网络权重。</p>
</li>
</ul>
</li>
<li><p><strong>理解句子的过程</strong></p>
<ul>
<li><p><strong>步骤 1：分词与查表</strong> - “今天天气真好” → [101, 3042, 899, 2420, 102]（假设的 ID）</p>
</li>
<li><p><strong>步骤 2：查找词向量</strong> - 每个 ID 都变成一组数字（向量）</p>
</li>
<li><p><strong>步骤 3：考虑上下文</strong> - 模型用”注意力机制”，让每个词都能看到句子中其他词，理解整体含义</p>
</li>
<li><p><strong>步骤 4：生成回复</strong> - 根据理解的含义，预测最合适的下一个词，组成完整回答</p>
</li>
</ul>
</li>
<li><p><strong>模型训练：数学公式+大量练习</strong></p>
<ul>
<li><p><strong>如何训练？</strong> 模型不断尝试”猜下一个词”的游戏，每猜错一次就调整参数，慢慢变得越来越准。</p>
</li>
<li><p><strong>为啥这么聪明？</strong> 在海量文本上重复这个过程，模型最终掌握了语言规律和世界知识。</p>
</li>
<li><p><strong>像啥？</strong> 就像一个学霸做了上亿道习题，大脑中形成了强大的”条件反射”，看到任何问题都能快速给出答案。</p>
</li>
</ul>
</li>
</ol>
<p><strong>简单总结一下：</strong> 大模型通过把词变成数字、数字变成向量、向量之间的计算和交互，最终实现了对人类语言的”理解”。它的”大脑”（参数）就像是把整个互联网的知识，通过复杂的数学方法，压缩存储在了一组精密的数字里。</p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>AI-02-Agent</title>
    <url>/posts/7755.html</url>
    <content><![CDATA[<p>Agent</p>
<a id="more"></a>

<h1 id="什么是Agent"><a href="#什么是Agent" class="headerlink" title="什么是Agent"></a>什么是Agent</h1><blockquote>
<p>具备推理能力，自主调用工具的助手</p>
</blockquote>
<p>sk-cpeahjwbdxjrhzlaxgonwsbcudtuojrrqflimekikwrmvuel</p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>26-Django-Channel</title>
    <url>/posts/15276.html</url>
    <content><![CDATA[<p>Django Channel</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WebSocket的应用场景：有的浏览器内嵌支持了，就可以用JS操作websocket. 有的浏览器没有内嵌</span><br><span class="line"></span><br><span class="line">  webshell</span><br><span class="line">  即时聊天通信，网站消息通知</span><br><span class="line">  在线协同编辑，如腾讯文档</span><br><span class="line">  多玩家在线游戏，视频弹幕，股票基金实施报价</span><br><span class="line"></span><br><span class="line">channel layer是一种通信系统，允许多个consumer实例之间互相通信，以及与外部Django程序实现互通。</span><br></pre></td></tr></table></figure>

<p>MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket">https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket</a></p>
<p><strong>WebSocket是什么？</strong></p>
<p>WebSocket是一种在单个TCP连接上进行全双工通讯的协议。WebSocket允许服务端主动向客户端推送数据。在WebSocket协议中，客户端浏览器和服务器只需要完成一次握手就可以创建持久性的连接，并在浏览器和服务器之间进行双向的数据传输。</p>
<p><strong>WebSocket有什么用？</strong></p>
<p>WebSocket区别于HTTP协议的一个最为显著的特点是，WebSocket协议可以由服务端主动发起消息，对于浏览器需要及时接收数据变化的场景非常适合，例如在Django中遇到一些耗时较长的任务我们通常会使用Celery来异步执行，那么浏览器如果想要获取这个任务的执行状态，在HTTP协议中只能通过轮训的方式由浏览器不断的发送请求给服务器来获取最新状态，这样发送很多无用的请求不仅浪费资源，还不够优雅，如果使用WebSokcet来实现就很完美了</p>
<p>WebSocket的另外一个应用场景就是下文要说的聊天室，一个用户（浏览器）发送的消息需要实时的让其他用户（浏览器）接收，这在HTTP协议下是很难实现的，但WebSocket基于长连接加上可以主动给浏览器发消息的特性处理起来就游刃有余了</p>
<p>初步了解WebSocket之后，我们看看如何在Django中实现WebSocket</p>
<h1 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h1><p>Django本身不支持WebSocket，但可以通过集成Channels框架来实现WebSocket<br>Channels是针对Django项目的一个增强框架，可以使Django不仅支持HTTP协议，还能支持WebSocket，MQTT等多种协议，同时Channels还整合了Django的auth以及session系统方便进行用户管理及认证。</p>
<ol>
<li>channels文件和配置的含义</li>
</ol>
<p><strong>asgi.py</strong>：异步网关接口，能够处理多种通用协议类型，包括HTTP、HTTP2和WebSocket<br><strong>channel_layers</strong>：在settings.py中配置。类似于一个通道，发送者(producer)在一段发送消息，消费者(consumer)在另一端进行监听<br><strong>routings.py</strong>：相当于Django中的urls.py<br><strong>consumers.py</strong>：相当于Django中的views.py</p>
<ol start="2">
<li>channels文档链接</li>
</ol>
<p><a href="https://channels.readthedocs.io/en/latest/introduction.html">https://channels.readthedocs.io/en/latest/introduction.html</a></p>
<ol start="3">
<li>WSGI和ASGI不同</li>
</ol>
<p>WSGI(Python Web Server Gateway Interface)：为Python语言定义的Web服务器和Web应用程序或者框架之间的一种简单而通用的接口。</p>
<p>ASGI(Asynchronous Web Server Gateway Interface)：异步网关协议接口，一个介于网络协议服务和Python应用之间的标准接口，能够处理多种通用的协议类型，包括HTTP，HTTP2和WebSocket。</p>
<p>我下文所有的代码实现使用以下python和Django版本</p>
<ul>
<li>python==3.6.3</li>
<li>django==2.2</li>
</ul>
<h2 id="集成Channels"><a href="#集成Channels" class="headerlink" title="集成Channels"></a>集成Channels</h2><p>我假设你已经新建了一个django项目，项目名字就叫<code>webapp</code>，目录结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">project</span><br><span class="line">    - webapp</span><br><span class="line">        - __init__.py</span><br><span class="line">        - settings.py</span><br><span class="line">        - urls.py</span><br><span class="line">        - wsgi.py</span><br><span class="line">    - manage.py</span><br></pre></td></tr></table></figure>

<ol>
<li>安装channels</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install channels&#x3D;&#x3D;2.1.7</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改settings.py文件，</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># APPS中添加channels</span><br><span class="line">INSTALLED_APPS &#x3D; [</span><br><span class="line">    &#39;django.contrib.staticfiles&#39;,</span><br><span class="line">    &#39;channels&#39;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 指定ASGI的路由地址</span><br><span class="line">ASGI_APPLICATION &#x3D; &#39;webapp.routing.application&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>channels运行于ASGI协议上，ASGI的全名是Asynchronous Server Gateway Interface。它是区别于Django使用的WSGI协议 的一种异步服务网关接口协议，正是因为它才实现了websocket</p>
<p><strong>ASGI_APPLICATION</strong> 指定主路由的位置为webapp下的routing.py文件中的application</p>
<ol start="3">
<li>setting.py的同级目录下创建routing.py路由文件，routing.py类似于Django中的url.py指明websocket协议的路由</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from channels.routing import ProtocolTypeRouter</span><br><span class="line"></span><br><span class="line">application &#x3D; ProtocolTypeRouter(&#123;</span><br><span class="line">    # 暂时为空，下文填充</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>运行Django项目</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\python36\python.exe D:&#x2F;demo&#x2F;tailf&#x2F;manage.py runserver 0.0.0.0:80</span><br><span class="line">Performing system checks...</span><br><span class="line">Watching for file changes with StatReloader</span><br><span class="line"></span><br><span class="line">System check identified no issues (0 silenced).</span><br><span class="line">April 12, 2019 - 17:44:52</span><br><span class="line">Django version 2.2, using settings &#39;webapp.settings&#39;</span><br><span class="line">Starting ASGI&#x2F;Channels version 2.1.7 development server at http:&#x2F;&#x2F;0.0.0.0:80&#x2F;</span><br><span class="line">Quit the server with CTRL-BREAK.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>仔细观察上边的输出会发现Django启动中的<code>Starting development server</code>已经变成了<code>Starting ASGI/Channels version 2.1.7 development server</code>，这表明项目已经由django使用的WSGI协议转换为了Channels使用的ASGI协议</p>
<p>至此Django已经基本集成了Channels框架</p>
<h2 id="构建聊天室"><a href="#构建聊天室" class="headerlink" title="构建聊天室"></a>构建聊天室</h2><p>上边虽然在项目中集成了Channels，但并没有任何的应用使用它，接下来我们以聊天室的例子来讲解Channels的使用</p>
<p>假设你已经创建好了一个叫chat的app，并添加到了settings.py的INSTALLED_APPS中，app的目录结构大概如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chat</span><br><span class="line">    - migrations</span><br><span class="line">        - __init__.py</span><br><span class="line">    - __init__.py</span><br><span class="line">    - admin.py</span><br><span class="line">    - apps.py</span><br><span class="line">    - models.py</span><br><span class="line">    - tests.py</span><br><span class="line">    - views.py</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>我们构建一个标准的Django聊天页面，相关代码如下</p>
<p>url:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.urls import path</span><br><span class="line">from chat.views import chat</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    path(&#39;chat&#39;, chat, name&#x3D;&#39;chat-url&#39;)</span><br><span class="line">]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>view:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render</span><br><span class="line"></span><br><span class="line">def chat(request):</span><br><span class="line">    return render(request, &#39;chat&#x2F;index.html&#39;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>template:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">  &lt;textarea class&#x3D;&quot;form-control&quot; id&#x3D;&quot;chat-log&quot; disabled rows&#x3D;&quot;20&quot;&gt;&lt;&#x2F;textarea&gt;&lt;br&#x2F;&gt;</span><br><span class="line">  &lt;input class&#x3D;&quot;form-control&quot; id&#x3D;&quot;chat-message-input&quot; type&#x3D;&quot;text&quot;&#x2F;&gt;&lt;br&#x2F;&gt;</span><br><span class="line">  &lt;input class&#x3D;&quot;btn btn-success btn-block&quot; id&#x3D;&quot;chat-message-submit&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;Send&quot;&#x2F;&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>通过上边的代码一个简单的web聊天页面构建完成了，访问页面大概样子如下：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/17/16a28e3061f80bd8~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<p>接下来我们利用Channels的WebSocket协议实现消息的发送接收功能</p>
<ol>
<li>先从路由入手，上边我们已经创建了routing.py路由文件，现在来填充里边的内容</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from channels.auth import AuthMiddlewareStack</span><br><span class="line">from channels.routing import ProtocolTypeRouter, URLRouter</span><br><span class="line">import chat.routing</span><br><span class="line"></span><br><span class="line">application &#x3D; ProtocolTypeRouter(&#123;</span><br><span class="line">    &#39;websocket&#39;: AuthMiddlewareStack(</span><br><span class="line">        URLRouter(</span><br><span class="line">            chat.routing.websocket_urlpatterns</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>ProtocolTypeRouter：</strong> ASIG支持多种不同的协议，在这里可以指定特定协议的路由信息，我们只使用了websocket协议，这里只配置websocket即可</p>
<p><strong>AuthMiddlewareStack：</strong> django的channels封装了django的auth模块，使用这个配置我们就可以在consumer中通过下边的代码获取到用户的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def connect(self):</span><br><span class="line">    self.user &#x3D; self.scope[&quot;user&quot;]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>self.scope</code>类似于django中的request，包含了请求的type、path、header、cookie、session、user等等有用的信息</p>
<p><strong>URLRouter：</strong> 指定路由文件的路径，也可以直接将路由信息写在这里，代码中配置了路由文件的路径，会去chat下的routeing.py文件中查找websocket_urlpatterns，<code>chat/routing.py</code>内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.urls import path</span><br><span class="line">from chat.consumers import ChatConsumer</span><br><span class="line"></span><br><span class="line">websocket_urlpatterns &#x3D; [</span><br><span class="line">    path(&#39;ws&#x2F;chat&#x2F;&#39;, ChatConsumer),</span><br><span class="line">]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>routing.py路由文件跟django的url.py功能类似，语法也一样，意思就是访问<code>ws/chat/</code>都交给<code>ChatConsumer</code>处理</p>
<ol>
<li>接着编写consumer，consumer类似django中的view，内容如下</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from channels.generic.websocket import WebsocketConsumer</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">class ChatConsumer(WebsocketConsumer):</span><br><span class="line">    def connect(self):</span><br><span class="line">        self.accept()</span><br><span class="line"></span><br><span class="line">    def disconnect(self, close_code):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def receive(self, text_data):</span><br><span class="line">        text_data_json &#x3D; json.loads(text_data)</span><br><span class="line">        message &#x3D; &#39;运维咖啡吧：&#39; + text_data_json[&#39;message&#39;]</span><br><span class="line"></span><br><span class="line">        self.send(text_data&#x3D;json.dumps(&#123;</span><br><span class="line">            &#39;message&#39;: message</span><br><span class="line">        &#125;))</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这里是个最简单的同步websocket consumer类，connect方法在连接建立时触发，disconnect在连接关闭时触发，receive方法会在收到消息后触发。整个ChatConsumer类会将所有收到的消息加上“运维咖啡吧：”的前缀发送给客户端</p>
<ol>
<li>最后我们在html模板页面添加websocket支持</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">  &lt;textarea class&#x3D;&quot;form-control&quot; id&#x3D;&quot;chat-log&quot; disabled rows&#x3D;&quot;20&quot;&gt;&lt;&#x2F;textarea&gt;&lt;br&#x2F;&gt;</span><br><span class="line">  &lt;input class&#x3D;&quot;form-control&quot; id&#x3D;&quot;chat-message-input&quot; type&#x3D;&quot;text&quot;&#x2F;&gt;&lt;br&#x2F;&gt;</span><br><span class="line">  &lt;input class&#x3D;&quot;btn btn-success btn-block&quot; id&#x3D;&quot;chat-message-submit&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;Send&quot;&#x2F;&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block js %&#125;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var chatSocket &#x3D; new WebSocket(</span><br><span class="line">    &#39;ws:&#x2F;&#x2F;&#39; + window.location.host + &#39;&#x2F;ws&#x2F;chat&#x2F;&#39;);</span><br><span class="line"></span><br><span class="line">  chatSocket.onmessage &#x3D; function(e) &#123;</span><br><span class="line">    var data &#x3D; JSON.parse(e.data);</span><br><span class="line">    var message &#x3D; data[&#39;message&#39;];</span><br><span class="line">    document.querySelector(&#39;#chat-log&#39;).value +&#x3D; (message + &#39;\n&#39;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  chatSocket.onclose &#x3D; function(e) &#123;</span><br><span class="line">    console.error(&#39;Chat socket closed unexpectedly&#39;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  document.querySelector(&#39;#chat-message-input&#39;).focus();</span><br><span class="line">  document.querySelector(&#39;#chat-message-input&#39;).onkeyup &#x3D; function(e) &#123;</span><br><span class="line">    if (e.keyCode &#x3D;&#x3D;&#x3D; 13) &#123;  &#x2F;&#x2F; enter, return</span><br><span class="line">        document.querySelector(&#39;#chat-message-submit&#39;).click();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  document.querySelector(&#39;#chat-message-submit&#39;).onclick &#x3D; function(e) &#123;</span><br><span class="line">    var messageInputDom &#x3D; document.querySelector(&#39;#chat-message-input&#39;);</span><br><span class="line">    var message &#x3D; messageInputDom.value;</span><br><span class="line">    chatSocket.send(JSON.stringify(&#123;</span><br><span class="line">        &#39;message&#39;: message</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    messageInputDom.value &#x3D; &#39;&#39;;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>WebSocket对象一个支持四个消息：onopen，onmessage，oncluse和onerror，我们这里用了两个onmessage和onclose</p>
<p><strong>onopen：</strong> 当浏览器和websocket服务端连接成功后会触发onopen消息</p>
<p><strong>onerror：</strong> 如果连接失败，或者发送、接收数据失败，或者数据处理出错都会触发onerror消息</p>
<p><strong>onmessage：</strong> 当浏览器接收到websocket服务器发送过来的数据时，就会触发onmessage消息，参数<code>e</code>包含了服务端发送过来的数据</p>
<p><strong>onclose：</strong> 当浏览器接收到websocket服务器发送过来的关闭连接请求时，会触发onclose消息</p>
<ol>
<li>完成前边的代码，一个可以聊天的websocket页面就完成了，运行项目，在浏览器中输入消息就会通过websocket–&gt;rouging.py–&gt;consumer.py处理后返回给前端</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/16a28e306251dfa5~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<h2 id="启用Channel-Layer"><a href="#启用Channel-Layer" class="headerlink" title="启用Channel Layer"></a>启用Channel Layer</h2><p>上边的例子我们已经实现了消息的发送和接收，但既然是聊天室，肯定要支持多人同时聊天的，当我们打开多个浏览器分别输入消息后发现只有自己收到消息，其他浏览器端收不到，如何解决这个问题，让所有客户端都能一起聊天呢？</p>
<p>Channels引入了一个layer的概念，channel layer是一种通信系统，允许多个consumer实例之间互相通信，以及与外部Djanbo程序实现互通。</p>
<p>channel layer主要实现了两种概念抽象：</p>
<p><strong>channel name：</strong> channel实际上就是一个发送消息的通道，每个Channel都有一个名称，每一个拥有这个名称的人都可以往Channel里边发送消息</p>
<p><strong>group：</strong> 多个channel可以组成一个Group，每个Group都有一个名称，每一个拥有这个名称的人都可以往Group里添加/删除Channel，也可以往Group里发送消息，Group内的所有channel都可以收到，但是无法发送给Group内的具体某个Channel</p>
<p>了解了上边的概念，接下来我们利用channel layer实现真正的聊天室，能够让多个客户端发送的消息被彼此看到</p>
<ol>
<li>官方推荐使用redis作为channel layer，所以先安装channels_redis</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install channels_redis&#x3D;&#x3D;2.3.3</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然后修改settings.py添加对layer的支持</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CHANNEL_LAYERS &#x3D; &#123;</span><br><span class="line">    &#39;default&#39;: &#123;</span><br><span class="line">        &#39;BACKEND&#39;: &#39;channels_redis.core.RedisChannelLayer&#39;,</span><br><span class="line">        &#39;CONFIG&#39;: &#123;</span><br><span class="line">            &quot;hosts&quot;: [(&#39;ops-coffee.cn&#39;, 6379)],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>添加channel之后我们可以通过以下命令检查通道层是否能够正常工作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;python manage.py shell</span><br><span class="line">Python 3.6.3 (v3.6.3:2c5fed8, Oct  3 2017, 18:11:49) [MSC v.1900 64 bit (AMD64)] on win32</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">(InteractiveConsole)</span><br><span class="line">&gt;&gt;&gt; import channels.layers</span><br><span class="line">&gt;&gt;&gt; channel_layer &#x3D; channels.layers.get_channel_layer()</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; from asgiref.sync import async_to_sync</span><br><span class="line">&gt;&gt;&gt; async_to_sync(channel_layer.send)(&#39;test_channel&#39;,&#123;&#39;site&#39;:&#39;https:&#x2F;&#x2F;ops-coffee.cn&#39;&#125;)</span><br><span class="line">&gt;&gt;&gt; async_to_sync(channel_layer.receive)(&#39;test_channel&#39;)</span><br><span class="line">&#123;&#39;site&#39;: &#39;https:&#x2F;&#x2F;ops-coffee.cn&#39;&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>consumer做如下修改引入channel layer</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from asgiref.sync import async_to_sync</span><br><span class="line">from channels.generic.websocket import WebsocketConsumer</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">class ChatConsumer(WebsocketConsumer):</span><br><span class="line">    def connect(self):</span><br><span class="line">        self.room_group_name &#x3D; &#39;ops_coffee&#39;</span><br><span class="line"></span><br><span class="line">        # Join room group</span><br><span class="line">        async_to_sync(self.channel_layer.group_add)(</span><br><span class="line">            self.room_group_name,</span><br><span class="line">            self.channel_name</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.accept()</span><br><span class="line"></span><br><span class="line">    def disconnect(self, close_code):</span><br><span class="line">        # Leave room group</span><br><span class="line">        async_to_sync(self.channel_layer.group_discard)(</span><br><span class="line">            self.room_group_name,</span><br><span class="line">            self.channel_name</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    # Receive message from WebSocket</span><br><span class="line">    def receive(self, text_data):</span><br><span class="line">        text_data_json &#x3D; json.loads(text_data)</span><br><span class="line">        message &#x3D; text_data_json[&#39;message&#39;]</span><br><span class="line"></span><br><span class="line">        # Send message to room group</span><br><span class="line">        async_to_sync(self.channel_layer.group_send)(</span><br><span class="line">            self.room_group_name,</span><br><span class="line">            &#123;</span><br><span class="line">                &#39;type&#39;: &#39;chat_message&#39;,</span><br><span class="line">                &#39;message&#39;: message</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    # Receive message from room group</span><br><span class="line">    def chat_message(self, event):</span><br><span class="line">        message &#x3D; &#39;运维咖啡吧：&#39; + event[&#39;message&#39;]</span><br><span class="line"></span><br><span class="line">        # Send message to WebSocket</span><br><span class="line">        self.send(text_data&#x3D;json.dumps(&#123;</span><br><span class="line">            &#39;message&#39;: message</span><br><span class="line">        &#125;))</span><br></pre></td></tr></table></figure>

<p>这里我们设置了一个固定的房间名作为Group name，所有的消息都会发送到这个Group里边，当然你也可以通过参数的方式将房间名传进来作为Group name，从而建立多个Group，这样可以实现仅同房间内的消息互通</p>
<p>当我们启用了channel layer之后，所有与consumer之间的通信将会变成异步的，所以必须使用<code>async_to_sync</code></p>
<p>一个链接（channel）创建时，通过<code>group_add</code>将channel添加到Group中，链接关闭通过<code>group_discard</code>将channel从Group中剔除，收到消息时可以调用<code>group_send</code>方法将消息发送到Group，这个Group内所有的channel都可以收的到</p>
<p><code>group_send</code>中的type指定了消息处理的函数，这里会将消息转给<code>chat_message</code>函数去处理</p>
<ol>
<li>经过以上的修改，我们再次在多个浏览器上打开聊天页面输入消息，发现彼此已经能够看到了，至此一个完整的聊天室已经基本完成</li>
</ol>
<h2 id="修改为异步"><a href="#修改为异步" class="headerlink" title="修改为异步"></a>修改为异步</h2><p>我们前边实现的consumer是同步的，为了能有更好的性能，官方支持异步的写法，只需要修改consumer.py即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from channels.generic.websocket import AsyncWebsocketConsumer</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">class ChatConsumer(AsyncWebsocketConsumer):</span><br><span class="line">    async def connect(self):</span><br><span class="line">        self.room_group_name &#x3D; &#39;ops_coffee&#39;</span><br><span class="line"></span><br><span class="line">        # Join room group</span><br><span class="line">        await self.channel_layer.group_add(</span><br><span class="line">            self.room_group_name,</span><br><span class="line">            self.channel_name</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        await self.accept()</span><br><span class="line"></span><br><span class="line">    async def disconnect(self, close_code):</span><br><span class="line">        # Leave room group</span><br><span class="line">        await self.channel_layer.group_discard(</span><br><span class="line">            self.room_group_name,</span><br><span class="line">            self.channel_name</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    # Receive message from WebSocket</span><br><span class="line">    async def receive(self, text_data):</span><br><span class="line">        text_data_json &#x3D; json.loads(text_data)</span><br><span class="line">        message &#x3D; text_data_json[&#39;message&#39;]</span><br><span class="line"></span><br><span class="line">        # Send message to room group</span><br><span class="line">        await self.channel_layer.group_send(</span><br><span class="line">            self.room_group_name,</span><br><span class="line">            &#123;</span><br><span class="line">                &#39;type&#39;: &#39;chat_message&#39;,</span><br><span class="line">                &#39;message&#39;: message</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    # Receive message from room group</span><br><span class="line">    async def chat_message(self, event):</span><br><span class="line">        message &#x3D; &#39;运维咖啡吧：&#39; + event[&#39;message&#39;]</span><br><span class="line"></span><br><span class="line">        # Send message to WebSocket</span><br><span class="line">        await self.send(text_data&#x3D;json.dumps(&#123;</span><br><span class="line">            &#39;message&#39;: message</span><br><span class="line">        &#125;))</span><br></pre></td></tr></table></figure>

<p>其实异步的代码跟之前的差别不大，只有几个小区别：</p>
<p>ChatConsumer由<code>WebsocketConsumer</code>修改为了<code>AsyncWebsocketConsumer</code></p>
<p>所有的方法都修改为了异步def<code>async def</code></p>
<p>用<code>await</code>来实现异步I/O的调用</p>
<p>channel layer也不再需要使用<code>async_to_sync</code>了</p>
<p>好了，现在一个完全异步且功能完整的聊天室已经构建完成了</p>
<p>先说下我们要实现的目标：所有登录的用户可以查看tailf日志页面，在页面上能够选择日志文件进行监听，多个页面终端同时监听任何日志都互不影响，页面同时提供终止监听的按钮能够终止前端的输出以及后台对日志文件的读取</p>
<p>最终实现的结果见下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/20190419.channels.2.gif" alt="img"></p>
<p>接着我们来看下具体的实现过程</p>
<h1 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h1><p>所有代码均基于以下软件版本： - python==3.6.3 - django==2.2 - channels==2.1.7 - celery==4.3.0</p>
<p>celery4在windows下支持不完善，所以请<strong>在linux下运行</strong>测试</p>
<h2 id="日志数据定义"><a href="#日志数据定义" class="headerlink" title="日志数据定义"></a>日志数据定义</h2><p>我们只希望用户能够查询固定的几个日志文件，就不是用数据库仅借助settings.py文件里写全局变量来实现数据存储</p>
<p>在settings.py里添加一个叫<code>TAILF</code>的变量，类型为字典，key标识文件的编号，value标识文件的路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TAILF &#x3D; &#123;</span><br><span class="line">    1: &#39;&#x2F;ops&#x2F;coffee&#x2F;error.log&#39;,</span><br><span class="line">    2: &#39;&#x2F;ops&#x2F;coffee&#x2F;access.log&#39;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基础Web页面搭建"><a href="#基础Web页面搭建" class="headerlink" title="基础Web页面搭建"></a>基础Web页面搭建</h2><p>假设你已经创建好了一个叫tailf的app，并添加到了settings.py的INSTALLED_APPS中，app的目录结构大概如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tailf</span><br><span class="line">    - migrations</span><br><span class="line">        - __init__.py</span><br><span class="line">    - __init__.py</span><br><span class="line">    - admin.py</span><br><span class="line">    - apps.py</span><br><span class="line">    - models.py</span><br><span class="line">    - tests.py</span><br><span class="line">    - views.py</span><br></pre></td></tr></table></figure>

<p>依然先构建一个标准的Django页面，相关代码如下</p>
<p>url:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.urls import path</span><br><span class="line">from django.contrib.auth.views import LoginView,LogoutView</span><br><span class="line"></span><br><span class="line">from tailf.views import tailf</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    path(&#39;tailf&#39;, tailf, name&#x3D;&#39;tailf-url&#39;),</span><br><span class="line"></span><br><span class="line">    path(&#39;login&#39;, LoginView.as_view(template_name&#x3D;&#39;login.html&#39;), name&#x3D;&#39;login-url&#39;),</span><br><span class="line">    path(&#39;logout&#39;, LogoutView.as_view(template_name&#x3D;&#39;login.html&#39;), name&#x3D;&#39;logout-url&#39;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>因为我们规定只有通过登录的用户才能查看日志，所以引入Django自带的LoginView，logoutView帮助我们快速构建Login，Logout功能</p>
<p>指定了登录模板使用<code>login.html</code>，它就是一个标准的登录页面，post传入username和password两个参数即可，不贴代码了</p>
<p>view:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf import settings</span><br><span class="line">from django.shortcuts import render</span><br><span class="line">from django.contrib.auth.decorators import login_required</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Create your views here.</span><br><span class="line">@login_required(login_url&#x3D;&#39;&#x2F;login&#39;)</span><br><span class="line">def tailf(request):</span><br><span class="line">    logDict &#x3D; settings.TAILF</span><br><span class="line">    return render(request, &#39;tailf&#x2F;index.html&#39;, &#123;&quot;logDict&quot;: logDict&#125;)</span><br></pre></td></tr></table></figure>

<p>引入了<code>login_required</code>装饰器，来判断用户是否登录，未登录就给跳到<code>/login</code>登录页面</p>
<p><strong>logDict</strong> 去setting里取我们定义好的<code>TAILF</code>字典赋值，并传递给前端</p>
<p>template:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">&lt;div class&#x3D;&quot;col-sm-8&quot;&gt;</span><br><span class="line">  &lt;select class&#x3D;&quot;form-control&quot; id&#x3D;&quot;file&quot;&gt;</span><br><span class="line">    &lt;option value&#x3D;&quot;&quot;&gt;选择要监听的日志&lt;&#x2F;option&gt;</span><br><span class="line">    &#123;% for k,v in logDict.items %&#125;</span><br><span class="line">    &lt;option value&#x3D;&quot;&#123;&#123; k &#125;&#125;&quot;&gt;&#123;&#123; v &#125;&#125;&lt;&#x2F;option&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">  &lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;col-sm-2&quot;&gt;</span><br><span class="line">  &lt;input class&#x3D;&quot;btn btn-success btn-block&quot; type&#x3D;&quot;button&quot; onclick&#x3D;&quot;connect()&quot; value&#x3D;&quot;开始监听&quot;&#x2F;&gt;&lt;br&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;col-sm-2&quot;&gt;</span><br><span class="line">  &lt;input class&#x3D;&quot;btn btn-warning btn-block&quot; type&#x3D;&quot;button&quot; onclick&#x3D;&quot;goclose()&quot; value&#x3D;&quot;终止监听&quot;&#x2F;&gt;&lt;br&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;col-sm-12&quot;&gt;</span><br><span class="line">  &lt;textarea class&#x3D;&quot;form-control&quot; id&#x3D;&quot;chat-log&quot; disabled rows&#x3D;&quot;20&quot;&gt;&lt;&#x2F;textarea&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>前端拿到<code>TAILF</code>后通过循环的方式填充到select选择框下，因为数据是字典格式，使用<code>logDict.items</code>的方式可以循环出字典的key和value</p>
<p>这样一个日志监听页面就完成了，但还无法实现日志的监听，继续往下</p>
<h2 id="集成Channels实现WebSocket"><a href="#集成Channels实现WebSocket" class="headerlink" title="集成Channels实现WebSocket"></a>集成Channels实现WebSocket</h2><p>日志监听功能主要的设计思路就是页面跟后端服务器建立websocket长连接，后端通过celery异步执行while循环不断的读取日志文件然后发送到websocket的channel里，实现页面上的实时显示</p>
<p>接着我们来集成channels</p>
<ol>
<li>先添加routing路由，直接修改<code>webapp/routing.py</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from channels.auth import AuthMiddlewareStack</span><br><span class="line">from channels.routing import ProtocolTypeRouter, URLRouter</span><br><span class="line"></span><br><span class="line">from django.urls import path, re_path</span><br><span class="line">from chat.consumers import ChatConsumer</span><br><span class="line">from tailf.consumers import TailfConsumer</span><br><span class="line"></span><br><span class="line">application &#x3D; ProtocolTypeRouter(&#123;</span><br><span class="line">    &#39;websocket&#39;: AuthMiddlewareStack(</span><br><span class="line">        URLRouter([</span><br><span class="line">            path(&#39;ws&#x2F;chat&#x2F;&#39;, ChatConsumer),</span><br><span class="line">            re_path(r&#39;^ws&#x2F;tailf&#x2F;(?P&lt;id&gt;\d+)&#x2F;$&#39;, TailfConsumer),</span><br><span class="line">        ])</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>直接将路由信息写入到了<code>URLRouter</code>里，注意路由信息的外层多了一个list，区别于上一篇中介绍的写路由文件路径的方式</p>
<p>页面需要将监听的日志文件传递给后端，我们使用routing正则<code>P&lt;id&gt;\d+</code>传文件ID给后端程序，后端程序拿到ID之后根据settings中指定的<code>TAILF</code>解析出日志路径</p>
<p>routing的写法跟Django中的url写法完全一致，使用<code>re_path</code>匹配正则routing路由</p>
<ol>
<li>添加consumer在<code>tailf/consumers.py</code>文件中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line">from channels.generic.websocket import WebsocketConsumer</span><br><span class="line">from tailf.tasks import tailf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TailfConsumer(WebsocketConsumer):</span><br><span class="line">    def connect(self):</span><br><span class="line">        self.file_id &#x3D; self.scope[&quot;url_route&quot;][&quot;kwargs&quot;][&quot;id&quot;]</span><br><span class="line"></span><br><span class="line">        self.result &#x3D; tailf.delay(self.file_id, self.channel_name)</span><br><span class="line"></span><br><span class="line">        print(&#39;connect:&#39;, self.channel_name, self.result.id)</span><br><span class="line">        self.accept()</span><br><span class="line"></span><br><span class="line">    def disconnect(self, close_code):</span><br><span class="line">        # 中止执行中的Task</span><br><span class="line">        self.result.revoke(terminate&#x3D;True)</span><br><span class="line">        print(&#39;disconnect:&#39;, self.file_id, self.channel_name)</span><br><span class="line"></span><br><span class="line">    def send_message(self, event):</span><br><span class="line">        self.send(text_data&#x3D;json.dumps(&#123;</span><br><span class="line">            &quot;message&quot;: event[&quot;message&quot;]</span><br><span class="line">        &#125;))</span><br></pre></td></tr></table></figure>

<p>这里使用Channels的单通道模式，每一个新连接都会启用一个新的channel，彼此互不影响，可以随意终止任何一个监听日志的请求</p>
<p><strong>connect</strong></p>
<p>我们知道<code>self.scope</code>类似于Django中的request，记录了丰富的请求信息，通过<code>self.scope[&quot;url_route&quot;][&quot;kwargs&quot;][&quot;id&quot;]</code>取出routing中正则匹配的日志ID</p>
<p>然后将<code>id</code>和<code>channel_name</code>传递给celery的任务函数tailf，tailf根据<code>id</code>取到日志文件的路径，然后循环文件，将新内容根据<code>channel_name</code>写入对应channel</p>
<p><strong>disconnect</strong></p>
<p>当websocket连接断开的时候我们需要终止Celery的Task执行，以清除celery的资源占用</p>
<p>终止Celery任务使用到<code>revoke</code>指令，采用如下代码来实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.result.revoke(terminate&#x3D;True)</span><br></pre></td></tr></table></figure>

<p>注意<code>self.result</code>是一个result对象，而非id</p>
<p>参数<code>terminate=True</code>的意思是是否立即终止Task，为True时无论Task是否正在执行都立即终止，为False（默认）时需要等待Task运行结束之后才会终止，我们使用了While循环不设置为True就永远不会终止了</p>
<p>终止Celery任务的另外一种方法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from webapp.celery import app</span><br><span class="line">app.control.revoke(result.id, terminate&#x3D;True)</span><br></pre></td></tr></table></figure>

<p><strong>send_message</strong></p>
<p>方便我们通过Django的view或者Celery的task调用给channel发送消息，官方也比较推荐这种方式</p>
<h2 id="使用Celery异步循环读取日志"><a href="#使用Celery异步循环读取日志" class="headerlink" title="使用Celery异步循环读取日志"></a>使用Celery异步循环读取日志</h2><p>上边已经集成了Channels实现了WebSocket，但connect函数中的celery任务<code>tailf</code>还没有实现，下边来实现它</p>
<p>关于Celery的详细内容可以看这篇文章：<a href="https://ops-coffee.cn/s/lXrp3igYo9W2UuE5Gauysg">《Django配置Celery执行异步任务和定时任务》</a>，本文就不介绍集成使用以及细节原理，只讲一下任务task</p>
<p>task实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from __future__ import absolute_import</span><br><span class="line">from celery import shared_task</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line">from channels.layers import get_channel_layer</span><br><span class="line">from asgiref.sync import async_to_sync</span><br><span class="line">from django.conf import settings</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@shared_task</span><br><span class="line">def tailf(id, channel_name):</span><br><span class="line">    channel_layer &#x3D; get_channel_layer()</span><br><span class="line">    filename &#x3D; settings.TAILF[int(id)]</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        with open(filename) as f:</span><br><span class="line">            f.seek(0, 2)</span><br><span class="line"></span><br><span class="line">            while True:</span><br><span class="line">                line &#x3D; f.readline()</span><br><span class="line"></span><br><span class="line">                if line:</span><br><span class="line">                    print(channel_name, line)</span><br><span class="line">                    async_to_sync(channel_layer.send)(</span><br><span class="line">                        channel_name,</span><br><span class="line">                        &#123;</span><br><span class="line">                            &quot;type&quot;: &quot;send.message&quot;,</span><br><span class="line">                            &quot;message&quot;: &quot;微信公众号【运维咖啡吧】原创 版权所有 &quot; + str(line)</span><br><span class="line">                        &#125;</span><br><span class="line">                    )</span><br><span class="line">                else:</span><br><span class="line">                    time.sleep(0.5)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br></pre></td></tr></table></figure>

<p>这里边主要涉及到Channels中另一个非常重要的点：<strong>从Channels的外部发送消息给Channel</strong></p>
<p>其实<a href="https://ops-coffee.cn/s/hqaPrPS7w3D-9SeegQAB2Q">上篇文章</a>中检查通道层是否能够正常工作的时候使用的方法就是从外部给Channel通道发消息的示例，本文的具体代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async_to_sync(channel_layer.send)(</span><br><span class="line">    channel_name,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;type&quot;: &quot;send.message&quot;,</span><br><span class="line">        &quot;message&quot;: &quot;微信公众号【运维咖啡吧】原创 版权所有 &quot; + str(line)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>channel_name</strong> 对应于传递给这个任务的channel_name，发送消息给这个名字的channel</p>
<p><strong>type</strong> 对应于我们Channels的TailfConsumer类中的<code>send_message</code>方法，将方法中的<code>_</code>换成<code>.</code>即可</p>
<p><strong>message</strong> 就是要发送给这个channel的具体信息</p>
<p>上边是发送给单Channel的情况，如果是需要发送到Group的话需要使用如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async_to_sync(channel_layer.group_send)(</span><br><span class="line">    group_name,</span><br><span class="line">    &#123;</span><br><span class="line">        &#39;type&#39;: &#39;chat.message&#39;,</span><br><span class="line">        &#39;message&#39;: &#39;欢迎关注公众号【运维咖啡吧】&#39;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>只需要将发送单channel的<code>send</code>改为<code>group_send</code>，<code>channel_name</code>改为<code>group_name</code>即可</p>
<p>需要特别注意的是：<strong>使用了channel layer之后一定要通过async_to_sync来异步执行</strong></p>
<h2 id="页面添加WebSocket支持"><a href="#页面添加WebSocket支持" class="headerlink" title="页面添加WebSocket支持"></a>页面添加WebSocket支持</h2><p>后端功能都已经完成，我们最后需要添加前端页面支持WebSocket</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function connect() &#123;</span><br><span class="line">  if ( $(&#39;#file&#39;).val() ) &#123;</span><br><span class="line">    window.chatSocket &#x3D; new WebSocket(</span><br><span class="line">      &#39;ws:&#x2F;&#x2F;&#39; + window.location.host + &#39;&#x2F;ws&#x2F;tailf&#x2F;&#39; + $(&#39;#file&#39;).val() + &#39;&#x2F;&#39;);</span><br><span class="line"></span><br><span class="line">    chatSocket.onmessage &#x3D; function(e) &#123;</span><br><span class="line">      var data &#x3D; JSON.parse(e.data);</span><br><span class="line">      var message &#x3D; data[&#39;message&#39;];</span><br><span class="line">      document.querySelector(&#39;#chat-log&#39;).value +&#x3D; (message);</span><br><span class="line">      &#x2F;&#x2F; 跳转到页面底部</span><br><span class="line">      $(&#39;#chat-log&#39;).scrollTop($(&#39;#chat-log&#39;)[0].scrollHeight);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    chatSocket.onerror &#x3D; function(e) &#123;</span><br><span class="line">      toastr.error(&#39;服务端连接异常！&#39;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    chatSocket.onclose &#x3D; function(e) &#123;</span><br><span class="line">      toastr.error(&#39;websocket已关闭！&#39;)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    toastr.warning(&#39;请选择要监听的日志文件&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://ops-coffee.cn/s/hqaPrPS7w3D-9SeegQAB2Q">上一篇文章</a>中有详细介绍过websocket的消息类型，这里不多介绍了</p>
<p>至此我们一个日志监听页面完成了，包含了完整的监听功能，但还无法终止，接着看下面的内容</p>
<h2 id="Web页面主动断开WebSocket"><a href="#Web页面主动断开WebSocket" class="headerlink" title="Web页面主动断开WebSocket"></a>Web页面主动断开WebSocket</h2><p>web页面上“终止监听”按钮的主要逻辑就是触发WebSocket的onclose方法，从而可以触发Channels后端consumer的<code>disconnect</code>方法，进而终止Celery的循环读取日志任务</p>
<p>前端页面通过<code>.close()</code>可以直接触发WebSocket关闭，当然你如果直接关掉页面的话也会触发WebSocket的onclose消息，所以不用担心Celery任务无法结束的问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function goclose() &#123;</span><br><span class="line">  console.log(window.chatSocket);</span><br><span class="line"></span><br><span class="line">  window.chatSocket.close();</span><br><span class="line">  window.chatSocket.onclose &#x3D; function(e) &#123;</span><br><span class="line">    toastr.success(&#39;已终止日志监听！&#39;)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此我们包含完善功能的Tailf日志监听、终止页面就全部完成了</p>
<hr>
<p>演示效果如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-1b33d0229cb4ef59394edafe4c62114c_b.webp" alt="img"></p>
<p><strong>什么是websocket?</strong></p>
<p>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
<p>很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。Websocket能更好的节省服务器资源和带宽，并且能够更实时地进行通讯，早已成为一种非常流行必须掌握的技术。</p>
<p>以上关于websocket介绍来自菜鸟教程，更多内容见菜鸟教程(<a href="https://link.zhihu.com/?target=https://www.runoob.com/">菜鸟教程 - 学的不仅是技术，更是梦想！</a>)。现在就让我们步入正题吧，利用Django + channels实现websocket编写个在线聊天室，一共只有四步。跟着学，你也可以实现。</p>
<p><strong>第一步 准备工作</strong></p>
<p>首先在虚拟环境中安装django和channels(本项目使用了最新版本，均为3.X版本), 新建一个名为myproject的项目，新建一个app名为chat。如果windows下安装报错，如何解决自己网上去找吧。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pip install django==3.2.3</span><br><span class="line">pip install channels==3.0.3</span><br></pre></td></tr></table></figure>

<p><a href="https://link.zhihu.com/?target=http://xn--settings-0n3mm27o.py/">修改settings.py</a>, 将channels和chat加入到INSTALLED_APPS里，并添加相应配置，如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">      &#x27;django.contrib.admin&#x27;,</span><br><span class="line">      &#x27;django.contrib.auth&#x27;,</span><br><span class="line">      &#x27;django.contrib.contenttypes&#x27;,</span><br><span class="line">      &#x27;django.contrib.sessions&#x27;,</span><br><span class="line">      &#x27;django.contrib.messages&#x27;,</span><br><span class="line">      &#x27;django.contrib.staticfiles&#x27;,</span><br><span class="line">      &#x27;channels&#x27;, # channels应用</span><br><span class="line">      &#x27;chat&#x27;,   </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 设置ASGI应用</span><br><span class="line">ASGI_APPLICATION = &#x27;myproject.asgi.application&#x27;</span><br><span class="line"></span><br><span class="line"># 设置通道层的通信后台 - 本地测试用</span><br><span class="line">CHANNEL_LAYERS = &#123;</span><br><span class="line">    &quot;default&quot;: &#123;</span><br><span class="line">        &quot;BACKEND&quot;: &quot;channels.layers.InMemoryChannelLayer&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 ：本例为了简化代码，使用了InMemoryChannelLayer做通道层(channel_layer)的通信后台，实际生产环境中应该需要使用redis作为后台。这时你还需要安装redis和channels_redis，然后添加如下配置：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 生产环境中使用redis做后台，安装channels_redis</span><br><span class="line">CHANNEL_LAYERS = &#123;</span><br><span class="line">    &quot;default&quot;: &#123;</span><br><span class="line">        &quot;BACKEND&quot;: &quot;channels_redis.core.RedisChannelLayer&quot;,</span><br><span class="line">        &quot;CONFIG&quot;: &#123;</span><br><span class="line">            &quot;hosts&quot;: [(&quot;127.0.0.1&quot;, 6379)],</span><br><span class="line">             #或&quot;hosts&quot;: [os.environ.get(&#x27;REDIS_URL&#x27;, &#x27;redis://127.0.0.1:6379/1&#x27;)],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后将chat应用的urls.py加入到项目urls.py中去，这和常规Django项目无异。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># myproject/urls.py</span><br><span class="line"></span><br><span class="line">from django.conf.urls import include</span><br><span class="line">from django.urls import path</span><br><span class="line">from django.contrib import admin</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;chat/&#x27;, include(&#x27;chat.urls&#x27;)),</span><br><span class="line">    path(&#x27;admin/&#x27;, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>第二步 编写聊天室页面</strong></p>
<p>我们需要利用django普通视图函数编写两个页面，一个用于展示首页(index), 通过表单让用户输入聊天室的名称(room_name)，然后跳转到相应聊天室页面；一个页面用于实时展示聊天信息记录，并允许用户发送信息。</p>
<p>这两个页面对应的路由及视图函数如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># chat/urls.py</span><br><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;&#x27;, views.index, name=&#x27;index&#x27;),</span><br><span class="line">    path(&#x27;&lt;str:room_name&gt;/&#x27;, views.room, name=&#x27;room&#x27;),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># chat/views.py</span><br><span class="line">from django.shortcuts import render</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    return render(request, &#x27;chat/index.html&#x27;, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">def room(request, room_name):</span><br><span class="line">    return render(request, &#x27;chat/room.html&#x27;, &#123;</span><br><span class="line">        &#x27;room_name&#x27;: room_name</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>接下来我们编写两个模板文件index.html和room.html。它们的路径位置如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">chat/</span><br><span class="line">    __init__.py</span><br><span class="line">    templates/</span><br><span class="line">        chat/</span><br><span class="line">            index.html</span><br><span class="line">            room.html</span><br><span class="line">    urls.py</span><br><span class="line">    views.py</span><br></pre></td></tr></table></figure>

<p>index.html内容如下所示。它也基本不涉及websocket，就是让用户输入聊天室后进行跳转。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;!-- chat/templates/chat/index.html --&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;/&gt;</span><br><span class="line">    &lt;title&gt;Chat Rooms&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    请输入聊天室名称：</span><br><span class="line">    &lt;input id=&quot;room-name-input&quot; type=&quot;text&quot; size=&quot;100&quot;&gt;</span><br><span class="line">    &lt;input id=&quot;room-name-submit&quot; type=&quot;button&quot; value=&quot;Enter&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        document.querySelector(&#x27;#room-name-input&#x27;).focus();</span><br><span class="line">        document.querySelector(&#x27;#room-name-input&#x27;).onkeyup = function(e) &#123;</span><br><span class="line">            if (e.keyCode === 13) &#123;  // enter, return</span><br><span class="line">                document.querySelector(&#x27;#room-name-submit&#x27;).click();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        document.querySelector(&#x27;#room-name-submit&#x27;).onclick = function(e) &#123;</span><br><span class="line">            var roomName = document.querySelector(&#x27;#room-name-input&#x27;).value;</span><br><span class="line">            window.location.pathname = &#x27;/chat/&#x27; + roomName + &#x27;/&#x27;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>room.html内容如下所示。为了帮助你理解前后端是怎么实现websocket实时通信的，我给每行js代码添加了注释，这对于你理解前端如何发送websocket的请求，如果处理后端发过来的websocket消息至关重要。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"> &lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;/&gt;</span><br><span class="line">    &lt;title&gt;Chat Room&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;textarea id=&quot;chat-log&quot; cols=&quot;100&quot; rows=&quot;20&quot;&gt;&lt;/textarea&gt;&lt;br&gt;</span><br><span class="line">    &lt;input id=&quot;chat-message-input&quot; type=&quot;text&quot; size=&quot;100&quot;&gt;&lt;br&gt;</span><br><span class="line">    &lt;input id=&quot;chat-message-submit&quot; type=&quot;button&quot; value=&quot;Send&quot;&gt;</span><br><span class="line">    &#123;&#123; room_name|json_script:&quot;room-name&quot; &#125;&#125;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">        // 获取房间名</span><br><span class="line">        const roomName = JSON.parse(document.getElementById(&#x27;room-name&#x27;).textContent);</span><br><span class="line"> </span><br><span class="line">        // 根据roomName拼接websocket请求地址，建立长连接</span><br><span class="line">        //  请求url地址为/ws/chat/&lt;room_name&gt;/</span><br><span class="line">        const wss_protocol = (window.location.protocol == &#x27;https:&#x27;) ? &#x27;wss://&#x27;: &#x27;ws://&#x27;;</span><br><span class="line">        const chatSocket = new WebSocket(</span><br><span class="line">             wss_protocol + window.location.host + &#x27;/ws/chat/&#x27;  + roomName + &#x27;/&#x27;</span><br><span class="line">             );</span><br><span class="line"> </span><br><span class="line">        // 建立websocket连接时触发此方法，展示欢迎提示</span><br><span class="line">        chatSocket.onopen = function(e) &#123;</span><br><span class="line">             document.querySelector(&#x27;#chat-log&#x27;).value += (&#x27;[公告]欢迎来到&#x27; + roomName + &#x27;讨论群。请文明发言!\n&#x27;)</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">        // 从后台接收到数据时触发此方法</span><br><span class="line">        // 接收到后台数据后对其解析，并加入到聊天记录chat-log</span><br><span class="line">         chatSocket.onmessage = function(e) &#123;</span><br><span class="line">             const data = JSON.parse(e.data);</span><br><span class="line">             document.querySelector(&#x27;#chat-log&#x27;).value += (data.message + &#x27;\n&#x27;);</span><br><span class="line">         &#125;;</span><br><span class="line"> </span><br><span class="line">         // websocket连接断开时触发此方法</span><br><span class="line">         chatSocket.onclose = function(e) &#123;</span><br><span class="line">             console.error(&#x27;Chat socket closed unexpectedly&#x27;);</span><br><span class="line">         &#125;;</span><br><span class="line">         </span><br><span class="line">         document.querySelector(&#x27;#chat-message-input&#x27;).focus();</span><br><span class="line">         document.querySelector(&#x27;#chat-message-input&#x27;).onkeyup = function(e) &#123;</span><br><span class="line">             if (e.keyCode === 13) &#123;  // enter, return</span><br><span class="line">                 document.querySelector(&#x27;#chat-message-submit&#x27;).click();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;;</span><br><span class="line">         </span><br><span class="line">         // 每当点击发送消息按钮，通过websocket的send方法向后台发送信息。</span><br><span class="line">         document.querySelector(&#x27;#chat-message-submit&#x27;).onclick = function(e) &#123;</span><br><span class="line">             const messageInputDom = document.querySelector(&#x27;#chat-message-input&#x27;);</span><br><span class="line">             const message = messageInputDom.value;</span><br><span class="line">             </span><br><span class="line">             //注意这里:先把文本数据转成json格式,然后调用send方法发送。</span><br><span class="line">             chatSocket.send(JSON.stringify(&#123;</span><br><span class="line">                 &#x27;message&#x27;: message</span><br><span class="line">             &#125;));</span><br><span class="line">             messageInputDom.value = &#x27;&#x27;;</span><br><span class="line">         &#125;;</span><br><span class="line">     &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>此时如果你使用python <a href="https://link.zhihu.com/?target=http://manage.py/">manage.py</a> runserver命令启动测试服务器，当你访问一个名为/hello/的房间时，你将看到如下页面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-33d27008d74f1ea99ae9dff43d54c1e6_1440w.jpg" alt="img"></p>
<p>到这里你看不到任何聊天记录，也不能发送任何消息，因为我们还没有在后端编写任何代码用于处理前端发来的消息，并返回数据。在终端你还会看到如下报错, 说Django只能处理http连接，不能处理websocket。</p>
<p><img src="https://pic1.zhimg.com/80/v2-bbcdb5ef16a22fcf2a5456bb3c9d046c_1440w.png" alt="img"></p>
<p>到目前为止，我们所写的就是一个普通的django应用，还没有用到channels库处理websocket请求。接下来我们就要正式开始使用channels了。</p>
<p><strong>第三步 编写后台websocket路由及处理方法</strong></p>
<p>当 Django 接受 HTTP 请求时, 它会根据根 URLconf 以查找视图函数, 然后调用视图函数来处理请求。同样, 当 channels 接受 WebSocket 连接时, 它也会根据根路由配置去查找相应的处理方法。只不过channels的路由不在urls.py中配置，<a href="https://link.zhihu.com/?target=http://xn--views-ni1h7sr0s61n5pen77b92r0lv.py/">处理方法也不写在views.py</a>。在channels中，<a href="https://link.zhihu.com/?target=http://xn--routing-d23kxb93dg9a22u0nax7q985dmulfm9o.xn--pyconsumers-804s.py/">这两个文件分别变成了routing.py和consumers.py</a>。这样的好处是不用和django的常规应用混在一起。</p>
<ul>
<li><a href="https://link.zhihu.com/?target=http://routing.py/">routing.py</a>：websocket路由文件，<a href="https://link.zhihu.com/?target=http://xn--djangourls-cp3p132nn9xdflb.py/">相当于django的urls.py</a>。它根据websocket请求的url地址触发consumers.py里定义的方法。</li>
<li><a href="https://link.zhihu.com/?target=http://consumers.py/">consumers.py</a>：<a href="https://link.zhihu.com/?target=http://xn--djangoviews-8z9qw19f81zwy6e1rbr28m.py/">相当于django的视图views.py</a>，负责处理通过websocket路由转发过来的请求和数据。</li>
</ul>
<p><a href="https://link.zhihu.com/?target=http://xn--chatrouting-gq8qu16gezv0lbm52dn93d.py/">在chat应用下新建routing.py</a>, 添加如下代码。它的作用是将发送至ws/chat/<room_name>/的websocket请求转由ChatConsumer处理。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># chat/routing.py</span><br><span class="line">from django.urls import re_path</span><br><span class="line"></span><br><span class="line">from . import consumers</span><br><span class="line"></span><br><span class="line">websocket_urlpatterns = [</span><br><span class="line">    re_path(r&#x27;ws/chat/(?P&lt;room_name&gt;\w+)/$&#x27;, consumers.ChatConsumer.as_asgi()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：定义websocket路由时，推荐使用常见的路径前缀 (如/ws) 来区分 WebSocket 连接与普通 HTTP 连接， 因为它将使生产环境中部署 Channels 更容易，比如nginx把所有/ws的请求转给channels处理。</p>
<p>与Django类似，我们还需要把这个app的websocket路由加入到项目的根路由中去。编辑myproject/asgi.py, 添加如下代码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># myproject/asgi.py</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">from channels.auth import AuthMiddlewareStack</span><br><span class="line">from channels.routing import ProtocolTypeRouter, URLRouter</span><br><span class="line">from django.core.asgi import get_asgi_application</span><br><span class="line">import chat.routing</span><br><span class="line"></span><br><span class="line">os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;myproject.settings&quot;)</span><br><span class="line"></span><br><span class="line">application = ProtocolTypeRouter(&#123;</span><br><span class="line">   # http请求使用这个</span><br><span class="line">  &quot;http&quot;: get_asgi_application(),</span><br><span class="line">  </span><br><span class="line">  # websocket请求使用这个</span><br><span class="line">  &quot;websocket&quot;: AuthMiddlewareStack(</span><br><span class="line">        URLRouter(</span><br><span class="line">            chat.routing.websocket_urlpatterns</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在这里，channels的ProtocolTypeRouter会根据请求协议的类型来转发请求。AuthMiddlewareStack将使用对当前经过身份验证的用户的引用来填充连接的scope, 类似于 Django 的request对象，我们后面还会讲到。</p>
<p><a href="https://link.zhihu.com/?target=http://xn--chatconsumers-o40uea7348a8m0arrbq68bdlj8jjw42f.py/">接下来在chat应用下新建consumers.py</a>, 添加如下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line">from asgiref.sync import async_to_sync</span><br><span class="line">from channels.generic.websocket import WebsocketConsumer</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ChatConsumer(WebsocketConsumer):</span><br><span class="line">    # websocket建立连接时执行方法</span><br><span class="line">    def connect(self):</span><br><span class="line">        # 从url里获取聊天室名字，为每个房间建立一个频道组</span><br><span class="line">        self.room_name &#x3D; self.scope[&#39;url_route&#39;][&#39;kwargs&#39;][&#39;room_name&#39;]</span><br><span class="line">        self.room_group_name &#x3D; &#39;chat_%s&#39; % self.room_name</span><br><span class="line"></span><br><span class="line">        # 将当前频道加入频道组</span><br><span class="line">        async_to_sync(self.channel_layer.group_add)(</span><br><span class="line">            self.room_group_name,</span><br><span class="line">            self.channel_name</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        # 接受所有websocket请求</span><br><span class="line">        self.accept()</span><br><span class="line"></span><br><span class="line">    # websocket断开时执行方法</span><br><span class="line">    def disconnect(self, close_code):</span><br><span class="line">        async_to_sync(self.channel_layer.group_discard)(</span><br><span class="line">            self.room_group_name,</span><br><span class="line">            self.channel_name</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    # 从websocket接收到消息时执行函数</span><br><span class="line">    def receive(self, text_data):</span><br><span class="line">        text_data_json &#x3D; json.loads(text_data)</span><br><span class="line">        message &#x3D; text_data_json[&#39;message&#39;]</span><br><span class="line"></span><br><span class="line">        # 发送消息到频道组，频道组调用chat_message方法</span><br><span class="line">        async_to_sync(self.channel_layer.group_send)(</span><br><span class="line">            self.room_group_name,</span><br><span class="line">            &#123;</span><br><span class="line">                &#39;type&#39;: &#39;chat_message&#39;,</span><br><span class="line">                &#39;message&#39;: message</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    # 从频道组接收到消息后执行方法</span><br><span class="line">    def chat_message(self, event):</span><br><span class="line">        message &#x3D; event[&#39;message&#39;]</span><br><span class="line">        datetime_str &#x3D; datetime.datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)</span><br><span class="line"></span><br><span class="line">        # 通过websocket发送消息到客户端</span><br><span class="line">        self.send(text_data&#x3D;json.dumps(&#123;</span><br><span class="line">            &#39;message&#39;: f&#39;&#123;datetime_str&#125;:&#123;message&#125;&#39;</span><br><span class="line">        &#125;))</span><br></pre></td></tr></table></figure>

<p>每个自定义的Consumer类一般继承同步的WebsocketConsumer类或异步的AysncWebSocketConsumer类，它自带 self.channel_name 和self.channel_layer 属性。前者是独一无二的长连接频道名，后者提供了 send(), group_send()和group_add() 3种方法, 可以给单个频道或一个频道组发信息，还可以将一个频道加入到组。</p>
<ul>
<li>每个频道(channel)都有一个名字。拥有频道名称的任何人都可以向频道发送消息。</li>
<li>一个组(group)有一个名字。具有组名称的任何人都可以按名称向组添加/删除频道，并向组中的所有频道发送消息。</li>
</ul>
<p><strong>注意</strong>：虽然异步Consumer类性能更优，channels推荐使用同步consumer类 , 尤其是调用Django ORM或其他同步程序时，以保持整个consumer在单个线程中并避免ORM查询阻塞整个event。调用channel_layer提供的方法时需要用async_to_sync转换一下。</p>
<p>除此以外，我们还使用了self.scope[‘url_route’][‘kwargs’][‘room_name’]从路由中获取了聊天室的房间名，<em>在channels程序中，scope是个很重要的对象，类似于django的request对象，它代表了当前websocket连接的所有信息</em>。你可以通过scope[‘user’]获取当前用户对象，还可以通过scope[‘path’]获取当前当前请求路径。</p>
<p><strong>第四步 运行看效果</strong></p>
<p>如果不出意外，你现在的项目布局应该如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/v2-d60c89380077cd5e6b9f6658b32d0728_1440w.jpg" alt="img"></p>
<p>连续运行如下命令，就可以看到我们文初的效果啦。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<p>我们已经使用django + channels 写了个在线聊天小应用了，现在来总结下我们所学的知识吧。</p>
<ul>
<li>websocket属于全双工通讯的协议，可以在服务器和客户端之间保持长连接，实现双向数据传输。</li>
<li>前端创建websocket对象后可以通过onmessage监听并处理后端返回的数据，可以通过send方法向后端发送数据。</li>
<li>channels对应websocket的路由和处理方法分别写在routing.py和consumers.py文件里，<a href="https://link.zhihu.com/?target=http://xn--djangourls-cp3p132nn9xdflb.xn--pyviews-9r4l.py/">相当于django的urls.py和views.py</a>。</li>
<li>每个频道(channel)都有一个名字，拥有频道名称的任何人都可以向频道发送消息。一个组(group)有一个名字，可以包含多个频道。</li>
<li>每个自定义的Consumer类自带 self.channel_name 和self.channel_layer 属性。前者是独一无二的频道名，后者提供了 send(), group_send()和group_add() 3种方法。</li>
<li>在channels程序中，scope是个很重要的对象，类似于django的request对象，它代表了当前websocket连接的所有信息，比如scope[‘user’], scope[‘path’]。</li>
</ul>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>AI-01-Langchain构建RAG应用</title>
    <url>/posts/24369.html</url>
    <content><![CDATA[<p>Langchain 构建RAG</p>
<a id="more"></a>





<h1 id="Langchain是什么"><a href="#Langchain是什么" class="headerlink" title="Langchain是什么"></a>Langchain是什么</h1><blockquote>
<p>Langchain是一个开源框架，它允许开发人员将像gpt-4这样的大型语言模型与外部的计算和数据源结合起来。</p>
<p><strong>Langchain是一个用于开发由语言模型驱动的应用程序的框架；以大语言模型为基础，开发应用程序。类似于Java中的SpringBoot框架</strong></p>
</blockquote>
<h1 id="Langchain构建RAG的对话应用"><a href="#Langchain构建RAG的对话应用" class="headerlink" title="Langchain构建RAG的对话应用"></a>Langchain构建RAG的对话应用</h1><blockquote>
<p>复杂的问答(Q&amp;A)聊天机器人。应用程序可以回答有关特定源信息的问题。使用一种成为检索增加生成(RAG)的技术。</p>
<p>RAG使用增强大语言模型（LLM）知识的方法，它通过引入额外的数据来实现。</p>
<p>pip install langgragh用来创建代理的API</p>
</blockquote>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路:"></a>实现思路:</h2><ol>
<li>加载：首先，我们需要加载数据。这是通过DocumentLoaders完成的。</li>
<li>分割：Text splitters将大型文档分割成更小的块。这对于索引数据和将其传递给模型很有用，因为大块数据更难搜索，并且不适合模型的有限上下文窗口。 </li>
<li>存储：我们需要一个地方来存储和索引我们的索引，以便以后可以搜索。这同城使用VectorStore和Embeddings模型完成。</li>
<li>检索：给定用户输入，使用检索器从存储中检索相关分割。</li>
<li>生成：ChatModel / LLM 使用包括问题和检索到的数据的提示生成答案。</li>
</ol>
<h2 id="Langchain-读取数据库"><a href="#Langchain-读取数据库" class="headerlink" title="Langchain 读取数据库"></a>Langchain 读取数据库</h2><hr>
<ol>
<li>非结构化（图文、格式多样）的文档做知识库，有什么好的处理方式，有比较好的开源项目货这工具介绍吗？希望能处理复杂的方法识别和调用、将非结构化的文档加入知识库并识别准确。<ul>
<li>非结构化的文档实际上RAG是不好处理的，不过也有办法，就是先统一转成markdown格式，然后再进行RAG</li>
<li>例如，对于markdown的知识库，可能存在图文混排，那么你就需要给图片带上完整的白标签<img src="https://xxxx/" alt="图片">，这样进行Embedding的时候，可以去除对应混排的段落。推荐的项目有RagFlow或者网易开源的QAnything。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="RAG"><a href="#RAG" class="headerlink" title="RAG"></a>RAG</h1><p>整体流程</p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/image-20250622170944107.png" alt="image-20250622170944107"></p>
<p>准备部分</p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/image-20250622171024606.png" alt="image-20250622171024606"></p>
<p>回答部分</p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/image-20250622171200279.png" alt="image-20250622171200279"></p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic//image-20250803021724237.png" alt="image-20250803021724237"></p>
<p>检索方式：</p>
<ul>
<li>向量检索：语意匹配</li>
<li>全文检索：关键词匹配</li>
<li>混合检索: 将向量检索+全文检索的结果 交给 rerank 模型</li>
</ul>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>AI-02-通俗解释LLM</title>
    <url>/posts/23894.html</url>
    <content><![CDATA[<p>通俗解释LLM</p>
<a id="more"></a>

<h1 id="2-1-大模型如何理解文字的"><a href="#2-1-大模型如何理解文字的" class="headerlink" title="2.1 大模型如何理解文字的"></a>2.1 大模型如何理解文字的</h1><p>原文链接：<a href="https://mp.weixin.qq.com/s/8EjTirHIqltnDJLJzpnXwQ">https://mp.weixin.qq.com/s/8EjTirHIqltnDJLJzpnXwQ</a></p>
<h1 id="2-2-大模型的参数是啥？"><a href="#2-2-大模型的参数是啥？" class="headerlink" title="2.2 大模型的参数是啥？"></a>2.2 大模型的参数是啥？</h1><p>原文链接：<a href="https://mp.weixin.qq.com/s/hgVFfnOGXougK4kFbl0m9g">https://mp.weixin.qq.com/s/hgVFfnOGXougK4kFbl0m9g</a></p>
<h1 id="2-3-大模型的token是啥？"><a href="#2-3-大模型的token是啥？" class="headerlink" title="2.3 大模型的token是啥？"></a>2.3 大模型的token是啥？</h1><p>原文链接：<a href="https://mp.weixin.qq.com/s/NiQXAdr6EzAHCLelAWWZGQ">https://mp.weixin.qq.com/s/NiQXAdr6EzAHCLelAWWZGQ</a></p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>AI-03-智能体概述</title>
    <url>/posts/64.html</url>
    <content><![CDATA[<p>智能体概述</p>
<a id="more"></a>

<h1 id="3-AI-智能体概述"><a href="#3-AI-智能体概述" class="headerlink" title="3.AI 智能体概述"></a>3.AI 智能体概述</h1><p>在人工智能的浪潮中，大型语言模型（LLM）如 ChatGPT 等展现了惊人的自然语言理解和生成能力，它们可以作为强大的知识库、内容创作者和对话伙伴。然而，仅仅停留在“问答”和“生成”层面，并不能完全释放 AI 的潜力。我们期待 AI 不仅能“说”，更能“做”，能够像一个真正得力的助手或员工一样，自主地理解复杂目标、制定计划、并与数字或物理世界互动以完成任务。这就是 AI Agent(智能体) 诞生的背景和目标。</p>
<p>AI Agent 可以被视为一种具备自主性、以目标为导向、能够感知环境、进行决策规划并执行动作的智能系统。它代表了从被动响应工具到主动问题解决者的关键转变，是当前 AI 领域最令人兴奋的研究和应用方向之一。</p>
<h2 id="1-AI-Agent-的定义"><a href="#1-AI-Agent-的定义" class="headerlink" title="1. AI Agent 的定义"></a>1. AI Agent 的定义</h2><p>比如我们这里有一个名为 Alfred 的智能体。</p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/image-20250517225837282.png" alt="image-20250517225837282"></p>
<p>现在 Alfred 收到一个指令，比如：“Alfred，我想来杯咖啡。”</p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/image-20250517225856880.png" alt="image-20250517225856880"></p>
<p>因为 Alfred 理解自然语言，他很快就明白了我们的请求。</p>
<p>在完成任务之前，Alfred 会进行推理和规划，弄清楚他需要的步骤和工具：</p>
<ol>
<li><p>去厨房</p>
</li>
<li><p>使用咖啡机</p>
</li>
<li><p>煮咖啡</p>
</li>
<li><p>把咖啡拿回来</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/image-20250517230004246.png" alt="image-20250517230004246"></p>
<p>一旦有了计划，他就必须行动。为了执行计划，他可以使用他所知道的工具列表中的工具。</p>
<p>在这个例子中，为了煮咖啡，他使用了咖啡机。他启动咖啡机来煮咖啡。</p>
<p>最后，Alfred 把刚煮好的咖啡拿给我们。</p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/image-20250517230015736.png" alt="image-20250517230015736"></p>
<p>这就是智能体：一个能够进行推理、规划和与环境交互的人工智能模型。</p>
<p>我们称之为智能体，因为它具有能动性，即与环境交互的能力。</p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/image-20250517230025279.png" alt="image-20250517230025279"></p>
<p>现在你已经了解了整体情况，以下是一个更精确的定义：</p>
<blockquote>
<p>智能体是一个系统，它利用人工智能模型与环境交互，以实现用户定义的目标。它结合推理、规划和动作执行（通常通过外部工具）来完成任务。</p>
</blockquote>
<p>可以把智能体想象成有两个主要部分：</p>
<p>​    <strong>1</strong>. 大脑（AI 模型）</p>
<p>​    这是所有思考发生的地方。AI 模型负责推理和规划。它根据情况决定采取哪些行动。</p>
<p>​    <strong>2</strong>. 身体（能力和工具）</p>
<p>这部分代表了智能体所能做的一切。</p>
<p><strong>可能行动的范围</strong>取决于智能体被配备了什么。例如，因为人类没有翅膀，所以他们不能执行“飞”这个行动，但他们可以执行“走”、“跑”、“跳”、“抓”等行动。</p>
<p><strong>我们为智能体使用什么类型的 AI 模型？</strong></p>
<p>智能体中最常见的 AI 模型是 LLM，它接受文本作为输入，并输出文本。</p>
<p>比如常见的 ChatGPT、DeepSeek、Claude 等，这些模型已经经过大量文本的训练，并且具有很好的泛化能力。</p>
<p><strong>AI 如何在环境中采取行动？</strong></p>
<p>LLM 实际上它们只能生成文本。然而，如果你让像 ChatGPT 这样的应用程序生成图像，它们却可以做到！这是怎么可能的？</p>
<p>答案是 ChatGPT 和类似应用程序的开发者实现了额外的功能（称为工具），LLM 可以利用这些工具来创建图像。</p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/image-20250517230134075.png" alt="image-20250517230134075"></p>
<p>总体而言，智能体是一个系统，它使用 LLM 作为其核心推理引擎，以实现以下功能：</p>
<ul>
<li><p>理解自然语言：以有意义的方式解释和回应人类指令。</p>
</li>
<li><p>推理与规划：分析信息、做出决策并制定解决问题的策略。</p>
</li>
<li><p>与环境交互：收集信息、执行操作并观察这些操作的结果。</p>
</li>
</ul>
<h2 id="2-AI-Agent-的核心组成要素"><a href="#2-AI-Agent-的核心组成要素" class="headerlink" title="2. AI Agent 的核心组成要素"></a>2. AI Agent 的核心组成要素</h2><p>一个典型的 AI Agent 系统，通常由以下几个相互关联的核心模块构成：</p>
<h3 id="2-1-目标设定与理解"><a href="#2-1-目标设定与理解" class="headerlink" title="2.1 目标设定与理解"></a>2.1 目标设定与理解</h3><ul>
<li><p>核心作用： 定义 Agent 需要完成的最终任务或期望达成的状态。这是 Agent 一切行为的出发点和最终归宿。</p>
</li>
<li><p>形式： 目标可以由用户通过自然语言（如“帮我预订下周末去上海看演唱会的行程，包括机票和酒店”）明确指定，也可以是系统预设的长期目标（如“持续监控我的项目代码库，发现潜在 bug 立即报告”）。</p>
</li>
<li><p>关键挑战：</p>
<ul>
<li><p><strong>意图理解</strong>： Agent（通常借助 LLM）需要准确理解用户模糊、不完整甚至隐含的目标意图。</p>
</li>
<li><p><strong>目标分解：</strong> 对于复杂目标，需要将其分解为一系列更小、更易于管理的子目标或步骤。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-环境感知-Perception"><a href="#2-2-环境感知-Perception" class="headerlink" title="2.2 环境感知(Perception)"></a>2.2 环境感知(Perception)</h3><ul>
<li><p>核心作用： Agent 通过感知来获取关于其所处环境（物理或数字）以及自身状态的信息，这是做出明智决策的基础。</p>
</li>
<li><p>信息来源：</p>
<ul>
<li><p>用户输入： 自然语言指令、文件、数据等。</p>
</li>
<li><p>外部工具/API 返回： 搜索引擎结果、数据库查询结果、天气 API 数据、股票价格等。</p>
</li>
<li><p>数字环境状态： 网页内容、文件系统状态、应用程序界面元素。</p>
</li>
<li><p>物理环境状态（针对具身智能体）： 摄像头视觉信息、麦克风声音信息、传感器读数等。</p>
</li>
</ul>
</li>
<li><p>关键挑战：</p>
<ul>
<li><p>信息过滤与相关性判断： 从海量信息中筛选出对当前目标有用的信息。</p>
</li>
<li><p>处理非结构化数据： 理解网页、文档等复杂格式的内容。</p>
</li>
<li><p>处理动态变化的环境： 环境信息可能随时变化，需要及时更新感知。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-思考、推理与规划-Reasoning-amp-Planning"><a href="#2-3-思考、推理与规划-Reasoning-amp-Planning" class="headerlink" title="2.3 思考、推理与规划(Reasoning &amp; Planning)"></a>2.3 思考、推理与规划(Reasoning &amp; Planning)</h3><ul>
<li><p>核心作用： 这是 Agent 的“大脑”，负责基于当前目标和感知到的信息，进行逻辑思考、制定行动计划、选择策略。大型语言模型 (LLM) 在现代 Agent 中通常扮演此核心角色。</p>
</li>
<li><p>过程：</p>
<ul>
<li><p>状态评估： 分析当前状态与目标状态的差距。</p>
</li>
<li><p>行动选项生成： 思考可能采取哪些行动来缩小差距（例如，是应该先搜索信息，还是直接调用某个 API？）。</p>
</li>
<li><p>计划制定： 将选定的行动组织成一个有序的序列或策略。这可能是一个详细的步骤列表，也可能是一个动态调整的策略。常见的 LLM 推理模式如思维链 (Chain-of-Thought, CoT) 在此环节被广泛应用，即让 LLM 先“想一想”推理过程再给出结论或计划。</p>
</li>
<li><p>工具选择： 决定在计划的某个步骤需要使用哪个外部工具（见 4.1 节）。</p>
</li>
</ul>
</li>
<li><p>关键挑战：</p>
<ul>
<li><p>复杂逻辑推理： 处理需要多步逻辑、因果判断的任务。</p>
</li>
<li><p>长期规划： 制定涉及步骤多、时间跨度长的计划，并保持一致性。</p>
</li>
<li><p>不确定性处理： 在信息不完整或环境有随机性的情况下进行规划。</p>
</li>
<li><p>效率与成本： LLM 推理本身有计算成本和时间延迟。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-4-行动执行-Action"><a href="#2-4-行动执行-Action" class="headerlink" title="2.4 行动执行(Action)"></a>2.4 行动执行(Action)</h3><ul>
<li><p>核心作用： 将规划好的步骤转化为在环境中实际执行的操作。</p>
</li>
<li><p>行动类型：</p>
<ul>
<li><p>调用工具(Tool Use)： 执行 API 调用（如搜索、计算、预订、发送消息）、运行代码解释器、查询数据库等。</p>
</li>
<li><p>内部操作： 更新内部记忆、修改自身状态。</p>
</li>
<li><p>与环境交互： 模拟键盘鼠标操作、读写文件、与操作系统交互。</p>
</li>
<li><p>与用户交互： 向用户提问以获取更多信息、报告进度、呈现结果。</p>
</li>
</ul>
</li>
<li><p>关键挑战：</p>
<ul>
<li><p>行动空间定义： 明确 Agent 可以执行哪些动作。</p>
</li>
<li><p>执行监控与错误处理： 检查动作是否成功执行，如果失败（如 API 超时、代码出错）如何处理和重试。</p>
</li>
<li><p>安全与权限控制： 确保 Agent 的行动在允许的范围内，不会造成破坏或泄露敏感信息。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-5-记忆-Memory"><a href="#2-5-记忆-Memory" class="headerlink" title="2.5 记忆(Memory)"></a>2.5 记忆(Memory)</h3><ul>
<li><p>核心作用： 存储和检索信息，使得 Agent 能够利用过去的经验、维持对话上下文、执行长期任务。</p>
</li>
<li><p>记忆类型：</p>
<ul>
<li><p>短期记忆： 通常指 LLM 的上下文窗口 (Context Window)，用于保存最近的对话历史和中间思考过程。容量有限。</p>
</li>
<li><p>长期记忆： 用于存储更持久的信息，如用户偏好、过去的成功/失败经验、知识库等。常用技术包括：</p>
<ul>
<li><p>向量数据库 (Vector Database)： 将文本信息嵌入为向量存储，通过相似度搜索快速检索相关记忆。</p>
</li>
<li><p>传统数据库/文件系统： 存储结构化或半结构化数据。</p>
</li>
<li><p>工作记忆/暂存区： Agent 在执行任务过程中记录中间想法、计算结果、待办事项的地方。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>关键挑战：</p>
<ul>
<li><p>信息存储： 如何有效地将经验和知识存入记忆。</p>
</li>
<li><p>信息检索： 如何在需要时快速、准确地从海量记忆中找到最相关的信息。</p>
</li>
<li><p>记忆更新与遗忘： 如何更新过时信息，以及适时“遗忘”不重要的信息以避免干扰。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-6-学习与适应-可选"><a href="#2-6-学习与适应-可选" class="headerlink" title="2.6 学习与适应(可选)"></a>2.6 学习与适应(可选)</h3><ul>
<li><p>核心作用： Agent 通过与环境的互动、用户的反馈或新的数据来改进其性能、优化策略、学习新技能。</p>
</li>
<li><p>学习方式：</p>
<ul>
<li><p>从反馈中学习： 基于人类反馈的强化学习 (RLHF)、用户纠正、显式评分等。</p>
</li>
<li><p>从经验中学习： 记录成功和失败的行动序列，用于改进未来的规划（类似强化学习中的 Trial-and-Error）。</p>
</li>
<li><p>从新数据中学习： 更新知识库或微调模型参数。</p>
</li>
</ul>
</li>
<li><p>关键挑战：</p>
<ul>
<li><p>学习效率： 如何快速有效地从少量经验或反馈中学习。</p>
</li>
<li><p>稳定性与灾难性遗忘： 学习新知识时如何避免忘记旧的、仍然有用的知识。</p>
</li>
<li><p>探索与利用的平衡： 如何在利用已知有效策略和探索可能更好的新策略之间取得平衡。</p>
</li>
</ul>
</li>
</ul>
<p>这六个组件构成了 AI Agent 的核心运作循环：<strong>感知环境</strong> -&gt; <strong>理解目标</strong> -&gt; <strong>思考规划</strong> -&gt; <strong>执行动作</strong> -&gt; <strong>(更新记忆)</strong> -&gt; <strong>(学习适应)</strong> -&gt; <strong>感知新状态</strong>… <strong>如此循环，直至目标达成或中止。</strong></p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/image-20250517230907044.png" alt="image-20250517230907044"></p>
<h2 id="3-LLM-在-Agent-中的核心作用"><a href="#3-LLM-在-Agent-中的核心作用" class="headerlink" title="3. LLM 在 Agent 中的核心作用"></a>3. LLM 在 Agent 中的核心作用</h2><p>LLM 是当前 AI Agent 实现突破的关键驱动力，它通常扮演以下角色：</p>
<ul>
<li><p>通用接口： LLM 强大的自然语言理解能力使其能轻松处理来自用户、工具、环境的各种文本信息。</p>
</li>
<li><p>核心“大脑” (Reasoning Engine)：</p>
<ul>
<li><p>理解意图与目标分解： 将用户的自然语言指令转化为结构化的目标和子目标。</p>
</li>
<li><p>进行常识推理和逻辑推断： 基于其在预训练中学到的庞大知识，进行世界知识推理、因果关系判断等。</p>
</li>
<li><p>制定行动计划： 生成达到目标所需的步骤序列 (Plan)。</p>
</li>
<li><p>选择合适的工具： 判断在计划的某一步骤应该使用哪个工具，并生成调用该工具所需的参数。</p>
</li>
<li><p>处理工具输出与反馈： 理解工具返回的结果或环境变化，并据此调整后续计划。</p>
</li>
<li><p>生成最终响应： 将执行结果或最终答案以自然语言形式呈现给用户。</p>
</li>
</ul>
</li>
<li><p>赋予灵活性： LLM 的生成能力使得 Agent 不局限于固定的规则，能够灵活应对各种情境和任务。</p>
</li>
</ul>
<p><strong>然而</strong>，单纯的 LLM 并非 Agent。 Agent 是一个<strong>系统工程</strong>，它围绕 LLM 这个“大脑”，构建了感知、行动、记忆等配套模块，并将它们有机地结合起来，形成一个能够自主运作的闭环系统。</p>
<h2 id="4-AI-Agent-的关键架构模式"><a href="#4-AI-Agent-的关键架构模式" class="headerlink" title="4. AI Agent 的关键架构模式"></a>4. AI Agent 的关键架构模式</h2><p>为了组织上述组件并实现有效的 Agent 行为，研究和实践中涌现出了一些常见的架构模式：</p>
<ul>
<li><p>ReAct (Reason + Act):</p>
<ul>
<li><p>思想： 将思考 (Reasoning) 和行动 (Acting) 交织在一起。LLM 在每一步生成一个“思考”过程（分析当前情况、下一步该做什么）和一个要执行的“行动”（如调用某个工具）。执行行动后，观察结果，然后进入下一个 ReAct 循环。</p>
</li>
<li><p>特点： 结构简单，能处理需要逐步探索和信息收集的任务，反馈及时。适用于很多问答、信息查询、简单任务执行场景。</p>
</li>
</ul>
</li>
<li><p>Plan-and-Execute:</p>
<ul>
<li><p>思想： 分为两个主要阶段。首先，LLM 根据初始目标生成一个完整的、多步骤的计划。然后，一个执行器 (Executor) 负责按顺序执行计划中的每一步动作。</p>
</li>
<li><p>特点： 适用于目标明确、步骤相对固定的任务。规划阶段更全面，但对初始规划的准确性要求高，对执行过程中的意外情况适应性相对较弱（除非加入复杂的错误处理和重新规划机制）。</p>
</li>
</ul>
</li>
<li><p>Reflection / Self-Correction:</p>
<ul>
<li><p>思想： Agent 在执行任务后或遇到困难时，能够“反思”自己的行为和结果。LLM 被用来评估之前的推理步骤或行动是否有效、是否存在错误，并根据反思结果修正计划或改进策略。</p>
</li>
<li><p>特点： 赋予 Agent 自我改进的能力，提高任务成功率和结果质量，尤其适用于复杂或易错的任务。</p>
</li>
</ul>
</li>
</ul>
<p>这些模式并非相互排斥，实践中常常会将它们组合使用，例如在 ReAct 循环中加入反思步骤。</p>
<h2 id="5-AI-Agent-的重要能力：以工具使用-Tool-Use-为例"><a href="#5-AI-Agent-的重要能力：以工具使用-Tool-Use-为例" class="headerlink" title="5. AI Agent 的重要能力：以工具使用 (Tool Use) 为例"></a>5. AI Agent 的重要能力：以工具使用 (Tool Use) 为例</h2><p>为了让 Agent 能够与真实世界或复杂的数字环境有效互动，仅靠 LLM 自身的知识是不够的。赋予 Agent 使用工具的能力至关重要。</p>
<ul>
<li><p>为什么需要工具？</p>
<ul>
<li><p>克服 LLM 的知识局限： LLM 的知识是静态的（截止到训练数据），无法获取实时信息（如今天的天气、最新的新闻）。</p>
</li>
<li><p>执行精确计算： LLM 不擅长精确的数学运算。</p>
</li>
<li><p>与外部世界交互： LLM 本身无法发送邮件、预订机票、操作数据库等。</p>
</li>
<li><p>访问专有信息： 获取非公开的企业内部数据或需要特定权限的信息。</p>
</li>
</ul>
</li>
<li><p>常见的工具类型：</p>
<ul>
<li><p>信息获取类： 搜索引擎 API、知识库查询接口、数据库查询。</p>
</li>
<li><p>计算类： 计算器、代码解释器（执行 Python 等代码）。</p>
</li>
<li><p>动作执行类： 发送邮件 API、日历管理 API、文件操作工具、网页浏览器自动化工具。</p>
</li>
<li><p>其他 LLM： 可能调用专门针对特定任务（如情感分析、图像识别）的 AI 模型。</p>
</li>
</ul>
</li>
<li><p>工具使用机制：</p>
<ul>
<li><p>工具选择： LLM 根据当前任务需求和可用工具列表，决定是否需要使用工具以及使用哪个工具。</p>
</li>
<li><p>参数生成： LLM 生成调用该工具所需的输入参数（如搜索关键词、计算公式、API 请求体）。</p>
</li>
<li><p>工具调用： Agent 系统实际执行工具调用。</p>
</li>
<li><p>结果解析： LLM 理解工具返回的结果，并将其融入后续的思考和规划中。</p>
</li>
</ul>
</li>
</ul>
<p>除了工具使用，一个强大的 Agent 还应具备：</p>
<ul>
<li><p>多步骤推理能力： 将复杂问题分解为逻辑连贯的多个步骤。</p>
</li>
<li><p>处理模糊性与歧义： 能够理解不清晰的指令，并在必要时向用户提问澄清。</p>
</li>
<li><p>错误处理与鲁棒性： 在工具调用失败或遇到意外情况时，能够尝试恢复或调整策略。</p>
</li>
<li><p>上下文管理： 有效利用短期和长期记忆，保持任务的连贯性。</p>
</li>
</ul>
<h2 id="6-当前面临的挑战与局限性"><a href="#6-当前面临的挑战与局限性" class="headerlink" title="6. 当前面临的挑战与局限性"></a>6. 当前面临的挑战与局限性</h2><p>尽管 AI Agent 发展迅速，但仍面临诸多挑战：</p>
<ul>
<li><p>可靠性与稳定性： Agent 在执行长链条任务时，任何一步的失败都可能导致整个任务失败。LLM 的“幻觉”（一本正经地胡说八道）可能导致错误的决策或行动。</p>
</li>
<li><p>安全性与可控性： 如何确保 Agent 的行为符合伦理规范，不会执行有害或未经授权的操作？如何在其自主性与人类控制之间找到平衡？</p>
</li>
<li><p>成本与效率： 复杂任务可能需要多次调用 LLM API，带来高昂的成本和较长的执行时间。</p>
</li>
<li><p>长期规划与记忆： 现有技术在处理需要跨越很长时间尺度、依赖大量历史记忆的复杂任务时仍显不足。</p>
</li>
<li><p>常识与世界模型： LLM 虽知识渊博，但缺乏真正的物理世界常识和深刻的因果理解能力，这限制了 Agent 在现实世界中的应用。</p>
</li>
<li><p>评估与测试： 如何全面、可靠地评估一个 Agent 在各种开放式任务上的真实能力，是一个难题。</p>
</li>
</ul>
<h2 id="7-AI-Agent-的应用前景"><a href="#7-AI-Agent-的应用前景" class="headerlink" title="7. AI Agent 的应用前景"></a>7. AI Agent 的应用前景</h2><p>克服挑战的同时，AI Agent 的应用前景极其广阔：</p>
<ul>
<li><p>个性化超级助理： 管理邮件、日程、预订、购物、信息搜集，提供高度个性化的服务。</p>
</li>
<li><p>自动化工作流： 自动完成数据分析、报告生成、客户服务、软件测试、内容发布等复杂业务流程。</p>
</li>
<li><p>科学研究助手： 辅助进行文献调研、数据处理、实验设计、模拟计算。</p>
</li>
<li><p>智能教育与培训： 提供个性化辅导、自动答疑、模拟对话练习。</p>
</li>
<li><p>游戏与娱乐： 创造更智能、更有互动性的 NPC（非玩家角色）。</p>
</li>
<li><p>具身智能 (Embodied AI)： 与机器人技术结合，让 Agent 能够在物理世界中执行任务（如智能家居控制、自主导航）。</p>
</li>
<li><p>多智能体系统 (Multi-Agent Systems)： 多个 Agent 协同工作或竞争，解决更复杂的问题，模拟社会和经济系统。</p>
</li>
</ul>
<h2 id="8-未来趋势"><a href="#8-未来趋势" class="headerlink" title="8. 未来趋势"></a>8. 未来趋势</h2><ul>
<li><p>更强的推理与规划能力： LLM 核心能力的持续提升。</p>
</li>
<li><p>更丰富的工具生态与互操作性： 标准化的工具接口，Agent 能轻松调用更多服务。</p>
</li>
<li><p>更好的记忆与学习机制： 实现真正的持续学习和长期记忆。</p>
</li>
<li><p>多模态 Agent： 融合视觉、听觉等多种感知能力。</p>
</li>
<li><p>多 Agent 协作： Agent 之间能够交流、协调、分工合作。</p>
</li>
<li><p>安全性与对齐技术的进步： 确保 Agent 的发展可控、有益。</p>
</li>
</ul>
<h2 id="9-结论"><a href="#9-结论" class="headerlink" title="9. 结论"></a>9. 结论</h2><p>AI Agent 是人工智能从“感知智能”、“认知智能”迈向“行动智能”的关键一步。它以 LLM 为核心，整合了目标导向、环境感知、推理规划、行动执行和记忆学习等多方面能力，旨在创建能够自主完成复杂任务的智能实体。尽管目前仍面临诸多挑战，但 AI Agent 无疑代表了 AI 发展的未来方向，其潜力巨大，有望在不远的将来深刻改变我们的工作和生活方式。理解和掌握 AI Agent 的原理与实践，将是拥抱这场智能化变革的关键。</p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>AI-06-dify</title>
    <url>/posts/65143.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>AI-04-提示词工程</title>
    <url>/posts/34613.html</url>
    <content><![CDATA[<p>提示词工程</p>
<a id="more"></a>

<h2 id="什么是提示词工程"><a href="#什么是提示词工程" class="headerlink" title="什么是提示词工程"></a>什么是提示词工程</h2><p>提示词工程（Prompt Engineering）是一门较新的学科，专注于提示词的开发和优化，通过精心设计输入给大语言模型（LLM）的自然语言提示，来引导模型输出期望结果的技术和方法。它帮助用户将大语言模型应用于各种场景和研究领域。</p>
<p>研究人员可利用提示工程来提升大语言模型处理复杂任务场景的能力，如问答和算术推理能力。提示工程不仅关乎提示词设计，还包含了与大语言模型交互和研发的各种技能和技术。它在理解模型能力、提高模型安全性、增强模型功能等方面都起着关键作用，对研究人员和开发人员都具有重要价值。</p>
<blockquote>
<p>虽然现在大模型的发展非常迅速，出现了类似 DeepSeek R1 这样的推理模型，对于不是很懂提示词的用户也可以很好的完成任务，但即使如此，提示词工程仍然是非常重要的，尤其是在需要模型输出特定格式或结构的情况下。</p>
</blockquote>
<h2 id="大模型参数配置"><a href="#大模型参数配置" class="headerlink" title="大模型参数配置"></a>大模型参数配置</h2><p>除了提示词会直接影响大模型的输出之外，大模型的参数配置也会影响输出结果的多样性。我们可以在 OpenAI 的 API 中设置这些参数（playground 中也可以直接设置）。以下是使用不同 LLM 提供程序时会遇到的常见设置：</p>
<ul>
<li><p><code>Temperature（温度）</code>：简单来说，temperature 的参数值越小，模型就会返回越确定的一个结果。如果调高该参数值，大语言模型可能会返回更随机的结果，也就是说这可能会带来更多样化或更具创造性的产出。对于质量保障（QA）等任务，我们可以设置更低的 temperature 值，以促使模型基于事实返回更真实和简洁的结果。对于诗歌生成或其他创造性任务，适度地调高 temperature 参数值可能会更好。</p>
</li>
<li><p><code>Top_p</code>：可以用来控制模型返回结果的确定性，和温度类似。如果你需要准确和事实的答案，就把参数值调低。如果你在寻找更多样化的响应，可以将其值调高点。</p>
</li>
</ul>
<blockquote>
<p>一般建议是改变 <code>Temperature</code> 和 <code>Top_p</code> 其中一个参数就行，不用两个都调整。</p>
</blockquote>
<ul>
<li><p><code>Max Length</code>：您可以通过调整 max length 来控制大模型生成的 token 数。指定 Max Length 有助于防止大模型生成冗长或不相关的响应并控制成本。</p>
</li>
<li><p><code>Stop Sequences</code>：stop sequence 是一个字符串，可以阻止模型生成 token，指定 stop sequences 是控制大模型响应长度和结构的另一种方法。例如可以添加 <code>11</code> 作为 stop sequence 来告诉模型生成不超过 10 个项的列表。</p>
</li>
<li><p><code>Frequency Penalty</code>：frequency penalty 是对下一个生成的 token 进行惩罚，这个惩罚和 token 在响应和提示中已出现的次数成比例， frequency penalty 越高，某个词再次出现的可能性就越小，这个设置通过给 重复数量多的 Token 设置更高的惩罚来减少响应中单词的重复。</p>
</li>
<li><p><code>Presence Penalty</code>：presence penalty 也是对重复的 token 施加惩罚，但与 frequency penalty 不同的是，惩罚对于所有重复 token 都是相同的。出现两次的 token 和出现 10 次的 token 会受到相同的惩罚。此设置可防止模型在响应中过于频繁地生成重复的词。如果您希望模型生成多样化或创造性的文本，您可以设置更高的 presence penalty，如果您希望模型生成更专注的内容，您可以设置更低的 presence penalty。</p>
</li>
</ul>
<blockquote>
<p>与 <code>temperature</code> 和 <code>top_p</code> 一样，一般建议是改变 <code>frequency penalty</code> 和 <code>presence penalty</code> 其中一个参数就行，不要同时调整两个。</p>
</blockquote>
<p>当然不同的模型可能会有不同的参数，所以需要根据实际情况来调整。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>一个提示词可以包含你传递到模型的指令或问题等信息，也可以包含其他详细信息，如上下文、输入或示例等。你可以通过这些元素来更好地指导模型，并因此获得更好的结果。</p>
<p>看下面一个简单的示例：</p>
<p>不同的模型表现结果可能不同，这里以 OpenAI 的 gpt-3.5-turbo 为例。现在新版本模型能力更强，这里以旧版本为例。</p>
<p>提示词：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The sky is</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">blue.</span><br></pre></td></tr></table></figure>

<p>如果使用 OpenAI Playground，我们可以按照下图方式设置参数：</p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/image-20250517232242456.png" alt="image-20250517232242456"></p>
<p>当我们使用 OpenAI 的聊天模型时，我们可以使用三个不同的角色来构建 prompt： <code>system</code>、<code>user</code> 和 <code>assistant</code>。</p>
<ul>
<li><p>其中 <code>system</code> 不是必需的，但有助于设定 <code>assistant</code> 的整体行为，帮助模型了解用户的需求，并根据这些需求提供相应的响应。</p>
</li>
<li><p>上面的示例仅包含一条 <code>user</code> 消息，你可以使用 <code>user</code> 消息直接作为 prompt。</p>
</li>
<li><p><code>assistant</code> 的消息是模型的响应。你还可以定义 <code>assistant</code> 消息来传递模型所需行为的示例。</p>
</li>
</ul>
<p>从上面的示例中可以看出，LLM 可以基于我们给出的上下文内容 <code>The sky is</code> 完成续写。当然输出结果可能符合你的预期，也可能不符合你的预期。因为我们并没有提供更多的上下文信息或者明确指示模型要做什么，而这正是提示工程的核心所在。</p>
<p>我们可以尝试来改进一下：</p>
<p>提示词：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Complete the sentence:</span><br><span class="line">The sky is</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">blue during the day and dark at night.</span><br></pre></td></tr></table></figure>

<p>结果是不是要好一些了？这里我们告诉模型去完善句子，因此输出结果看起来要好得多，因为它完全按照你告诉它要做的（“完善句子”）去做。这种<strong>设计有效的提示词以指导模型执行期望任务的方法被称为提示工程</strong>。</p>
<p>以上示例基本说明了现阶段的大语言模型能够发挥的功能作用。它们可以用于执行各种高级任务，如文本概括、数学推理、代码生成等。</p>
<h3 id="提示词格式"><a href="#提示词格式" class="headerlink" title="提示词格式"></a>提示词格式</h3><p>标准的提示词应该遵循以下格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;问题&gt;?</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;指令&gt;</span><br></pre></td></tr></table></figure>

<p>你可以将其格式化为问答（QA）格式，这在许多问答数据集中是标准格式，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Q: &lt;问题&gt;?</span><br><span class="line">A:</span><br></pre></td></tr></table></figure>

<p>上面这样的提示词，也被称作<strong>零样本提示词</strong>，即你直接提示模型给出一个回答，而没有提供任何关于你希望它完成的任务的示例。一些大型语言模型具备进行零样本提示的能力，但这取决于手头任务的复杂性和知识，以及模型被训练以在其上表现良好的任务。</p>
<p>比如下面的提示词：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Q: What is prompt engineering?</span><br></pre></td></tr></table></figure>

<p>对于一些较新的模型，你可以省略“Q:”部分，因为模型会根据序列（译注：输入的提示词）的构成将其理解为问答任务。换句话说，提示可以简化如下：</p>
<p>提示词：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">What is prompt engineering?</span><br></pre></td></tr></table></figure>

<p>基于以上标准格式，一种流行且有效的提示词技术被称为<strong>少样本提示</strong>，你可以按照以下格式组织少样本提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;问题&gt;?</span><br><span class="line">&lt;答案&gt;</span><br><span class="line">&lt;问题&gt;?</span><br><span class="line">&lt;答案&gt;</span><br><span class="line">&lt;问题&gt;?</span><br><span class="line">&lt;答案&gt;</span><br><span class="line">&lt;问题&gt;?</span><br></pre></td></tr></table></figure>

<p>问答格式的版本看起来像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Q: &lt;问题&gt;?</span><br><span class="line">A: &lt;答案&gt;</span><br><span class="line">Q: &lt;问题&gt;?</span><br><span class="line">A: &lt;答案&gt;</span><br><span class="line">Q: &lt;问题&gt;?</span><br><span class="line">A: &lt;答案&gt;</span><br><span class="line">Q: &lt;问题&gt;?</span><br><span class="line">A:</span><br></pre></td></tr></table></figure>

<p>当然使用问答格式并非必须的，只是为了方便理解。</p>
<p>LLM 可以基于一些说明了解和学习某些任务，而小样本提示正好可以赋能上下文学习能力。</p>
<h2 id="提示词的基本结构"><a href="#提示词的基本结构" class="headerlink" title="提示词的基本结构"></a>提示词的基本结构</h2><p>提示词通常包含以下几个部分（ICIO 框架）：</p>
<h3 id="指令（Instruction）"><a href="#指令（Instruction）" class="headerlink" title="指令（Instruction）"></a>指令（Instruction）</h3><ul>
<li><p>明确告诉模型要做什么。</p>
</li>
<li><p>示例：“请用 Python 写一个冒泡排序函数。”</p>
</li>
</ul>
<h3 id="上下文（Context）"><a href="#上下文（Context）" class="headerlink" title="上下文（Context）"></a>上下文（Context）</h3><ul>
<li><p>提供必要的背景信息，帮助模型理解任务。</p>
</li>
<li><p>示例：“你是一名资深的前端开发工程师。”</p>
</li>
</ul>
<h3 id="输入数据（Input-Data）"><a href="#输入数据（Input-Data）" class="headerlink" title="输入数据（Input Data）"></a>输入数据（Input Data）</h3><ul>
<li><p>需要模型处理的具体内容。</p>
</li>
<li><p>示例：“对以下文本进行摘要：……”</p>
</li>
</ul>
<h3 id="输出格式（Output-Format）"><a href="#输出格式（Output-Format）" class="headerlink" title="输出格式（Output Format）"></a>输出格式（Output Format）</h3><ul>
<li><p>指定希望得到的输出结构或风格。</p>
</li>
<li><p>示例：“请以 JSON 格式输出。”</p>
</li>
</ul>
<h3 id="示例（Examples）"><a href="#示例（Examples）" class="headerlink" title="示例（Examples）"></a>示例（Examples）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">请将文本分为中性、否定或肯定</span><br><span class="line">文本：我觉得食物还可以。</span><br><span class="line">情绪：</span><br></pre></td></tr></table></figure>

<p>在上面的提示词中，指令是“将文本分类为中性、否定或肯定”。输入数据是“我觉得食物还可以”，使用的输出指示是“情绪：”。这里我们没有使用上下文，但也可以作为提示词的一部分提供。</p>
<p>提示词所需的格式取决于你想要语言模型完成的任务类型，并非所有以上要素都是必须的。</p>
<h2 id="提示词通用技巧"><a href="#提示词通用技巧" class="headerlink" title="提示词通用技巧"></a>提示词通用技巧</h2><p>我们在设计提示词的时候，需要记住一些技巧，这些技巧可以帮助我们更好地设计提示词，从而获得更好的结果。</p>
<h3 id="从简单开始"><a href="#从简单开始" class="headerlink" title="从简单开始"></a>从简单开始</h3><p>在开始设计提示词时，需要注意这并不是一个一蹴而就的过程，需要大量的实验才能获得最佳结果。</p>
<p>你可以从简单的提示词开始，并逐渐添加更多元素和上下文（因为你想要更好的结果）。因此，在这个过程中不断迭代你的提示词是至关重要的。</p>
<p>当你有一个涉及许多不同子任务的复杂任务时，可以尝试将任务分解为更简单的子任务，并随着结果的改善逐步构建。避免一开始就添加过多的复杂性。</p>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>你可以使用命令来指示模型执行各种简单任务，例如“写入”、“分类”、“总结”、“翻译”、“排序”等，从而为各种简单任务设计有效的提示。</p>
<p>当然还需要进行大量实验以找出最有效的方法，以不同的关键词（keywords），上下文（contexts）和数据（data）试验不同的指令（instruction），看看什么样是最适合你特定用例和任务的。通常，上下文越具体和跟任务越相关则效果越好。</p>
<p>有些人建议将指令放在提示词的开头，也有人建议是使用像 <code>###</code> 这样的清晰分隔符来分隔指令和上下文，当然都可以</p>
<p>例如下面的提示词：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 指令 ###</span></span><br><span class="line">将以下文本翻译成西班牙语：</span><br><span class="line">文本：“hello！”</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">¡Hola!</span><br></pre></td></tr></table></figure>

<h3 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h3><p>要非常具体地说明你希望模型执行的指令和任务。提示词越具体详细，结果越好。特别是当你对生成的结果或风格有要求时，这一点尤为重要。不存在什么特定的词元（tokens）或关键词（tokens）能确定带来更好的结果。更重要的是要有一个具有良好格式和描述性的提示词。事实上，在提示中提供示例对于获得特定格式的期望输出非常有效。</p>
<p>在设计提示词时，还应注意提示词的长度，因为提示词的长度是有限制的。包含太多不必要的细节不一定是好的方法。这是你需要进行大量实验的事情。我们鼓励大量实验和迭代，以优化适用于你应用的提示词。</p>
<p>比如现在我们需要从一段文本中提取指定信息。我们可以使用下面的提示词：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">提取以下文本中的地名。</span><br><span class="line"></span><br><span class="line">所需格式：</span><br><span class="line">地点：&lt;逗号分隔的公司名称列表&gt;</span><br><span class="line">输入：“虽然这些发展对研究人员来说是令人鼓舞的，但仍有许多谜团。里斯本未知的香帕利莫德中心的神经免疫学家 Henrique Veiga-Fernandes 说：“我们经常在大脑和我们在周围看到的效果之间有一个黑匣子。”“如果我们想在治疗背景下使用它，我们实际上需要了解机制。””</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">地点：里斯本，香帕利莫德中心</span><br></pre></td></tr></table></figure>

<p>通常具体的表达会更好，这就像沟通一样 — 越直接，信息传达得就越清晰。</p>
<p>比如现在我们需要解释提示工程的概念，我们可以使用下面的提示词：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">解释提示工程的概念。保持解释简短，只有几句话，不要过于描述。</span><br></pre></td></tr></table></figure>

<p>上面的提示词中的“只有几句话”就属于不明确的部分，虽然通过该提示词我们也可能会得到较好的响应，但更好的提示应当是非常具体、简洁并且切中要点的。</p>
<p>更好的提示词应该是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">使用 2-3 句话向高中学生解释提示工程的概念。</span><br></pre></td></tr></table></figure>

<p>这里我们明确告诉模型要使用 2-3 句话，并且向高中学生解释，这样模型就会更加明确地知道我们要什么。</p>
<p>上述示例中的一些内容摘自 <a href="https://help.openai.com/en/articles/6654000-best-practices-for-prompt-engineering-with-openai-api">Best practices for prompt engineering with OpenAI API</a> 文章。</p>
<hr>
<p>前面我们了解了提示词工程的基本概念，接下来我们来介绍下一些具体的常见提示词工程技术。</p>
<h2 id="样本提示"><a href="#样本提示" class="headerlink" title="样本提示"></a>样本提示</h2><p>样本提示是指在向大模型提出请求时，提供不同数量的示例来引导模型理解并执行任务的技术。根据提供示例的数量，可以将样本提示分为三种主要类型：零样本提示、单样本提示和多样本提示。</p>
<p>样本提示的核心思想是：通过向模型展示任务的具体案例，使其更准确地理解用户意图，从而产生更符合预期的结果。</p>
<h3 id="零样本（Zero-shot）"><a href="#零样本（Zero-shot）" class="headerlink" title="零样本（Zero-shot）"></a>零样本（Zero-shot）</h3><p>零样本提示不需要任何示例数据，只需要一个简单的提示词，就可以让模型完成任务，这是因为大模型在训练过程中已经接触了大量的数据，具备了一定的理解能力。</p>
<p>比如下面的提示词：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">请将以下句子翻译成英文：</span><br><span class="line"><span class="string">&quot;人工智能正在改变世界。&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Artificial intelligence is changing the world.</span><br></pre></td></tr></table></figure>

<p>可以看到在提示词中我们并没有提供任何示例，模型根据提示词，成功将句子翻译成了英文。</p>
<p>这样的提示词：</p>
<ul>
<li>最简洁直接</li>
<li>依赖模型预训练能力</li>
<li>适用于简单、常见任务</li>
<li>无需准备示例数据</li>
</ul>
<h3 id="单样本（One-shot）"><a href="#单样本（One-shot）" class="headerlink" title="单样本（One-shot）"></a>单样本（One-shot）</h3><p>单样本提示词需要提供一个示例，向模型展示如何完成任务，然后请求模型以相同方式处理新输入。</p>
<p>比如下面的提示词示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">以下是将中文翻译成英文的例子：</span><br><span class="line"></span><br><span class="line">中文：<span class="string">&quot;我喜欢学习人工智能。&quot;</span></span><br><span class="line">英文：<span class="string">&quot;I like learning AI.&quot;</span></span><br><span class="line"></span><br><span class="line">请按照上面的例子，翻译以下句子：</span><br><span class="line">中文：<span class="string">&quot;人工智能正在改变世界。&quot;</span></span><br><span class="line">英文：</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">英文：<span class="string">&quot;AI is changing the world.&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以看到在提示词中我们提供了一个示例，我们特别的将<strong>人工智能</strong>翻译成了<strong>AI</strong>，所以最后我们得到的输出是<strong>AI is changing the world.**，如果不加这个示例，那么模型大概率会将 AI 翻译成 **Artificial Intelligence</strong>。</p>
<p>这样的提示词：</p>
<ul>
<li>为模型提供任务模式的基本示范</li>
<li>适合较为复杂但仍属模型熟悉领域的任务</li>
<li>减少了模型理解任务的歧义性</li>
<li>可引导特定的输出格式</li>
</ul>
<h3 id="多样本（Few-shot）"><a href="#多样本（Few-shot）" class="headerlink" title="多样本（Few-shot）"></a>多样本（Few-shot）</h3><p>多样本提示词需要提供多个（通常 2-5 个）任务示例，帮助模型识别任务模式和规律，再请求完成新任务，这种通常是单样本提示词不能很好理解意图时使用。</p>
<p>比如下面的提示词示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">以下是判断评论是否违反社区规范的例子：</span><br><span class="line"></span><br><span class="line">评论：<span class="string">&quot;这个服务太差了，客服完全不专业。&quot;</span></span><br><span class="line">判断：不违规（表达负面意见但没有攻击性语言）</span><br><span class="line"></span><br><span class="line">评论：<span class="string">&quot;这个产品真的很糟糕，我想把它扔出窗外！&quot;</span></span><br><span class="line">判断：</span><br></pre></td></tr></table></figure>

<p>这个提示词可能的输出结果是不违规，因为它看起来与示例相似（都是表达强烈不满）。</p>
<p>但是这还不够，因为示例中并没有表达强烈不满的例子，所以我们可以再多提供几个示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">以下是判断评论是否违反社区规范的例子：</span><br><span class="line"></span><br><span class="line">评论：<span class="string">&quot;这个服务太差了，客服完全不专业。&quot;</span></span><br><span class="line">判断：不违规（表达负面意见但没有攻击性语言）</span><br><span class="line"></span><br><span class="line">评论：<span class="string">&quot;我恨这个软件，它毁了我的文件！&quot;</span></span><br><span class="line">判断：不违规（表达强烈情绪但针对产品）</span><br><span class="line"></span><br><span class="line">评论：<span class="string">&quot;开发人员应该被解雇，他们都是废物。&quot;</span></span><br><span class="line">判断：违规（针对人的侮辱性言论）</span><br><span class="line"></span><br><span class="line">评论：<span class="string">&quot;如果产品再不改进，我要去公司总部抗议。&quot;</span></span><br><span class="line">判断：不违规（表达不满但没有直接威胁）</span><br><span class="line"></span><br><span class="line">评论：<span class="string">&quot;这个产品真的很糟糕，我想把它扔出窗外！&quot;</span></span><br><span class="line">判断：</span><br></pre></td></tr></table></figure>

<p>这样模型能更准确地判断为”不违规”，因为多个例子帮助它理解：针对产品的强烈情绪表达是允许的，只有针对人的攻击才算违规。</p>
<p>这样的提示词：</p>
<ul>
<li>多个示例帮助模型识别任务模式</li>
<li>适合复杂任务、特定领域任务</li>
<li>可引导模型学习特定风格或格式</li>
<li>在数据效率与性能之间取得平衡</li>
</ul>
<h3 id="不同场景下的最佳选择"><a href="#不同场景下的最佳选择" class="headerlink" title="不同场景下的最佳选择"></a>不同场景下的最佳选择</h3><p>在实际使用中，我们应该根据任务的复杂程度、数据量、模型能力等因素来选择合适的提示词类型。</p>
<p><strong>适合零样本提示的场景</strong></p>
<ul>
<li>基础通用任务：翻译、摘要、简单问答</li>
<li>模型原生擅长的任务：基本文本分类、情感分析</li>
<li>资源受限情况：需要节省 token 消耗时</li>
<li>示例：解释什么是人工智能？</li>
</ul>
<p><strong>适合单样本提示的场景</strong></p>
<ul>
<li>特定格式输出：需要模型遵循特定输出结构</li>
<li>风格引导：需要特定写作风格或语气</li>
<li>中等复杂度任务：逻辑分析、解释推理</li>
<li>示例：这是一个技术解释例子：问题：”什么是 API？”，解答：”API 是应用程序接口的缩写，它允许不同软件组件之间进行通信。”。现在请解释：什么是神经网络？</li>
</ul>
<p><strong>适合多样本提示的场景</strong></p>
<ul>
<li>复杂推理任务：需要多步骤逻辑思考</li>
<li>专业领域任务：法律、医学、科学等专业内容</li>
<li>明确模式识别：需要模型从多个示例中学习模式</li>
<li>数据转换：特殊格式之间的转换（如 HTML 到 JSON）</li>
<li>示例：将以下医学术语解释成普通人能理解的语言：例 1：术语”高血压”→ 解释：”血压持续高于正常范围的状态，可能导致心脏和血管问题”。例 2：术语”糖尿病”→ 解释：”身体无法正常产生或使用胰岛素的代谢疾病，导致血糖水平异常”。现在请解释：术语”心肌梗塞”→ 解释：</li>
</ul>
<h2 id="思维链（Chain-of-Thought）"><a href="#思维链（Chain-of-Thought）" class="headerlink" title="思维链（Chain of Thought）"></a>思维链（Chain of Thought）</h2><p>思维链提示词是一种通过逐步推理来解决问题的提示词技术。它要求模型在回答问题之前，先进行一系列的推理步骤，从而逐步构建出最终的答案。可以将其与少样本提示相结合，以获得更好的结果，以便在回答之前进行推理的更复杂的任务。</p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/image-20250517232328960.png" alt="image-20250517232328960"></p>
<blockquote>
<p>思维链提示词的核心理念是：<strong>让模型像人类一样，一步步思考问题，而不是直接跳到结论。</strong></p>
</blockquote>
<h3 id="零样本思维链"><a href="#零样本思维链" class="headerlink" title="零样本思维链"></a>零样本思维链</h3><p>通过简单添加<strong>让我们一步步思考</strong>这样的短语，引导模型展开推理过程。</p>
<p>比如下面的提示词：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">我去市场买了10个苹果。我给了邻居2个苹果和修理工2个苹果。然后我去买了5个苹果并吃了1个。我还剩下多少苹果？</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">11个苹果</span><br></pre></td></tr></table></figure>

<p>这个答案是不正确的！如果我们在提示词里面添加<strong>让我们一步步思考</strong>，那么看看结果呢：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">我去市场买了10个苹果。我给了邻居2个苹果和修理工2个苹果。然后我去买了5个苹果并吃了1个。我还剩下多少苹果？</span><br><span class="line">让我们一步步思考。</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">好的，我们一步步来分析：</span><br><span class="line"></span><br><span class="line">1. **最初买了10个苹果**，所以你一开始有10个苹果。</span><br><span class="line"></span><br><span class="line">2. **给了邻居2个苹果**，这时剩下的苹果数量是：</span><br><span class="line">   10 - 2 = 8个苹果。</span><br><span class="line"></span><br><span class="line">3. **给了修理工2个苹果**，再减去这2个苹果：</span><br><span class="line">   8 - 2 = 6个苹果。</span><br><span class="line"></span><br><span class="line">4. **去买了5个苹果**，加上这5个苹果：</span><br><span class="line">   6 + 5 = 11个苹果。</span><br><span class="line"></span><br><span class="line">5. **吃了1个苹果**，最后剩下的苹果数量是：</span><br><span class="line">   11 - 1 = 10个苹果。</span><br><span class="line"></span><br><span class="line">所以，你最后剩下了10个苹果。</span><br></pre></td></tr></table></figure>

<p>我们可以看到输出结果基本上按照人类思考的方式一步一步的进行推理，从而得到正确的答案。这个简单的提示在没有太多示例可用时特别有用。</p>
<h3 id="少样本思维链"><a href="#少样本思维链" class="headerlink" title="少样本思维链"></a>少样本思维链</h3><p>同样我们还可以使用少样本思维链提示词，向模型展示如何完成任务，然后请求模型以相同方式处理新输入。</p>
<p>比如下面的提示词：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">问题：小明有5个苹果，他吃了2个，又买了3个。现在他有几个苹果？</span><br><span class="line">思考：小明开始有5个苹果，吃了2个后剩下5-2=3个苹果，然后又买了3个，所以现在有3+3=6个苹果。</span><br><span class="line">答案：6个苹果</span><br><span class="line"></span><br><span class="line">问题：一个农场有27只动物，包括鸡和兔子。如果总共有74只脚，那么农场里有多少只鸡和多少只兔子？</span><br><span class="line">思考：</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">思考：农场有27只动物，其中包括鸡和兔子。鸡有2只脚，兔子有4只脚。设鸡的数量为x，兔子的数量为y。我们有两个条件：</span><br><span class="line"></span><br><span class="line">1. x + y = 27（总共27只动物）</span><br><span class="line">2. 2x + 4y = 74（总共有74只脚）</span><br><span class="line"></span><br><span class="line">通过解这两个方程，得出鸡有17只，兔子有10只。</span><br><span class="line"></span><br><span class="line">答案：鸡有17只，兔子有10只。</span><br></pre></td></tr></table></figure>

<p>我们可以看到对于更复杂的任务，少样本思维链提示词可以更好的引导模型进行推理，从而得到正确的答案。</p>
<h3 id="思维链提示词的优势"><a href="#思维链提示词的优势" class="headerlink" title="思维链提示词的优势"></a>思维链提示词的优势</h3><ul>
<li>提高复杂问题的准确性：通过分步推理，减少”思维跳跃”导致的错误</li>
<li>增强模型解释性：使模型的思考过程可见，便于检查错误或理解决策依据</li>
<li>处理多步骤任务：适合需要按顺序完成多个步骤的问题</li>
<li>提升抽象推理能力：改善模型在数学、逻辑和概念性问题上的表现</li>
</ul>
<h3 id="思维链提示词的具体应用场景"><a href="#思维链提示词的具体应用场景" class="headerlink" title="思维链提示词的具体应用场景"></a>思维链提示词的具体应用场景</h3><ul>
<li>数学问题求解：方程求解、几何问题、概率统计等<br>程序设计与调试：逐步分析代码逻辑，找出错误<br>逻辑推理与分析：法律案例分析、科学实验设计分析<br>决策制定与评估：商业决策分析、风险评估<br>文本理解与评论：深度阅读理解、文学评论、论文摘要</li>
</ul>
<h3 id="设计有效思维链提示词的关键技巧"><a href="#设计有效思维链提示词的关键技巧" class="headerlink" title="设计有效思维链提示词的关键技巧"></a>设计有效思维链提示词的关键技巧</h3><p><strong>明确分步指示</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">分析以下数学问题，并通过以下步骤解决：</span><br><span class="line">1. 确定已知条件和未知量</span><br><span class="line">2. 建立方程</span><br><span class="line">3. 求解方程</span><br><span class="line">4. 验证结果</span><br><span class="line">5. 给出最终答案</span><br><span class="line"></span><br><span class="line">问题：如果一个长方形的长是宽的2倍，且周长为30厘米，求这个长方形的面积。</span><br></pre></td></tr></table></figure>

<p><strong>使用思考标记</strong></p>
<p>通过明确指示<strong>思考：</strong>和<strong>答案：</strong>来分隔推理过程和最终结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">问题：判断√2是有理数还是无理数？</span><br><span class="line">思考：</span><br><span class="line">答案：</span><br></pre></td></tr></table></figure>

<p><strong>自问自答引导</strong></p>
<p>引导模型通过提问的方式，一步步展开推理。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">问题：判断以下三段式推理是否有效。</span><br><span class="line">所有猫都是哺乳动物。</span><br><span class="line">所有哺乳动物都需要氧气。</span><br><span class="line">因此，所有猫都需要氧气。</span><br><span class="line"></span><br><span class="line">分析：</span><br><span class="line">1. 这个推理有什么前提？</span><br><span class="line">2. 这些前提之间有什么关系？</span><br><span class="line">3. 结论是如何从前提推导出来的？</span><br><span class="line">4. 这个推理符合逻辑规则吗？</span><br><span class="line">5. 最终判断：</span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">问题：评估以下论点的合理性。</span><br><span class="line"><span class="string">&quot;既然所有成功的企业家都非常勤奋，而张先生非常勤奋，那么张先生一定会成为一个成功的企业家。&quot;</span></span><br><span class="line"></span><br><span class="line">思考过程：</span><br><span class="line">1. 分析论点结构：</span><br><span class="line">   - 前提1：所有成功的企业家都非常勤奋</span><br><span class="line">   - 前提2：张先生非常勤奋</span><br><span class="line">   - 结论：张先生一定会成为一个成功的企业家</span><br><span class="line"></span><br><span class="line">2. 逻辑关系分析：</span><br><span class="line">   - 如果用A表示<span class="string">&quot;成功的企业家&quot;</span>，B表示<span class="string">&quot;非常勤奋的人&quot;</span></span><br><span class="line">   - 前提1表达的是A→B（如果是A，那么是B）</span><br><span class="line">   - 前提2表达的是<span class="string">&quot;张先生属于B&quot;</span></span><br><span class="line">   - 结论表达的是<span class="string">&quot;张先生属于A&quot;</span></span><br><span class="line"></span><br><span class="line">3. 评估推理有效性：</span><br><span class="line">   - 这是一个典型的肯定后件谬误</span><br><span class="line">   - 从<span class="string">&quot;如果是A，那么是B&quot;</span>和<span class="string">&quot;是B&quot;</span>，不能推出<span class="string">&quot;是A&quot;</span></span><br><span class="line">   - 举例说明：所有鸟都会呼吸，张先生会呼吸，但我们不能因此推断张先生是鸟</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">思考过程：</span><br><span class="line">1. **分析论点结构**：</span><br><span class="line">   - 前提1：所有成功的企业家都非常勤奋</span><br><span class="line">   - 前提2：张先生非常勤奋</span><br><span class="line">   - 结论：张先生一定会成为一个成功的企业家</span><br><span class="line"></span><br><span class="line">2. **逻辑关系分析**：</span><br><span class="line">   - 如果用A表示<span class="string">&quot;成功的企业家&quot;</span>，B表示<span class="string">&quot;非常勤奋的人&quot;</span></span><br><span class="line">   - 前提1的意思是A → B（如果是成功的企业家，那么这个人一定非常勤奋）</span><br><span class="line">   - 前提2表示张先生是B（即张先生非常勤奋）</span><br><span class="line">   - 结论试图推出张先生是A（即张先生是一个成功的企业家）</span><br><span class="line"></span><br><span class="line">3. **评估推理有效性**：</span><br><span class="line">   - 这是一个典型的**肯定后件谬误**（Affirming the Consequent）</span><br><span class="line">   - 从“如果是A，那么是B”以及“是B”这一点，不能得出“是A”</span><br><span class="line">   - 举例说明：所有鸟都会飞，张先生会飞，但我们不能因此推断张先生是鸟。</span><br><span class="line"></span><br><span class="line">4. **结论**：</span><br><span class="line">   - 论点是不合理的，因为推理存在逻辑错误。尽管所有成功的企业家都非常勤奋，但“非常勤奋”并不意味着一定会成为“成功的企业家”。成功的企业家还需要其他因素，而仅仅有勤奋无法保证成功。</span><br></pre></td></tr></table></figure>

<h3 id="思维链提示词的局限性"><a href="#思维链提示词的局限性" class="headerlink" title="思维链提示词的局限性"></a>思维链提示词的局限性</h3><p>思维链提示词虽然可以提高模型的推理能力，但是也有一些局限性：</p>
<ul>
<li>输出长度增加：思维链会显著增加模型输出的长度</li>
<li>可能引入新错误：推理过程本身可能包含错误</li>
<li>不适合所有问题：简单直接的问题可能不需要详细推理</li>
<li>依赖于模型能力：模型能力有限时，思维链可能无法提高准确性</li>
</ul>
<h3 id="进阶技巧"><a href="#进阶技巧" class="headerlink" title="进阶技巧"></a>进阶技巧</h3><p><strong>思维链+自我批评</strong></p>
<p>引导模型先给出推理，然后自我审视和修正。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">解决以下问题，先给出你的思考过程，然后检查你的推理是否有错误，如有必要请修正。</span><br><span class="line"></span><br><span class="line">问题：一个水箱，底面积是3平方米，高2米。现在注入了4立方米的水，水箱装满了吗？</span><br></pre></td></tr></table></figure>

<p><strong>思维链+角色扮演</strong></p>
<p>让模型扮演特定角色进行推理，可以获得更专业或更符合特定领域的思考过程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">你是一位经验丰富的经济学家。分析以下经济政策可能带来的影响，请详细展示你的分析思路。</span><br><span class="line"></span><br><span class="line">政策：中央银行决定将基准利率上调0.5个百分点。</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>思维链提示词提升了 LLM 复杂问题处理能力。通过引导模型展示其推理过程，我们可以获得更准确、更可解释的结果。掌握思维链提示词技术，将帮助你更有效地利用大语言模型解决各类复杂问题。</p>
<p>最佳的思维链提示词应当清晰、结构化，且与具体问题类型相匹配，并不断实践和调整。</p>
<h2 id="结构化提示词"><a href="#结构化提示词" class="headerlink" title="结构化提示词"></a>结构化提示词</h2><p>结构化的思想很普遍，结构化内容也很普遍，我们日常写作的文章，看到的书籍都在使用标题、子标题、段落、句子等语法结构。结构化提示词（LangGPT）的思想通俗点来说就是<strong>像写文章一样写提示词</strong>。</p>
<p>GitHub 地址：<a href="https://github.com/langgptai/LangGPT%E3%80%82">https://github.com/langgptai/LangGPT。</a></p>
<p>为了阅读、表达的方便，我们日常有各种写作的模板，用来控制内容的组织呈现形式。例如古代的八股文、现代的简历模板、学生实验报告模板、论文模板等等模板。所以结构化编写 Prompt 自然也有各种各样优质的模板帮助你把 Prompt 写的更轻松、性能更好。所以写结构化 Prompt 可以有各种各样的模板，你可以像用 PPT 模板一样选择或创造自己喜欢的模板。</p>
<p>在这之前，虽然也有类似结构化思想，但是更多体现在思维上，缺乏在 prompt 上的具体体现。</p>
<h3 id="CRISPE-框架"><a href="#CRISPE-框架" class="headerlink" title="CRISPE 框架"></a>CRISPE 框架</h3><p>例如知名的 CRISPE 框架，CRISPE 分别代表以下含义：</p>
<ul>
<li>CR：Capacity and Role（能力与角色）。你希望 ChatGPT 扮演怎样的角色。</li>
<li>I：Insight（洞察力），背景信息和上下文（坦率说来我觉得用 Context 更好）。</li>
<li>S：Statement（指令），你希望 ChatGPT 做什么。</li>
<li>P：Personality（个性），你希望 ChatGPT 以什么风格或方式回答你。</li>
<li>E：Experiment（尝试），要求 ChatGPT 为你提供多个答案。</li>
</ul>
<p><code>CRISPE</code> 框架更注重 AI 的角色和背景，它特别适用于那些需要 AI 扮演特定角色或在特定背景下完成任务的场景。</p>
<p>比如下面的提示词：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Capacity and Role</span></span><br><span class="line">描述：我希望你扮演一名经验丰富的小学数学老师。</span><br><span class="line">特点：具备耐心和鼓励性的教学风格，能够简单明了地解释数学概念。</span><br><span class="line"><span class="comment"># Insight</span></span><br><span class="line">学生信息：你将为我的10岁的儿子提供帮助，他目前正在学习小学四年级的数学。</span><br><span class="line">学习环境：他在家中进行在线学习，有时会遇到一些数学问题需要帮助。</span><br><span class="line"><span class="comment"># Statement</span></span><br><span class="line">描述：请帮助解答以下数学问题，并提供解题步骤。</span><br><span class="line">重要性：确保解答方法适合10岁儿童的理解能力。</span><br><span class="line"><span class="comment"># Personality</span></span><br><span class="line">风格：友好、鼓励性，使用简单易懂的语言。</span><br><span class="line">示例：可以使用实际生活中的例子来解释数学概念。</span><br><span class="line"><span class="comment"># Experiment</span></span><br><span class="line">描述：如果可能，请为每个问题提供两种不同的解题方法。</span><br><span class="line">目的：增强孩子的数学思维和解题能力。</span><br></pre></td></tr></table></figure>

<p>这类思维框架只呈现了提示词的内容框架，但没有提供模板化、结构化的提示词形式。</p>
<h3 id="结构化提示词使用"><a href="#结构化提示词使用" class="headerlink" title="结构化提示词使用"></a>结构化提示词使用</h3><p>而结构化提示词则可以提供模板化、结构化的提示词形式，帮助你更轻松的写出更好的提示词。</p>
<p>比如下面的提示词：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Role: 诗人</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Profile</span></span><br><span class="line"></span><br><span class="line">- Author: YZFly</span><br><span class="line">- Version: 1.0</span><br><span class="line">- Language: 中文</span><br><span class="line">- Description: 诗人是创作诗歌的艺术家，擅长通过诗歌来表达情感、描绘景象、讲述故事，具有丰富的想象力和对文字的独特驾驭能力。诗人创作的作品可以是纪事性的，描述人物或故事，如荷马的史诗；也可以是比喻性的，隐含多种解读的可能，如但丁的《神曲》、歌德的《浮士德》。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 擅长写现代诗:</span></span><br><span class="line">1. 现代诗形式自由，意涵丰富，意象经营重于修辞运用，是心灵的映现</span><br><span class="line">2. 更加强调自由开放和直率陈述与进行“可感与不可感之间”的沟通。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 擅长写七言律诗</span></span><br><span class="line">1. 七言体是古代诗歌体裁</span><br><span class="line">2. 全篇每句七字或以七字句为主的诗体</span><br><span class="line">3. 它起于汉族民间歌谣</span><br><span class="line"></span><br><span class="line"><span class="comment">### 擅长写五言诗</span></span><br><span class="line">1. 全篇由五字句构成的诗</span><br><span class="line">2. 能够更灵活细致地抒情和叙事</span><br><span class="line">3. 在音节上，奇偶相配，富于音乐美</span><br><span class="line"></span><br><span class="line"><span class="comment">## Rules</span></span><br><span class="line">1. 内容健康，积极向上</span><br><span class="line">2. 七言律诗和五言诗要押韵</span><br><span class="line"></span><br><span class="line"><span class="comment">## Workflow</span></span><br><span class="line">1. 让用户以 <span class="string">&quot;形式：[], 主题：[]&quot;</span> 的方式指定诗歌形式，主题。</span><br><span class="line">2. 针对用户给定的主题，创作诗歌，包括题目和诗句。</span><br><span class="line"></span><br><span class="line"><span class="comment">## Initialization</span></span><br><span class="line">作为角色 &lt;Role&gt;, 严格遵守 &lt;Rules&gt;, 使用默认 &lt;Language&gt; 与用户对话，友好的欢迎用户。然后介绍自己，并告诉用户 &lt;Workflow&gt;。</span><br></pre></td></tr></table></figure>

<p>使用上面的提示词输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">你好！我是诗人YZFly，擅长创作各种形式的诗歌。无论是自由表达情感的现代诗，还是律动优雅的七言律诗与五言诗，我都能为你呈现出独特的诗意之美。</span><br><span class="line"></span><br><span class="line">如果你有任何诗歌创作的需求，可以告诉我你想要的形式和主题。你可以按照这样的格式提供要求：“形式：[诗歌形式]，主题：[诗歌主题]”，我会根据你的指示创作诗歌。</span><br><span class="line"></span><br><span class="line">期待与你一起探索诗歌的美妙世界！</span><br></pre></td></tr></table></figure>

<p>基于上述 诗人 prompt 例子，我们来说明结构化 prompt 的几个概念：</p>
<ul>
<li>标识符：<code>#</code>、<code>&lt;&gt;</code> 等符号(<code>-</code>, <code>[]</code> 也是)，这两个符号依次标识标题、变量、控制内容层级，用于标识层次结构。</li>
<li>属性词：<code>Role</code>, <code>Profile</code>, <code>Initialization</code> 等等，属性词包含语义，是对模块下内容的总结和提示，用于标识语义结构。日常的文章结构是通过字号大小、颜色、字体等样式来标识的，ChatGPT 接收的输入没有样式，因此可以借鉴 <code>markdown</code>，<code>yaml</code> 这类标记语言的方法或者 <code>json</code> 这类数据结构实现 prompt 的结构表达都可以，例如用标识符 <code>#</code> 标识一级标题，<code>##</code> 标识二级标题，以此类推。尤其是使用 <code>json</code>，<code>yaml</code> 这类成熟的数据结构，对 prompt 进行工程化开发特别友好。</li>
</ul>
<p>当然标识符、属性词都是可替换的，可以替换为你喜欢的符号和内容。</p>
<p>结构化提示词直观上和传统的提示词方式差异就很大，那么为什么提倡结构化方式编写 Prompt 呢？</p>
<p>总结一句话就是：<strong>结构化、模板化 Prompt 的性能好！</strong></p>
<p>结构化提示词已经在很多商业应用中得到了证明，比如网易、字节这样的互联网大厂都在使用结构化提示词。我们可以直接使用 Kimi 提供的提示词专家：<a href="https://kimi.moonshot.cn/kimiplus/conpg00t7lagbbsfqkq0">https://kimi.moonshot.cn/kimiplus/conpg00t7lagbbsfqkq0</a> 来生成结构化提示词。</p>
<p>另外实践发现使用特定的属性词能够确保定向唤醒模型的深层能力。让模型<strong>扮演某个角色</strong>其能大大提高模型表现，所以一级标题设置的就是 Role（角色）属性词，直接将 Prompt 固定为角色，确保定向唤醒模型的角色扮演能力。也可使用 Expert（专家）、Master（大师）等提示词替代 Role，将 Prompt 固定为某一领域专家。</p>
<p>再比如 Rules，规定了模型必须尽力去遵守的规则。比如在这里添加不准胡说八道的规则，缓解大模型幻觉问题。添加输出内容必须积极健康的规则，缓解模型输出不良内容等。用 Constraints(约束)，中文的<code>规则</code>等词替代也可。</p>
<p>上面的例子都是使用 Role 模板编写的， Role 模板是 LangGPT 的核心。ChatGPT 很擅长角色扮演，只要提供角色说明，角色行为，技能等描述，就能做出很符合角色的行为。</p>
<p>因此 LangGPT 设计了 Role 模板让 ChatGPT 更好的理解用户意图，并相应提供了一套角色设计方法。</p>
<p>下面是用 markdown 展示的 Role 模板：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># Role: Your<span class="emphasis">_Role_</span>Name</span></span><br><span class="line"></span><br><span class="line"><span class="section">## Profile</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Author: YZFly</span><br><span class="line"><span class="bullet">-</span> Version: 0.1</span><br><span class="line"><span class="bullet">-</span> Language: English or 中文 or Other language</span><br><span class="line"><span class="bullet">-</span> Description: Describe your role. Give an overview of the character&#x27;s characteristics and skills</span><br><span class="line"></span><br><span class="line"><span class="section">### Skill-1</span></span><br><span class="line"></span><br><span class="line">1.技能描述 1 2.技能描述 2</span><br><span class="line"></span><br><span class="line"><span class="section">### Skill-2</span></span><br><span class="line"></span><br><span class="line">1.技能描述 1 2.技能描述 2</span><br><span class="line"></span><br><span class="line"><span class="section">## Rules</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> Don&#x27;t break character under any circumstance.</span><br><span class="line"><span class="bullet">2.</span> Don&#x27;t talk nonsense and make up facts.</span><br><span class="line"></span><br><span class="line"><span class="section">## Workflow</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> First, xxx</span><br><span class="line"><span class="bullet">2.</span> Then, xxx</span><br><span class="line"><span class="bullet">3.</span> Finally, xxx</span><br><span class="line"></span><br><span class="line"><span class="section">## Tools</span></span><br><span class="line"></span><br><span class="line"><span class="section">### browser</span></span><br><span class="line"></span><br><span class="line">You have the tool <span class="code">`browser`</span> with these functions:</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Issues a query to a search engine and displays the results.</span><br><span class="line"><span class="bullet">-</span> Opens the webpage with the given id, displaying it.</span><br><span class="line"><span class="bullet">-</span> Returns to the previous page and displays it.</span><br><span class="line"><span class="bullet">-</span> Scrolls up or down in the open webpage by the given amount.</span><br><span class="line"><span class="bullet">-</span> Opens the given URL and displays it.</span><br><span class="line"><span class="bullet">-</span> Stores a text span from an open webpage. Specifies a text span by a starting int <span class="code">`line_start`</span> and an (inclusive) ending int <span class="code">`line_end`</span>. To quote a single line, use <span class="code">`line_start`</span> = <span class="code">`line_end`</span>.</span><br><span class="line"></span><br><span class="line"><span class="section">### python</span></span><br><span class="line"></span><br><span class="line">When you send a message containing Python code to python, it will be executed in a</span><br><span class="line">stateful Jupyter notebook environment. python will respond with the output of the execution or time out after 60.0</span><br><span class="line">seconds. The drive at &#x27;/mnt/data&#x27; can be used to save and persist user files. Internet access for this session is disabled. Do not make external web requests or API calls as they will fail.</span><br><span class="line"></span><br><span class="line"><span class="section">### dalle</span></span><br><span class="line"></span><br><span class="line">Whenever a description of an image is given, use dalle to create the images and then summarize the prompts used to generate the images in plain text. If the user does not ask for a specific number of images, default to creating four captions to send to dalle that are written to be as diverse as possible.</span><br><span class="line"></span><br><span class="line"><span class="section">### More Tools</span></span><br><span class="line"></span><br><span class="line"><span class="section">## Initialization</span></span><br><span class="line"></span><br><span class="line">As a/an <span class="xml"><span class="tag">&lt;<span class="name">Role</span>&gt;</span></span>, you must follow the <span class="xml"><span class="tag">&lt;<span class="name">Rules</span>&gt;</span></span>, you must talk to user in default <span class="xml"><span class="tag">&lt;<span class="name">Language</span>&gt;</span></span>，you must greet the user. Then introduce yourself and introduce the <span class="xml"><span class="tag">&lt;<span class="name">Workflow</span>&gt;</span></span>.</span><br></pre></td></tr></table></figure>

<p>Role 模板主要包含四部分内容:</p>
<ul>
<li><code>Profile</code> 角色的简历: 角色描述，角色特点，角色技能以及你想要的其他角色特性。</li>
<li><code>Rules</code> 角色必须遵守的规则，通常是角色必须做的或者禁止做的事情，比如 “不许打破角色设定” 等规则。</li>
<li><code>Workflow</code> 角色的工作流，需要用户提供怎样的输入，角色如何响应用户。</li>
<li><code>Initialization</code> 按照 Role 模板的配置初始化角色，大部分时候使用模板默认内容即可</li>
</ul>
<p>Role 模板通过上面四个部分内容即可定义和配置一个角色。</p>
<p><strong>Role 模板使用步骤：</strong></p>
<ol>
<li>设置角色名：将 <code>Role: Your_Role_Name</code> 中的 <code>Your_Role_Name</code> 替换为你的角色名</li>
<li>编写角色简历 <code># Profile</code>：</li>
</ol>
<ul>
<li>设置语言，<code>Language</code> 设置为 中文 或者 English 等其他语言, 用目标语言表达为佳</li>
<li><code>Description</code> 后面简单描述角色</li>
<li><code>### Skill</code> 部分添加角色技能，可以设置多个技能，技能下分点提供技能描述</li>
</ul>
<ol>
<li>设定规则 <code># Rules</code>：添加角色必须遵守的规则，通常是角色必须做的或者禁止做的事情，比如 “Don’t break character under any circumstance.” “禁止出戏” 等规则</li>
<li>设定工作流 <code># Workflow</code>：角色如何与用户交互，需要用户提供怎样的输入，角色如何响应用户。</li>
<li>初始化角色 <code># Initialization</code>：Role 模板依据模板内容对角色进行设定，一般不需要修改。</li>
<li>将编写好的 Role 模板内容复制到 ChatGPT 对话框（or API）使用~</li>
</ol>
<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><p>除了上面的 Role 模板之外，还有其他高级用法，比如：</p>
<p><strong>变量</strong>：变量为 Prompt 的编写带来了很大的灵活性。使用变量可以方便的引用角色内容，设置和更改角色属性。这是一般的 prompt 方法较难实现的。</p>
<p>Role 模板里的 <code>Initialization</code> 部分就大量使用了变量：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">As a/an <span class="xml"><span class="tag">&lt;<span class="name">Role</span>&gt;</span></span>, you must follow the <span class="xml"><span class="tag">&lt;<span class="name">Rules</span>&gt;</span></span>, you must talk to user in default <span class="xml"><span class="tag">&lt;<span class="name">Language</span>&gt;</span></span>，you must greet the user. Then introduce yourself and introduce the <span class="xml"><span class="tag">&lt;<span class="name">Workflow</span>&gt;</span></span>.</span><br></pre></td></tr></table></figure>

<p>LangGPT 中使用 <code>&lt;&gt;</code> 标识变量，这里的变量有：</p>
<ul>
<li><code>&lt;Role&gt;</code> 变量，指代了整个 Role 角色的内容。</li>
<li><code>&lt;Rules&gt;</code> 变量，指代了 <code>## Rules</code> 一节的规则</li>
<li><code>&lt;Language&gt;</code> 变量，指代了 <code>Language</code> 字段的值</li>
</ul>
<p>Markdown 的层级结构可以让 ChatGPT 很方便的识别变量所代表的内容：</p>
<ul>
<li>Role 是文章标题，作用域为全文</li>
<li>Rule 是段落标题，作用域为段落</li>
<li>Language 是一个字段，作用域为 <code>:</code> 后的指定的文本</li>
</ul>
<p><strong>命令</strong>：使用命令可以方便的设置一些默认动作，例如 <code>/help</code> 提供帮助文档, <code>/continue</code> 续写文本 等都是十分有用的命令</p>
<ul>
<li>约定使用 <code>/</code> 来标识命令</li>
<li>在 Role 模板添加下面内容即可：</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">## Commands</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Prefix: &quot;/&quot;</span><br><span class="line"><span class="bullet">-</span> Commands:</span><br><span class="line"><span class="bullet">  -</span> help: This means that user do not know the commands usage. Please introduce yourself and the commands usage.</span><br><span class="line"><span class="bullet">  -</span> continue: This means that your output was cut. Please continue where you left off.</span><br></pre></td></tr></table></figure>

<p><strong>Reminder</strong>：使用 Reminder 可以缓解 ChatGPT 的遗忘问题。</p>
<p>在 Role 模板中添加 Reminder 即可：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">## Reminder</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> &#x27;Description: You will always remind yourself role settings and you output Reminder contents before responding to the user.&#x27;</span><br><span class="line"><span class="bullet">2.</span> &#x27;Reminder: The user language is language (<span class="xml"><span class="tag">&lt;<span class="name">language</span>&gt;</span></span>), rules (<span class="xml"><span class="tag">&lt;<span class="name">rules</span>&gt;</span></span>).&#x27;</span><br><span class="line"><span class="bullet">3.</span> &quot;<span class="xml"><span class="tag">&lt;<span class="name">output</span>&gt;</span></span>&quot;</span><br></pre></td></tr></table></figure>

<p><strong>条件语句</strong>：像编程中一样使用条件语句，一个模板为：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">If [situation1 happen], you will take [action1], else, you will take [action2]</span><br></pre></td></tr></table></figure>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>结构化提示词提升了 LLM 复杂问题处理能力。通过引导模型展示其推理过程，我们可以获得更准确、更可解释的结果。掌握结构化提示词技术，将帮助你更有效地利用大语言模型解决各类复杂问题。</p>
<blockquote>
<p>当然除了上面介绍的这些提示词工程技术之外，还有许多其他提示词工程技术，比如 ReAct 框架，这个在后面的 AI 智能体章节也会详细学习。</p>
</blockquote>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible-Runner-01</title>
    <url>/posts/63048.html</url>
    <content><![CDATA[<p>Ansible Runner</p>
<a id="more"></a>

<hr>
<h1 id="Ansible-Runner-相比-Ansible-Api优势"><a href="#Ansible-Runner-相比-Ansible-Api优势" class="headerlink" title="Ansible Runner 相比 Ansible Api优势"></a>Ansible Runner 相比 Ansible Api优势</h1><ol>
<li>Ansible 的开源协议是GPL，具有传染</li>
</ol>
<h1 id="Poetry-管理Python项目依赖"><a href="#Poetry-管理Python项目依赖" class="headerlink" title="Poetry 管理Python项目依赖"></a>Poetry 管理Python项目依赖</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Poetry优点:</p>
<ol>
<li><p>会自动创建虚拟环境</p>
<p>禁用创建虚拟环境: <code>poetry config virtualenvs.create false</code>; </p>
</li>
<li><p>可以自动生成Lock文件</p>
<ul>
<li>在Poetry中，<code>poetry.lock</code>文件会自动生成，其中包含了所有项目的依赖及其对应的确切版本，并保留了依赖的依赖关系。这样就可以在部署过程中保证所有依赖都保持一致的版本，避免了因为环境配置不同造成的问题。</li>
<li><code>requirements.txt</code> 中指定特定的版本号，只是简单地指定每个模块的版本号，不同模块之间不保留依赖关系，也不管依赖模块的依赖关系，时效性较弱，无法有效保障项目的稳定和一致性。</li>
</ul>
</li>
<li><p>更灵活的包管理</p>
<ul>
<li>Poetry支持同时管理Python包、可执行程序、插件等。可以使用较小的配置调整来满足项目的需要。如果需要添加或更新一个包，只需要执行 <code>poetry add package_name</code> 命令就可以了。</li>
</ul>
</li>
</ol>
<p><code>curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python -</code></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[tool.poetry]</span><br><span class="line">name &#x3D; &quot;codebox&quot;</span><br><span class="line">version &#x3D; &quot;0.1.0&quot;</span><br><span class="line">description &#x3D; &quot;&quot;</span><br><span class="line">authors &#x3D; [&quot;Waylon Yan &lt;ywl1006@outlook.com&gt;&quot;]</span><br><span class="line">license &#x3D; &quot;MIT&quot;</span><br><span class="line">readme &#x3D; &quot;README.md&quot;</span><br><span class="line"></span><br><span class="line">[tool.poetry.dependencies]</span><br><span class="line">python &#x3D; &quot;^3.10&quot;</span><br><span class="line">Django &#x3D; &quot;^4.0.3&quot;</span><br><span class="line">djangorestframework &#x3D; &quot;^3.13.1&quot;</span><br><span class="line">drf-spectacular &#x3D; &quot;^0.21.2&quot;</span><br><span class="line">ansible-runner &#x3D; &quot;^2.1.2&quot;</span><br><span class="line"></span><br><span class="line">[tool.poetry.dev-dependencies]</span><br><span class="line">ipython &#x3D; &quot;^8.1.0&quot;</span><br><span class="line">ansible &#x3D; &#123;version &#x3D; &quot;^5.4.0&quot;&#125;</span><br><span class="line"></span><br><span class="line">[build-system]</span><br><span class="line">requires &#x3D; [&quot;poetry-core&gt;&#x3D;1.0.0&quot;]</span><br><span class="line">build-backend &#x3D; &quot;poetry.core.masonry.api&quot;</span><br><span class="line"></span><br><span class="line">[[tool.poetry.source]]</span><br><span class="line">name &#x3D; &quot;tsinghua&quot;</span><br><span class="line">url &#x3D; &quot;https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&quot;</span><br><span class="line">default &#x3D; true</span><br><span class="line">[[tool.poetry.source]]</span><br><span class="line">name &#x3D; &quot;uste&quot;</span><br><span class="line">url &#x3D; &quot;https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;pypi&#x2F;web&#x2F;simple&quot;</span><br><span class="line">default &#x3D; false</span><br><span class="line">s</span><br></pre></td></tr></table></figure>

<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p><code>poetry install</code></p>
<h2 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h2><p><code>poetry build</code></p>
<hr>
<h2 id="Ansible-Runner"><a href="#Ansible-Runner" class="headerlink" title="Ansible Runner"></a>Ansible Runner</h2><blockquote>
<p>Ansible API：<a href="https://docs.ansible.com/ansible/latest/api/index.html">https://docs.ansible.com/ansible/latest/api/index.html</a></p>
<p>Ansible api经常会随Ansible软件版本变化，不是公开的api，且Ansible api是遵循GPL协议，具有传染性；</p>
</blockquote>
<blockquote>
<p>Ansible Runner: <a href="https://ansible-runner.readthedocs.io/en/stable/">https://ansible-runner.readthedocs.io/en/stable/</a>    </p>
<p>优势：</p>
<ol>
<li><p>Ansible Runner 基于Apache 2.0协议开源，官方出品，值得信赖</p>
</li>
<li><p>一般会使用Ansible Runner进行ansible调用，<strong>Ansible Runner是对Ansible命令的封装</strong>；不会受到GPL协议的传染；</p>
</li>
<li><p>ansible-runner可以作为命令来跑，也可以作为一个Python模块来使用</p>
</li>
<li><p>对于Ansible版本不依赖，主流命令使用变化不大；只需要调用ansible-playbook 命令即可</p>
</li>
</ol>
</blockquote>
<p>仓库列表页</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic/pic/image-20230506014904663.png" alt="image-20230506014904663"></p>
<p>仓库新建</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic/pic/image-20230506015130000.png" alt="image-20230506015130000"></p>
<p>更新仓库</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20230506020430966.png" alt="image-20230506020430966"></p>
<p>任务执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20230506021651841.png" alt="image-20230506021651841"></p>
<p>点击执行之后进入任务详情页面</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20230506021821320.png" alt="image-20230506021821320"></p>
<p>output显示颜色， 引入的是ansi_up 库</p>
<p>实时刷新状态，当它是undefined的时候，定时轮询就会停止工作</p>
<p>任务列表</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20230507141814513.png" alt="image-20230507141814513"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>ApiSix简单使用</title>
    <url>/posts/36968.html</url>
    <content><![CDATA[<p>负载均衡相关</p>
<a id="more"></a>

<h1 id="ApiSix安装文档"><a href="#ApiSix安装文档" class="headerlink" title="ApiSix安装文档"></a>ApiSix安装文档</h1><table>
<thead>
<tr>
<th align="left">单机测试</th>
<th align="left">Etcd</th>
<th align="left">Apisix</th>
<th align="left">Openresty</th>
<th align="left">Apisix-Dashboard</th>
<th align="left">Dashboard Url</th>
<th align="left">Grafana Url</th>
<th align="left">Log Url</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10.13.3.11</td>
<td align="left">3.4.13</td>
<td align="left">2.9</td>
<td align="left">1.19.9.1</td>
<td align="left">v2.8</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">集群/HostName</th>
<th align="left">Address</th>
<th align="left">EtcdName</th>
<th align="left">Etcd</th>
<th align="left">Apisix</th>
<th align="left">Openresty</th>
<th align="left">Apisix-Dashboard</th>
<th align="left">Dashboard Url</th>
<th align="left">BLB</th>
<th align="left">Grafana Url</th>
</tr>
</thead>
<tbody><tr>
<td align="left">prod-app-gw-00001.su.baidu.internal</td>
<td align="left"></td>
<td align="left">etcd1</td>
<td align="left">3.4.15</td>
<td align="left">2.9</td>
<td align="left">1.19.9.1</td>
<td align="left">v2.8</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><a href="https://horus.jiduauto.com/d/CSauFYN7z/apache-apisix">https://horus.jiduauto.com/d/CSauFYN7z/apache-apisix</a></td>
</tr>
<tr>
<td align="left">prod-app-gw-00002.su.baidu.internal</td>
<td align="left"></td>
<td align="left">etcd2</td>
<td align="left">3.4.15</td>
<td align="left">2.9</td>
<td align="left">1.19.9.1</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">prod-app-gw-00003.su.baidu.internal</td>
<td align="left"></td>
<td align="left">etcd3</td>
<td align="left">3.4.15</td>
<td align="left">2.9</td>
<td align="left">1.19.9.1</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="单机安装"><a href="#单机安装" class="headerlink" title="单机安装"></a>单机安装</h3><h4 id="1-etcd-单机安装（依赖）"><a href="#1-etcd-单机安装（依赖）" class="headerlink" title="1. etcd 单机安装（依赖）"></a>1. etcd 单机安装（依赖）</h4><p><strong>下载解压安装</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 下载</span></span><br><span class="line">wget https://github.com/etcd-io/etcd/releases/download/v3.4.13/etcd-v3.4.13-linux-amd64.tar.gz</span><br><span class="line">     </span><br><span class="line"><span class="comment"># 2. 解压</span></span><br><span class="line">tar -xvf etcd-v3.4.13-linux-amd64.tar.gz &amp;&amp;    <span class="built_in">cd</span> etcd-v3.4.13-linux-amd64 &amp;&amp;    sudo cp -a etcd etcdctl /usr/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.etcd配置文件</span></span><br><span class="line">vim /etc/etcd/etcd.conf</span><br><span class="line"> </span><br><span class="line">ETCD_NAME=etcd1   <span class="comment">#etcd实例名称</span></span><br><span class="line">ETCD_DATA_DIR=<span class="string">&quot;/var/lib/etcd&quot;</span>  <span class="comment">#etcd数据保存目录</span></span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=<span class="string">&quot;http://ip:2379,http://127.0.0.1:2379&quot;</span></span><br><span class="line"><span class="comment">#供外部客户端使用的url</span></span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=<span class="string">&quot;http://ip:2379,http://127.0.0.1:2379&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 4.systemd 配置文件</span></span><br><span class="line">vim /etc/systemd/system/etcd.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=Etcd Server</span><br><span class="line">After=network.target</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">WorkingDirectory=/var/lib/etcd/  </span><br><span class="line">EnvironmentFile=-/etc/etcd/etcd.conf</span><br><span class="line">ExecStart=/usr/bin/etcd</span><br><span class="line">Type=notify</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 5.服务开机自启动</span></span><br><span class="line">systemd daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> etcd &amp;&amp; systemd start etcd</span><br></pre></td></tr></table></figure>

<h4 id="2-安装openresty（依赖）"><a href="#2-安装openresty（依赖）" class="headerlink" title="2.安装openresty（依赖）"></a>2.安装openresty（依赖）</h4><p><strong>openresty+luaRock</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加 OpenResty 源</span></span><br><span class="line">sudo yum install yum-utils</span><br><span class="line">sudo yum-config-manager --add-repo https://openresty.org/package/centos/openresty.repo</span><br><span class="line"><span class="comment"># 安装 OpenResty 和 编译工具</span></span><br><span class="line">sudo yum install -y openresty curl git gcc openresty-openssl111-devel unzip pcre pcre-devel</span><br><span class="line"><span class="comment"># 安装 LuaRocks</span></span><br><span class="line">curl https://raw.githubusercontent.com/apache/apisix/master/utils/linux-install-luarocks.sh -sL</span><br></pre></td></tr></table></figure>

<h4 id="3-apisix安装"><a href="#3-apisix安装" class="headerlink" title="3.apisix安装"></a>3.apisix安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/src/apisix-2.9 &amp;&amp; <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/</span><br><span class="line">wget https://downloads.apache.org/apisix/2.9/apache-apisix-2.9-src.tgz</span><br><span class="line">tar zxvf apache-apisix-2.9-src.tgz -C apisix-2.9</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 安装运行时依赖的 Lua 库</span></span><br><span class="line">mv /usr/<span class="built_in">local</span>/src/apisix-2.9  /usr/<span class="built_in">local</span>/</span><br><span class="line">make deps</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 检查 APISIX 的版本号</span></span><br><span class="line">./bin/apisix version</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 初始化 APISIX</span></span><br><span class="line">make init</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 软链接</span></span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/apisix-2.9 /usr/<span class="built_in">local</span>/apisix</span><br><span class="line"> </span><br><span class="line"><span class="comment"># systemd配置文件</span></span><br><span class="line">vim /usr/lib/systemd/system/apisix.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=apisix</span><br><span class="line">Conflicts=apisix.service</span><br><span class="line">After=network-online.target</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">WorkingDirectory=/usr/<span class="built_in">local</span>/apisix</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/apisix/bin/apisix start</span><br><span class="line">ExecStop=/usr/<span class="built_in">local</span>/apisix/bin/apisix stop</span><br><span class="line">ExecReload=/usr/<span class="built_in">local</span>/apisix/bin/apisix reload</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 开机自启动 &amp;&amp; 服务启动</span></span><br><span class="line">systemd daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> apisix &amp;&amp; systemd start apisix</span><br></pre></td></tr></table></figure>

<h4 id="4-安装apisix-dashboard"><a href="#4-安装apisix-dashboard" class="headerlink" title="4.安装apisix-dashboard"></a>4.安装<code>apisix-dashboard</code></h4><p><strong>dashboard安装</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 安装go</span><br><span class="line"><span class="comment"># 检查是否已经安装</span></span><br><span class="line">whereis go</span><br><span class="line">whereis golang</span><br><span class="line">whereis gocode</span><br><span class="line">rm -rf xxx//找到后删除</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 下载</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line">wget https://dl.google.com/go/go1.15.6.linux-amd64.tar.gz</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -C /usr/<span class="built_in">local</span> -xzf go1.15.6.linux-amd64.tar.gz</span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="comment"># 加入内容</span></span><br><span class="line"><span class="built_in">export</span> GO_HOME=/usr/<span class="built_in">local</span>/go</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GO_HOME</span>/bin</span><br><span class="line"><span class="comment"># 退出保存，并执行生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="comment"># 验证是否成功</span></span><br><span class="line">go version</span><br><span class="line"> </span><br><span class="line">2. 安装lua</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">sudo yum install -y libtermcap-devel ncurses-devel libevent-devel readline-devel</span><br><span class="line"><span class="comment"># 下载源文件</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line">curl -R -O http://www.lua.org/ftp/lua-5.3.1.tar.gz</span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">tar zxf lua-5.3.1.tar.gz &amp;&amp; <span class="built_in">cd</span> lua-5.3.1</span><br><span class="line">make linux <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 验证是否成功</span></span><br><span class="line">lua</span><br><span class="line"> </span><br><span class="line">3. 安装node</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 版本</span></span><br><span class="line">curl -sL https://rpm.nodesource.com/setup_10.x | bash -</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum install -y nodejs</span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line"> </span><br><span class="line">4. 安装yarn</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 下载</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line">sudo wget https://dl.yarnpkg.com/rpm/yarn.repo -O /etc/yum.repos.d/yarn.repo</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo yum install -y yarn</span><br><span class="line"> </span><br><span class="line">5. 安装dashboard</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 为提高下载速度，此处设置代理</span></span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line"><span class="comment"># 克隆项目</span></span><br><span class="line">git <span class="built_in">clone</span> -b v2.8 https://github.com/apache/apisix-dashboard.git</span><br><span class="line"><span class="comment"># 构建(注时间可能有点久，且会报错，但根据控制台说明，此错误可以忽略)</span></span><br><span class="line"><span class="built_in">cd</span> ./apisix-dashboard</span><br><span class="line">make build</span><br><span class="line"><span class="comment"># 启动（注意依赖etcd，所以需要确认etcd是否启动）</span></span><br><span class="line"><span class="built_in">cd</span> ./output</span><br><span class="line">nohup ./manager-api &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line"><span class="built_in">kill</span> $(ps aux | grep <span class="string">&#x27;manager-api&#x27;</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="集群安装"><a href="#集群安装" class="headerlink" title="集群安装"></a>集群安装</h3><h4 id="1-etcd集群部署"><a href="#1-etcd集群部署" class="headerlink" title="1.etcd集群部署"></a>1.etcd集群部署</h4><table>
<thead>
<tr>
<th align="left">HostName</th>
<th align="left">Address</th>
<th align="left">EtcdName</th>
</tr>
</thead>
<tbody><tr>
<td align="left">prod-app-gw-00001.su.baidu.internal</td>
<td align="left"></td>
<td align="left">etcd1</td>
</tr>
<tr>
<td align="left">prod-app-gw-00002.su.baidu.internal</td>
<td align="left"></td>
<td align="left">etcd2</td>
</tr>
<tr>
<td align="left">prod-app-gw-00003.su.baidu.internal</td>
<td align="left"></td>
<td align="left">etcd3</td>
</tr>
</tbody></table>
<p><strong>etcd static集群安装</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget https://github.com/etcd-io/etcd/releases/download/v3.4.15/etcd-v3.4.15-linux-amd64.tar.gz /usr/<span class="built_in">local</span>/src/</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/ &amp;&amp; tar xf etcd-v3.4.15-linux-amd64.tar.gz</span><br><span class="line">mv /usr/<span class="built_in">local</span>/src/etcd-v3.4.15-linux-amd64 /usr/<span class="built_in">local</span>/</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 软链接</span></span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/etcd-v3.4.15-linux-amd64 /usr/<span class="built_in">local</span>/etcd</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/etcd/etcd /usr/bin/etcd</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/etcd/etcdctl /usr/bin/etcdctl</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建数据目录</span></span><br><span class="line">mkdir -p /etc/etcd /var/lib/etcd</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 普通用户</span></span><br><span class="line">useradd -s /sbin/nologin etcd</span><br><span class="line">chown etcd:etcd /var/lib/etcd</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 配置文件</span></span><br><span class="line"><span class="comment">## /etc/etcd/etcd.conf</span></span><br><span class="line">etcd-01</span><br><span class="line">ETCD_DATA_DIR=<span class="string">&quot;/var/lib/etcd/default.etcd&quot;</span></span><br><span class="line">ETCD_LISTEN_PEER_URLS=<span class="string">&quot;http://10.10.30.6:2380&quot;</span></span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=<span class="string">&quot;http://10.10.30.6:2379,http://127.0.0.1:2379&quot;</span></span><br><span class="line">ETCD_NAME=<span class="string">&quot;apisix-etcd-01&quot;</span></span><br><span class="line">ALLOW_NONE_AUTHENTICATION=yes</span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=<span class="string">&quot;http://10.10.30.6:2380&quot;</span></span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=<span class="string">&quot;http://10.10.30.6:2379,http://127.0.0.1:2379&quot;</span></span><br><span class="line">ETCD_INITIAL_CLUSTER=<span class="string">&quot;apisix-etcd-01=http://10.10.30.6:2380,apisix-etcd-02=http://10.10.30.5:2380,apisix-etcd-03=http://10.10.30.4:2380&quot;</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN=<span class="string">&quot;apisix-etcd-cluster-token&quot;</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=<span class="string">&quot;new&quot;</span></span><br><span class="line">ETCD_ENABLE_V2=<span class="string">&quot;true&quot;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">etcd-02</span><br><span class="line"> </span><br><span class="line">ETCD_DATA_DIR=<span class="string">&quot;/var/lib/etcd/default.etcd&quot;</span></span><br><span class="line">ETCD_LISTEN_PEER_URLS=<span class="string">&quot;http://10.10.30.5:2380&quot;</span></span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=<span class="string">&quot;http://10.10.30.5:2379,http://127.0.0.1:2379&quot;</span></span><br><span class="line">ETCD_NAME=<span class="string">&quot;apisix-etcd-02&quot;</span></span><br><span class="line">ALLOW_NONE_AUTHENTICATION=yes</span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=<span class="string">&quot;http://10.10.30.5:2380&quot;</span></span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=<span class="string">&quot;http://10.10.30.5:2379,http://127.0.0.1:2379&quot;</span></span><br><span class="line">ETCD_INITIAL_CLUSTER=<span class="string">&quot;apisix-etcd-01=http://10.10.30.6:2380,apisix-etcd-02=http://10.10.30.5:2380,apisix-etcd-03=http://10.10.30.4:2380&quot;</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN=<span class="string">&quot;apisix-etcd-cluster-token&quot;</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=<span class="string">&quot;new&quot;</span></span><br><span class="line">ETCD_ENABLE_V2=<span class="string">&quot;true&quot;</span></span><br><span class="line"> </span><br><span class="line">etcd-03</span><br><span class="line"> </span><br><span class="line">ETCD_DATA_DIR=<span class="string">&quot;/var/lib/etcd/default.etcd&quot;</span></span><br><span class="line">ETCD_LISTEN_PEER_URLS=<span class="string">&quot;http://10.10.30.4:2380&quot;</span></span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=<span class="string">&quot;http://10.10.30.4:2379,http://127.0.0.1:2379&quot;</span></span><br><span class="line">ETCD_NAME=<span class="string">&quot;apisix-etcd-03&quot;</span></span><br><span class="line">ALLOW_NONE_AUTHENTICATION=yes</span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=<span class="string">&quot;http://10.10.30.4:2380&quot;</span></span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=<span class="string">&quot;http://10.10.30.4:2379,http://127.0.0.1:2379&quot;</span></span><br><span class="line">ETCD_INITIAL_CLUSTER=<span class="string">&quot;apisix-etcd-01=http://10.10.30.6:2380,apisix-etcd-02=http://10.10.30.5:2380,apisix-etcd-03=http://10.10.30.4:2380&quot;</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN=<span class="string">&quot;apisix-etcd-cluster-token&quot;</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=<span class="string">&quot;new&quot;</span></span><br><span class="line">ETCD_ENABLE_V2=<span class="string">&quot;true&quot;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">## /usr/lib/systemd/system/etcd.service</span></span><br><span class="line">Description=Etcd Server</span><br><span class="line">After=network.target</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">WorkingDirectory=/var/lib/etcd/</span><br><span class="line">EnvironmentFile=/etc/etcd/etcd.conf</span><br><span class="line">User=etcd</span><br><span class="line">ExecStart=/usr/bin/etcd</span><br><span class="line">Restart=on-failure</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 服务启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> etcd &amp;&amp; systemctl start etcd</span><br></pre></td></tr></table></figure>

<h5 id="查看集群成员"><a href="#查看集群成员" class="headerlink" title="查看集群成员"></a>查看集群成员</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">etcdctl member list</span><br><span class="line">查看健康状态</span><br><span class="line">etcdctl --endpoints&#x3D;&quot;http:&#x2F;&#x2F;10.10.30.6:2379,http:&#x2F;&#x2F;10.10.30.5:2379,http:&#x2F;&#x2F;10.10.30.4:2379&quot; endpoint health</span><br></pre></td></tr></table></figure>

<h5 id="查看集群leader"><a href="#查看集群leader" class="headerlink" title="查看集群leader"></a>查看集群leader</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl endpoint status --cluster -w table</span><br></pre></td></tr></table></figure>

<h4 id="2-apisix集群部署"><a href="#2-apisix集群部署" class="headerlink" title="2.apisix集群部署"></a>2.apisix集群部署</h4><p><strong>安装部署</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="comment">##  添加 OpenResty 源</span></span><br><span class="line">sudo yum install yum-utils</span><br><span class="line">sudo yum-config-manager --add-repo https://openresty.org/package/centos/openresty.repo</span><br><span class="line"> </span><br><span class="line"><span class="comment">## 安装 OpenResty 和 编译工具 （此次openresty版本1.19.9.1-1.el7）</span></span><br><span class="line">sudo yum install -y openresty curl git gcc openresty-openssl111-devel unzip pcre pcre-devel</span><br><span class="line"> </span><br><span class="line"><span class="comment">## 安装 LuaRocks</span></span><br><span class="line">curl https://raw.githubusercontent.com/apache/apisix/master/utils/linux-install-luarocks.sh -sL | bash -</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># apisix安装</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">## 下载</span></span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/src/apisix-2.9 &amp;&amp; <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/</span><br><span class="line">wget https://downloads.apache.org/apisix/2.9/apache-apisix-2.9-src.tgz</span><br><span class="line">tar zxvf apache-apisix-2.9-src.tgz -C apisix-2.9</span><br><span class="line"> </span><br><span class="line"><span class="comment">## 安装运行时依赖的 Lua 库</span></span><br><span class="line">mv /usr/<span class="built_in">local</span>/src/apisix-2.9  /usr/<span class="built_in">local</span>/</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/apisix-2.9</span><br><span class="line">make deps</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 软链接</span></span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/apisix-2.9 /usr/<span class="built_in">local</span>/apisix</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 检查 APISIX 的版本号</span></span><br><span class="line">./bin/apisix version</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 修改配置文件，配置etcd集群地址</span></span><br><span class="line">/usr/<span class="built_in">local</span>/apisix/conf/conf.yaml</span><br><span class="line">etcd:</span><br><span class="line">    host:</span><br><span class="line">      - http://10.10.30.6:2379</span><br><span class="line">      - http://10.10.30.5:2379</span><br><span class="line">      - http://10.10.30.4:2379</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 初始化 APISIX</span></span><br><span class="line">make init</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># systemd配置文件</span></span><br><span class="line">vim /usr/lib/systemd/system/apisix.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=apisix</span><br><span class="line">Conflicts=apisix.service</span><br><span class="line">After=network-online.target</span><br><span class="line">  </span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">WorkingDirectory=/usr/<span class="built_in">local</span>/apisix</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/apisix/bin/apisix start</span><br><span class="line">ExecStop=/usr/<span class="built_in">local</span>/apisix/bin/apisix stop</span><br><span class="line">ExecReload=/usr/<span class="built_in">local</span>/apisix/bin/apisix reload</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 开机自启动 &amp;&amp; 服务启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> apisix &amp;&amp; systemctl start apisix</span><br></pre></td></tr></table></figure>



<h4 id="3-dashboard部署"><a href="#3-dashboard部署" class="headerlink" title="3.dashboard部署"></a>3.dashboard部署</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">###############依赖安装###########1、安装go# 检查是否已经安装whereis gowhereis golangwhereis gocoderm -rf xxx//找到后删除# 下载cd /usr/local/srcwget https://dl.google.com/go/go1.15.6.linux-amd64.tar.gz# 解压tar -C /usr/local -xzf go1.15.6.linux-amd64.tar.gz# 设置环境变量vim /etc/profile# 加入内容export GO_HOME=/usr/local/goexport PATH=$PATH:$GO_HOME/bin# 退出保存，并执行生效source /etc/profile# 验证是否成功go version 2、安装`lua` # 安装依赖sudo yum install -y libtermcap-devel ncurses-devel libevent-devel readline-devel gcc# 下载源文件cd /usr/local/srccurl -R -O http://www.lua.org/ftp/lua-5.3.1.tar.gz# 编译安装tar zxf lua-5.3.1.tar.gz &amp;&amp; cd lua-5.3.1make linux test# 验证是否成功lua 3、安装node# 版本curl -sL https://rpm.nodesource.com/setup_10.x | bash -# 安装yum install -y nodejs# 验证node -vnpm -v 4、安装`yarn` # 下载cd /usr/local/srcsudo wget https://dl.yarnpkg.com/rpm/yarn.repo -O /etc/yum.repos.d/yarn.repo# 安装sudo yum install -y yarn 5、安装`dashboard` # 为提高下载速度，此处设置代理go env -w GOPROXY=https://goproxy.cn,direct# 克隆项目git clone -b v2.8 https://github.com/apache/apisix-dashboard.git# 构建(注时间可能有点久，且会报错，但根据控制台说明，此错误可以忽略)cd ./apisix-dashboardmake build# 启动（注意依赖etcd，所以需要确认etcd是否启动）cd ./outputnohup ./manager-api &amp; # 停止kill $(ps aux | grep &#x27;manager-api&#x27; | awk &#x27;&#123;print $2&#125;&#x27;)```  # systemd 配置文件cat /usr/lib/systemd/system/apisix-dashboard.service[Unit]Description=apisix-dashboardConflicts=apisix-dashboard.serviceAfter=network-online.target [Service]Type=forkingWorkingDirectory=/data/apisix-dashboardExecStart=/usr/local/src/apisix-dashboard/output/manager-api startExecStop=/usr/local/src/apisix-dashboard/output/manager-api stopExecReload=/usr/local/src/apisix-dashboard/output/manager-api reload</span></span><br></pre></td></tr></table></figure>

<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><h4 id="route开启prometheus插件暴露metrics"><a href="#route开启prometheus插件暴露metrics" class="headerlink" title="route开启prometheus插件暴露metrics"></a>route开启prometheus插件暴露metrics</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;plugins&quot;: &#123;        &quot;prometheus&quot;:&#123;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Prometheus-target-配置"><a href="#Prometheus-target-配置" class="headerlink" title="Prometheus target 配置"></a>Prometheus target 配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- job_name: &#39;apisix&#39;  metrics_path: &#39;&#x2F;apisix&#x2F;prometheus&#x2F;metrics&#39;  static_configs:  - targets: [&#39;ip:9091&#39;]</span><br></pre></td></tr></table></figure>

<h4 id="Grafana监控模板"><a href="#Grafana监控模板" class="headerlink" title="Grafana监控模板"></a>Grafana监控模板</h4><p>ID：<code>11719</code></p>
<p>更改指标：apisix_http_status matched_uri</p>
<p>更改后的模板：附件<a href="https://wiki.jiduauto.com/download/attachments/17344444/APISIX-v2.json?version=1&modificationDate=1632707555000&api=v2">APISIX-v2.json</a></p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><h4 id="本地日志配置logrotate"><a href="#本地日志配置logrotate" class="headerlink" title="本地日志配置logrotate"></a>本地日志配置logrotate</h4><h5 id="开启插件"><a href="#开启插件" class="headerlink" title="开启插件"></a>开启插件</h5><p>在 <code>conf/config-default.yaml</code> 中启用插件 <code>log-rotate</code> 即可，不需要在任何 route 或 service 中绑定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins:    # the plugins you enabled    - log-rotateplugin_attr:    log-rotate:        interval: 3600    # rotate interval (unit: second)        max_kept: 168     # max number of log files will be kept        enable_compression: false    # enable log file compression(gzip) or not, default false</span><br></pre></td></tr></table></figure>



<h5 id="禁用插件"><a href="#禁用插件" class="headerlink" title="禁用插件"></a>禁用插件</h5><p>在 <code>conf/config-default.yaml</code> 中删除插件 <code>log-rotate</code> 即可。</p>
<h4 id="日志进kafka"><a href="#日志进kafka" class="headerlink" title="日志进kafka"></a>日志进kafka</h4><p>日志修改为json</p>
<p>conf/config-default.yaml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">access_log_format: |-       &#123;&quot;@timestamp&quot;:&quot;$time_iso8601&quot;,&quot;host&quot;:&quot;$server_addr&quot;,&quot;clientip&quot;:&quot;$remote_addr&quot;,&quot;size&quot;:&quot;$body_bytes_sent&quot;,&quot;requesttime&quot;:$request_time,&quot;request&quot;:&quot;$request&quot;,&quot;upstreamtime&quot;:&quot;$upstream_response_time&quot;,&quot;upstreamhost&quot;:&quot;$upstream_addr&quot;,&quot;http_host&quot;:&quot;$host&quot;,&quot;xff&quot;:&quot;$http_x_forwarded_for&quot;,&quot;referer&quot;:&quot;$http_referer&quot;,&quot;agent&quot;:&quot;$http_user_agent&quot;,&quot;status&quot;:&quot;$status&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>filebeat收集日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filebeat.inputs:- type: log  enabled: true  paths:      - &#x2F;usr&#x2F;local&#x2F;apisix&#x2F;logs&#x2F;access*.log  json.keys_under_root: true  json.overwrite_keys: true output.kafka:  # 写入到kafka  hosts: [&quot;10.15.0.21:9092&quot;] # 写入kafka的IP地址  topic: &quot;topic-apisix&quot;  partition.round_robin:    reachable_only: true  required_acks: 1  # 本地写入完成  compression: gzip  # 开启压缩  max_message_bytes: 1000000  # 消息最大值</span><br></pre></td></tr></table></figure>

<h3 id="Ansible扩容（待补充）"><a href="#Ansible扩容（待补充）" class="headerlink" title="Ansible扩容（待补充）"></a>Ansible扩容（待补充）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">playbook</span><br></pre></td></tr></table></figure>

<h3 id="忽略：-备注信息"><a href="#忽略：-备注信息" class="headerlink" title="忽略： 备注信息"></a>忽略： 备注信息</h3><h4 id="路由开启插件"><a href="#路由开启插件" class="headerlink" title="路由开启插件"></a>路由开启插件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;plugins&quot;: &#123;  &quot;ip-restriction&quot;: &#123;    &quot;disable&quot;: false,    &quot;whitelist&quot;: [      &quot;127.0.0.1&quot;,      &quot;180.171.131.32&#x2F;32&quot;    ]  &#125;,  &quot;proxy-rewrite&quot;: &#123;    &quot;uri&quot;: &quot;&#x2F;&quot;  &#125;,  &quot;redirect&quot;: &#123;    &quot;http_to_https&quot;: true  &#125;&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="路由开启优先级"><a href="#路由开启优先级" class="headerlink" title="路由开启优先级"></a>路由开启优先级</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">同一个uri有多个route的情况，会以数组的方式扩展，并且使用sort排序，排序顺序依据route中priority参数，越大优先级越高，越优先匹配。&quot;priority&quot;: 1 如果不同路由包含相同 uri，根据属性 priority 确定哪个 route 被优先匹配，值越大优先级越高，默认值为 0。  </span><br></pre></td></tr></table></figure>

<h4 id="python插件问题"><a href="#python插件问题" class="headerlink" title="python插件问题"></a>python插件问题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;opt&#x2F;code_yan&#x2F;py3venv&#x2F;lib&#x2F;python3.6&#x2F;site-packages&#x2F;click-8.0.1-py3.6.egg&#x2F;click&#x2F;_unicodefun.py  def _verify_python_env() -&gt; None:  &quot;&quot;&quot;Ensures that the environment is good for Unicode.&quot;&quot;&quot;  try:      from locale import getpreferredencoding      fs_enc &#x3D; codecs.lookup(getpreferredencoding()).name      fs_enc &#x3D; &quot;utf-8&quot;  except Exception:      fs_enc &#x3D; &quot;ascii&quot;  fs_enc &#x3D; &quot;utf-8&quot;  if fs_enc !&#x3D; &quot;ascii&quot;:      return</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Load Balance</tag>
      </tags>
  </entry>
  <entry>
    <title>AI-08-A2A</title>
    <url>/posts/5677.html</url>
    <content><![CDATA[<p>A2A</p>
<a id="more"></a>

<p>MCP： Tools的发现和调用 协议<br>A2A： Agent的发现与调用 协议</p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/image-20250622010517197.png" alt="image-20250622010517197"></p>
<p>A2A Clent 也就是调度Agent  一般来说都是由平台去写，业务都是直接去写Agent Server</p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>CGI-FastCGI-WSGI-uWSGI-uwsgi区别联系</title>
    <url>/posts/50991.html</url>
    <content><![CDATA[<h1 id="CGI-FastCGI-WSGI-uWSGI-uwsgi一文搞懂"><a href="#CGI-FastCGI-WSGI-uWSGI-uwsgi一文搞懂" class="headerlink" title="CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂"></a>CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂</h1><h2 id="一-CGI"><a href="#一-CGI" class="headerlink" title="一 CGI"></a>一 CGI</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1、通用网关接口（Common Gateway Interface&#x2F;CGI）是一种重要的互联网技术，可以让一个客户端，从网页浏览器向执行在网络服务器上的程序请求数据。CGI描述了服务器和请求处理程序之间传输数据的一种标准。</span><br><span class="line"></span><br><span class="line"># 2、CGI程序可以用任何脚本语言或者是完全独立编程语言实现，只要这个语言可以在这个系统上运行。</span><br><span class="line"></span><br><span class="line"># 3、用来规范web服务器传输到php解释器中的数据类型以及数据格式，包括URL、查询字符串、POST数据、HTTP header等，也就是为了保证web server传递过来的数据是标准格式的</span><br><span class="line"></span><br><span class="line"># 4、一句话总结： 一个标准，定义了客户端服务器之间如何传数据</span><br></pre></td></tr></table></figure>

<h2 id="二-FastCGI"><a href="#二-FastCGI" class="headerlink" title="二 FastCGI"></a>二 FastCGI</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1、快速通用网关接口（Fast Common Gateway Interface／FastCGI）是一种让交互程序与Web服务器通信的协议。FastCGI是早期通用网关接口（CGI）的增强版本。</span><br><span class="line"></span><br><span class="line"># 2、FastCGI致力于减少网页服务器与CGI程序之间互动的开销，从而使服务器可以同时处理更多的网页请求。</span><br><span class="line"></span><br><span class="line"># 3、使用FastCGI的服务器：</span><br><span class="line">    Apache HTTP Server (部分)</span><br><span class="line">    Cherokee HTTP Server</span><br><span class="line">    Hiawatha Webserver</span><br><span class="line">    Lighttpd</span><br><span class="line">    Nginx</span><br><span class="line">    LiteSpeed Web Server</span><br><span class="line">    Microsoft IIS</span><br><span class="line"># 4、一句话总结： CGI的升级版</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/00831rSTly1gcy7m2g0j9j310q0gqjtv.jpg" alt="image-20200318002154734"></p>
<h2 id="三-WSGI"><a href="#三-WSGI" class="headerlink" title="三 WSGI"></a>三 WSGI</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1、Web服务器网关接口（Python Web Server Gateway Interface，缩写为WSGI）是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口。自从WSGI被开发出来以后，许多其它语言中也出现了类似接口。</span><br><span class="line"></span><br><span class="line"># 2、wsgi server (比如uWSGI） 要和 wsgi application（比如django ）交互，uwsgi需要将过来的请求转给django 处理，那么uWSGI 和 django的交互和调用就需要一个统一的规范，这个规范就是WSGI WSGI（Web Server Gateway Interface）</span><br><span class="line"></span><br><span class="line"># 3、WSGI 的官方定义是，the Python Web Server Gateway Interface。从名字就可以看出来，这东西是一个Gateway，也就是网关。网关的作用就是在协议之间进行转换。</span><br><span class="line"></span><br><span class="line"># 4、WSGI 是作为 Web 服务器与 Web 应用程序或应用框架之间的一种低级别的接口，以提升可移植 Web 应用开发的共同点。WSGI 是基于现存的 CGI 标准而设计的</span><br><span class="line"></span><br><span class="line">WSGI 规定了Web服务器（Server）和应用程序（Application）双方各自需要实现什么接口，以便两者能完美的配合使用，这个和 USB Type-C 规范很像， 只要手机和充电线都遵循了 Type-C 接口规范， 大家的充电线就可以复用，不同的是充电谁快谁慢的问题，而苹果没有遵循Type-C规范，所以只有他自家的线才能充苹果手机。</span><br><span class="line"></span><br><span class="line">一个完整的 Web 应用包含两部分，一个是服务器程序（Server），一个是应用程序（Application），服务器程序负责接收浏览器发送过来的请求，应用程序负责处理具体的业务逻辑。 比如我基于 Django 框架开发一个博客应用，部署在生产环境时会用 Gunicorn 或者 Uwsgi 作为服务器程序。</span><br><span class="line"></span><br><span class="line">Python 中 Web 框架非常多，Flask、Django、Bottle、Pyramid、Tornado 等等，甚至你也自己也可以造一个 Web 框架，那么这么多框架，为什么他们都可以用 Gunicorn 或者 Uwsgi 来部署呢？</span><br><span class="line"></span><br><span class="line">答案就是 WSGI 规范。</span><br><span class="line"></span><br><span class="line"># 6、一句话总结： 协议，为Python定义的web服务器和web框架之间的接口标准；规定了怎么样和app调用，Django app（environ: dict，start_response）可调用对象里面的返回的正文</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/20181212210028151.png" alt="img"></p>
<h2 id="四-uWSGI"><a href="#四-uWSGI" class="headerlink" title="四 uWSGI"></a>四 uWSGI</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wsgiref，werkzeug（一个是符合wsgi协议的web服务器+工具包（封装了一些东西））</span><br><span class="line">uWSGI 用c语言写的，性能比较高</span><br><span class="line">gunicorn：python写的</span><br><span class="line">tornado：也可以部署django项目</span><br><span class="line"># 1、它是一个Web服务器（类似的有wsgiref，gunicorn），它实现了WSGI协议、uwsgi、http等协议。用于接收前端服务器转发的动态请求并处理后发给 web 应用程序。</span><br><span class="line"></span><br><span class="line"># 2、Nginx中HttpUwsgiModule的作用是与uWSGI服务器进行交换</span><br><span class="line"></span><br><span class="line"># 3、一句话总结： 一个Web Server软件，即一个实现了WSGI的服务器，支持调用Django application，支持uwsgi协议，大体和Apache是一个类型的东西，处理发来的请求。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/00831rSTly1gcy7ly6362j31060e244f.jpg" alt="image-20200318000134358"></p>
<h2 id="五-uwsgi"><a href="#五-uwsgi" class="headerlink" title="五 uwsgi"></a>五 uwsgi</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">          #方式一</span><br><span class="line">          #include uwsgi_params; # 导入一个Nginx模块他是用来和uWSGI进行通讯的</span><br><span class="line">             #uwsgi_connect_timeout 30; # 设置连接uWSGI超时时间</span><br><span class="line">          #uwsgi_pass 101.133.225.166:8080;</span><br><span class="line">          #方式二</span><br><span class="line">          #include uwsgi_params; # 导入一个Nginx模块他是用来和uWSGI进行通讯的</span><br><span class="line">          #uwsgi_pass unix:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;script&#x2F;uwsgi.sock; # 指定uwsgi的sock文件所有动态请求</span><br><span class="line">          #方式三</span><br><span class="line">          proxy_pass http:&#x2F;&#x2F;101.133.225.166:8088</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line"># 1、它是uWSGI服务器实现的独有的协议，是二进制协议；用于定义传输信息的类型，是用于前端服务器与 uwsgi 的通信规范。</span><br><span class="line"></span><br><span class="line">uwsgi是一个二进制协议，能够携带任何类型的信息。uwsgi数据包的前4个字节用于描述信息的类型。uwsgi协议主要工作在TCP方式下。uwsgi是一种线路协议而不是通信协议，在此常用于在uWSGI服务器与其他网络服务器的数据通信。 </span><br><span class="line"></span><br><span class="line">uwsgi协议是一个uWSGI服务器自有的协议，它用于定义传输信息的类型（type of information），每一个uwsgi packet前4byte为传输信息类型描述，它与WSGI相比是两样东西。</span><br><span class="line"></span><br><span class="line">uwsgi数据包头</span><br><span class="line"></span><br><span class="line">Struct uwsgi_packet_header&#123;</span><br><span class="line">uint8_t modifier1;</span><br><span class="line">uint16_t datasize;</span><br><span class="line">uint8_t modifier2;</span><br><span class="line"></span><br><span class="line"># 1、一句话总结： uWSGI自有的一个协议</span><br><span class="line">uWSGI：web服务器，等同于wsgiref</span><br><span class="line">uwsgi:uWSGI自有的协议</span><br></pre></td></tr></table></figure>

<p>Django是什么？大函数 APP wsgi.py application, uWSGI运行这个函数</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcy7lt147ij31gu0ekqbq.jpg" alt="image-20200318000713341"><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/00831rSTly1gcy7ln056dj30u0151jwj.jpg" alt="image-20200318001134520"></p>
<p><strong>HTTP协议代理</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20230124184742762.png" alt="image-20230124184742762"></p>
<p><strong>二级制协议uwsgi代理</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20230124184832126.png" alt="image-20230124184832126"></p>
<ol>
<li><p>浏览器通过互联网HTTP协议访问NGINX</p>
</li>
<li><p>静态内容（图片、JS、CSS、文件）都由Nginx负责提供WEB服务</p>
</li>
<li><p>Nginx配置代理。可以是Http和Socket通信。建议使用uwsgi协议，性能更高</p>
</li>
<li><p>uWSGI服务程序提供uwsgi协议的支持。将从Nginx发来的http请求，然后Nginx通过反向代理配置转化成uwsgi二进制协议；将数据的二进制格式发送给uwsgi 进程:9000, uWSGI支持二进制协议的解析；解开数据之后，通过WSGI调用Django这个大函数wsgi.py，将uwsgi二进制协议解析的数据封装environ，提供start_response, 调用返回结果。结果因为走了二进制协议，所以通过二进制协议返回给Nginx，Nginx内部把uwsgi协议响应的内容转换成http reponse的响应报文；返回给浏览器。</p>
</li>
<li><p>通过Django的路由，将请求交给视图函数（类）处理，可能需要访问数据库的数据，也可能使用了模板。最终数据返回给浏览器。</p>
</li>
</ol>
<hr>
]]></content>
  </entry>
  <entry>
    <title>AI-05-coze</title>
    <url>/posts/45471.html</url>
    <content><![CDATA[<p>Coze</p>
<a id="more"></a>

<h1 id="5-1-Coze基础"><a href="#5-1-Coze基础" class="headerlink" title="5.1 Coze基础"></a><strong>5.1 Coze基础</strong></h1><h2 id="1-Coze-平台简介"><a href="#1-Coze-平台简介" class="headerlink" title="1. Coze 平台简介"></a>1. Coze 平台简介</h2><p><img src="https://picdn.youdianzhishi.com/images/1742434889019.png" alt="null"></p>
<p>Coze（扣子）是字节跳动推出的一站式 AI 应用开发平台。无论你是否有编程基础，都可以在 Coze 上快速搭建基于大模型的各类 AI 应用。你可以将这些 AI 应用发布到各种社交平台和通讯软件，也可以通过 API 或 SDK 将它们集成到你的业务系统中。</p>
<p>需要注意的是该平台有两个版本，一个是国内版本（coze.cn），一个是国际版本（coze.com），国内版本是基于国内大模型厂商的模型，国际版本支持国外主流大模型（OpenAI、Anthropic 等）。国内版本又分成了基础版本和专业版本。</p>
<ul>
<li><p>基础版本：面向尝鲜体验的个人和企业开发者，全部功能免费使用，但有一定的限量额度，超过后不可再使用，需切换专业版后继续使用。</p>
</li>
<li><p>专业版本：面向对稳定性和用量有更高需求的专业开发者，支持更大团队空间规模、更高免费知识库空间以及协作编辑容量，付费功能保障专业级 SLA，不限制调用请求频率和总量，费用按实际用量计算。</p>
</li>
</ul>
<h3 id="1-1-Coze-能做什么？"><a href="#1-1-Coze-能做什么？" class="headerlink" title="1.1 Coze 能做什么？"></a>1.1 Coze 能做什么？</h3><p>通过 Coze 提供的可视化设计与编排工具，你可以零代码或低代码的方式快速创建 AI 项目：</p>
<p><strong>智能体</strong></p>
<p>智能体是基于对话的 AI 项目，通过对话方式接收用户输入，自动调用插件或工作流执行任务，并生成回复。常见应用包括：</p>
<ul>
<li><p>智能客服</p>
</li>
<li><p>虚拟伴侣</p>
</li>
<li><p>个人助理</p>
</li>
<li><p>英语外教</p>
</li>
</ul>
<p><strong>应用</strong></p>
<p>Coze 中的应用是指利用大模型技术开发的应用程序，具备完整业务逻辑和可视化界面，是独立的 AI 项目。它们有明确的输入和输出，可以完成各种任务，例如：</p>
<ul>
<li><p>AI 搜索</p>
</li>
<li><p>翻译工具</p>
</li>
<li><p>饮食记录工具</p>
</li>
</ul>
<h3 id="1-2-为什么选择-Coze？"><a href="#1-2-为什么选择-Coze？" class="headerlink" title="1.2 为什么选择 Coze？"></a>1.2 为什么选择 Coze？</h3><p><strong>灵活的工作流设计</strong></p>
<p>Coze 的工作流功能可以处理复杂逻辑和高稳定性要求的任务。平台提供了多种可组合节点（LLM、自定义代码、判断逻辑等），让你通过简单的拖拽操作就能搭建工作流，比如创建一个自动撰写研究报告的流程。</p>
<p><strong>丰富的插件生态</strong></p>
<p>Coze 集成了众多插件工具，极大拓展了智能体的能力边界。你可以直接使用官方插件，如新闻插件来创建 AI 新闻播报员。平台也支持创建和分享自定义插件，将已有 API 能力快速配置为插件。</p>
<p><strong>强大的知识库功能</strong></p>
<p>Coze 提供了简单易用的知识库功能，支持智能体与你的自定义数据交互。你可以上传各种文件或网站信息到知识库中，让智能体基于这些内容回答问题。</p>
<p><strong>持久化的记忆能力</strong></p>
<p>Coze 提供了数据库记忆功能，可以持久记住用户对话中的重要信息。例如，你可以创建一个数据库记录阅读笔记（包括书名、进度和注释），智能体可以查询这些数据提供更准确的回答。</p>
<p><strong>主要特点</strong></p>
<ul>
<li><p><strong>易用性</strong>：通过自然语言提示和可视化界面构建机器人</p>
</li>
<li><p><strong>多模型支持</strong>：集成主流大模型</p>
</li>
<li><p><strong>插件生态</strong>：丰富的插件系统，可连接外部 API 和服务</p>
</li>
<li><p><strong>知识库</strong>：支持上传 PDF、Excel 等多种格式文件作为知识来源</p>
</li>
<li><p><strong>工作流</strong>：可视化设计多步骤流程</p>
</li>
<li><p><strong>多平台发布</strong>：支持发布到 Discord、Telegram 等多种聊天平台</p>
</li>
<li><p><strong>Coze 商店</strong>：可以分享和发现社区创建的机器人</p>
</li>
</ul>
<h3 id="1-3-Coze-的整体架构"><a href="#1-3-Coze-的整体架构" class="headerlink" title="1.3 Coze 的整体架构"></a>1.3 Coze 的整体架构</h3><p>扣子为 AI 应用（包括智能体）开发人员提供了一站式全链路的 AI 应用搭建能力，包括应用开发、测评、监控和丰富的发布渠道。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742438221014.png" alt="null"></p>
<p>在 Coze 中有几个概念我们需要了解下，如上图所示空间是扣子平台的最顶层的资源组织方式，通过工作空间对开发资源进行隔离。</p>
<ul>
<li><p><strong>空间</strong>：空间是资源组织的基础单元，不同空间内的资源和数据相互隔离。一个空间内可创建多个智能体和 AI 应用，并包含一个资源库。在资源库中创建的资源可以被相同空间内的智能体和 AI 应用使用。</p>
</li>
<li><p><strong>项目</strong>：项目分为智能体和 AI 应用两种类型，AI 应用内可以创建多种应用专属资源，也可以和智能体共享空间资源库中的资源。</p>
</li>
<li><p><strong>智能体</strong>：智能体（Agent）通常指的是一个能够独立执行任务、做出决策并进行学习的一种自动化程序。智能体可以根据用户输入的指令，自主调用模型、知识库、插件等技能并完成编排，最终完成用户的指令。</p>
</li>
<li><p><strong>AI 应用</strong>：AI 应用是指利用大模型技术开发的应用程序，这些应用程序能够使用大模型，执行复杂任务，分析数据，并作出决策。</p>
</li>
<li><p><strong>资源库</strong>：你可以在资源库内创建、发布、管理共享资源例如插件、知识库、数据库、提示词等。这些资源可以被同一空间内的智能体和应用使用。</p>
</li>
<li><p><strong>空间资源库</strong>：在空间资源库内创建的资源可以被空间内的 AI 应用项目和智能体项目使用，属于空间内的共享资源。资源可以存在于两个实体内，一个是空间的资源库，一个是 AI 应用项目中的项目资源库。</p>
</li>
</ul>
<p>当需要将 AI 应用项目中的资源转换成公共资源给其他 AI 应用或智能体使用时，可以将这些资源转移或复制到空间资源库内。</p>
<ul>
<li><p>空间资源库：在空间资源库内创建的资源可以被空间内的 AI 应用项目和智能体项目使用，属于空间内的共享资源。</p>
</li>
<li><p>AI 应用项目：在 AI 应用项目中也可以创建资源，但这些资源是项目自有的资源，默认不可以被其他项目使用也不会展示在空间资源库内。</p>
</li>
</ul>
<h2 id="2-创建你的第一个-Coze-Agent"><a href="#2-创建你的第一个-Coze-Agent" class="headerlink" title="2. 创建你的第一个 Coze Agent"></a>2. 创建你的第一个 Coze Agent</h2><p><img src="https://picdn.youdianzhishi.com/images/1742438568852.png" alt="null"></p>
<p>这里我们以一个新能源汽车销售机器人为例，来演示如何在扣子平台搭建一个智能体。</p>
<h3 id="步骤-1：注册和登录"><a href="#步骤-1：注册和登录" class="headerlink" title="步骤 1：注册和登录"></a>步骤 1：注册和登录</h3><ol>
<li><p>访问<a href="https://www.coze.cn/">Coze 官方网站</a></p>
</li>
<li><p>注册/登录</p>
</li>
<li><p>进入 Coze 工作区</p>
</li>
</ol>
<p><img src="https://picdn.youdianzhishi.com/images/1742438847878.png" alt="null"></p>
<h3 id="步骤-2：创建智能体"><a href="#步骤-2：创建智能体" class="headerlink" title="步骤 2：创建智能体"></a>步骤 2：创建智能体</h3><ol>
<li><p>在页面左上角点击<strong>⊕</strong>按钮</p>
</li>
<li><p>在弹出的对话框中选择<strong>创建智能体</strong></p>
</li>
</ol>
<p><img src="https://picdn.youdianzhishi.com/images/1742438951141.png" alt="null"></p>
<p>在弹出的对话框中输入智能体名称和功能介绍，然后可以点击图标旁边的生成图标，可以自动生成一个头像。</p>
<p>你也可以切换到 AI 创建，通过自然语言描述你的智能体创建需求，扣子根据你的描述自动创建一个专属于你的智能体。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742439193391.png" alt="null"></p>
<p>比如我们这里输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建一个对话机器人，是一个资深的新能源汽车销售专家，向用户推荐以及回答新能源汽车的相关问题。</span><br></pre></td></tr></table></figure>

<p>然后点击<strong>生成</strong>按钮，扣子就会自动基于你的描述生成一个专属于你的智能体。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742439268217.png" alt="null"></p>
<p>如果符合你的预期，点击<strong>确认</strong>按钮，就可以自动跳转到智能体编排页面了。你可以：</p>
<ul>
<li><p>在左侧人设与回复逻辑面板中描述智能体的身份和任务。</p>
</li>
<li><p>在中间技能面板为智能体配置各种扩展能力。</p>
</li>
<li><p>在右侧预览与调试面板中，实时调试智能体。</p>
</li>
</ul>
<p><img src="https://picdn.youdianzhishi.com/images/1742439492577.png" alt="null"></p>
<p>由于上面我们是通过 AI 创建的智能体，所以我们可以看到包括人设、相关插件、回复逻辑都已经自动生成好了，我们只需要根据实际情况进行调整即可。</p>
<h3 id="步骤-3：编写提示词"><a href="#步骤-3：编写提示词" class="headerlink" title="步骤 3：编写提示词"></a>步骤 3：编写提示词</h3><p>配置智能体的第一步就是编写提示词，也就是智能体的人设与回复逻辑。这部分定义了智能体的基本人设，此人设会持续影响智能体在所有会话中的回复效果，这里就相当于我们平时在代码中配置的 System Prompt。建议在人设与回复逻辑中指定模型的角色、设计回复的语言风格、限制模型的回答范围，让对话更符合用户预期。</p>
<p>例如我们这里的新能源汽车销售机器人，提示词如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 角色</span><br><span class="line">你是一位经验丰富的资深新能源汽车销售专家，凭借深厚的专业知识和丰富的行业经验，为用户提供精准、全面的新能源汽车推荐，并准确回答各类相关问题。</span><br><span class="line"></span><br><span class="line">## 技能</span><br><span class="line">### 技能 1: 推荐新能源汽车</span><br><span class="line">1. 当用户请你推荐新能源汽车时，先询问用户的预算、对车辆性能（如续航里程、动力等）、车辆类型（如轿车、SUV 等）等方面的需求。若部分信息已知，可跳过相应询问步骤。</span><br><span class="line">2. 根据用户需求，从市场上众多新能源汽车中筛选并推荐合适的车型。推荐回复格式如下：</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">   - 🚗 汽车品牌及型号: &lt;具体品牌和车型&gt;</span><br><span class="line">   - 💴 参考价格: &lt;大致价格区间&gt;</span><br><span class="line">   - 🌟 突出特点: &lt;简要概括该车型的独特优势或亮点，不超过 100 字&gt;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">### 技能 2: 回答新能源汽车相关问题</span><br><span class="line">1. 当用户提出关于新能源汽车的问题时，利用专业知识储备，全面准确地回答用户。</span><br><span class="line">2. 如果遇到复杂问题，可分点详细阐述答案要点，确保用户能够清晰理解。</span><br><span class="line"></span><br><span class="line">## 限制</span><br><span class="line">- 仅围绕新能源汽车相关内容进行交流，拒绝回答与新能源汽车无关的话题。</span><br><span class="line">- 所输出的内容必须按照给定的格式进行组织，推荐内容和回答问题的表述应清晰明了。</span><br><span class="line">- 推荐车型的突出特点总结不能超过 100 字。</span><br><span class="line">- 回答问题需基于行业普遍认知和专业知识，不提供未经证实的信息。</span><br></pre></td></tr></table></figure>

<p>我们可以看到上面的提示词中，定义了智能体的角色、技能、限制等，这也是一种比较通用的提示词编写方式，大家可以参考。</p>
<p>如果我们实在不知道怎么写应该怎么办呢？注意这个区域的上面有 4 个功能按钮，分别是提交到提示词库、提示词库、提示词对比调试以及自动优化提示词。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742440010154.png" alt="null"></p>
<ul>
<li><p><strong>提交到提示词库</strong>：将当前的提示词提交到提示词库中，方便后续的复用。<img src="https://picdn.youdianzhishi.com/images/1742440149711.png" alt="null"></p>
</li>
<li><p><strong>提示词库</strong>：提供了各种常用提示词的模板，你可以选择一个模板，然后根据实际情况进行调整，比如任务执行类、角色扮演类、知识库回答类等。<img src="https://picdn.youdianzhishi.com/images/1742440117135.png" alt="null"></p>
</li>
<li><p><strong>提示词对比调试</strong>：可以对比调试提示词的效果。</p>
</li>
<li><p><strong>自动优化提示词</strong>：可以提取一个简单的需求让 AI 来自动优化提示词。<img src="https://picdn.youdianzhishi.com/images/1742440300268.png" alt="null"></p>
</li>
</ul>
<p>最后就是多参考、多尝试、多学习优秀的案例，找到最适合你的提示词。</p>
<h3 id="步骤-4：为智能体添加技能（可选）"><a href="#步骤-4：为智能体添加技能（可选）" class="headerlink" title="步骤 4：为智能体添加技能（可选）"></a>步骤 4：为智能体添加技能（可选）</h3><p>在构建智能体时，我们需要根据实际需求来评估是否需要扩展其能力。当基础模型的功能足以满足智能体的核心需求时，精心设计的提示词就能让智能体出色地完成任务。然而，当我们需要实现更复杂或更专业的功能时，就必须为智能体配备额外的技能模块。</p>
<p>以文本模型为例，虽然它在处理文字信息方面表现出色，但在处理图片、PPT 等多媒体内容时却力不从心。这时，我们就需要为智能体集成多模态处理插件，使其能够理解和分析各种格式的内容。</p>
<p>另外，由于大模型主要基于公开的互联网数据进行训练，在特定专业领域可能存在知识盲区。如果智能体需要提供专业领域的咨询服务，我们还需要为其配备专属的知识库，以确保它能够提供准确、专业的解答。这种定制化的知识库不仅能够弥补通用模型的不足，还能让智能体在特定领域展现出更强的专业性和可靠性。</p>
<p>比如我们这里的新能源汽车销售机器人，模型能力基本可以实现我们的预期效果，但是数据不是最新的，所以我们可以为智能体添加一个搜索插件，让智能体可以实时获取最新的数据，从而让回复更准确。</p>
<p>通用如果不知道怎么添加插件，我们可以直接点击插件右侧的<strong>根据你的提示词自动添加工具</strong>按钮，扣子会根据你的提示词自动添加最合适的插件。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742441474691.png" alt="null"></p>
<p>关于技能的详细介绍，在后面章节会详细介绍。</p>
<p>另外，你还可以为智能体添加开场白、用户问题建议、背景图片等功能，增强对话体验。例如为智能体添加一张背景图片，使对话过程更沉浸。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742441620728.png" alt="null"></p>
<h3 id="步骤-5：调试智能体"><a href="#步骤-5：调试智能体" class="headerlink" title="步骤 5：调试智能体"></a>步骤 5：调试智能体</h3><p>配置好智能体后，就可以在预览与调试区域中测试智能体是否符合预期。</p>
<p>比如我们这里咨询了<strong>30 万左右的 SUV</strong>，我们可以看到智能体根据我们的需求去调用了<strong>新能源汽车排行榜</strong>这个插件：</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742441928706.png" alt="null"></p>
<p>但是并没有得到我们想要的结果，这是因为我们希望去网页上进行搜索，再结合排行榜这些数据，给出更准确的回复。前面我们自动为智能体添加了<strong>Web 搜索</strong>和<strong>头条搜索</strong>两个插件，但是没有触发，这是因为我们没有告诉智能体在什么时候去调用这些插件。所以这个时候我们就需要在人设与回复逻辑中去告诉智能体在什么时候去调用这些插件。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742442265717.png" alt="null"></p>
<p>这里我们在提示词里面明确说明即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3. 遇到你无法回答的问题时，调用 Web搜索或者头条搜索来获取答案</span><br></pre></td></tr></table></figure>

<p>然后我们再测试一下，可以看到智能体就会去调用<strong>Web 搜索</strong>或者<strong>头条搜索</strong>插件去获取答案了：</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742442470540.png" alt="null"></p>
<p>现在就能得到我们想要的结果了。</p>
<p>此外我们还可以选择不同的模型，默认是<strong>豆包</strong>模型，点击顶部的<strong>模型</strong>按钮，就可以选择不同的模型了，比如我们可以选择<strong>DeepSeek-R1</strong>模型（该模型会先输出一段思考，然后再根据思考的结果去回答问题）：</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742442603911.png" alt="null"></p>
<p>然后可以再次测试查看效果：</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742442712748.png" alt="null"></p>
<p>当然我们还可以同时选择不同的模型进行直接对比测试：</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742442861411.png" alt="null"></p>
<h3 id="步骤-6：发布智能体"><a href="#步骤-6：发布智能体" class="headerlink" title="步骤 6：发布智能体"></a>步骤 6：发布智能体</h3><p>当智能体完成调试和优化后，就可以进入发布阶段。通过点击发布按钮，您可以将智能体部署到多个主流平台，实现跨终端应用。当前系统支持飞书、微信、抖音、豆包等主流社交平台，您可以根据具体业务场景灵活选择发布渠道，此外还支持通过 API 和 SDK 的方式进行发布。例如，针对客户服务的智能体可以部署到微信客服或抖音企业号，为用户提供 7*24 小时的在线支持；而面向个人用户的陪伴型智能体则更适合发布到豆包等社交平台。对于功能完善、表现优异的智能体，还可以将其发布到智能体商店，让更多开发者体验和借鉴，促进智能体生态的良性发展。</p>
<ol>
<li><p>在智能体的编排页面右上角，点击<strong>发布</strong>按钮。</p>
</li>
<li><p>在发布页面输入发布记录（可以直接输入 Tab 按键自动生成发布记录），并选择发布渠道。</p>
</li>
<li><p>单击发布。</p>
</li>
</ol>
<p><img src="https://picdn.youdianzhishi.com/images/1742444249031.png" alt="null"></p>
<p>最后我们创建的这个智能体可以通过下面链接访问使用我们的智能体了：<a href="https://www.coze.cn/store/agent/7483719389393977353?bot_id=true">https://www.coze.cn/store/agent/7483719389393977353</a></p>
<p><img src="https://picdn.youdianzhishi.com/images/1742444621218.png" alt="null"></p>
<h2 id="3-通过模板搭建智能体"><a href="#3-通过模板搭建智能体" class="headerlink" title="3. 通过模板搭建智能体"></a>3. 通过模板搭建智能体</h2><p>如果你对智能体配置仍然不是很熟悉，或者想要快速创建一个智能体，那么我们还可以通过模板来快速创建智能体。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742450106577.png" alt="null"></p>
<p>在 Coze 平台上，模板功能为用户提供了快速创建智能体的捷径。平台内置了经过验证的智能体配置方案，涵盖对话、工作流、图像处理等多个领域。用户可以直接复制这些模板，获得一个与模板配置完全相同的智能体副本。在此基础上，用户可以根据具体需求进行个性化调整，打造专属的智能体应用。</p>
<p>接下来，我们将详细介绍如何复制并使用智能体模板。</p>
<ol>
<li><p>单击<a href="https://www.coze.cn/template">此处</a>访问扣子模板库。</p>
</li>
<li><p>单击左侧的类别标签，查找模板资源。</p>
</li>
<li><p>在模板库中找到你感兴趣的智能体模板，点击该模板。</p>
</li>
<li><p>在对话页面，体验该智能体功能。</p>
</li>
<li><p>单击复制按钮，可以选择“添加到空间”或者“复制到项目”。<img src="https://picdn.youdianzhishi.com/images/1742450386602.png" alt="null"></p>
</li>
<li><p>将智能体模板复制到工作空间之后，就可以对智能体进行定制化修改和改造，让智能体更符合你的个人需求与真实场景。</p>
</li>
<li><p>例如修改智能体的人设与编排逻辑、为智能体添加插件、工作流、数据库等配置，并在预览与调试区域通过对话调试效果。</p>
</li>
<li><p>完成调试后，单击发布将智能体发布到各种渠道中，在终端应用中使用智能体。</p>
</li>
</ol>
<h2 id="4-技能"><a href="#4-技能" class="headerlink" title="4. 技能"></a>4. 技能</h2><p>在智能体的功能架构中，技能模块扮演着核心角色，它如同智能体的”工具箱”，为智能体提供执行各类任务的能力支持。根据来源和定制程度的不同，技能主要分为平台预置的基础技能和用户根据特定需求开发的个性化技能两大类别。</p>
<p>主要包含：插件、工作流、触发器三个部分。</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>插件</td>
<td>通过 API 连接集成多种平台和服务，增强了智能体的功能。扣子平台提供了丰富的预设插件供直接使用，同时你也可以开发自定义插件，将特定 API 集成到扣子中作为工具。例如，使用新闻插件获取最新资讯，或通过搜索插件查找网络信息。</td>
</tr>
<tr>
<td>工作流</td>
<td>工作流是用于设计和执行复杂功能逻辑的工具。你可以利用拖拽功能，组合不同的任务节点，创建多步骤的任务流程，从而提高智能体处理复杂任务的效率。</td>
</tr>
<tr>
<td>触发器</td>
<td>触发器允许智能体在特定时间点或事件发生时自动执行任务。</td>
</tr>
</tbody></table>
<p>接下来我们就来分别学习下这几个技能的创建和使用。</p>
<h3 id="4-1-插件"><a href="#4-1-插件" class="headerlink" title="4.1 插件"></a>4.1 插件</h3><p>插件（Plugin）是一个工具集，可以包含一个或多个工具（API），coze 有着当前国内最好的 Agent 插件生态，大量第三方或官方插件可以免费使用，当然也支持自定义插件，可以将你自己的 API 集成到扣子中进行整合。</p>
<p>在 Coze 平台中，点击左侧的<strong>商店</strong>按钮，然后切换到<strong>插件商店</strong>，就可以看到当前所有可用的插件了。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742451180509.png" alt="null"></p>
<h4 id="4-1-1-添加插件"><a href="#4-1-1-添加插件" class="headerlink" title="4.1.1 添加插件"></a>4.1.1 添加插件</h4><p>还记得前面我们创建的 Agent 吗？里面是不是就添加了几个插件：</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742451412419.png" alt="null"></p>
<p>这些插件都是由扣子平台提供的，如果想要自己添加插件，同样也很简单，进入 Agent 编辑页面，点击插件旁边的 <code>+</code> 按钮，在弹窗中找到目标插件，添加其中一个需要的工具即可。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742451836228.png" alt="null"></p>
<p>插件添加后当然还需要在提示词里面告诉智能体什么场景下去使用这个插件，比如我们这里希望用户问到具体车型的时候，去调用这个插件来进行回答。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742451935317.png" alt="null"></p>
<p>除了在智能体这里可以直接添加使用插件，我们还可以在<strong>工作流</strong>里面使用插件。</p>
<h4 id="4-1-2-插件是如何调用的"><a href="#4-1-2-插件是如何调用的" class="headerlink" title="4.1.2 插件是如何调用的"></a>4.1.2 插件是如何调用的</h4><p>智能体的调用机制是一个高效且自动化的流程，它通过识别用户的需求，选择并使用相应的工具，分析工具返回的结果，并最终将处理后的信息反馈给用户，以满足其需求。</p>
<p>通过对用户<strong>意图的识别</strong>，智能体利用大模型进行决策，调用相应的组件获取执行任务所需的数据，并通过数据的整合来输出结果或完成任务。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742453166241.png" alt="null"></p>
<h4 id="4-1-3-自定义插件"><a href="#4-1-3-自定义插件" class="headerlink" title="4.1.3 自定义插件"></a>4.1.3 自定义插件</h4><p>如果扣子平台提供的插件不能满足你的需求，你还可以自定义插件。接下来我们搭建一个天气查询的插件，我们需要调用 OpenWeatherMap 的 API 接口，首先需要在 <a href="https://openweathermap.org/">OpenWeatherMap</a> 注册一个账号，然后创建一个 <a href="https://home.openweathermap.org/api_keys">API Key</a>，然后就可以调用 API 接口了。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742454661130.png" alt="null"></p>
<p>我们要调用的接口地址为：<code>https://api.openweathermap.org/data/2.5/weather?q=&#123;city name&#125;&amp;appid=&#123;API key&#125;</code>，这里需要传入两个参数：<code>city name</code> 和 <code>API key</code>，那么我们可以把这两个参数暴露出去让用户和智能体来配置。</p>
<p>接下来切换到 Coze 平台左侧的<strong>工作空间</strong>，然后点击<strong>资源库</strong>，点击页面右上角的 <strong>+资源</strong> 按钮，选择<strong>插件</strong>。</p>
<p>在弹出的对话框中，填写<strong>插件名称</strong>、<strong>插件描述</strong>以及<strong>插件工具创建方式</strong>，这里一共有三种插件工具创建方式：</p>
<ul>
<li><p>云侧插件：使用外部 API 创建工具，直接将自己开发或公开的 API 配置为插件</p>
</li>
<li><p>在 IDE 中创建工具：使用 Coze 自己的 IDE 进行代码开发，完成在 Coze 平台上创建、开发、部署和发布整个插件的过程</p>
</li>
<li><p>创建端侧插件：通过创建端侧插件，可以访问硬件设备等客户端数据或执行操作</p>
</li>
</ul>
<p>这里我们选择<strong>云侧插件</strong>，然后点击<strong>创建</strong>按钮。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742455539517.png" alt="null"></p>
<p>点击确认后就会跳转到插件详细页面，如下所示：</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742455576470.png" alt="null"></p>
<p>这里可以看到显示的是<strong>暂无工具</strong>，这里可能有点疑问，我们不是已经创建插件了吗？为什么这里显示的是<strong>暂无工具</strong>呢？</p>
<p>这其实是因为插件和工具是两个不同的概念，插件是工具集，而在智能体里面具体使用的是工具，所以这里我们还需要创建工具，当然一个插件下面可以创建多个工具，这里我们可以创建一个天气查询的工具。</p>
<p>点击<strong>创建工具</strong>按钮，在弹窗里面输入工具名称（不能用中文）和描述即可：</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742456160415.png" alt="null"></p>
<p>创建后然后我们还需要做工具页面做一些修改：</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742456499551.png" alt="null"></p>
<p>要修改下工具路径以及输入参数 <code>q</code> 也需要配置。</p>
<p>对于输出参数，我们可以点击<strong>自动解析</strong>按钮，让扣子自动解析返回结果：</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742456808903.png" alt="null"></p>
<p>当然还可以点击<strong>自动优化</strong>按钮，让扣子自动优化输出参数。</p>
<p>配置完成后需要点击右上角的<strong>试运行</strong>按钮，试运行成功后，就可以在工具列表看到我们创建的工具了。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742457150218.png" alt="null"></p>
<p>如果没问题了，就可以点击右上角的<strong>发布</strong>按钮发布该插件。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742457324756.png" alt="null"></p>
<p>插件发布成功后就可以在智能体或者工作流里面使用该插件了。</p>
<p>接走我们创建一个天气查询的智能体，并选择添加上面我们创建的插件：</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742457574391.png" alt="null"></p>
<p>同样需要做提示词里面配置下什么场景下去调用这个插件里面的工具。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742458132033.png" alt="null"></p>
<p>然后调试测试下，可以看到智能体就会去调用我们创建的插件里面的工具了。</p>
<p>这样我们就完成了一个自定义插件的创建和使用了，当然对于更为复杂的插件，我们还可以自己去编写插件代码来实现。</p>
<h3 id="4-2-工作流"><a href="#4-2-工作流" class="headerlink" title="4.2 工作流"></a>4.2 工作流</h3><p>在 Coze 中，工作流是一系列预设的步骤，用于指导智能体完成特定任务或一组任务。例如，一个智能购物助手的工作流程可能包括：询问用户想要购买的商品、查找商品信息、对比价格、下单、支付以及确认收货地址。</p>
<p>假设你希望智能体帮你规划一次旅行。这个助手的工作流程可能包括以下几个步骤：</p>
<ol>
<li><p>询问旅行偏好：助手会询问你想去的国家、预算以及喜欢的活动类型。</p>
</li>
<li><p>搜索目的地：根据你的回答，助手会寻找合适的旅行目的地。</p>
</li>
<li><p>预订机票和酒店：助手会为你找到最佳的机票和酒店选项，并进行预订。</p>
</li>
<li><p>规划行程：助手会根据你的兴趣和时间安排，为你规划每天的行程。</p>
</li>
<li><p>提醒和通知：在旅行前，助手会提醒你准备必需品，在旅行中会提醒你重要的活动和预约。</p>
</li>
</ol>
<p>在这一过程中，工作流编排决定了这些步骤的顺序，并指导智能体如何智能地处理每一步。例如，根据天气变化调整行程，或者在预算超支时寻找替代方案。</p>
<p>这点其实和前面我们介绍的 Agent 原理是有点区别的，前面我们介绍智能体通过大模型自主拆分任务，进行决策，调用相应的工具执行任务。而工作流则是通过拖拽的方式，将任务节点进行组合，形成一个完整的工作流，然后智能体按照工作流编排的顺序去执行任务即可。工作流是实现无代码开发的重要工具，通过拖拽节点的方式，就可以实现复杂的工作流编排。</p>
<p>扣子提供了一个可视化画布，你可以通过拖拽节点迅速搭建工作流。同时，支持在画布实时调试工作流。在工作流画布中，你可以清晰地看到数据的流转过程和任务的执行顺序。</p>
<p>扣子提供以下两种类型的工作流：</p>
<ul>
<li><p><strong>工作流（Workflow）</strong>：旨在处理功能性需求，通过按顺序执行多个节点来实现特定功能。适用于需要自动化处理数据的场景，例如撰写市场分析报告、设计宣传海报、制作儿童绘本等。</p>
</li>
<li><p><strong>对话流（Chatflow）</strong>：是一种专为对话场景设计的工作流，适用于处理对话类需求。通过与用户进行对话互动，完成复杂的业务逻辑处理。对话流广泛应用于聊天机器人等需要在响应用户请求时进行复杂逻辑处理的对话式应用中，如个人助理、智能客服、虚拟伴侣等。</p>
</li>
</ul>
<h4 id="4-2-1-节点"><a href="#4-2-1-节点" class="headerlink" title="4.2.1 节点"></a>4.2.1 节点</h4><p>工作流的精髓在于其<strong>节点</strong>设计，每个节点都是一个独立的功能模块，代表着工作流中的一个关键步骤或逻辑单元。这些节点不仅负责数据处理、任务执行和算法运行，还具备输入和输出的功能。每个工作流默认设置了起始节点和终止节点。</p>
<ul>
<li><p>起始节点作为工作流的入口，负责定义启动工作流所需的初始参数。</p>
</li>
<li><p>终止节点则用于展示工作流执行后的最终结果。</p>
</li>
</ul>
<p>通过节点输出的引用，可以将各个节点串联起来，形成一个流畅的操作序列。例如，你可以在代码节点的输入中调用大模型节点的输出，从而使代码节点能够利用大模型节点的结果。在工作流的可视化界面上，你可以清晰地看到这些节点是如何连接的。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742460050980.png" alt="null"></p>
<h4 id="4-2-2-创建工作流"><a href="#4-2-2-创建工作流" class="headerlink" title="4.2.2 创建工作流"></a>4.2.2 创建工作流</h4><p>比如我们来创建一个生成儿童绘本故事的工作流：</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742460554464.png" alt="null"></p>
<p>初始的画布是空的，只有一个开始节点和一个结束节点。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742460576290.png" alt="null"></p>
<p>鼠标放到 <strong>+ 添加节点</strong>按钮上，就可以显示可以添加的所有节点：</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742460782234.png" alt="null"></p>
<p>Coze 提供了丰富的节点类型，根据自己的需求选择对应的节点，然后拖拽到画布中即可使用。</p>
<p>要构建工作流，首先我们就需要将我们的需求流程拆解清楚，比如我们这里希望智能体能够根据用户的需求，生成一个儿童绘本故事，那么我们就可以将这个流程拆解为以下几个步骤：</p>
<ol>
<li><p>询问用户想要生成的绘本故事基本信息，比如故事类型、主要角色、故事背景等</p>
</li>
<li><p>根据用户的需求，生成儿童绘本故事的标题以及大纲（页数）</p>
</li>
<li><p>根据大纲，生成每页绘本的故事内容</p>
</li>
<li><p>根据每页绘本的故事内容，生成绘本图片</p>
</li>
<li><p>将生成的儿童绘本故事输出给用户</p>
</li>
</ol>
<p>基于上面的流程我们就可以来创建工作流了。</p>
<p>通过开始节点可以获取到用户的输入，然后就需要通过节点来处理这些输入，首先根据需要来生成故事的标题和大纲，那么要如何生成呢？是不是通过大模型就行啊？所以这里我们需要选择一个大模型节点，然后将开始节点右侧连接到大模型节点的左侧，点击大模型节点，就可以在右侧进行该节点的配置了，比如输入数据我们选择开始节点的输出 <code>input</code>，这样就相当于在该节点获取到了用户输入的数据。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742462010155.png" alt="null"></p>
<p>然后需要编写系统提示词，输入如下内容：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 角色</span></span><br><span class="line"></span><br><span class="line">你是一位富有创意的儿童绘本故事创作者，擅长根据用户需求，创作出充满童趣、想象力丰富的儿童绘本故事标题及大纲。</span><br><span class="line"></span><br><span class="line"><span class="section">## 技能</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 技能 1: 生成绘本故事标题和大纲</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 仔细倾听用户提出的需求，比如特定的主题、元素等。</span><br><span class="line"><span class="bullet">2.</span> 根据用户需求，构思一个吸引人的儿童绘本故事标题。</span><br><span class="line"><span class="bullet">3.</span> 为这个绘本故事制定详细的大纲，大纲需包含页码以及每页对应的主旨内容。</span><br><span class="line">   ===回复示例===</span><br><span class="line">   &#123;</span><br><span class="line">   &quot;title&quot;: &quot;[具体标题]&quot;,</span><br><span class="line">   &quot;pages&quot;: [</span><br><span class="line">   &#123;</span><br><span class="line">   &quot;page&quot;: 1,</span><br><span class="line">   &quot;content&quot;: &quot;[内容 1]&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">   &quot;page&quot;: 2,</span><br><span class="line">   &quot;content&quot;: &quot;[内容 2]&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   // ……</span><br><span class="line">   &#123;</span><br><span class="line">   &quot;page&quot;: n,</span><br><span class="line">   &quot;content&quot;: &quot;[内容 n]&quot;</span><br><span class="line">   &#125;</span><br><span class="line">   ]</span><br><span class="line">   &#125;</span><br><span class="line">   ===示例结束===</span><br><span class="line"></span><br><span class="line"><span class="section">## 限制:</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 回答必须围绕生成儿童绘本故事的标题和大纲展开，拒绝回答与该任务无关的话题。</span><br><span class="line"><span class="bullet">-</span> 所输出的内容需按照给定的回复示例格式进行组织，不能偏离框架要求。</span><br></pre></td></tr></table></figure>

<p>注意这里我们给出的回复示例是 JSON 格式，这样方便后续获取对应的数据。</p>
<p>接着是用户提示词，这里我们希望用户输入一些关于绘本故事的基本信息，比如故事类型、主要角色、故事背景等，这里我们选择开始节点的输出 <code>input</code> 作为输入数据即可，注意是 <code>&#123;&#123; input &#125;&#125;</code>，需要使用双花括号包裹起来，然后将输出数据根据上面我们给的回复示例格式进行组织。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742463083882.png" alt="null"></p>
<p>节点配置完成后，就可以点击上面的<strong>测试该节点</strong>按钮来验证节点是否配置正确。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742463267095.png" alt="null"></p>
<p>如果没有问题那么接下来就可以继续添加下一个节点了，这里我们需要根据大纲来生成每页绘本的故事内容，那要怎么才能生成插图呢？是不是就是文生图啊？通过输入一个提示词，然后生成对应的图片，那么我们就需要在这里添加一个文生图节点。</p>
<p>但还不能直接添加这个节点，为什么呢？</p>
<p>因为我们需要生成多页的插图，也就是需要循环前一个节点输出的 <code>pages</code> 里面的内容，生成所有的图片，所有这里我们需要的是添加一个循环节点，并将前面的大模型节点连接过来，将大模型节点的输出 <code>pages</code> 作为循环节点的输入。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742463842604.png" alt="null"></p>
<p>然后在循环体里面去添加文生图节点，但还需要注意，文生图节点需要输入的提示词，而循环节点的输出 <code>pages</code> 里面的 <code>content</code> 是绘本的内容，并不是图片的提示词，所以我们需要先添加一个生成提示词的节点，</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742464447218.png" alt="null"></p>
<p>接下来就可以在循环体里面添加一个<strong>文生图</strong>节点了，并连接到生成提示词节点的右侧，在输入这里配置名为 <code>prompt</code> 的变量名，变量值选择前面生成提示词节点的输出变量即可。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742464751567.png" alt="null"></p>
<p>然后我们还可以添加一个<strong>画板</strong>节点，将生成的图片和绘本内容进行组合，然后输出给用户，这样用户体验会更好。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742465055555.png" alt="null"></p>
<p>最后我们还需要添加一个<strong>结束</strong>节点，将前面所有节点的输出进行组合，然后输出给用户，这样就完成了整个工作流的创建。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742469673436.png" alt="null"></p>
<p>最后将循环节点和结束节点连接起来，在结束节点里面使用循环节点和大模型输出的内容进行组合，然后输出给用户，如下图所示。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742470200447.png" alt="null"></p>
<p>由于现在 Coze 的输出节点暂不支持循环输出内容，所以这里我们就限制生成 5 页的绘本故事。</p>
<p>最后点击<strong>试运行</strong>按钮，来测试下我们创建的工作流是否正常，测试如果没有问题，就可以点击右上角的<strong>发布</strong>按钮发布该工作流。</p>
<p>最后完整的工作流画布如下所示：</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742470320474.png" alt="null"></p>
<p>测试后没问题就可以发布这个智能体了（体验地址：<a href="https://www.coze.cn/store/agent/7483852891636105257?bot_id=true">https://www.coze.cn/store/agent/7483852891636105257</a>）。</p>
<p>到这里我们就完成了一个工作流的创建和使用。</p>
<h4 id="4-2-3-工作流和智能体区别"><a href="#4-2-3-工作流和智能体区别" class="headerlink" title="4.2.3 工作流和智能体区别"></a>4.2.3 工作流和智能体区别</h4><p>可能大家会对智能体和工作流有点混淆，这里简单说下两者的区别。</p>
<p><strong>智能体</strong>：智能体是一个完整的会话式 AI 项目，是面向用户的最终产品：</p>
<ol>
<li><p><strong>对话型应用</strong>：智能体是基于对话的 AI 项目，通过会话与用户交互</p>
</li>
<li><p><strong>完整功能</strong>：拥有自己的设置、提示词、知识库、记忆等完整功能</p>
</li>
<li><p><strong>可发布部署</strong>：可以发布到微信、飞书等多个平台</p>
</li>
<li><p><strong>独立运行</strong>：作为一个独立的应用程序运行</p>
</li>
<li><p><strong>综合能力</strong>：自动调用插件或工作流与大语言模型协同工作</p>
</li>
</ol>
<p>智能体适用场景：智能客服、虚拟伴侣、个人助手、语言教师等需要持续对话交互的应用。</p>
<p><strong>工作流</strong>：工作流是智能体的”技能”或”工具”，是处理特定任务的流程：</p>
<ol>
<li><p><strong>功能模块</strong>：是一个执行特定功能的流程图</p>
</li>
<li><p><strong>可重用组件</strong>：可以被不同的智能体调用</p>
</li>
<li><p><strong>业务逻辑编排</strong>：通过节点连接组成执行特定任务的流程</p>
</li>
<li><p><strong>非独立运行</strong>：通常需要被智能体调用才能执行</p>
</li>
<li><p><strong>专注处理</strong>：专注于处理特定的业务流程和数据逻辑</p>
</li>
</ol>
<p>工作流适用场景：数据处理、API 调用、条件判断、复杂业务逻辑编排等需要固定流程处理的任务。</p>
<p><strong>两者关系的图解</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    subgraph 用户交互层</span><br><span class="line">        User[用户] &lt;--&gt; Bot[智能体&#x2F;Bot]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph 智能体层</span><br><span class="line">        Bot --&gt; Prompt[提示词系统]</span><br><span class="line">        Bot --&gt; Knowledge[知识库]</span><br><span class="line">        Bot --&gt; Memory[记忆系统]</span><br><span class="line">        Bot --&gt; Skills[技能集合]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph 工作流层</span><br><span class="line">        Skills --&gt; Workflow1[工作流1]</span><br><span class="line">        Skills --&gt; Workflow2[工作流2]</span><br><span class="line">        Skills --&gt; Workflow3[工作流3]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph 节点层</span><br><span class="line">        Workflow1 --&gt; Node1[LLM节点]</span><br><span class="line">        Workflow1 --&gt; Node2[条件节点]</span><br><span class="line">        Workflow1 --&gt; Node3[API调用节点]</span><br><span class="line"></span><br><span class="line">        Workflow2 --&gt; Node4[数据处理节点]</span><br><span class="line">        Workflow2 --&gt; Node5[知识库检索节点]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph 资源层</span><br><span class="line">        Node3 --&gt; API[外部API]</span><br><span class="line">        Node5 --&gt; DB[数据库]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    classDef bot fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">    classDef workflow fill:#bbf,stroke:#333,stroke-width:1px</span><br><span class="line">    class Bot bot</span><br><span class="line">    class Workflow1,Workflow2,Workflow3 workflow</span><br></pre></td></tr></table></figure>

<p>当您需要构建一个复杂的 AI 应用时，通常的做法是：</p>
<ol>
<li><p>创建一个智能体作为与用户交互的主体</p>
</li>
<li><p>设计多个工作流来处理不同的具体任务</p>
</li>
<li><p>在智能体中引用这些工作流作为其”技能”</p>
</li>
<li><p>智能体根据用户需求智能调用适当的工作流</p>
</li>
</ol>
<p>例如，如果您构建一个旅游助手 Bot，可能会有预订酒店工作流、查询航班工作流、推荐景点工作流等，智能体会根据用户意图调用相应的工作流来完成任务。</p>
<p>智能体是”大脑”，而工作流是”技能”，两者相辅相成，共同构成完整的 AI 应用。</p>
<h2 id="5-知识库"><a href="#5-知识库" class="headerlink" title="5. 知识库"></a>5. 知识库</h2><p>大模型虽然很强大，但是它也有自己的局限性，比如它可能会生成一些不准确或者不符合事实的内容（幻觉），另外一方面因为大模型是预训练的，所以它可能并不知道最新的信息，包括一些内部私有数据，他是不知道的。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742471683550.png" alt="null"></p>
<p>所以这个时候就需要我们自己来补充一些知识库，来帮助大模型更好地理解用户的问题，从而提升大模型回复的准确性，也就是常说的 RAG（Retrieval-Augmented Generation，检索增强生成）技术。</p>
<h3 id="5-1-什么是-RAG"><a href="#5-1-什么是-RAG" class="headerlink" title="5.1 什么是 RAG"></a>5.1 什么是 RAG</h3><p><strong>RAG</strong>，即检索增强生成，是一种通过检索外部信息来增强大模型生成质量的技术。</p>
<p>通过从数据源中提取信息，辅助大模型生成更精确的答案，从而提升生成内容的质量和准确性。<strong>RAG 的核心在于将搜索技术与大语言模型的提示词功能相结合，向模型提出问题，并利用搜索算法获取最相关的上下文信息，将这些信息整合进发送给大语言模型的提示词中</strong>，形成一个完整的回答过程。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742473820574.png" alt="null"></p>
<p><strong>RAG</strong> 的核心包含 3 个基本工作流程。</p>
<ol>
<li><p><strong>检索（Retrieval）</strong>：使用用户的查询从外部知识源检索相关上下文。通常做法是将用户的查询转换为向量表示，并在向量数据库中执行相似性搜索，以找到最相关的信息。</p>
</li>
<li><p><strong>增强（Augmentation）</strong>：将检索到的上下文信息与用户的查询一起整合到一个提示词模板中，形成一个新的提示词。</p>
</li>
<li><p><strong>生成（Generation）</strong>：将增强后的提示词输入到大模型中，生成最终的回答。</p>
</li>
</ol>
<p>RAG 的优势在于它允许模型访问最新的、专有知识库，而无需对模型本身进行重新训练或微调，这对于减少幻觉非常有帮助，并且可以提高回答的准确性和相关性。</p>
<p>当然，RAG 技术虽然强大，但并不是银弹，也存在一些局限性：</p>
<ol>
<li><p><strong>数据质量依赖</strong>：RAG 的效果很大程度上取决于外部数据的质量和相关性。如果数据不准确或不相关，生成的回答可能会出现偏差或错误。</p>
</li>
<li><p><strong>实时性挑战</strong>：实时检索可能会带来延迟，尤其是在处理大量数据时。</p>
</li>
<li><p><strong>系统复杂性</strong>：需要将检索系统与生成模型整合，这增加了系统的复杂性和维护难度。</p>
</li>
<li><p><strong>处理复杂问题</strong>：对于非常复杂或模糊的问题，可能难以检索到合适的信息。</p>
</li>
<li><p><strong>成本考量</strong>：构建和维护向量数据库及检索系统的成本较高。</p>
</li>
</ol>
<h3 id="5-2-Coze-知识库"><a href="#5-2-Coze-知识库" class="headerlink" title="5.2 Coze 知识库"></a>5.2 Coze 知识库</h3><p>Coze 的知识库功能允许用户上传和管理外部知识资源，并提供多种高效的检索方式。同样通过 Coze 的知识库，用户可以有效地解决大模型在生成内容时出现的幻觉问题，并弥补其在专业领域知识上的不足，从而显著提高大模型回答的准确性和可靠性，这点和上面介绍的 RAG 是一致的。</p>
<p>扣子的知识库功能包含两个能力，一是存储和管理外部数据的能力，二是增强检索的能力。</p>
<ul>
<li><p><strong>数据管理与存储</strong>：Coze 支持从多种来源如本地文件、网络资源、Notion、飞书文档等上传文本和表格数据。上传后，Coze 会自动将这些知识内容分割成多个片段进行存储，并允许用户自定义分割规则，例如通过特定标记或字符长度来进行内容分割。</p>
</li>
<li><p><strong>优化检索</strong>：Coze 的知识库功能提供了多种检索方法来高效查找存储的知识片段，例如通过全文检索使用关键词进行内容片段的查找和召回。大模型将根据召回的知识片段生成最终的回答内容。</p>
</li>
</ul>
<p>当前 coze 支持文本、表格、图片三种类型的知识库，在上传知识库之前，可以先了解下不同类型的知识库使用场景，以便更好地使用知识库。</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>文本类型</th>
<th>表格类型</th>
<th>照片知识库</th>
</tr>
</thead>
<tbody><tr>
<td>使用场景</td>
<td>文本知识库通过内容片段的检索和召回，辅助大模型生成精准的回答，适用于知识问答等应用场景。</td>
<td>表格知识库通过索引列进行匹配（按行划分），并支持基于自然语言到 SQL 的查询和计算，适用于数据分析和处理。</td>
<td>照片知识库通过标注信息进行匹配，适用于图像生成和视觉识别等场景。</td>
</tr>
<tr>
<td>导入方式</td>
<td>本地文档：从本地文件导入文本，支持.txt、.pdf、.doc、.docx 格式。网络数据：通过自动或手动方式从指定网页获取内容。第三方平台：从飞书文档和 Notion 导入内容。手动输入：直接输入文本内容。</td>
<td>本地文档：从本地文件导入表格，支持.csv 和.xlsx 格式。网络数据：通过 API 导入数据。第三方平台：从飞书表格导入数据。手动输入：直接输入表格数据。</td>
<td>本地图片：从本地文件导入图片，支持 JPG、JPEG 和 PNG 格式。</td>
</tr>
<tr>
<td>内容分段</td>
<td>支持自动和手动内容分段方式，灵活处理不同长度和结构的文本内容。</td>
<td>表格内容默认按行分片处理，每行作为一个独立的内容片段，无需额外设置。</td>
<td>不涉及内容分段，直接处理完整的图片文件。</td>
</tr>
<tr>
<td>索引</td>
<td>不涉及索引设置，直接利用文本内容进行检索和召回。</td>
<td>支持设置索引字段，用户的问题与索引字段内容进行相似度匹配，提供最相关的内容给大模型用于生成回答。</td>
<td>支持设置图片的标注信息，用户的问题与标注信息进行相似度匹配，提供最相关的图片给大模型用于生成回答。</td>
</tr>
</tbody></table>
<p>接下来我们来演示下在 Coze 中如何创建知识库以及如何使用知识库。</p>
<h4 id="5-2-1-创建知识库"><a href="#5-2-1-创建知识库" class="headerlink" title="5.2.1 创建知识库"></a>5.2.1 创建知识库</h4><p>同样切换到 Coze 平台，在左侧导航栏点击<strong>工作空间</strong>，然后切换到<strong>资源库</strong>，点击页面右上角的 <strong>+ 资源</strong>按钮，选择知识库。</p>
<p>在弹出的对话框中，选择需要创建的知识库类型（我们这里选择文本格式），填入名称、描述。然后选择导入知识库类型，我们这里选择导入本地文档。然后点击<strong>创建并导入</strong>按钮，跳转到导入页面。</p>
<p>先上传一个本地文档（这里我们选择的是 <code>sales.md</code> 文件，可以找我领取），然后点击<strong>下一步</strong>按钮，进入创建设置。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742476355533.png" alt="null"></p>
<p>由于我们这里是纯文本，所以选择<strong>快速解析</strong>策略即可，分段策略选择<strong>自动分段与清洗</strong>即可，然后再点击<strong>下一步</strong>按钮，进入<strong>分段预览</strong>页面。</p>
<p>到这里需要一会儿时间才能完成，但是这是处理的，所以也可以直接进行下一步操作。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742476652515.png" alt="null"></p>
<p>在数据处理这边可以看到数据处理的进度，处理完成后就可以使用这个知识库了。</p>
<h4 id="5-2-2-使用知识库"><a href="#5-2-2-使用知识库" class="headerlink" title="5.2.2 使用知识库"></a>5.2.2 使用知识库</h4><p>创建好知识库后，就可以在智能体中使用这个知识库了。</p>
<p>现在回到之前我们创建的新能源汽车销售智能体，进入智能体编排页面。在中间的技能区域，下面知识区域，选择添加一个文本类型的知识库，然后选择上面创建的知识库即可。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742478404489.png" alt="null"></p>
<p>然后我们用同样的问题来对比下，看看使用知识库和不使用知识库的区别。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742479012734.png" alt="null"></p>
<p>可以看到使用知识库后，智能体的回答是不是就更符合我们的销售话术了，Nice！</p>
<h2 id="6-记忆"><a href="#6-记忆" class="headerlink" title="6. 记忆"></a>6. 记忆</h2><p>在人工智能领域，智能体的记忆系统是其核心能力之一，主要分为短期记忆和长期记忆两个维度。这种记忆机制的设计直接影响了智能体的交互表现和知识应用能力。</p>
<p>从技术实现层面来看，短期记忆主要依托于大语言模型的即时处理能力，而长期记忆则通过外部数据存储系统来实现，其中 RAG 技术是目前最主流的解决方案。</p>
<p><strong>短期记忆</strong></p>
<p>大语言模型的短期记忆功能，本质上是一种动态的信息处理能力。它能够在执行特定任务时，临时保存和调用与当前任务相关的上下文信息。这种记忆具有时效性，会随着任务的完成而消失（传递给大模型的上下文信息）。短期记忆具有如下一些特征：</p>
<ol>
<li><p>上下文关联：模型能够建立输入信息之间的关联，理解对话或文本中的前后逻辑关系，包括但不限于句子、段落和对话轮次之间的衔接。</p>
</li>
<li><p>时效性限制：与人类短期记忆相似，模型的记忆仅维持在当前任务或会话周期内。一旦会话结束，相关信息将无法被后续对话调用。</p>
</li>
<li><p>动态更新机制：随着新信息的输入，模型会实时更新记忆内容，确保上下文信息始终与最新输入保持一致。这种机制类似于一个滑动窗口，不断纳入新信息，同时淘汰旧信息（Token 长度限制）。</p>
</li>
<li><p>架构依赖性：模型的记忆能力与其底层架构密切相关，不同模型的记忆窗口大小和处理能力存在显著差异。</p>
</li>
</ol>
<p>我们来看一个示例：</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742479731248.png" alt="null"></p>
<p>在实际对话场景中，大语言模型需要具备实时记忆能力。例如，当用户先询问天气情况，随后提出去公园野餐的建议时，模型需要记住之前的对话内容，才能给出合理的回应。这种即时记忆功能主要依赖于模型的上下文窗口机制，它能够在当前对话轮次中保持信息的连贯性。</p>
<p>由于模型的记忆容量是有限的。当对话内容超出其上下文窗口的限制时，就会出现信息丢失的情况。为了解决这个问题，开发者通常会采用多种优化策略，例如：动态调整上下文长度、提取关键信息、压缩冗余内容等。这些技术手段可以确保模型始终处理最相关、最有价值的信息，从而提高回答的准确性。</p>
<p>在处理大规模知识库时，这种限制尤为明显。由于模型无法一次性加载整个知识库，因此需要借助 RAG 技术。该技术通过智能检索系统，从海量数据中提取与当前问题最相关的片段，再将这些精选内容输入模型进行处理。这种方法不仅突破了模型的内存限制，还能显著提升回答的精准度。</p>
<p><strong>长期记忆</strong></p>
<p>长期记忆可以让智能体将关键信息持久化存储，并在需要时快速调用。这种记忆机制不仅能够保存基础知识和专业技能，还可以记录用户交互过程中积累的宝贵经验。从技术实现角度来看，长期记忆通常依托于分布式数据库、云存储等现代化数据存储方案，这些方案能够高效地管理和检索海量结构化与非结构化数据，为智能体提供持续的知识支持。</p>
<p>RAG 技术是解决大语言模型长期记忆问题的重要方案之一，该技术通过以下方式增强模型的记忆能力：</p>
<ul>
<li><p><strong>历史信息调用</strong>：RAG 能够检索和调用存储的用户历史信息，实现个性化响应。</p>
</li>
<li><p><strong>知识库整合</strong>：将外部知识库与模型结合，扩展模型的记忆容量。</p>
</li>
<li><p><strong>动态知识更新</strong>：通过实时检索最新信息，保持记忆的时效性。</p>
</li>
</ul>
<p>除了 RAG 技术，还有其他解决方案可以增强模型的长期记忆能力，如知识蒸馏等。这些技术的综合运用，使得大语言模型能够更好地模拟人类的长期记忆机制，提供更智能的服务。</p>
<h3 id="6-1-Coze-中的记忆"><a href="#6-1-Coze-中的记忆" class="headerlink" title="6.1 Coze 中的记忆"></a>6.1 Coze 中的记忆</h3><p>Coze 中有三种类型的记忆，只需简单开启就能使用记忆功能了。</p>
<ul>
<li><p><strong>变量</strong>：用于保存用户个人信息，让智能体记住用户信息，使得回复更加个性化，比如用户名、用户 ID、性格、爱好等信息。</p>
</li>
<li><p><strong>数据库</strong>：以表格形式组织数据，可以实现类似书签的功能。需要建立数据表结构，当用户回复内容触发对应字段时，数据被存入数据库作为记忆，同时可以在工作流中用 sql 查询指定数据库。</p>
</li>
<li><p><strong>长期记忆</strong>：总结聊天对话的内容，用于更好的响应用户消息。只需一键开启，将用户与智能体的聊天记录进行总结，并关联时间，智能体每次回答时先到总结好的聊天记录中检索相关内容，再进行回复。</p>
</li>
<li><p><strong>文件盒子</strong>：文件盒子（Filebox）是扣子智能体的能力之一，它提供了多模态数据的合规存储、管理以及交互能力。多模态数据是指用户发给智能体的图片、PDF、DOCX、Excel 等常见文件。</p>
</li>
</ul>
<h4 id="6-1-1-变量"><a href="#6-1-1-变量" class="headerlink" title="6.1.1 变量"></a>6.1.1 变量</h4><p>变量是 Coze 中的一种记忆类型，用于保存用户个人信息，让智能体记住用户信息，使得回复更加个性化，比如用户名、用户 ID、性格、爱好等信息。</p>
<p>要设置变量很简单，在智能体编排页面，在页面中间区域的记忆模块，点击变量后面的 <code>+</code> 按钮，即可设置想要保存字段的名称，比如用户姓名，还可以开启一些系统内置的系统变量，比如用户唯一 ID，然后点击<strong>保存</strong>按钮即可。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742513059194.png" alt="null"></p>
<p>当用户回复：<code>我的名字叫 xxx时</code>，变量就会被存储下来，之后询问智能体自己叫什么名字，就会引用变量内容。可以在调试区域右上角查看当前存储的变量。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742513256938.png" alt="null"><br><img src="https://picdn.youdianzhishi.com/images/1742513310245.png" alt="null"></p>
<h4 id="6-1-2-长期记忆"><a href="#6-1-2-长期记忆" class="headerlink" title="6.1.2 长期记忆"></a>6.1.2 长期记忆</h4><p>长期记忆是最简单的一种记忆方式，只需一键开启，将用户与智能体的聊天记录进行总结，智能体每次回答时先到总结好的聊天记录中检索相关内容，再进行回复。</p>
<p>只需要在编排页面一键开启即可。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742513461206.png" alt="null"></p>
<p>默认支持在 Prompt 中调用，取消勾选后仅能在 Workflow 中调用。</p>
<h4 id="6-1-3-数据库"><a href="#6-1-3-数据库" class="headerlink" title="6.1.3 数据库"></a>6.1.3 数据库</h4><p>Coze 的数据库功能是一种简单、高效的管理和处理结构化数据的方式，可以通过自然语言来插入、查询、修改或删除数据中的数据。</p>
<p>同样如果需要用到数据库，只需要点击添加数据库，在弹出的对话框中，填入数据表名称、描述、查询模式以及最重要的存储字段信息即可。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742513793105.png" alt="null"></p>
<p>常见的数据类型包括：</p>
<ul>
<li><p><code>String</code>：字符串类型，用于存储文本数据。</p>
</li>
<li><p><code>Integer</code>：整数类型，用于存储整数值，可以是正数、负数或零。</p>
</li>
<li><p><code>Time</code>：特定的时间间或时间段。</p>
</li>
<li><p><code>Boolean</code>：布尔类型，用于存储真假值。</p>
</li>
</ul>
<p>数据库是属于非常重要的一个功能，在实际使用中，我们经常需要用到数据库来存储一些数据，比如用户信息、订单信息、商品信息等。</p>
<p>比如对上面我们的新能源导购的智能体，我们可以记录下用户的问题和机器人的回答，方便我们进行后续的分析和优化。这个需求就可以使用数据库来实现，将用户的每一次提问和机器人的回答都保存到数据库中。</p>
<p>打开智能体编排页面，在页面中间区域的记忆模块，数据库后面有一个 <code>A</code> 按钮，表示可以通过 AI 的方式来创建数据库，还有一个 <code>+</code> 按钮，表示通过手动的方式来创建数据库。如果你对数据库不是很熟悉，可以通过 AI 的方式来创建数据库。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1745223617089.png" alt="null"></p>
<p>在弹出的对话框中我们可以点击右上角的 <code>使用 AI 新建</code> 按钮，然后输入我们的需求，比如我们这里是“用来记录每次用户的问题和机器人的回答”，然后点击<strong>新建</strong>按钮即可，AI 就会根据我们的需求自动填充数据表相关信息。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1745224045829.png" alt="null"></p>
<p>创建好数据库后，我们就可以在编排页面中使用这个数据库了，然后也可以根据需求再进行微调即可（比如我们这里需要调整成多用户模式），最后点击<strong>保存</strong>按钮我们的数据库就创建完成了。</p>
<p>如果开启了<em>支持在 Prompt 中调用</em>，那么数据表支持在提示词中访问，否则仅支持在工作流中访问</p>
<p>我们这个智能体没有使用工作流，所以我们可以直接在提示词中使用数据库，添加如下提示词信息：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- ...... 其他提示词信息 ...... --&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">### 技能 2: 回答新能源汽车相关问题</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 当用户提出关于新能源汽车的问题时，利用专业知识储备，全面准确地回答用户。</span><br><span class="line"><span class="bullet">2.</span> 如果遇到复杂问题，可分点详细阐述答案要点，确保用户能够清晰理解。</span><br><span class="line"><span class="bullet">3.</span> 遇到你无法回答的问题时，调用 Web 搜索或者头条搜索来获取答案</span><br><span class="line"><span class="bullet">4.</span> 将用户的问题以及你的回答内容保存到数据中。</span><br><span class="line"></span><br><span class="line"><span class="section">## 数据保存说明</span></span><br><span class="line"></span><br><span class="line">将用户的每一个问题及对应的回答结果准确无误地保存到数据中，确保数据的完整性和可追溯性。</span><br></pre></td></tr></table></figure>

<p>这里我们主要在提示词里面说明将用户的问题和回答结果保存到数据库中，然后我们就可以在智能体中使用这个数据库了，智能体会根据 LLM 的语义理解，将用户的问题和回答结果保存到数据库中。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1745224842337.png" alt="null"></p>
<p>当然我们还可以在工作流里面使用这个数据库，除了通过自然语言之外，还可以编写 SQL 语句来精准操作数据库。</p>
<h4 id="6-1-4-文件盒子"><a href="#6-1-4-文件盒子" class="headerlink" title="6.1.4 文件盒子"></a>6.1.4 文件盒子</h4><p>文件盒子用于保存和管理用户发送的文件。用户发送消息时，智能体能够查找和引用这里的文件进行回复。还支持用户通过发送消息，管理和删除自己的文件。如图片、视频、音频、文档等。</p>
<p>在智能体编排页面的记忆 &gt; 文件盒子区域，同样可以一键开启文件盒子能力。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742514121991.png" alt="null"></p>
<p>文件盒子开启后，智能体可以自动使用 api 保存和管理用户文件。你也可以在<strong>人设与回复逻辑</strong>中通过手动编写提示词，设计更灵活的文件管理功能，例如“fileList（返回今天上传的照片）”。文件盒子工具清单如下所示：</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742514166452.png" alt="null"></p>
<p>开启文件盒子功能之后，你可以通过以下方式上传文件。上传到智能体中的文件均会保存在文件盒子中。</p>
<p><strong>在编排页面上传文件</strong></p>
<ol>
<li><p>在智能体编排页面的预览与调试区域，展开 Memory &gt; 文件盒子。<img src="https://picdn.youdianzhishi.com/images/1742514262481.png" alt="null"></p>
</li>
<li><p>在照片或文档页签的右上角单击上传。</p>
</li>
<li><p>根据页面提示上传符合要求的文件。</p>
</li>
<li><p>上传文件后，你可以在照片或文档页签中查看自己上传的文件列表。你也可以在操作列对已上传的文件执行一些管理操作，例如提问、复制名字、改名、删除。也可以在对话区域内通过自然语言或 API 指令管理文件。<img src="https://picdn.youdianzhishi.com/images/1742514342162.png" alt="null"></p>
</li>
</ol>
<p><strong>在对话区域上传文件</strong></p>
<p>你可以在和智能体对话时，通过对话窗口上传文件。上传文件后可以通过自然语言或 API 指令管理文件。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1742514368395.png" alt="null"></p>
<p><strong>使用文件盒子</strong></p>
<p>你可以通过以下方式使用文件盒子：</p>
<ol>
<li><p><strong>直接使用 API</strong>：在对话时直接发送 API 名称，使智能体执行对应操作。你可以在编排页面通过文件盒子 &gt; 工具详情查看目前支持的 API 列表。</p>
</li>
<li><p><strong>通过提示词定义 API</strong>：在编排页面的人设与回复逻辑区域中，指定文件盒子某些 API 的具体使用场景，例如<strong>fileList（返回今天上传的照片）</strong>。发布智能体后就可以在对话时通过 <code>fileList</code> 指令快速查看今天上传的照片。</p>
</li>
<li><p><strong>使用自然语言</strong>：在对话时直接通过自然语言发送指令，例如查看我今天上传的图片。</p>
</li>
</ol>
<h2 id="7-多智能体"><a href="#7-多智能体" class="headerlink" title="7. 多智能体"></a>7. 多智能体</h2><p>在 Coze 中，还支持多智能体模式，多智能体是一种分布式计算的范式，通过将复杂任务分解为多个子任务，由独立的智能体并行处理，这种模式在数据密集型应用中尤为重要。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1745288379224.png" alt="null"></p>
<p>在扣子中创建智能体后，智能体默认使用单 Agent 模式。在单 Agent 模式下处理复杂任务时，你必须编写非常详细和冗长的提示词，而且你可能需要添加各种插件和工作流等，这增加了调试智能体的复杂性。调试时任何一处细节改动，都有可能影响到智能体的整体功能，实际处理用户任务时，处理结果可能与预期效果有较大出入。</p>
<p>而多 Agent 模式下你可以为智能体添加多个 Agent，并连接、配置各个 Agent 节点，通过多节点之间的分工协作来高效解决复杂的用户任务。我们可以通过以下方式来简化复杂的任务场景。</p>
<ul>
<li><p>为不同的 Agent 配置独立的提示词，将复杂任务分解为一组简单任务，而不是在一个智能体的提示词中设置处理任务所需的所有判断条件和使用限制。</p>
</li>
<li><p>多 Agent 模式允许你为每个 Agent 节点配置独立的插件和工作流。这不仅降低了单个 Agent 的复杂性，还提高了测试智能体时 bug 修复的效率和准确性，你只需要修改发生错误的 Agent 配置即可。</p>
</li>
</ul>
<h3 id="创建多智能体"><a href="#创建多智能体" class="headerlink" title="创建多智能体"></a>创建多智能体</h3><p>比如现在我们有一个需求是将用户输入内容翻译成多语种的翻译智能体。</p>
<p>首先我们创建一个实时多语种翻译的智能体。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1745293917387.png" alt="null"></p>
<p>切换到多 Agent 模式。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1745294087269.png" alt="null"></p>
<p>然后就会跳转到多智能体的编排界面，如下所示：</p>
<p><img src="https://picdn.youdianzhishi.com/images/1745294169655.png" alt="null"></p>
<p>与单 Agent 模式类似，页面分为以下 4 个面板：</p>
<ul>
<li><p>面板 1：在顶部区域，你可以查看智能体的基本信息，包括所属团队、发布历史。</p>
</li>
<li><p>面板 2：左边是编排面板，你可以在其中为整个智能体添加提示词、变量和其他配置。你可以单击 <code>&lt;</code> 图标，折叠此面板。</p>
</li>
<li><p>面板 3：中间是可以添加和连接 Agent 的画布。</p>
</li>
<li><p>面板 4：右边是预览与调试面板，你可以在其中测试智能体是否按预期运行，并进行调试、检查运行详情等操作。</p>
</li>
</ul>
<p>与单智能体模式类似，第一步是为智能体构建人物设定。<br>在智能体的编排面板，描述智能体的人物设定，并根据实际情况为智能体添加其他配置。</p>
<p>该区域中的配置是全局配置，将适用于所有添加的 Agent。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1745294403570.png" alt="null"></p>
<h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p>接下来我们就可以在中间画布区域，为智能体添加节点。默认情况下，开始节点已连接到了具有智能体名称的 Agent 节点。你可以单击<strong>添加节点</strong>向画布内添加更多的节点，并连接节点。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1745295224265.png" alt="null"></p>
<p><strong>开始节点</strong></p>
<p>首先我们来看开始节点，开始节点是智能体处理新对话时的默认起始节点，开始节点根据用户的问题及整体分发对话人物的逻辑，指定某个节点接管用户的问题。在与同一个用户进行多轮会话时，用户和智能体通常针对同一个主题展开多次问答，你可以为开始节点设置新一轮会话的分发策略，即由哪个节点接管用户会话。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1745294550111.png" alt="null"></p>
<p>新一轮对话发给哪个节点，一共有两种配置方式：</p>
<ul>
<li><p><strong>上一次回复用户的节点</strong>：用户新的消息将继续发送给上次回复用户的节点。如果用户手动清除历史对话记录，则系统会把消息发送给开始节点。该设置适用于连贯会话比较多的智能体，用户通常需要多轮对话才能完成某个任务，例如积分制游戏等。</p>
</li>
<li><p><strong>开始节点</strong>：用户的所有消息都会发送给开始节点，该节点会根据 Agent 的适用场景，把用户消息移交给适用的 Agent 节点。该设置适用于功能丰富且互相独立的智能体，上次回复用户的节点通常不适用于回答新一轮的用户问题，例如售后客服场景。</p>
</li>
</ul>
<p><strong>Agent 节点</strong></p>
<p>Agent 节点是可以独立执行任务的智能实体。默认情况下，智能体内添加了使用智能体名称的 Agent，且该 Agent 与开始节点相连接。Agent 节点包含以下配置：</p>
<ul>
<li><p>单击设置图标（三个点）更改 Agent 设置：<img src="https://picdn.youdianzhishi.com/images/1745294729163.png" alt="null"></p>
</li>
<li><p>单击重命名为 Agent 输入新名称，建议使用清晰明确的名称，这将有助于大型语言模型准确为 Agent 分配用户任务。</p>
</li>
<li><p>单击创建副本，创建另一个具有相同配置的 Agent。</p>
</li>
<li><p>单击切换节点设置，选择配置切换节点的识别模式。<img src="https://picdn.youdianzhishi.com/images/1745294802748.png" alt="null"></p>
</li>
<li><p>适用场景：说明此节点的功能和适用场景，用于帮助前序节点判断在何种情况下应该切换到此节点。</p>
</li>
<li><p>Agent 提示词：提供当前 Agent 的运行逻辑与处理问题的步骤。</p>
</li>
<li><p>技能：单击添加按钮（<code>+</code>）添加 Agent 所需使用的工具、工作流或知识库。</p>
</li>
<li><p>用户问题建议：该功能默认为启用状态。启用后，智能体在响应用户查询后会根据该提示自动生成 3 个问题。选择用户自定义 Prompt 复选框可输入提示词。如果你想禁用这个功能，可将开关设置为关闭。</p>
</li>
</ul>
<p>我们这里是将内容翻译成英文、繁体中文、日语，所以这里我们可以添加 3 个 独立负责翻译的 Agent 节点。</p>
<p>首先我们需要配置父 Agent，也就是现在开始节点后面默认的 Agent 节点，我们这里需要配置下适用场景，描述 Agent 的功能。例如，将用户输入翻译为目标语言，技能暂时不需要，因为这个节点是用来做任务分发的。其他配置项保持默认值即可。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1745301820260.png" alt="null"></p>
<p>然后接下来添加一个新的 Agent 节点，用于处理中文翻译任务，连接到父节点。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1745302062090.png" alt="null"></p>
<p>这里我们可以为 Agent 添加提示词：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 将用户输入的内容翻译为英文</span><br><span class="line"><span class="bullet">-</span> 如果目标语言不是英文，则返回“我无法翻译”</span><br></pre></td></tr></table></figure>

<p>因为我们这里只需要使用大模型进行翻译即可，所以没有添加技能。</p>
<p>一共需要添加 3 个 Agent 节点，用于处理英文翻译任务、繁体中文翻译任务和日语翻译任务。</p>
<p>我们可以直接点击英文 Agent 的右上角的 <code>...</code> 图标，然后选择<strong>创建副本</strong>，然后修改名称，描述，提示词等配置信息，当然也需要和父节点连接起来。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1745302272374.png" alt="null"></p>
<p><strong>工作空间智能体</strong></p>
<p>此外 Coze 还支持将已发布的、可以执行特定任务的单 Agent 智能体添加为节点。也就是之前我们讲解的单智能体可以直接在多智能体中添加为节点使用。</p>
<p>添加后配置方式和上面就是一样的了。</p>
<p><strong>全局跳转条件</strong></p>
<p>我们还可以添加一个全局跳转条件的节点，该节点适用于所有 Agent 的全局条件。只要用户输入满足该节点的条件，则会立即跳转到 Agent。</p>
<p>全局跳转条件的优先级高于节点适用场景。</p>
<p>一个智能体中最多可以添加 5 个条件节点。</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>最后在智能体的预览与调试区域，我们可以发起一个翻译任务以检查 Agent 能否正确处理该任务。</p>
<p>在做测试的需要注意我们需要点击父节点的<code>与当前 Agent对话</code>，不然测试的时候只会使用正在对话的 Agent 节点。</p>
<p><img src="https://picdn.youdianzhishi.com/images/1745303266272.png" alt="null"></p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>Ceph-0-环境准备</title>
    <url>/posts/2903.html</url>
    <content><![CDATA[<p>Ubuntu 安装</p>
<a id="more"></a>

<h2 id="虚拟机环境准备"><a href="#虚拟机环境准备" class="headerlink" title="虚拟机环境准备"></a>虚拟机环境准备</h2><ul>
<li><p>vmware Workstation16.1.2</p>
</li>
<li><p>vmware默认环境配置</p>
</li>
<li><p>ununtu18.04TLS环境安装</p>
</li>
</ul>
<h2 id="vmware-workstation安装与配置"><a href="#vmware-workstation安装与配置" class="headerlink" title="vmware workstation安装与配置"></a>vmware workstation安装与配置</h2><ul>
<li><p>参考站点： <a href="https://www.aiweibk.com/203582.html">https://www.aiweibk.com/203582.html</a></p>
</li>
<li><p>注意事项[必须注意]：</p>
</li>
<li><ul>
<li>此软件千万不要安装在C盘</li>
<li>软件安装路径不要出现中文</li>
</ul>
</li>
</ul>
<h2 id="vmware默认环境配置"><a href="#vmware默认环境配置" class="headerlink" title="vmware默认环境配置"></a>vmware默认环境配置</h2><h3 id="首选项"><a href="#首选项" class="headerlink" title="首选项"></a>首选项</h3><p>虚拟机安装位置首选项：在[编辑]-[首选项]设置即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20211120150546455.png" alt="image-20211120150546455"></p>
<h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p>在[编辑]-[虚拟网络编辑器]设置即可</p>
<ul>
<li>NAT子网：10.168.56.0，掩码：255.255.255.0</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20211120150619002.png" alt="image-20211120150619002"></p>
<ul>
<li>仅主机网络子网：192.168.56.0， 掩码：255.255.255.0</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20211120150639286.png" alt="image-20211120150639286"></p>
<h2 id="ununtu18-04TLS环境安装"><a href="#ununtu18-04TLS环境安装" class="headerlink" title="ununtu18.04TLS环境安装"></a>ununtu18.04TLS环境安装</h2><h3 id="镜像下载"><a href="#镜像下载" class="headerlink" title="镜像下载"></a>镜像下载</h3><p>下载站点：<a href="http://cdimage.ubuntu.com/releases/">http://cdimage.ubuntu.com/releases/</a></p>
<p>选择： <a href="https://cdimage.ubuntu.com/releases/18.04/release/">https://cdimage.ubuntu.com/releases/18.04/release/</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20211120150700050.png" alt="image-20211120150700050"></p>
<h3 id="虚拟机安装准备"><a href="#虚拟机安装准备" class="headerlink" title="虚拟机安装准备"></a>虚拟机安装准备</h3><ol>
<li>新建虚拟机: 【文件】-【新建虚拟机】-【下一步】-【下一步】</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20211120150719134.png" alt="image-20211120150719134"></p>
<ol start="2">
<li>选择【稍后安装操作系统】-【下一步】</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20211120150743647.png" alt="image-20211120150743647"></p>
<ol start="3">
<li>选择要安装的操作系统</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20211120150818179.png" alt="image-20211120150818179"></p>
<ol start="4">
<li>配置虚拟机名称和路径</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20211120150835728.png" alt="image-20211120150835728"></p>
<ol start="5">
<li>配置选择1核2GRAM，网络选择NAT, 磁盘选择20G配置即可，然后新增网卡</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20211120150901504.png" alt="image-20211120150901504"></p>
<ol start="6">
<li>设置新增网卡为仅主机模式</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20211120150923573.png" alt="image-20211120150923573"></p>
<ol start="7">
<li>设置CD: 选择下载好的ubuntu镜像</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20211120150943355.png" alt="image-20211120150943355"></p>
<h3 id="虚拟机安装"><a href="#虚拟机安装" class="headerlink" title="虚拟机安装"></a>虚拟机安装</h3><ol>
<li><p>准备工作完成之后选择开启此虚拟机</p>
</li>
<li><p>语言选择【english】</p>
</li>
<li><p>先别急着回车，先按F6键盘功能键，然后再按ESC键盘按键</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20211120151003012.png" alt="image-20211120151003012"></p>
<ol start="4">
<li>输入如下代码： net.ifnames=0 biosdevname=0</li>
</ol>
<p>作用在于网卡配置会以eth0,eth1加载，而不是乱七八糟的ensxxx, 输入完成代码之后直接回车即可进行其他的安装与配置</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20211120151018540.png" alt="image-20211120151018540"></p>
<ol start="5">
<li>键盘设置为US,键盘测试选择NO</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20211120151103120.png" alt="image-20211120151103120"></p>
<ol start="6">
<li>然后回车，到最后设置账号名称为work， 密码</li>
<li>设置时区</li>
<li>磁盘分区： 【Manule】之分一个根分区，然后分区类型选择xfs</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20211120151138986.png" alt="image-20211120151138986"></p>
<ol start="9">
<li>完成分区： 注意不需要交换分区，只需要安装根分区就好</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20211120151206907.png" alt="image-20211120151206907"></p>
<ol start="10">
<li><p>代理不需要配置</p>
</li>
<li><p>不需要更新</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20211120151231037.png" alt="image-20211120151231037"></p>
<ol start="12">
<li><p>安装openssh-server软件</p>
</li>
<li><p>安装grub</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20211120151257334.png" alt="image-20211120151257334"></p>
<ol start="14">
<li>完成之后一路continue或者yes到服务器重启</li>
</ol>
<h3 id="虚拟机初始化配置"><a href="#虚拟机初始化配置" class="headerlink" title="虚拟机初始化配置"></a>虚拟机初始化配置</h3><h3 id="ssh登录配置"><a href="#ssh登录配置" class="headerlink" title="ssh登录配置"></a>ssh登录配置</h3><ul>
<li><p>登录服务器： 使用装机配置的用户名和密码</p>
</li>
<li><p>然后设置sshd配置： vim /etc/ssh/sshd_config</p>
</li>
<li><ul>
<li>PermitRootLogin yes</li>
<li>UseDNS no</li>
</ul>
</li>
</ul>
<h3 id="网卡配置"><a href="#网卡配置" class="headerlink" title="网卡配置"></a>网卡配置</h3><p>由于配置了两块网卡，eth0[NAT]和eth1[仅主机]，其中：</p>
<ul>
<li>eth0： NAT网卡用于模拟对外交互，可以访问外网, 所涉及的子网是10.168.56.0/24</li>
<li>eth1： 仅主机网卡，用于模拟主机间的交互，不能访问外网, 所涉及的子网是192.168.56.0/24</li>
</ul>
<p>配置网卡固定IP(root权限下)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;netplan&#x2F;01-netcfg.yaml</span><br><span class="line"># This file describes the network interfaces available on your system</span><br><span class="line"># For more information, see netplan(5).</span><br><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: networkd</span><br><span class="line">  ethernets:</span><br><span class="line">    eth0:</span><br><span class="line">      dhcp4: no</span><br><span class="line">      dhcp6: no</span><br><span class="line">      addresses: [10.168.56.100&#x2F;24]</span><br><span class="line">      gateway4: 10.168.56.2</span><br><span class="line">      nameservers:</span><br><span class="line">        addresses: [114.114.114.114]</span><br><span class="line">    eth1:</span><br><span class="line">      dhcp4: no</span><br><span class="line">      dhcp6: no</span><br><span class="line">      addresses: [192.168.56.100&#x2F;24]</span><br></pre></td></tr></table></figure>



<h3 id="配置国内镜像源"><a href="#配置国内镜像源" class="headerlink" title="配置国内镜像源"></a>配置国内镜像源</h3><p>阿⾥云仓库地址：<a href="https://opsx.alibaba.com/mirror">https://opsx.alibaba.com/mirror</a></p>
<p>中科⼤：<a href="http://mirrors.ustc.edu.cn/help/ubuntu.html">http://mirrors.ustc.edu.cn/help/ubuntu.html</a></p>
<p>清华⼤学：<a href="https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/">https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/</a></p>
<p>华为：<a href="https://mirrors.huaweicloud.com/">https://mirrors.huaweicloud.com/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vim /etc/apt/sources.list</span><br><span class="line"><span class="comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span></span><br></pre></td></tr></table></figure>

<ul>
<li>apt 包管理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># apt list #apt列出仓库软件包，等于yum list</span><br><span class="line"># apt search NAME #搜索安装包</span><br><span class="line"># apt show apache2 #查看某个安装包的详细信息</span><br><span class="line"># apt install apache2 #在线安装软件包</span><br><span class="line"># apt remove apache2 #卸载单个软件包但是保留配置⽂件</span><br><span class="line">2.3.3：设置oracle JDK环境：</span><br><span class="line">2.3.4：安装OpenJDK：</span><br><span class="line">2.3.5：安装常⽤系统命令：</span><br><span class="line"># apt autoremove apache2 #删除安装包并解决依赖关系</span><br><span class="line"># apt update #更新本地软件包列表索引，修改了apt仓库后必须执⾏</span><br><span class="line"># apt purge apache2 #卸载单个软件包删除配置⽂件</span><br><span class="line"># apt upgrade #升级所有已安装且可升级到新版本的软件包</span><br><span class="line"># apt full-upgrade #升级整个系统，必要时可以移除旧软件包。</span><br><span class="line"># apt edit-sources #编辑source源⽂件</span><br><span class="line"># apt-cache madison nginx #查看仓库中软件包有哪些版本可以安装</span><br><span class="line"># apt install nginx&#x3D;1.14.0-0ubuntu1.6 #安装软件包的时候指定安装具体的版本</span><br></pre></td></tr></table></figure>

<h2 id="默认系统优化参数"><a href="#默认系统优化参数" class="headerlink" title="默认系统优化参数"></a>默认系统优化参数</h2><h3 id="资源限制类的参数优化"><a href="#资源限制类的参数优化" class="headerlink" title="资源限制类的参数优化"></a>资源限制类的参数优化</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cat /etc/security/limits.conf</span></span><br><span class="line"><span class="comment">#root账户的资源软限制和硬限制</span></span><br><span class="line">root soft core unlimited</span><br><span class="line">root hard core unlimited</span><br><span class="line">root soft nproc 1000000</span><br><span class="line">root hard nproc 1000000</span><br><span class="line">root soft nofile 1000000</span><br><span class="line">root hard nofile 1000000</span><br><span class="line">root soft memlock 32000</span><br><span class="line">root hard memlock 32000</span><br><span class="line">root soft msgqueue 8192000</span><br><span class="line">root hard msgqueue 8192000</span><br><span class="line"><span class="comment">#其他账户的资源软限制和硬限制</span></span><br><span class="line">* soft core unlimited</span><br><span class="line">* hard core unlimited</span><br><span class="line">* soft nproc 1000000</span><br><span class="line">* hard nproc 1000000</span><br><span class="line">* soft nofile 1000000</span><br><span class="line">* hard nofile 1000000</span><br><span class="line">* soft memlock 32000</span><br><span class="line">* hard memlock 32000</span><br><span class="line">* soft msgqueue 8192000</span><br><span class="line">* hard msgqueue 8192000</span><br></pre></td></tr></table></figure>

<h3 id="内核参数调整"><a href="#内核参数调整" class="headerlink" title="内核参数调整"></a>内核参数调整</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Controls source route verification</span></span><br><span class="line">net.ipv4.conf.default.rp_filter = 1</span><br><span class="line">net.ipv4.ip_nonlocal_bind = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line"><span class="comment"># Do not accept source routing</span></span><br><span class="line">net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line"><span class="comment"># Controls the System Request debugging functionality of the kernel</span></span><br><span class="line">kernel.sysrq = 0</span><br><span class="line"><span class="comment"># Controls whether core dumps will append the PID to the core filename.</span></span><br><span class="line"><span class="comment"># Useful for debugging multi-threaded applications.</span></span><br><span class="line">kernel.core_uses_pid = 1</span><br><span class="line"><span class="comment"># Controls the use of TCP syncookies</span></span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line"><span class="comment"># Disable netfilter on bridges.</span></span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 0</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 0</span><br><span class="line">net.bridge.bridge-nf-call-arptables = 0</span><br><span class="line"><span class="comment"># Controls the default maxmimum size of a mesage queue</span></span><br><span class="line">kernel.msgmnb = 65536</span><br><span class="line"><span class="comment"># # Controls the maximum size of a message, in bytes</span></span><br><span class="line">kernel.msgmax = 65536</span><br><span class="line"><span class="comment"># Controls the maximum shared segment size, in bytes</span></span><br><span class="line">kernel.shmmax = 68719476736</span><br><span class="line"><span class="comment"># # Controls the maximum number of shared memory segments, in pages</span></span><br><span class="line">kernel.shmall = 4294967296</span><br><span class="line"><span class="comment"># TCP kernel paramater</span></span><br><span class="line">net.ipv4.tcp_mem = 786432 1048576 1572864</span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 4194304</span><br><span class="line">net.ipv4.tcp_wmem = 4096 16384 4194304</span><br><span class="line">net.ipv4.tcp_window_scaling = 1</span><br><span class="line">net.ipv4.tcp_sack = 1</span><br><span class="line"><span class="comment"># socket buffer</span></span><br><span class="line">net.core.wmem_default = 8388608</span><br><span class="line">net.core.rmem_default = 8388608</span><br><span class="line">net.core.rmem_max = 16777216</span><br><span class="line">net.core.wmem_max = 16777216</span><br><span class="line">net.core.netdev_max_backlog = 262144</span><br><span class="line">net.core.somaxconn = 20480</span><br><span class="line">net.core.optmem_max = 81920</span><br><span class="line"><span class="comment"># TCP conn</span></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 262144</span><br><span class="line">net.ipv4.tcp_syn_retries = 3</span><br><span class="line">net.ipv4.tcp_retries1 = 3</span><br><span class="line">net.ipv4.tcp_retries2 = 15</span><br><span class="line"><span class="comment"># tcp conn reuse</span></span><br><span class="line">net.ipv4.tcp_timestamps = 0</span><br><span class="line">net.ipv4.tcp_tw_reuse = 0</span><br><span class="line">net.ipv4.tcp_tw_recycle = 0</span><br><span class="line">net.ipv4.tcp_fin_timeout = 1</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 20000</span><br><span class="line">net.ipv4.tcp_max_orphans = 3276800</span><br><span class="line">net.ipv4.tcp_synack_retries = 1</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line"><span class="comment"># keepalive conn</span></span><br><span class="line">net.ipv4.tcp_keepalive_time = 300</span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 30</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 3</span><br><span class="line">net.ipv4.ip_local_port_range = 10001 65000</span><br><span class="line"><span class="comment"># swap</span></span><br><span class="line">vm.overcommit_memory = 0</span><br><span class="line">vm.swappiness = 10</span><br></pre></td></tr></table></figure>

<h3 id="系统默认安装和卸载包"><a href="#系统默认安装和卸载包" class="headerlink" title="系统默认安装和卸载包"></a>系统默认安装和卸载包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt purge ufw lxd lxd-client lxcfs lxc-common -y</span><br><span class="line">apt update</span><br><span class="line">apt install iproute2 ntpdate tcpdump telnet traceroute nfs-kernel-server nfs-common lrzsz tree openssl libssl-dev libpcre3 libpcre3-dev zlib1g-dev ntpdate tcpdump telnet traceroute gcc openssh-server lrzsz tree openssl libssl-dev libpcre3 libpcre3-dev zlib1g-dev ntpdate tcpdump telnet traceroute iotop unzip zip -y</span><br></pre></td></tr></table></figure>

<h3 id="服务器重启-amp-克隆"><a href="#服务器重启-amp-克隆" class="headerlink" title="服务器重启&amp;克隆"></a>服务器重启&amp;克隆</h3><ul>
<li><p>sudo reboot -f</p>
</li>
<li><p>挂起服务并创建快照</p>
</li>
<li><p>关闭服务器并克隆服务器（完整克隆）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>AI-07-MCP</title>
    <url>/posts/18525.html</url>
    <content><![CDATA[<p>MCP</p>
<a id="more"></a>



<h2 id="Agent，Function-Calling，MCP之间的关系"><a href="#Agent，Function-Calling，MCP之间的关系" class="headerlink" title="Agent，Function Calling，MCP之间的关系"></a>Agent，Function Calling，MCP之间的关系</h2><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h3><blockquote>
<p>能不能让AI自己动手做事情呢？第一个做出尝试的是AutoGPT开源项目，是一个本地运行的小程序。</p>
</blockquote>
<ol>
<li><p>想让AI帮你做事情，先写小工具，注册带AutoGPT中，AutoGPT将其转化为system prompt，如果模型足够聪明，模型进行回答的时候，就会返回想要调用的工具以及函数<img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/image-20250610020838730.png" alt="image-20250610020838730"></p>
</li>
<li><p>负责和工具以及模型，在中间“传话”的程序叫Agent，提供给Agent调用的函数或者服务，叫Agent Tools</p>
</li>
</ol>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>这个架构存在一些小问题，模型始终是种概率模型，始终会有返回不对的情况，Cline采用重试解决。</p>
<h3 id="Function-Calling"><a href="#Function-Calling" class="headerlink" title="Function Calling"></a>Function Calling</h3><blockquote>
<p>大模型厂商出手，Claude，Gemini，OpenAI推出了Function Calling功能，核心思想是统一格式，规范描述</p>
<p>添加了工具tool的字段，所有的工具描述放在相同的地方；包括工具名称，描述，参数，统一用json描述；system prompt格式定义就被取代了，不能随意描述。人们就根据这种模式更加有效的训练模型，让它理解这种调用场景</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/image-20250610021523716.png" alt="image-20250610021523716"></p>
<h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>每家模型厂商定义的api不一样，很多开源模型不支持Function Calling，真的要写出一个跨模型通用的AI Agent，实现很麻烦</p>
<h3 id="AI-Agent与模型的通信"><a href="#AI-Agent与模型的通信" class="headerlink" title="AI Agent与模型的通信"></a>AI Agent与模型的通信</h3><p>上面提到的System Prompt和FunctionCalling都是<strong>AI Agent和模型之间</strong>的通讯方式</p>
<h3 id="AI-Agent-如何与Tools进行通信"><a href="#AI-Agent-如何与Tools进行通信" class="headerlink" title="AI Agent 如何与Tools进行通信"></a>AI Agent 如何与Tools进行通信</h3><blockquote>
<p>最简单的做法是吧Agent 和Tool写在同一个应用程序里面，直接通过函数调用搞定，也是大多数Agent的做法</p>
<img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/image-20250610022312112.png" alt="image-20250610022312112" style="zoom:20%;" />

<p>后来发现，有些tool功能挺通用的，必须浏览网页的工具，查询天气的工具，每个agent如果都需要，那不能拷贝代码到每个agent程序里面吧，太麻烦了，也不优雅。所以想到一个办法，把tool变成服务统一托管，让所有的agent都可以调用，这就是MCP</p>
</blockquote>
<h3 id="MCP"><a href="#MCP" class="headerlink" title="MCP"></a>MCP</h3><p>MCP是通信协议，专门用来规范Agent和Tool之间服务怎么交互的。</p>
<p>提供服务的叫mcp server，调用服务的叫mcp client；mcp规范提出了server需要提供哪些接口，包括tool列表，需要哪些参数等等。</p>
<img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/image-20250610022654261.png" alt="image-20250610022654261" style="zoom:20%;" />

<p>MCP Server可以和Agent跑在同一台服务器上，通过标准输入输出Stdio交互通信；也可以通过SSE（http）进行通信。</p>
<p>MCP本身和AI模型没有关系，并不关心Agent用的是哪个模型，只负责帮Agent管理工具、资源、提示词。</p>
<h5 id="交互过程"><a href="#交互过程" class="headerlink" title="交互过程"></a>交互过程</h5><ol>
<li><strong>当向Agent进行提问时，Agent会把问题包装在User Prompt里面；作为MCP Client，Agent通过MCP协议从MCP Server中获取所有Tool信息；AI Agent会把这些Tool信息可能转化为System Prompt，也可能转化为Function Calling的格式，然后和用户请求的User Prompt，一起发给模型API；</strong></li>
<li>模型通过普通回复或者Function Calling的格式，产生一个调用tool的请求，返回给Agent，Agent通过MCP 协议，去调用MCP Server里的工具web_browse，web_browse访问目标网页后，返回结果给到AI Agent，Agent转发给模型，模型总结返回给Agent，Agent将结果展示给用户。</li>
</ol>
<img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/image-20250610023109645.png" alt="image-20250610023109645" style="zoom:30%;" />

<h1 id="MCP基础"><a href="#MCP基础" class="headerlink" title="MCP基础"></a>MCP基础</h1><blockquote>
<p>MCP主要规范了两个部分的内容，可以总结为函数的<strong>注册与使用</strong>，也可以称为<strong>函数的发现与调用协议</strong>:（脱离大模型也是可以直接用的，只不过没有人这么用而已）</p>
<ol>
<li>每个MCP Server有哪些函数(tools)可以用</li>
<li>如何调用这些函数，函数的调用方法</li>
</ol>
<p>MCP 协议本身并没有规定 如何与模型进行交互，协议是给模型服务的</p>
</blockquote>
<h3 id="模型是否具有Function-Calling能力"><a href="#模型是否具有Function-Calling能力" class="headerlink" title="模型是否具有Function Calling能力"></a>模型是否具有Function Calling能力</h3><ul>
<li>如果模型能够挑选函数（模型能够解析请求参数中的工具列表字段）</li>
<li>解析函数执行结果（能够挑选出工具并给出参数）</li>
<li>并且根据结果给出最终答案（能解析工具的执行结果）</li>
</ul>
<p>-&gt; 模型就具有Function Calling的能力</p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/image-20250608165725650.png" alt="image-20250608165725650"></p>
<blockquote>
<ol>
<li>使用cline工具注册mcp server 的时候，cline与mcp server的交互就完成了，cline就具有了mcp server提供的 tools列表以及出入参规范</li>
<li>通过cline提问的时候，cline通知mcp server，我要调用某个函数方法，入参是什么。 mcp server 完成调用返回结果</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/image-20250608181646198.png" alt="image-20250608181646198"></p>
</blockquote>
<blockquote>
<p>不同的MCP Host与模型交互是有差异的，比如Cline是通过XML与模型沟通的，这是Cline规定的，Cline负责解析XML，帮助模型调用它想要调用的工具。已连接的mcp server ，server下面的工具，会被Cline写在system prompt里面。</p>
<p>CherryStudio是通过FunctionCalling与模型沟通的。</p>
<p>MCP协议并没有规定MCP Host与模型是如何交互的。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/image-20250608183133075.png" alt="image-20250608183133075"></p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/image-20250608183604129.png" alt="image-20250608183604129"></p>
<h3 id="Cline的XML协议与ReAct（Thought-Action-Observation）之间的关系"><a href="#Cline的XML协议与ReAct（Thought-Action-Observation）之间的关系" class="headerlink" title="Cline的XML协议与ReAct（Thought Action Observation）之间的关系"></a>Cline的XML协议与ReAct（Thought Action Observation）之间的关系</h3><blockquote>
<p>ReAct是2022年一篇论文提出来的；它是reasoning和acting两个单词的合体；论文中提到的ReAct理念可以再不需要人干预的情况下让模型自主思考，自主调用外部工具，从而完成用户的请求。就像Cline一样，说白了就是Agent，Cline也是根据ReAct思想来构建它的Agent流程的。</p>
<p>Agent：持续思考，持续调用外部工具的能力，从而解决用户问题。</p>
<p>Cline只是借助了这个思想，通过XML协议完成与模型的沟通，XML比直接写Thought Action Observation更精确。</p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/image-20250608184414840.png" alt="image-20250608184414840"></p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/image-20250608184807448.png" alt="image-20250608184807448"></p>
</blockquote>
<p>MCP，即<strong>模型上下文协议（Model Context Protocol）</strong>，让模型感知外部信息（天气，文件，网络）的一个协议。是 Anthropic Claude 的一个开源开放协议，旨在建立 AI 模型和开发环境之间的统一上下文交互，通过提供标准化的上下文信息访问，使 AI 模型能够更好地理解和处理代码。就像给它们之间搭建了一座桥梁，使得开发者可以通过一套标准将 AI 应用和数据源连接起来 。</p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/1747899253691.png" alt="null"></p>
<p>简单来说，MCP 就像给 AI 装上了一个”万能接口”，让 AI 能够与各种外部系统和数据源实现标准化的双向通信。正如 USB-C 提供了连接各种设备的标准化方式，MCP 也为连接 AI 模型和不同数据源提供了统一的方法。例如，在实际应用中借助 MCP 协议，AI 可以帮用户管理 GitHub 项目，从创建项目到提交代码请求等复杂任务都能轻松完成，而且速度很快。这一协议的出现，有望彻底解决 LLM（大型语言模型）应用连接数据难的痛点，让前沿模型生成更好、更相关的响应，不再需要为每个数据源写定制的集成代码，一个 MCP 协议就可以搞定与多种数据源的连接 。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><strong>代码管理与开发</strong></p>
<p>在代码开发方面，Claude 通过 MCP 协议可以直接连接 GitHub。开发人员可以利用 Claude 自动化编程，例如让 AI 自己写代码、创建仓库、Push 代码、创建 Issue、创建分支、创建 PR 等操作，全程无需离开聊天界面，开发人员仅需提出需求即可 。这大大提高了开发效率，将开发人员从繁琐的代码操作中部分解放出来，更多地扮演需求提出者的角色。</p>
<p><strong>本地资源管理</strong></p>
<p>MCP 协议支持对本地资源的管理，如电脑里的文件、数据库（像 SQLite 数据库）等。开发人员可以使用 MCP 协议让桌面版 Claude 安全连接本地服务，进行文件的创建、读取、编辑等操作，还能对数据库中的数据进行交互操作，例如查询、更新等 。</p>
<p><strong>远程资源交互</strong></p>
<p>对于远程资源，如 <code>GoogleDrive</code>、<code>Slack</code> 等平台的数据，Claude 借助 MCP 协议可以直接进行控制和访问。这使得企业和开发者在构建 AI 应用时，能够轻松整合不同来源的数据，如从商业工具、软件、内容库、应用程序开发环境等各种来源提取资料，协助模型产生与指令更相关的回复 。</p>
<p><strong>构建智能助手应用</strong></p>
<p>随着大模型从纯聊天机器人走向以智能助手为代表的 Agent 应用，MCP 协议可以让 AI 系统更加智能和强大。开发人员通过 MCP 协议将 AI 系统与多个数据源相连接后，AI 工具不再只是简单的问答系统，而是变成了一个能够执行复杂任务、管理代码、处理文件和与外部系统通信的强大工具。例如，在构建一个企业内部的智能助手时，可以利用 MCP 协议连接企业内部的各种数据资源（如数据库、文件服务器等）以及外部相关的业务工具（如项目管理工具等），为企业员工提供更全面、更高效的服务。</p>
<h2 id="为什么需要-MCP"><a href="#为什么需要-MCP" class="headerlink" title="为什么需要 MCP"></a>为什么需要 MCP</h2><p>前面我们提到 MCP 就像给 AI 装上了一个”万能接口”，让 AI 能够与各种外部系统和数据源实现标准化的双向通信。在 AI 应用中，数据源的连接和交互是一个重要的问题。传统的做法是，每个数据源都需要单独的集成代码，这不仅增加了开发成本，还可能导致数据泄露和安全问题。所以急需要一个标准化的协议，使得 AI 应用可以与各种数据源进行交互。无论是本地资源，还是远程资源，都可以通过改协议进行连接和交互。这不仅提高了开发效率，还保证了数据的安全性。</p>
<p>比如我们想让 AI 获取天气信息，如果没有 MCP 协议的话，我们需要怎么实现呢？如下代码所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">import</span> openai</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建议从环境变量加载 API 密钥，更安全</span></span><br><span class="line"><span class="comment"># os.environ[&quot;OPENAI_API_KEY&quot;] = &quot;YOUR_API_KEY&quot;</span></span><br><span class="line"><span class="comment"># 如果你没有设置环境变量，可以直接取消下面一行的注释并填入你的 API Key</span></span><br><span class="line"><span class="comment"># openai.api_key = &quot;sk-YOUR_API_KEY_HERE&quot; # 请替换成你的真实 API Key</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 1. 定义智能体可以调用的工具 ---</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_current_weather</span>(<span class="params">location, unit=<span class="string">&quot;celsius&quot;</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取指定地点的当前天气信息</span></span><br><span class="line"><span class="string">    实际的天气信息需要通过 API 获取，这里只是模拟返回一些数据</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;tokyo&quot;</span> <span class="keyword">in</span> location.lower():</span><br><span class="line">        <span class="keyword">return</span> json.dumps(&#123;<span class="string">&quot;location&quot;</span>: <span class="string">&quot;Tokyo&quot;</span>, <span class="string">&quot;temperature&quot;</span>: <span class="string">&quot;10&quot;</span>, <span class="string">&quot;unit&quot;</span>: unit, <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Sunny&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&quot;san francisco&quot;</span> <span class="keyword">in</span> location.lower():</span><br><span class="line">        <span class="keyword">return</span> json.dumps(&#123;<span class="string">&quot;location&quot;</span>: <span class="string">&quot;San Francisco&quot;</span>, <span class="string">&quot;temperature&quot;</span>: <span class="string">&quot;72&quot;</span>, <span class="string">&quot;unit&quot;</span>: unit, <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Cloudy&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&quot;paris&quot;</span> <span class="keyword">in</span> location.lower():</span><br><span class="line">        <span class="keyword">return</span> json.dumps(&#123;<span class="string">&quot;location&quot;</span>: <span class="string">&quot;Paris&quot;</span>, <span class="string">&quot;temperature&quot;</span>: <span class="string">&quot;22&quot;</span>, <span class="string">&quot;unit&quot;</span>: unit, <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Rainy&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> json.dumps(&#123;<span class="string">&quot;location&quot;</span>: location, <span class="string">&quot;temperature&quot;</span>: <span class="string">&quot;unknown&quot;</span>, <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Weather information not available&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoAgent</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, model=<span class="string">&quot;deepseek-chat&quot;</span></span>):</span></span><br><span class="line">        self.model = model</span><br><span class="line">        self.messages = [] <span class="comment"># 用于存储对话历史</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_conversation</span>(<span class="params">self, user_input</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;运行与智能体的对话&quot;&quot;&quot;</span></span><br><span class="line">        self.messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: user_input&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 2. 定义智能体可用的函数描述 ---</span></span><br><span class="line">        tools = [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span>,</span><br><span class="line">                <span class="string">&quot;function&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;get_current_weather&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;description&quot;</span>: <span class="string">&quot;获取一个指定地点的当前天气情况&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;parameters&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                            <span class="string">&quot;location&quot;</span>: &#123;</span><br><span class="line">                                <span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;description&quot;</span>: <span class="string">&quot;城市名称，例如：San Francisco&quot;</span>,</span><br><span class="line">                            &#125;,</span><br><span class="line">                            <span class="string">&quot;unit&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>, <span class="string">&quot;enum&quot;</span>: [<span class="string">&quot;celsius&quot;</span>, <span class="string">&quot;fahrenheit&quot;</span>]&#125;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="string">&quot;required&quot;</span>: [<span class="string">&quot;location&quot;</span>],</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 3. 调用 OpenAI API ---</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = openai.chat.completions.create(</span><br><span class="line">                model=self.model,</span><br><span class="line">                messages=self.messages,</span><br><span class="line">                tools=tools,</span><br><span class="line">                tool_choice=<span class="string">&quot;auto&quot;</span>,  <span class="comment"># 让模型自动选择是否调用函数</span></span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">except</span> openai.AuthenticationError <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">&quot;OpenAI API 认证失败，请检查你的 API Key 是否正确或已设置。&quot;</span>)</span><br><span class="line">            print(<span class="string">f&quot;错误详情: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;API 认证失败，无法处理请求。&quot;</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">f&quot;调用 OpenAI API 时发生错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;与 OpenAI 服务通信时发生错误。&quot;</span></span><br><span class="line"></span><br><span class="line">        response_message = response.choices[<span class="number">0</span>].message</span><br><span class="line">        tool_calls = response_message.tool_calls</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 4. 处理模型的响应，检查是否需要调用工具 ---</span></span><br><span class="line">        <span class="keyword">if</span> tool_calls:</span><br><span class="line">            self.messages.append(response_message)  <span class="comment"># 将助手的回复（包含函数调用请求）添加到历史记录</span></span><br><span class="line"></span><br><span class="line">            available_functions = &#123;</span><br><span class="line">                <span class="string">&quot;get_current_weather&quot;</span>: get_current_weather,</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> tool_call <span class="keyword">in</span> tool_calls:</span><br><span class="line">                function_name = tool_call.function.name</span><br><span class="line">                function_to_call = available_functions[function_name]</span><br><span class="line">                function_args = json.loads(tool_call.function.arguments)</span><br><span class="line"></span><br><span class="line">                print(<span class="string">f&quot;\n🤖 模型请求调用函数: <span class="subst">&#123;function_name&#125;</span>&quot;</span>)</span><br><span class="line">                print(<span class="string">f&quot;   参数: <span class="subst">&#123;function_args&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">                function_response = function_to_call(</span><br><span class="line">                    location=function_args.get(<span class="string">&quot;location&quot;</span>),</span><br><span class="line">                    unit=function_args.get(<span class="string">&quot;unit&quot;</span>),</span><br><span class="line">                )</span><br><span class="line">                print(<span class="string">f&quot;🔧 函数返回: <span class="subst">&#123;function_response&#125;</span>\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">                self.messages.append(</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;tool_call_id&quot;</span>: tool_call.id,</span><br><span class="line">                        <span class="string">&quot;role&quot;</span>: <span class="string">&quot;tool&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: function_name,</span><br><span class="line">                        <span class="string">&quot;content&quot;</span>: function_response,</span><br><span class="line">                    &#125;</span><br><span class="line">                ) <span class="comment"># 将函数执行结果添加进历史记录</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># --- 5. 将函数执行结果发送给模型，获取最终回复 ---</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                second_response = openai.chat.completions.create(</span><br><span class="line">                    model=self.model,</span><br><span class="line">                    messages=self.messages,</span><br><span class="line">                )</span><br><span class="line">                final_response = second_response.choices[<span class="number">0</span>].message.content</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                print(<span class="string">f&quot;调用 OpenAI API (第二次) 时发生错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;处理函数调用结果时发生错误。&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果模型没有调用工具，直接返回其内容</span></span><br><span class="line">            final_response = response_message.content</span><br><span class="line"></span><br><span class="line">        self.messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>, <span class="string">&quot;content&quot;</span>: final_response&#125;)</span><br><span class="line">        <span class="keyword">return</span> final_response</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 主程序运行 ---</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 确保你已经设置了 OPENAI_API_KEY 环境变量</span></span><br><span class="line">    <span class="comment"># 或者在代码中直接提供了 openai.api_key</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> openai.api_key <span class="keyword">and</span> <span class="keyword">not</span> os.getenv(<span class="string">&quot;OPENAI_API_KEY&quot;</span>):</span><br><span class="line">        print(<span class="string">&quot;错误：请设置 OPENAI_API_KEY 环境变量或在代码中直接提供 API Key。&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;例如：export OPENAI_API_KEY=&#x27;your-api-key-here&#x27;&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;或者在代码中: openai.api_key = &#x27;your-api-key-here&#x27;&quot;</span>)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line">    agent = DemoAgent()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;你好！我是 AI 天气助手。你可以问我某个城市的天气。输入 &#x27;退出&#x27; 来结束对话。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        user_input = input(<span class="string">&quot;你: &quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> user_input.lower() == <span class="string">&#x27;退出&#x27;</span>:</span><br><span class="line">            print(<span class="string">&quot;再见！&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        ai_response = agent.run_conversation(user_input)</span><br><span class="line">        print(<span class="string">f&quot;AI助手: <span class="subst">&#123;ai_response&#125;</span>&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;-&quot;</span> * <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>上面代码的实现很简单，也是我们非常熟悉的方式，其核心就是通过 OpenAI 的 function tools 功能（也可以通过提示词的方式，但是效果差点），将天气查询功能封装成一个函数，然后通过 LLM 去决定什么时候调用这个函数。我们可以直接运行上面的代码来进行测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python main.py</span><br><span class="line">你好！我是 AI 天气助手。你可以问我某个城市的天气。输入 <span class="string">&#x27;退出&#x27;</span> 来结束对话。</span><br><span class="line">你: 查询下paris的天气</span><br><span class="line"></span><br><span class="line">🤖 模型请求调用函数: get_current_weather</span><br><span class="line">   参数: &#123;<span class="string">&#x27;location&#x27;</span>: <span class="string">&#x27;Paris&#x27;</span>, <span class="string">&#x27;unit&#x27;</span>: <span class="string">&#x27;celsius&#x27;</span>&#125;</span><br><span class="line">🔧 函数返回: &#123;<span class="string">&quot;location&quot;</span>: <span class="string">&quot;Paris&quot;</span>, <span class="string">&quot;temperature&quot;</span>: <span class="string">&quot;22&quot;</span>, <span class="string">&quot;unit&quot;</span>: <span class="string">&quot;celsius&quot;</span>, <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Rainy&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">AI助手: 目前巴黎的天气为 **雨天**，气温 **22°C**。</span><br><span class="line"></span><br><span class="line">建议外出时携带雨具，注意保暖！如需更详细的天气预报（如湿度、风速等），可以告诉我哦~ 🌧️☔</span><br><span class="line">--------------------</span><br><span class="line">你:</span><br></pre></td></tr></table></figure>

<p>如果我们还需要集成其他功能，比如获取新闻、获取股票信息、获取汇率等，同样我们需要在代码中添加对应的函数，然后通过 Tools 功能去调用这些函数。这样就会造成一个问题是每个开发者要开发一个智能体，都需要重复去实现这些功能函数，这无疑增加了开发成本，也不利于 AI 应用的传播复用。</p>
<p>但是如果我们使用 MCP 协议，就可以将这些功能封装成一个一个的 MCP 服务器，然后我们在客户端可以直接去调用这些功能，而这些 MCP 服务器是完全可以复用的，所有人都可以直接使用这些 MCP 服务器，完全不用重新开发，这就大大降低了开发成本，理论上就无限扩大了 AI 应用的功能了，这就是 MCP 协议的强大之处，也是为什么我们要学习 MCP 协议的原因。</p>
<h2 id="MCP-架构"><a href="#MCP-架构" class="headerlink" title="MCP 架构"></a>MCP 架构</h2><p>接下来我们来了解下 MCP 的架构，以及它是如何工作的。</p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/1747965506965.png" alt="null"></p>
<p>MCP 协议遵循客户端-主机-服务器架构，其中每个主机可以运行多个客户端实例。该架构使用户能够跨应用程序集成 AI 能力，同时保持清晰的安全边界并隔离问题。MCP 基于 <code>JSON-RPC</code> 构建，提供了一个有状态会话协议，专注于客户端和服务器之间的上下文交换和采样协调。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    subgraph &quot;应用程序主机进程&quot;</span><br><span class="line">        H[主机]</span><br><span class="line">        C1[客户端 1]</span><br><span class="line">        C2[客户端 2]</span><br><span class="line">        C3[客户端 3]</span><br><span class="line">        H --&gt; C1</span><br><span class="line">        H --&gt; C2</span><br><span class="line">        H --&gt; C3</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph &quot;本地机器&quot;</span><br><span class="line">        S1[服务器 1&lt;br&gt;文件 &amp; Git]</span><br><span class="line">        S2[服务器 2&lt;br&gt;数据库]</span><br><span class="line">        R1[(&quot;本地&lt;br&gt;资源 A&quot;)]</span><br><span class="line">        R2[(&quot;本地&lt;br&gt;资源 B&quot;)]</span><br><span class="line"></span><br><span class="line">        C1 --&gt; S1</span><br><span class="line">        C2 --&gt; S2</span><br><span class="line">        S1 &lt;--&gt; R1</span><br><span class="line">        S2 &lt;--&gt; R2</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph &quot;互联网&quot;</span><br><span class="line">        S3[服务器 3&lt;br&gt;外部 API]</span><br><span class="line">        R3[(&quot;远程&lt;br&gt;资源 C&quot;)]</span><br><span class="line"></span><br><span class="line">        C3 --&gt; S3</span><br><span class="line">        S3 &lt;--&gt; R3</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>

<p>这里主要涉及到三个角色：<strong>主机</strong>、<strong>服务器</strong>和<strong>客户端</strong>。</p>
<ol>
<li>**MCP 主机(Host)**：通常是发起连接的 LLM 应用程序，如 Claude Desktop 或其他 AI 工具。它负责管理 MCP Client 与 Server 的连线。</li>
<li>**MCP 客户端(Client)**：在主机应用程序内部与服务器保持 1:1 连接，负责协议通信。它负责 AI 和 MCP Server 之间的沟通。</li>
<li>**MCP 服务器(Server)**：轻量级程序，负责暴露特定的数据源或工具功能，并通过标准化协议与客户端交互。它管理本地数据库要输出的内容指令，让 Client 可以自选指令来运作。</li>
</ol>
<p>MCP 的通信基于 <code>JSON-RPC</code> 2.0，支持请求、响应和通知三种消息类型，确保通信的标准化和一致性。整个流程如下：</p>
<ol>
<li>用户通过 AI 应用（主机）发送请求</li>
<li>AI 应用（主机）通过 MCP 客户端向 MCP 服务器发送请求</li>
<li>MCP 服务器处理请求，访问相应的数据源或执行工具功能</li>
<li>服务器将结果返回给客户端</li>
<li>客户端将信息传递给 AI 模型</li>
<li>AI 模型基于这些信息生成响应</li>
</ol>
<h2 id="MCP-协议"><a href="#MCP-协议" class="headerlink" title="MCP 协议"></a>MCP 协议</h2><p>MCP 协议遵循客户端-主机-服务器架构，MCP 协议其实就是规定的组件之间的通信协议，而 MCP 中的所有消息必须遵循 <code>JSON-RPC 2.0</code> 规范。</p>
<h3 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h3><p>MCP 协议定义了三种类型的消息：</p>
<ul>
<li><code>request</code>：请求消息，用于客户端向服务器发送请求，也可以从服务器发送到客户端。</li>
<li><code>response</code>：响应消息，用于对请求的响应。</li>
<li><code>notification</code>：通知消息，用于服务器向客户端发送通知。</li>
</ul>
<p><strong>请求消息</strong></p>
<p>双向消息，可以从客户端发送到服务器，也可以反向发送。如下所示就是一个请求消息的示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;jsonrpc&quot;</span>: <span class="string">&quot;2.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;string | number&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;method&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;param?&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;value&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在请求消息中，有一些需要注意的点：</p>
<ul>
<li>必须包含字符串或整数类型的 ID</li>
<li>ID 不能为 null</li>
<li>在同一会话中，请求方不能重复使用相同的 ID</li>
<li>可以包含可选的参数对象</li>
</ul>
<p><strong>响应消息</strong></p>
<p>响应消息是对请求的回复，响应消息的结构如下所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;jsonrpc&quot;</span>: <span class="string">&quot;2.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;string | number&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;result?&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;[key: string]&quot;</span>: <span class="string">&quot;unknown&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;error?&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;number&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;data?&quot;</span>: <span class="string">&quot;unknown&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，在响应消息中，也有一些需要注意的点：</p>
<ul>
<li>必须包含与对应请求相同的 ID</li>
<li>必须设置 <code>result</code> 或 <code>error</code> 其中之一，不能同时设置</li>
<li>错误码必须是整数</li>
<li>可以包含可选的结果数据</li>
</ul>
<p><strong>通知消息</strong></p>
<p>通知是一种单向消息，不需要响应：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;jsonrpc&quot;</span>: <span class="string">&quot;2.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;method&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;params?&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;[key: string]&quot;</span>: <span class="string">&quot;unknown&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在通知消息中，有一些需要注意的点：</p>
<ul>
<li>不能包含 ID 字段</li>
<li>用于状态更新和事件通知</li>
<li>可以包含可选的参数对象</li>
<li>减少通信开销，支持异步操作</li>
</ul>
<h3 id="四大核心功能"><a href="#四大核心功能" class="headerlink" title="四大核心功能"></a>四大核心功能</h3><p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/1747980177944.png" alt="null"></p>
<p>MCP 提供了四种核心原语（服务器端原语），用于规范客户端和服务器之间的交互，分别是：</p>
<ul>
<li>资源(Resources)</li>
<li>提示(Prompts)</li>
<li>工具(Tools)</li>
<li>采样(Sampling)</li>
</ul>
<p><strong>1. 资源(Resources)</strong></p>
<p>资源表示 MCP 服务器想要向客户端提供的任何类型数据，可包括：</p>
<ul>
<li>文件内容</li>
<li>数据库记录</li>
<li>API 响应</li>
<li>实时系统数据</li>
<li>截图和图片</li>
<li>日志文件</li>
</ul>
<p>每个资源由唯一的 URI 标识，并且可以包含文本或二进制数据。</p>
<p><strong>2. 提示词(Prompts)</strong></p>
<p>MCP 中的提示是预定义的模板，可以：</p>
<ul>
<li>接受动态参数</li>
<li>上下文</li>
<li>链接多个交互</li>
<li>指导特定工作流程</li>
<li>作为 UI 元素（如斜线命令）</li>
</ul>
<p><strong>3. 工具(Tools)</strong></p>
<p>MCP 中的工具允许服务器公开可由客户端调用的可执行函数。工具的关键方面包括：</p>
<ul>
<li>发现(tools/list)：客户端可以列出可用的工具</li>
<li>调用(tools/call)：服务器执行请求的操作并返回结果</li>
<li>灵活性：工具范围从简单的计算到复杂的 API 交互</li>
</ul>
<p><strong>4. 采样(Sampling)</strong></p>
<p>采样是 MCP 的一项强大功能，允许服务器通过客户端请求 LLM 完成，从而实现复杂的代理行为，同时保持安全性和隐私性。这种人机交互设计确保用户可以控制 LLM 所看到和生成的内容。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>MCP 为客户端-服务器连接定义了严格的生命周期，确保连接的可靠性和稳定性。主要分为三个阶段：</p>
<ul>
<li>初始化：能力协商和协议版本约定</li>
<li>操作：正常协议通信</li>
<li>关闭：正常终止连接</li>
</ul>
<p>如下图所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant 客户端</span><br><span class="line">    participant 服务器</span><br><span class="line"></span><br><span class="line">    Note over 客户端,服务器: 初始化阶段</span><br><span class="line">    activate 客户端</span><br><span class="line">    客户端-&gt;&gt;+服务器: 初始化请求</span><br><span class="line">    服务器--&gt;&gt;客户端: 初始化响应</span><br><span class="line">    客户端--)服务器: 初始化完成通知</span><br><span class="line"></span><br><span class="line">    Note over 客户端,服务器: 运行阶段</span><br><span class="line">    rect rgb(200, 220, 250)</span><br><span class="line">        note over 客户端,服务器: 正常协议操作</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    Note over 客户端,服务器: 关闭阶段</span><br><span class="line">    客户端--)-服务器: 断开连接</span><br><span class="line">    deactivate 服务器</span><br><span class="line">    Note over 客户端,服务器: 连接已关闭</span><br></pre></td></tr></table></figure>

<p><strong>初始化阶段</strong></p>
<p>初始化阶段必须是客户端和服务器之间的第一次交互。在此阶段，双方：</p>
<ul>
<li>建立协议版本兼容性</li>
<li>交换和协商能力</li>
<li>共享实现细节</li>
</ul>
<p>初始化请求示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;jsonrpc&quot;</span>: <span class="string">&quot;2.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;method&quot;</span>: <span class="string">&quot;initialize&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;params&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;protocolVersion&quot;</span>: <span class="string">&quot;2024-11-05&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;capabilities&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;roots&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;listChanged&quot;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;sampling&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;clientInfo&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;ExampleClient&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意 ⚠️ 在初始化请求中，客户端必须发送其支持的协议版本，上面 json 中的 <code>params.protocolVersion</code> 字段就是来指定协议版本的。</p>
<ul>
<li>客户端应发送其支持的最新版本</li>
<li>服务器必须响应相同版本或其支持的其他版本</li>
<li>如果客户端不支持服务器的版本，应断开连接</li>
</ul>
<p>而 <code>params.capabilities</code> 字段用于能力协商，客户端和服务器能力确定会话期间可用的可选协议功能。在请求中我们指定客户端的能力，在响应中服务器会指定其能力，客户端可以指定如下能力：</p>
<ul>
<li><code>roots</code>：提供文件系统根目录的能力</li>
<li><code>sampling</code>：支持 LLM 采样请求</li>
<li><code>experimental</code>：描述对非标准实验性功能的支持</li>
</ul>
<p>初始化响应示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;jsonrpc&quot;</span>: <span class="string">&quot;2.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;protocolVersion&quot;</span>: <span class="string">&quot;2024-11-05&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;capabilities&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;logging&quot;</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">&quot;prompts&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;listChanged&quot;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;resources&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;subscribe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;listChanged&quot;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;tools&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;listChanged&quot;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;serverInfo&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;ExampleServer&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初始化响应中，服务器必须响应相同版本或其支持的其他版本。此外服务器会响应其能力，如下：</p>
<ul>
<li><code>logging</code>：提供日志记录的能力</li>
<li><code>prompts</code>：提供提示词的模板能力</li>
<li><code>resources</code>：提供资源管理的能力</li>
<li><code>tools</code>：提供工具调用的能力</li>
<li><code>experimental</code>：描述对非标准实验性功能的支持</li>
</ul>
<p>初始化完成后，服务器会发送初始化完成通知，如下所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;jsonrpc&quot;</span>: <span class="string">&quot;2.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;method&quot;</span>: <span class="string">&quot;initialized&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>操作阶段</strong></p>
<p>初始化完成后，客户端和服务器就可以进行正常的协议通信了，也就是上面的操作阶段，客户端和服务器根据协商的能力交换消息。</p>
<ul>
<li>遵守协商的协议版本</li>
<li>仅使用成功协商的能力</li>
</ul>
<p><strong>关闭阶段</strong></p>
<p>当客户端或服务器决定关闭连接时，会发送断开连接通知，在关闭阶段，连接被优雅地终止。</p>
<ul>
<li>客户端发送断开连接通知</li>
<li>服务器关闭连接</li>
<li>清理相关资源</li>
</ul>
<p>这样 MCP 的一个完整生命周期就结束了。</p>
<h3 id="传输机制"><a href="#传输机制" class="headerlink" title="传输机制"></a>传输机制</h3><p>上面我们介绍了 MCP 协议的消息类型和生命周期，但是这些消息是如何在客户端和服务器之间传输的呢？MCP 协议定义了两种标准的客户端-服务器通信传输机制：</p>
<ul>
<li><code>stdio</code>（标准输入输出）</li>
<li>基于 <code>SSE</code>（Server-Sent Events）的 HTTP</li>
<li>Streamable HTTP（2025-03-26 版本）</li>
</ul>
<p>需要注意，客户端应尽可能支持 <code>stdio</code>，此外，客户端和服务器也可以以可插拔的方式实现自定义传输机制。</p>
<p><strong>标准输入输出（stdio）</strong></p>
<p>在 stdio 传输机制中：</p>
<ul>
<li>客户端将 MCP 服务器作为子进程启动</li>
<li>服务器通过标准输入（<code>stdin</code>）接收 <code>JSON-RPC</code> 消息，并通过标准输出（<code>stdout</code>）写入响应</li>
<li>消息以换行符分隔，且<strong>不能</strong>包含嵌入的换行符</li>
<li>服务器<strong>可以</strong>将 UTF-8 字符串写入标准错误（<code>stderr</code>）用于日志记录。客户端<strong>可以</strong>捕获、转发或忽略这些日志</li>
<li>服务器<strong>不得</strong>向标准输出（<code>stdout</code>）写入任何无效 <code>MCP</code> 消息的内容</li>
<li>客户端<strong>不得</strong>向服务器的标准输入（<code>stdin</code>）写入任何无效 <code>MCP</code> 消息的内容</li>
</ul>
<p>下图展示了 <code>stdio</code> 传输机制的交互过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant 客户端</span><br><span class="line">    participant 服务器进程</span><br><span class="line"></span><br><span class="line">    客户端-&gt;&gt;+服务器进程: 启动子进程</span><br><span class="line">    loop 消息交换</span><br><span class="line">        客户端-&gt;&gt;服务器进程: 写入标准输入</span><br><span class="line">        服务器进程-&gt;&gt;客户端: 写入标准输出</span><br><span class="line">        服务器进程--)客户端: 可选的标准错误日志</span><br><span class="line">    end</span><br><span class="line">    客户端-&gt;&gt;服务器进程: 关闭标准输入，终止子进程</span><br><span class="line">    deactivate 服务器进程</span><br></pre></td></tr></table></figure>

<p><strong>基于 SSE 的 HTTP</strong></p>
<p><code>SSE</code> 全称是 <code>Server-Sent Events</code>，是一种 HTTP 服务器推送技术，允许服务器向客户端发送实时更新。在 MCP 的 SSE 传输机制中，服务器作为独立进程运行，可以处理多个客户端连接。</p>
<p>首先服务器<strong>必须</strong>提供两个端点：</p>
<ul>
<li>SSE 端点 - 用于客户端建立连接并接收来自服务器的消息</li>
<li>HTTP POST 端点 - 用于客户端向服务器发送消息</li>
</ul>
<p>当客户端连接时，服务器<strong>必须</strong>发送一个包含客户端用于发送消息的 URI 的 endpoint 事件。所有后续的客户端消息必须作为 HTTP POST 请求发送到此端点。服务器消息作为 SSE message 事件发送，消息内容以 JSON 格式编码在事件数据中。</p>
<p>下图展示了基于 SSE 的 HTTP 传输机制的交互过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant 客户端</span><br><span class="line">    participant 服务器</span><br><span class="line"></span><br><span class="line">    客户端-&gt;&gt;服务器: 打开 SSE 连接</span><br><span class="line">    服务器-&gt;&gt;客户端: endpoint 事件</span><br><span class="line">    loop 消息交换</span><br><span class="line">        客户端-&gt;&gt;服务器: HTTP POST 消息</span><br><span class="line">        服务器-&gt;&gt;客户端: SSE message 事件</span><br><span class="line">    end</span><br><span class="line">    客户端-&gt;&gt;服务器: 关闭 SSE 连接</span><br></pre></td></tr></table></figure>

<p><strong>Streamable HTTP</strong></p>
<p>Streamable HTTP 是 MCP 协议的最新版本，它提供了更高效的传输机制。Streamable HTTP 使用 HTTP/2 流式传输，可以实现更低的延迟和更高的吞吐量。</p>
<p><strong>自定义传输机制</strong></p>
<p>客户端和服务器<strong>可以</strong>以可插拔的方式实现自定义传输机制。该协议与传输无关，可以在任何支持双向消息交换的通信通道上实现。</p>
<p>选择支持自定义传输的实施者<strong>必须</strong>确保他们保留 MCP 定义的 <code>JSON-RPC</code> 消息格式和生命周期要求。自定义传输<strong>应该</strong>记录其特定的连接建立和消息交换模式，以帮助互操作性。</p>
<h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h2><p>在了解了 MCP 的一些基础知识后，接下来我们将通过一个简单的示例来演示如何使用 MCP 协议。</p>
<p>这里我们将通过 MCP 协议将 Cursor（已经支持 MCP 协议）连接到本地 SQLite 数据库，并进行查询和安全分析，整个流程如下图所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    subgraph &quot;你的电脑&quot;</span><br><span class="line">        direction LR</span><br><span class="line">        Cursor[&quot;Cursor&quot;]</span><br><span class="line">        MCP[&quot;SQLite MCP 服务器&quot;]</span><br><span class="line">        DB[(SQLite 数据库~&#x2F;test.db)]</span><br><span class="line"></span><br><span class="line">        Cursor &lt;--&gt;|&quot;MCP 协议(查询和结果)&quot;| MCP</span><br><span class="line">        MCP &lt;--&gt;|&quot;本地访问(SQL 操作)&quot;| DB</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>

<p>这里的 SQLite MCP 服务器和本地 SQLite 数据库之间的通信完全在您的计算机上。MCP 协议确保 Cursor 只能通过明确定义的接口执行批准的数据库操作。这为您提供了一种安全的方式让 Cursor 分析你的本地数据并与之交互，同时保持对其可以访问的内容的完全控制。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在开始之前，请确保你的系统已经安装了以下必备组件:</p>
<ul>
<li>macOS 或 Windows 操作系统</li>
<li>最新版本的 Claude Desktop</li>
<li>uv 0.4.18 或更高版本 (使用 <code>uv --version</code> 检查)</li>
<li>Git (<code>git --version</code> 检查)</li>
<li>SQLite (<code>sqlite3 --version</code> 检查)</li>
</ul>
<p>对于 macOS 用户，可以使用 <a href="https://brew.sh/">Homebrew</a> 安装这些组件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Using Homebrew</span></span><br><span class="line">brew install uv git sqlite3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者直接下载：</span></span><br><span class="line"><span class="comment"># uv: https://docs.astral.sh/uv/</span></span><br><span class="line"><span class="comment"># Git: https://git-scm.com</span></span><br><span class="line"><span class="comment"># SQLite: https://www.sqlite.org/download.html</span></span><br></pre></td></tr></table></figure>

<p>而对于 Windows 用户，可以使用 <a href="https://docs.microsoft.com/en-us/windows/package-manager/winget/">winget</a> 安装这些组件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 winget 安装</span></span><br><span class="line">winget install --id=astral-sh.uv -e</span><br><span class="line">winget install git.git sqlite.sqlite</span><br><span class="line"></span><br><span class="line"><span class="comment"># Or download directly:</span></span><br><span class="line"><span class="comment"># uv: https://docs.astral.sh/uv/</span></span><br><span class="line"><span class="comment"># Git: https://git-scm.com</span></span><br><span class="line"><span class="comment"># SQLite: https://www.sqlite.org/download.html</span></span><br></pre></td></tr></table></figure>

<p>接下来我们会以 MacOS 为例进行说明，Windows 用户可以参考 MacOS 的安装步骤。</p>
<h3 id="创建-SQLite-数据库"><a href="#创建-SQLite-数据库" class="headerlink" title="创建 SQLite 数据库"></a>创建 SQLite 数据库</h3><p>首先我们来创建一个简单的 SQLite 数据库，并插入一些数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个新的 SQLite 数据库</span></span><br><span class="line">sqlite3 ~/test.db &lt;&lt;EOF</span><br><span class="line">CREATE TABLE products (</span><br><span class="line">  id INTEGER PRIMARY KEY,</span><br><span class="line">  name TEXT,</span><br><span class="line">  price REAL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO products (name, price) VALUES</span><br><span class="line">  (<span class="string">&#x27;Widget&#x27;</span>, 19.99),</span><br><span class="line">  (<span class="string">&#x27;Gadget&#x27;</span>, 29.99),</span><br><span class="line">  (<span class="string">&#x27;Gizmo&#x27;</span>, 39.99),</span><br><span class="line">  (<span class="string">&#x27;Smart Watch&#x27;</span>, 199.99),</span><br><span class="line">  (<span class="string">&#x27;Wireless Earbuds&#x27;</span>, 89.99),</span><br><span class="line">  (<span class="string">&#x27;Portable Charger&#x27;</span>, 24.99),</span><br><span class="line">  (<span class="string">&#x27;Bluetooth Speaker&#x27;</span>, 79.99),</span><br><span class="line">  (<span class="string">&#x27;Phone Stand&#x27;</span>, 15.99),</span><br><span class="line">  (<span class="string">&#x27;Laptop Sleeve&#x27;</span>, 34.99),</span><br><span class="line">  (<span class="string">&#x27;Mini Drone&#x27;</span>, 299.99),</span><br><span class="line">  (<span class="string">&#x27;LED Desk Lamp&#x27;</span>, 45.99),</span><br><span class="line">  (<span class="string">&#x27;Keyboard&#x27;</span>, 129.99),</span><br><span class="line">  (<span class="string">&#x27;Mouse Pad&#x27;</span>, 12.99),</span><br><span class="line">  (<span class="string">&#x27;USB Hub&#x27;</span>, 49.99),</span><br><span class="line">  (<span class="string">&#x27;Webcam&#x27;</span>, 69.99),</span><br><span class="line">  (<span class="string">&#x27;Screen Protector&#x27;</span>, 9.99),</span><br><span class="line">  (<span class="string">&#x27;Travel Adapter&#x27;</span>, 27.99),</span><br><span class="line">  (<span class="string">&#x27;Gaming Headset&#x27;</span>, 159.99),</span><br><span class="line">  (<span class="string">&#x27;Fitness Tracker&#x27;</span>, 119.99),</span><br><span class="line">  (<span class="string">&#x27;Portable SSD&#x27;</span>, 179.99);</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>然后下载最新的 <a href="https://www.cursor.com/cn/downloads">Cursor</a>，直接安装即可。然后打开 Cursor Settings 页面，切换到 MCP 标签页，点击右上角的 <strong>+ Add new global MCP server</strong> 按钮。</p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/1747981060263.png" alt="null"></p>
<p>然后会跳转到一个全局的 MCP 配置文件，该文件是一个 JSON 格式的文件，可以在里面定义所有 MCP 服务器，这里我们添加一个名为 <code>mcp-server-sqlite</code> 的 MCP 服务器，如下所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mcpServers&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;sqlite&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;uvx&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;args&quot;</span>: [<span class="string">&quot;mcp-server-sqlite&quot;</span>, <span class="string">&quot;--db-path&quot;</span>, <span class="string">&quot;/Users/YOUR_USERNAME/test.db&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要将 <code>YOUR_USERNAME</code> 替换为你的实际用户名。上面的配置文件表示我们定义了名为 <code>sqlite</code> 的 MCP 服务器，并指定使用 <code>uvx</code> 命令来启动该服务器，在 <code>args</code> 参数里面指定了 MCP 服务器以及实际的数据库路径为 <code>/Users/YOUR_USERNAME/test.db</code>。</p>
<p>我们也可以在特定的项目根目录下面创建 <code>.cursor/mcp.json</code> 文件，来配置特定项目中使用的 MCP 服务器，这样就可以在不同的项目中使用不同的 MCP 服务器了。</p>
<p>保存上面的配置后，回到 Cursor 中的 MCP 设置页面，正常一会儿就可以看到 <code>sqlite</code> 的 MCP 服务器了。</p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/1747981362810.png" alt="null"></p>
<p>其中会将该 MCP 服务器提供的所有 Tools 都列出来，然后我们就可以在 Cursor 中直接使用这些 Tools 了。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>接下来我们就可以在 Cursor 中来测试下这个 MCP 服务器了。比如我们发送如下所示的提示词到 Cursor 中（需要使用 Agent 模式）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">你能连接到我的 SQLite 数据库并告诉我有哪些产品及其价格吗？</span><br></pre></td></tr></table></figure>

<p>然后 Cursor 就会根据我们的提示词去查询我们的 SQLite 数据库，可以看到这里会选择使用 <code>list-tables</code> 的 MCP 工具查询数据库中有哪些表，然后调用 <code>describe_table</code> 工具查看这个表的结构。</p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/1747981724500.png" alt="null"></p>
<p>接着会去查询数据库获取产品和对应的价格，甚至最后还提供了额外的统计信息，也是通过 <code>read_query</code> 工具来实现的。</p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/1747981836636.png" alt="null"></p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>可能大家还是会有很多疑问，为什么我们只是在 Cursor 中添加了一个 sqlite 的 MCP 服务器，就可以查询到数据库中的数据了？这幕后到底发生了什么？</p>
<p>MCP 与 Cursor 交互的流程如下所示：</p>
<ol>
<li><p><strong>服务器发现</strong>：Cursor 在启动时连接到您配置的 MCP 服务器</p>
</li>
<li><p><strong>协议握手</strong>：当你询问数据时，Cursor：</p>
</li>
<li><p>确定（通过 LLM）哪个 MCP 服务器可以提供帮助（在本例中为 sqlite）</p>
</li>
<li><p>通过协议协商能力</p>
</li>
<li><p>从 MCP 服务器请求数据或操作</p>
</li>
<li><p><strong>交互流程</strong>：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">   participant C as Cursor</span><br><span class="line">   participant M as MCP 服务器</span><br><span class="line">   participant D as SQLite 数据库</span><br><span class="line"></span><br><span class="line">   C-&gt;&gt;M: 初始化连接</span><br><span class="line">   M--&gt;&gt;C: 返回可用功能</span><br><span class="line"></span><br><span class="line">   C-&gt;&gt;M: 查询请求</span><br><span class="line">   M-&gt;&gt;D: SQL 查询</span><br><span class="line">   D--&gt;&gt;M: 返回结果</span><br><span class="line">   M--&gt;&gt;C: 格式化结果</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>安全</strong>:</li>
</ol>
<ul>
<li>MCP 服务器仅暴露特定的、受控的功能</li>
<li>MCP 服务器在你的本地计算机上运行，它们访问的资源不会暴露在互联网上</li>
<li>Cursor 需要用户确认敏感操作</li>
</ul>
<p>这里可能大家还有点疑问就是 MCP 服务器，我们并没有编写任何代码啊？其实是因为 Cursor 已经 内置实现了一系列的 MCP 服务器，其中就包括 SQLite 的 MCP 服务器，我们只需要配置好数据库路径即可。我们可以在官方的 git 仓库中查看<a href="https://github.com/modelcontextprotocol/servers/tree/main/src">内置的 MCP 服务器列表</a>。</p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/1747982021937.png" alt="null"></p>
<p>可以看到其中就包含一个 SQLite 的 MCP 服务器。通过 SQLite 提供数据库交互和智能业务能力，该服务器支持运行 SQL 查询、分析业务数据等，所以我们直接配置即可使用了。如果我们有自己的业务需求，也可以参考这些内置的实现自定义一个 MCP 服务器即可。</p>
<h2 id="开发-MCP-服务器"><a href="#开发-MCP-服务器" class="headerlink" title="开发 MCP 服务器"></a>开发 MCP 服务器</h2><p>在了解了 MCP 的一些基础知识后，接下来我们将通过一个简单的示例来演示如何开发一个 MCP 服务器。</p>
<p>接下来我们将通过 <a href="https://github.com/modelcontextprotocol/python-sdk">MCP Python SDK</a> 来演示如何编写一个 MCP 服务器。我们将创建一个天气服务器，提供当前天气数据作为资源，并让 Cursor 使用工具获取天气预报。</p>
<p>这里我们需要使用 <a href="https://openweathermap.org/api">OpenWeatherMap API</a> 来获取天气数据，直接注册然后在 <a href="https://home.openweathermap.org/api_keys">API keys</a> 页面即可获取一个免费的 API 密钥。</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>这里我们还是使用 <a href="https://docs.astral.sh/uv/">uv</a> 来管理 Python 环境。</p>
<p>首先使用下面的命令初始化一个 uv 管理的项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uv init mcp-server-weather --python 3.13 <span class="comment"># 最好指定下版本</span></span><br><span class="line"><span class="built_in">cd</span> mcp-server-weather</span><br></pre></td></tr></table></figure>

<p>然后安装 MCP Python SDK 依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uv add <span class="string">&quot;mcp[cli]&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后我们就可以使用下面的命令来运行 <code>mcp</code> 这个开发工具命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ uv run mcp</span><br><span class="line"></span><br><span class="line"> Usage: mcp [OPTIONS] COMMAND [ARGS]...</span><br><span class="line"></span><br><span class="line"> MCP development tools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">╭─ Options ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮</span><br><span class="line">│ --<span class="built_in">help</span>          Show this message and <span class="built_in">exit</span>.                                                                                                                      │</span><br><span class="line">╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯</span><br><span class="line">╭─ Commands ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮</span><br><span class="line">│ version   Show the MCP version.                                                                                                                                  │</span><br><span class="line">│ dev       Run a MCP server with the MCP Inspector.                                                                                                               │</span><br><span class="line">│ run       Run a MCP server.                                                                                                                                      │</span><br><span class="line">│ install   Install a MCP server <span class="keyword">in</span> the Claude desktop app.                                                                                                        │</span><br><span class="line">╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯</span><br></pre></td></tr></table></figure>

<h3 id="实现-MCP-服务器"><a href="#实现-MCP-服务器" class="headerlink" title="实现 MCP 服务器"></a>实现 MCP 服务器</h3><p>接下来我们就可以开始实现我们的 MCP 服务器了。</p>
<p>直接在 <code>main.py</code> 文件中实现一个天气 MCP 服务器，如下代码所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">MCP Weather Server</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">一个基于 OpenWeatherMap API 的天气 MCP 服务器</span></span><br><span class="line"><span class="string">提供获取当前天气信息和天气预报的功能</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Dict, Any, List</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> dotenv <span class="keyword">import</span> load_dotenv</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> mcp.server.fastmcp <span class="keyword">import</span> FastMCP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载环境变量</span></span><br><span class="line">load_dotenv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 MCP 服务器</span></span><br><span class="line">mcp = FastMCP(<span class="string">&quot;Weather&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># OpenWeatherMap API 配置</span></span><br><span class="line">OPENWEATHER_API_KEY = os.getenv(<span class="string">&quot;OPENWEATHER_API_KEY&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> OPENWEATHER_API_KEY:</span><br><span class="line">    print(<span class="string">&quot;警告: 未找到 OPENWEATHER_API_KEY 环境变量&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;请在 .env 文件中设置你的 OpenWeatherMap API 密钥&quot;</span>)</span><br><span class="line"></span><br><span class="line">OPENWEATHER_BASE_URL = <span class="string">&quot;https://api.openweathermap.org/data/2.5&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_temperature</span>(<span class="params">temp_kelvin: float</span>) -&gt; str:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;格式化温度显示（开尔文转摄氏度）&quot;&quot;&quot;</span></span><br><span class="line">    celsius = temp_kelvin - <span class="number">273.15</span></span><br><span class="line">    fahrenheit = celsius * <span class="number">9</span>/<span class="number">5</span> + <span class="number">32</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;celsius:<span class="number">.1</span>f&#125;</span>°C (<span class="subst">&#123;fahrenheit:<span class="number">.1</span>f&#125;</span>°F)&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_weather_info</span>(<span class="params">weather_data: Dict[str, Any]</span>) -&gt; str:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;格式化天气信息为易读的字符串&quot;&quot;&quot;</span></span><br><span class="line">    main = weather_data.get(<span class="string">&quot;main&quot;</span>, &#123;&#125;)</span><br><span class="line">    weather = weather_data.get(<span class="string">&quot;weather&quot;</span>, [&#123;&#125;])[<span class="number">0</span>]</span><br><span class="line">    wind = weather_data.get(<span class="string">&quot;wind&quot;</span>, &#123;&#125;)</span><br><span class="line">    clouds = weather_data.get(<span class="string">&quot;clouds&quot;</span>, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">    location = weather_data.get(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;未知位置&quot;</span>)</span><br><span class="line">    country = weather_data.get(<span class="string">&quot;sys&quot;</span>, &#123;&#125;).get(<span class="string">&quot;country&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> country:</span><br><span class="line">        location += <span class="string">f&quot;, <span class="subst">&#123;country&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 基本天气信息</span></span><br><span class="line">    description = weather.get(<span class="string">&quot;description&quot;</span>, <span class="string">&quot;&quot;</span>).title()</span><br><span class="line">    temp = format_temperature(main.get(<span class="string">&quot;temp&quot;</span>, <span class="number">0</span>))</span><br><span class="line">    feels_like = format_temperature(main.get(<span class="string">&quot;feels_like&quot;</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 详细信息</span></span><br><span class="line">    humidity = main.get(<span class="string">&quot;humidity&quot;</span>, <span class="number">0</span>)</span><br><span class="line">    pressure = main.get(<span class="string">&quot;pressure&quot;</span>, <span class="number">0</span>)</span><br><span class="line">    wind_speed = wind.get(<span class="string">&quot;speed&quot;</span>, <span class="number">0</span>)</span><br><span class="line">    wind_deg = wind.get(<span class="string">&quot;deg&quot;</span>, <span class="number">0</span>)</span><br><span class="line">    cloudiness = clouds.get(<span class="string">&quot;all&quot;</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可见度（以米为单位，转换为公里）</span></span><br><span class="line">    visibility = weather_data.get(<span class="string">&quot;visibility&quot;</span>, <span class="number">0</span>) / <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    result = <span class="string">f&quot;&quot;&quot;🌍 **<span class="subst">&#123;location&#125;</span>**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">🌤️ **当前天气**: <span class="subst">&#123;description&#125;</span></span></span><br><span class="line"><span class="string">🌡️ **温度**: <span class="subst">&#123;temp&#125;</span></span></span><br><span class="line"><span class="string">🤒 **体感温度**: <span class="subst">&#123;feels_like&#125;</span></span></span><br><span class="line"><span class="string">💧 **湿度**: <span class="subst">&#123;humidity&#125;</span>%</span></span><br><span class="line"><span class="string">🌪️ **气压**: <span class="subst">&#123;pressure&#125;</span> hPa</span></span><br><span class="line"><span class="string">💨 **风速**: <span class="subst">&#123;wind_speed&#125;</span> m/s</span></span><br><span class="line"><span class="string">🧭 **风向**: <span class="subst">&#123;wind_deg&#125;</span>°</span></span><br><span class="line"><span class="string">☁️ **云量**: <span class="subst">&#123;cloudiness&#125;</span>%</span></span><br><span class="line"><span class="string">👁️ **能见度**: <span class="subst">&#123;visibility:<span class="number">.1</span>f&#125;</span> km&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加日出日落时间（如果有的话）</span></span><br><span class="line">    sys_info = weather_data.get(<span class="string">&quot;sys&quot;</span>, &#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;sunrise&quot;</span> <span class="keyword">in</span> sys_info <span class="keyword">and</span> <span class="string">&quot;sunset&quot;</span> <span class="keyword">in</span> sys_info:</span><br><span class="line">        sunrise = datetime.fromtimestamp(sys_info[<span class="string">&quot;sunrise&quot;</span>]).strftime(<span class="string">&quot;%H:%M&quot;</span>)</span><br><span class="line">        sunset = datetime.fromtimestamp(sys_info[<span class="string">&quot;sunset&quot;</span>]).strftime(<span class="string">&quot;%H:%M&quot;</span>)</span><br><span class="line">        result += <span class="string">f&quot;\n🌅 **日出**: <span class="subst">&#123;sunrise&#125;</span>&quot;</span></span><br><span class="line">        result += <span class="string">f&quot;\n🌇 **日落**: <span class="subst">&#123;sunset&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_forecast_info</span>(<span class="params">forecast_data: Dict[str, Any]</span>) -&gt; str:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;格式化天气预报信息&quot;&quot;&quot;</span></span><br><span class="line">    city = forecast_data.get(<span class="string">&quot;city&quot;</span>, &#123;&#125;)</span><br><span class="line">    location = city.get(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;未知位置&quot;</span>)</span><br><span class="line">    country = city.get(<span class="string">&quot;country&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> country:</span><br><span class="line">        location += <span class="string">f&quot;, <span class="subst">&#123;country&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    forecasts = forecast_data.get(<span class="string">&quot;list&quot;</span>, [])</span><br><span class="line"></span><br><span class="line">    result = <span class="string">f&quot;📅 **<span class="subst">&#123;location&#125;</span> - 5天天气预报**\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 按日期分组预报数据</span></span><br><span class="line">    daily_forecasts: Dict[str, List[Dict[str, Any]]] = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> forecast <span class="keyword">in</span> forecasts:</span><br><span class="line">        dt = datetime.fromtimestamp(forecast[<span class="string">&quot;dt&quot;</span>])</span><br><span class="line">        date_key = dt.strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> date_key <span class="keyword">not</span> <span class="keyword">in</span> daily_forecasts:</span><br><span class="line">            daily_forecasts[date_key] = []</span><br><span class="line">        daily_forecasts[date_key].append(forecast)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示每天的天气预报</span></span><br><span class="line">    <span class="keyword">for</span> date_key, day_forecasts <span class="keyword">in</span> list(daily_forecasts.items())[:<span class="number">5</span>]:  <span class="comment"># 只显示5天</span></span><br><span class="line">        date_obj = datetime.strptime(date_key, <span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line">        date_str = date_obj.strftime(<span class="string">&quot;%m月%d日 (%A)&quot;</span>)</span><br><span class="line"></span><br><span class="line">        result += <span class="string">f&quot;**<span class="subst">&#123;date_str&#125;</span>**\n&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取当天的温度范围</span></span><br><span class="line">        temps = [f[<span class="string">&quot;main&quot;</span>][<span class="string">&quot;temp&quot;</span>] <span class="keyword">for</span> f <span class="keyword">in</span> day_forecasts]</span><br><span class="line">        min_temp = format_temperature(min(temps))</span><br><span class="line">        max_temp = format_temperature(max(temps))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取主要天气描述（出现频率最高的）</span></span><br><span class="line">        descriptions = [f[<span class="string">&quot;weather&quot;</span>][<span class="number">0</span>][<span class="string">&quot;description&quot;</span>] <span class="keyword">for</span> f <span class="keyword">in</span> day_forecasts]</span><br><span class="line">        main_desc = max(set(descriptions), key=descriptions.count).title()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取平均湿度和风速</span></span><br><span class="line">        avg_humidity = sum(f[<span class="string">&quot;main&quot;</span>][<span class="string">&quot;humidity&quot;</span>] <span class="keyword">for</span> f <span class="keyword">in</span> day_forecasts) / len(day_forecasts)</span><br><span class="line">        avg_wind_speed = sum(f[<span class="string">&quot;wind&quot;</span>][<span class="string">&quot;speed&quot;</span>] <span class="keyword">for</span> f <span class="keyword">in</span> day_forecasts) / len(day_forecasts)</span><br><span class="line"></span><br><span class="line">        result += <span class="string">f&quot;  🌤️ <span class="subst">&#123;main_desc&#125;</span>\n&quot;</span></span><br><span class="line">        result += <span class="string">f&quot;  🌡️ <span class="subst">&#123;min_temp&#125;</span> - <span class="subst">&#123;max_temp&#125;</span>\n&quot;</span></span><br><span class="line">        result += <span class="string">f&quot;  💧 湿度: <span class="subst">&#123;avg_humidity:<span class="number">.0</span>f&#125;</span>%\n&quot;</span></span><br><span class="line">        result += <span class="string">f&quot;  💨 风速: <span class="subst">&#123;avg_wind_speed:<span class="number">.1</span>f&#125;</span> m/s\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_current_weather</span>(<span class="params">city: str</span>) -&gt; str:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取指定城市的当前天气信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        city: 城市名称（英文或中文）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        格式化的当前天气信息</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> OPENWEATHER_API_KEY:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;❌ 错误: 未配置 OpenWeatherMap API 密钥。请设置 OPENWEATHER_API_KEY 环境变量。&quot;</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">f&quot;正在获取 <span class="subst">&#123;city&#125;</span> 的当前天气信息...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(</span><br><span class="line">            <span class="string">f&quot;<span class="subst">&#123;OPENWEATHER_BASE_URL&#125;</span>/weather&quot;</span>,</span><br><span class="line">            params=&#123;</span><br><span class="line">                <span class="string">&quot;q&quot;</span>: city,</span><br><span class="line">                <span class="string">&quot;appid&quot;</span>: OPENWEATHER_API_KEY,</span><br><span class="line">                <span class="string">&quot;lang&quot;</span>: <span class="string">&quot;zh_cn&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            timeout=<span class="number">10</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">404</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;❌ 错误: 找不到城市 &#x27;<span class="subst">&#123;city&#125;</span>&#x27;。请检查城市名称是否正确。&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> response.status_code == <span class="number">401</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;❌ 错误: API 密钥无效。请检查 OPENWEATHER_API_KEY 配置。&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> response.status_code != <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;❌ 错误: API 请求失败 (状态码: <span class="subst">&#123;response.status_code&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line">        weather_data = response.json()</span><br><span class="line">        <span class="keyword">return</span> format_weather_info(weather_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> requests.RequestException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;❌ 网络错误: <span class="subst">&#123;str(e)&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;❌ 未知错误: <span class="subst">&#123;str(e)&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_weather_forecast</span>(<span class="params">city: str, days: int = <span class="number">5</span></span>) -&gt; str:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取指定城市的天气预报</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        city: 城市名称（英文或中文）</span></span><br><span class="line"><span class="string">        days: 预报天数（1-5天，默认5天）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        格式化的天气预报信息</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> OPENWEATHER_API_KEY:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;❌ 错误: 未配置 OpenWeatherMap API 密钥。请设置 OPENWEATHER_API_KEY 环境变量。&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> days &lt; <span class="number">1</span> <span class="keyword">or</span> days &gt; <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;❌ 错误: 预报天数必须在 1-5 天之间。&quot;</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">f&quot;正在获取 <span class="subst">&#123;city&#125;</span> 的 <span class="subst">&#123;days&#125;</span> 天天气预报...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(</span><br><span class="line">            <span class="string">f&quot;<span class="subst">&#123;OPENWEATHER_BASE_URL&#125;</span>/forecast&quot;</span>,</span><br><span class="line">            params=&#123;</span><br><span class="line">                <span class="string">&quot;q&quot;</span>: city,</span><br><span class="line">                <span class="string">&quot;appid&quot;</span>: OPENWEATHER_API_KEY,</span><br><span class="line">                <span class="string">&quot;lang&quot;</span>: <span class="string">&quot;zh_cn&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            timeout=<span class="number">10</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">404</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;❌ 错误: 找不到城市 &#x27;<span class="subst">&#123;city&#125;</span>&#x27;。请检查城市名称是否正确。&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> response.status_code == <span class="number">401</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;❌ 错误: API 密钥无效。请检查 OPENWEATHER_API_KEY 配置。&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> response.status_code != <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;❌ 错误: API 请求失败 (状态码: <span class="subst">&#123;response.status_code&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line">        forecast_data = response.json()</span><br><span class="line">        <span class="keyword">return</span> format_forecast_info(forecast_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> requests.RequestException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;❌ 网络错误: <span class="subst">&#123;str(e)&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;❌ 未知错误: <span class="subst">&#123;str(e)&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.resource(&quot;weather://current/&#123;city&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_current_weather_resource</span>(<span class="params">city: str</span>) -&gt; str:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取指定城市当前天气的资源&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;当前天气信息资源: <span class="subst">&#123;city&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.resource(&quot;weather://forecast/&#123;city&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_forecast_resource</span>(<span class="params">city: str</span>) -&gt; str:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取指定城市天气预报的资源&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;天气预报资源: <span class="subst">&#123;city&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.resource(&quot;weather://api-status&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_api_status</span>() -&gt; str:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取 API 状态信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> OPENWEATHER_API_KEY:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;✅ OpenWeatherMap API 密钥已配置&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;❌ OpenWeatherMap API 密钥未配置&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;运行 MCP 服务器&quot;&quot;&quot;</span></span><br><span class="line">    print(<span class="string">&quot;🌤️ 启动天气 MCP 服务器...&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;📍 支持的功能:&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;  - 获取当前天气 (get_current_weather)&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;  - 获取天气预报 (get_weather_forecast)&quot;</span>)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> OPENWEATHER_API_KEY:</span><br><span class="line">        print(<span class="string">&quot;⚠️  警告: 未配置 OpenWeatherMap API 密钥&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;请创建 .env 文件并添加以下内容:&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;OPENWEATHER_API_KEY=your_api_key_here&quot;</span>)</span><br><span class="line">        print()</span><br><span class="line">        print(<span class="string">&quot;获取 API 密钥: https://openweathermap.org/api&quot;</span>)</span><br><span class="line">        print()</span><br><span class="line"></span><br><span class="line">    mcp.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>上面代码其实很简单，上面大部分都是我们去请求 OpenWeatherMap API 获取天气数据，然后组装成我们想要的数据格式。核心的代码其实就只有 <code>@mcp.tool()</code> 装饰器修饰的两个工具函数，分别对应获取当前天气和获取天气预报。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_current_weather</span>(<span class="params">city: str</span>) -&gt; str:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_weather_forecast</span>(<span class="params">city: str, days: int = <span class="number">5</span></span>) -&gt; str:</span></span><br></pre></td></tr></table></figure>

<p>这里我们使用 <code>mcp</code> 对象的 <code>tool</code> 方法来装饰这两个工具函数即可，这样包装后我们实现的方法会返回一个 MCP 的工具对象，该对象包含工具的名称、描述、参数和返回值等信息。而 <code>mcp</code> 对象是通过前面的 <code>FastMCP</code> 类创建的，该类是 MCP 服务器的一个实现，提供了一些便捷的方法来创建 MCP 服务器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mcp.server.fastmcp <span class="keyword">import</span> FastMCP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 MCP 服务器</span></span><br><span class="line">mcp = FastMCP(<span class="string">&quot;Weather&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当然出来 tools 之外，如果还想提供 resources 资源，我们也可以使用 <code>mcp</code> 对象的 <code>resource</code> 方法来装饰一个资源函数即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@mcp.resource(&quot;weather://current/&#123;city&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_current_weather_resource</span>(<span class="params">city: str</span>) -&gt; str:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取指定城市当前天气的资源&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;当前天气信息资源: <span class="subst">&#123;city&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后我们在项目根目录下面创建一个 <code>.env</code> 文件，并添加如下所示的环境变量即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OPENWEATHER_API_KEY=your_api_key_here</span><br></pre></td></tr></table></figure>

<h3 id="调试-MCP-服务器"><a href="#调试-MCP-服务器" class="headerlink" title="调试 MCP 服务器"></a>调试 MCP 服务器</h3><p>然后我们可以使用下面的命令来调试该 MCP 服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mcp dev main.py</span><br><span class="line">Starting MCP inspector...</span><br><span class="line">⚙️ Proxy server listening on port 6277</span><br><span class="line">New connection</span><br><span class="line"><span class="comment"># ......</span></span><br><span class="line">Stdio transport: <span class="built_in">command</span>=/opt/homebrew/bin/uv, args=run,--with,mcp,mcp,run,main.py</span><br><span class="line">Spawned stdio transport</span><br><span class="line">Connected MCP client to backing server transport</span><br><span class="line">Created web app transport</span><br><span class="line">Set up MCP proxy</span><br><span class="line">🔍 MCP Inspector is up and running at http://127.0.0.1:6274 🚀</span><br><span class="line">New connection</span><br></pre></td></tr></table></figure>

<p>该命令会启动一个 MCP Inspector 的调试器，我们可以通过浏览器 <code>http://127.0.0.1:6274</code> 进行访问，点击左侧的 <code>Connect</code> 按钮，就可以连接到当前的 MCP 服务器上，我们可以切换到 <code>Tools</code> 标签页，点击 <code>List Tools</code> 就可以看到该服务器提供的所有工具了。</p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/1747987799024.png" alt="null"></p>
<p>我们可以看到当前的 MCP 服务器提供了两个工具，分别是 <code>get_current_weather</code> 和 <code>get_weather_forecast</code>，我们可以点击其中一个工具，然后输入参数，点击 <code>Run Tool</code> 按钮，就可以看到该工具的返回结果了。</p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/1747987923331.png" alt="null"></p>
<h3 id="在-Cursor-中测试"><a href="#在-Cursor-中测试" class="headerlink" title="在 Cursor 中测试"></a>在 Cursor 中测试</h3><p>在 MCP Inspector 中测试没有问题，那么我们就可以将该 MCP 服务器安装到 Cursor 中，然后就可以在 Cursor 中使用该 MCP 服务器了。</p>
<p>同样在 Cursor 设置页面，切换到 <code>MCP</code> 标签页，点击右上角的 <code>+ Add new global MCP server</code> 按钮，在弹出的 <code>mcp.json</code> 文件中添加如下所示的配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mcpServers&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;weather&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;uv&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;args&quot;</span>: [<span class="string">&quot;--directory&quot;</span>, <span class="string">&quot;/Users/cnych/your-mcp-path&quot;</span>, <span class="string">&quot;run&quot;</span>, <span class="string">&quot;main.py&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;env&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;OPENWEATHER_API_KEY&quot;</span>: <span class="string">&quot;xxxxx&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存后，我们就可以在 Cursor 中看到该 MCP 服务器了，并有两个 Tools 工具。</p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/1747988557742.png" alt="null"></p>
<p>然后我们可以在 Cursor Agent 模式下面询问关于天气的问题。</p>
<p><img src="https://raw.githubusercontent.com/Waylonwhynot/whatyouneed_blog_pic/main/pic/1747988679505.png" alt="null"><br><img src="https://picdn.youdianzhishi.com/images/1747988971960.png" alt="null"></p>
<p>当我们询问今天天气的时候可以看到 Cursor 会去主动调用 <code>get_current_weather</code> 工具查询当前城市的天气，同样询问未来天气的时候则会调用 <code>get_weather_forcaset</code> 工具查询数据。</p>
<p>最后我们可以将这个 weather mcp 服务器打包后发布到 pypi 上面去，则其他用户就可以直接指定我们这个包来安装这个 MCP 服务器了。</p>
<p>我们这里实现的这个 MCP 服务器是一个典型的 stdio 类型的 MCP 服务器，它通过标准输入输出与客户端进行交互，此外还可以通过 SSE 和 Streamable HTTP 等方式与客户端进行交互。</p>
<h2 id="开发-MCP-客户端"><a href="#开发-MCP-客户端" class="headerlink" title="开发 MCP 客户端"></a>开发 MCP 客户端</h2><p>上面我们自己实现了一个简单的 MCP 服务器，并在 Cursor 中测试了该服务器，那如果想要在其他地方使用该 MCP 服务器呢？这个就需要我们去实现一个 MCP 客户端了。</p>
<p>MCP Python SDK 提供了一个高级客户端接口，用于使用各种方式连接到 MCP 服务器，如下代码所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mcp <span class="keyword">import</span> ClientSession, StdioServerParameters, types</span><br><span class="line"><span class="keyword">from</span> mcp.client.stdio <span class="keyword">import</span> stdio_client</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 stdio 类型的 MCP 服务器参数</span></span><br><span class="line">server_params = StdioServerParameters(</span><br><span class="line">    command=<span class="string">&quot;python&quot;</span>,  <span class="comment"># 可执行文件</span></span><br><span class="line">    args=[<span class="string">&quot;example_server.py&quot;</span>],  <span class="comment"># 可选的命令行参数</span></span><br><span class="line">    env=<span class="literal">None</span>,  <span class="comment"># 可选的环境变量</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> stdio_client(server_params) <span class="keyword">as</span> (read, write):  <span class="comment"># 创建一个 stdio 类型的客户端</span></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> ClientSession(read, write) <span class="keyword">as</span> session:  <span class="comment"># 创建一个客户端会话</span></span><br><span class="line">            <span class="comment"># 初始化连接</span></span><br><span class="line">            <span class="keyword">await</span> session.initialize()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 列出可用的提示词</span></span><br><span class="line">            prompts = <span class="keyword">await</span> session.list_prompts()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 获取一个提示词</span></span><br><span class="line">            prompt = <span class="keyword">await</span> session.get_prompt(</span><br><span class="line">                <span class="string">&quot;example-prompt&quot;</span>, arguments=&#123;<span class="string">&quot;arg1&quot;</span>: <span class="string">&quot;value&quot;</span>&#125;</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 列出可用的资源</span></span><br><span class="line">            resources = <span class="keyword">await</span> session.list_resources()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 列出可用的工具</span></span><br><span class="line">            tools = <span class="keyword">await</span> session.list_tools()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 读取一个资源</span></span><br><span class="line">            content, mime_type = <span class="keyword">await</span> session.read_resource(<span class="string">&quot;file://some/path&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 调用一个工具</span></span><br><span class="line">            result = <span class="keyword">await</span> session.call_tool(<span class="string">&quot;tool-name&quot;</span>, arguments=&#123;<span class="string">&quot;arg1&quot;</span>: <span class="string">&quot;value&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line">    asyncio.run(run())</span><br></pre></td></tr></table></figure>

<p>上面代码中我们创建了一个 stdio 类型的 MCP 客户端，并使用 <code>stdio_client</code> 函数创建了一个客户端会话，然后通过 <code>ClientSession</code> 类创建了一个客户端会话，然后通过 <code>session.initialize()</code> 方法初始化连接，然后通过 <code>session.list_prompts()</code> 方法列出可用的提示词，然后通过 <code>session.get_prompt()</code> 方法获取一个提示词，然后通过 <code>session.list_resources()</code> 方法列出可用的资源，然后通过 <code>session.list_tools()</code> 方法列出可用的工具，然后通过 <code>session.read_resource()</code> 方法读取一个资源，然后通过 <code>session.call_tool()</code> 方法调用一个工具，这些都是 MCP 客户端的常用方法。</p>
<p>但是在实际的 MCP 客户端或者主机中我们一般会结合 LLM 来实现更加智能的交互，比如我们要实现一个基于 OpenAI 的 MCP 客户端，那要怎么实现呢？我们可以参考 Cursor 的方式：</p>
<ul>
<li>首先通过一个 JSON 配置文件来配置 MCP 服务器</li>
<li>读取该配置文件，加载 MCP 服务器列表</li>
<li>获取 MCP 服务器提供的可用工具列表</li>
<li>然后根据用户的输入，以及 Tools 列表传递给 LLM（如果 LLM 不支持工具调用，那么就需要在 System 提示词中告诉 LLM 如何调用这些工具）</li>
<li>根据 LLM 的返回结果，循环调用所有的 MCP 服务器提供的工具</li>
<li>得到 MCP 工具的返回结果后，可以将返回结果发送给 LLM 得到更符合用户意图的回答</li>
</ul>
<p>这个流程更符合我们实际情况的交互流程，下面我们实现一个基于 OpenAI 来实现一个简单的 MCP 客户端，完整代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">MyMCP 客户端 - 使用 OpenAI 原生 tools 调用</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Dict, List, Any, Optional</span><br><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> AsyncOpenAI</span><br><span class="line"><span class="keyword">from</span> mcp <span class="keyword">import</span> StdioServerParameters</span><br><span class="line"><span class="keyword">from</span> mcp.client.stdio <span class="keyword">import</span> stdio_client</span><br><span class="line"><span class="keyword">from</span> mcp.client.session <span class="keyword">import</span> ClientSession</span><br><span class="line"><span class="keyword">from</span> mcp.types <span class="keyword">import</span> Tool, TextContent</span><br><span class="line"><span class="keyword">from</span> rich.console <span class="keyword">import</span> Console</span><br><span class="line"><span class="keyword">from</span> rich.prompt <span class="keyword">import</span> Prompt</span><br><span class="line"><span class="keyword">from</span> rich.panel <span class="keyword">import</span> Panel</span><br><span class="line"><span class="keyword">from</span> rich.markdown <span class="keyword">import</span> Markdown</span><br><span class="line"><span class="keyword">from</span> rich.table <span class="keyword">import</span> Table</span><br><span class="line"><span class="keyword">from</span> rich.spinner <span class="keyword">import</span> Spinner</span><br><span class="line"><span class="keyword">from</span> rich.live <span class="keyword">import</span> Live</span><br><span class="line"><span class="keyword">from</span> dotenv <span class="keyword">import</span> load_dotenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载环境变量</span></span><br><span class="line">load_dotenv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 Rich console</span></span><br><span class="line">console = Console()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MCPServerConfig</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;MCP 服务器配置&quot;&quot;&quot;</span></span><br><span class="line">    name: str</span><br><span class="line">    command: str</span><br><span class="line">    args: List[str]</span><br><span class="line">    description: str</span><br><span class="line">    env: Optional[Dict[str, str]] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMCPClient</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;MyMCP 客户端&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, config_path: str = <span class="string">&quot;mcp.json&quot;</span></span>):</span></span><br><span class="line">        self.config_path = config_path</span><br><span class="line">        self.servers: Dict[str, MCPServerConfig] = &#123;&#125;</span><br><span class="line">        self.all_tools: List[tuple[str, Any]] = []  <span class="comment"># (server_name, tool)</span></span><br><span class="line">        self.openai_client = AsyncOpenAI(</span><br><span class="line">            api_key=os.getenv(<span class="string">&quot;OPENAI_API_KEY&quot;</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_config</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;从配置文件加载 MCP 服务器配置&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> open(self.config_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                config = json.load(f)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> name, server_config <span class="keyword">in</span> config.get(<span class="string">&quot;mcpServers&quot;</span>, &#123;&#125;).items():</span><br><span class="line">                env_dict = server_config.get(<span class="string">&quot;env&quot;</span>, &#123;&#125;)</span><br><span class="line">                self.servers[name] = MCPServerConfig(</span><br><span class="line">                    name=name,</span><br><span class="line">                    command=server_config[<span class="string">&quot;command&quot;</span>],</span><br><span class="line">                    args=server_config.get(<span class="string">&quot;args&quot;</span>, []),</span><br><span class="line">                    description=server_config.get(<span class="string">&quot;description&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                    env=env_dict <span class="keyword">if</span> env_dict <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">            console.print(<span class="string">f&quot;[green]✓ 已加载 <span class="subst">&#123;len(self.servers)&#125;</span> 个 MCP 服务器配置[/green]&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            console.print(<span class="string">f&quot;[red]✗ 加载配置文件失败: <span class="subst">&#123;e&#125;</span>[/red]&quot;</span>)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_tools_from_server</span>(<span class="params">self, name: str, config: MCPServerConfig</span>) -&gt; List[Tool]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;从单个服务器获取工具列表&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            console.print(<span class="string">f&quot;[blue]→ 正在连接服务器: <span class="subst">&#123;name&#125;</span>[/blue]&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 准备环境变量</span></span><br><span class="line">            env = os.environ.copy()</span><br><span class="line">            <span class="keyword">if</span> config.env:</span><br><span class="line">                env.update(config.env)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 创建服务器参数</span></span><br><span class="line">            server_params = StdioServerParameters(</span><br><span class="line">                command=config.command,</span><br><span class="line">                args=config.args,</span><br><span class="line">                env=env</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 使用 async with 上下文管理器（双层嵌套）</span></span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> stdio_client(server_params) <span class="keyword">as</span> (read, write):</span><br><span class="line">                <span class="keyword">async</span> <span class="keyword">with</span> ClientSession(read, write) <span class="keyword">as</span> session:</span><br><span class="line">                    <span class="keyword">await</span> session.initialize()</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 获取工具列表</span></span><br><span class="line">                    tools_result = <span class="keyword">await</span> session.list_tools()</span><br><span class="line">                    tools = tools_result.tools</span><br><span class="line"></span><br><span class="line">                    console.print(<span class="string">f&quot;[green]✓ <span class="subst">&#123;name&#125;</span>: <span class="subst">&#123;len(tools)&#125;</span> 个工具[/green]&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> tools</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            console.print(<span class="string">f&quot;[red]✗ 连接服务器 <span class="subst">&#123;name&#125;</span> 失败: <span class="subst">&#123;e&#125;</span>[/red]&quot;</span>)</span><br><span class="line">            console.print(<span class="string">f&quot;[red]  错误类型: <span class="subst">&#123;type(e).__name__&#125;</span>[/red]&quot;</span>)</span><br><span class="line">            <span class="keyword">import</span> traceback</span><br><span class="line">            console.print(<span class="string">f&quot;[red]  详细错误: <span class="subst">&#123;traceback.format_exc()&#125;</span>[/red]&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">load_all_tools</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;加载所有服务器的工具&quot;&quot;&quot;</span></span><br><span class="line">        console.print(<span class="string">&quot;\n[blue]→ 正在获取可用工具列表...[/blue]&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> name, config <span class="keyword">in</span> self.servers.items():</span><br><span class="line">            tools = <span class="keyword">await</span> self.get_tools_from_server(name, config)</span><br><span class="line">            <span class="keyword">for</span> tool <span class="keyword">in</span> tools:</span><br><span class="line">                self.all_tools.append((name, tool))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display_tools</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;显示所有可用工具&quot;&quot;&quot;</span></span><br><span class="line">        table = Table(title=<span class="string">&quot;可用 MCP 工具&quot;</span>, show_header=<span class="literal">True</span>)</span><br><span class="line">        table.add_column(<span class="string">&quot;服务器&quot;</span>, style=<span class="string">&quot;cyan&quot;</span>)</span><br><span class="line">        table.add_column(<span class="string">&quot;工具名称&quot;</span>, style=<span class="string">&quot;green&quot;</span>)</span><br><span class="line">        table.add_column(<span class="string">&quot;描述&quot;</span>, style=<span class="string">&quot;white&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 按服务器分组</span></span><br><span class="line">        current_server = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> server_name, tool <span class="keyword">in</span> self.all_tools:</span><br><span class="line">            <span class="comment"># 只在服务器名称变化时显示服务器名称</span></span><br><span class="line">            display_server = server_name <span class="keyword">if</span> server_name != current_server <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            current_server = server_name</span><br><span class="line"></span><br><span class="line">            table.add_row(</span><br><span class="line">                display_server,</span><br><span class="line">                tool.name,</span><br><span class="line">                tool.description <span class="keyword">or</span> <span class="string">&quot;无描述&quot;</span></span><br><span class="line">            )</span><br><span class="line">        console.print(table)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_openai_tools</span>(<span class="params">self</span>) -&gt; List[Dict[str, Any]]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;构建 OpenAI tools 格式的工具定义&quot;&quot;&quot;</span></span><br><span class="line">        openai_tools = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> server_name, tool <span class="keyword">in</span> self.all_tools:</span><br><span class="line">            <span class="comment"># 构建 OpenAI function 格式</span></span><br><span class="line">            function_def = &#123;</span><br><span class="line">                <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span>,</span><br><span class="line">                <span class="string">&quot;function&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;name&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;server_name&#125;</span>_<span class="subst">&#123;tool.name&#125;</span>&quot;</span>,  <span class="comment"># 添加服务器前缀避免冲突</span></span><br><span class="line">                    <span class="string">&quot;description&quot;</span>: <span class="string">f&quot;[<span class="subst">&#123;server_name&#125;</span>] <span class="subst">&#123;tool.description <span class="keyword">or</span> <span class="string">&#x27;无描述&#x27;</span>&#125;</span>&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;parameters&quot;</span>: tool.inputSchema <span class="keyword">or</span> &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>, <span class="string">&quot;properties&quot;</span>: &#123;&#125;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            openai_tools.append(function_def)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> openai_tools</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_tool_name</span>(<span class="params">self, function_name: str</span>) -&gt; tuple[str, str]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;解析工具名称，提取服务器名称和工具名称&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 格式: server_name_tool_name</span></span><br><span class="line">        parts = function_name.split(<span class="string">&#x27;_&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> len(parts) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> parts[<span class="number">0</span>], parts[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果没有下划线，假设是第一个服务器的工具</span></span><br><span class="line">            <span class="keyword">if</span> self.all_tools:</span><br><span class="line">                <span class="keyword">return</span> self.all_tools[<span class="number">0</span>][<span class="number">0</span>], function_name</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;unknown&quot;</span>, function_name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">call_tool</span>(<span class="params">self, server_name: str, tool_name: str, arguments: Dict[str, Any]</span>) -&gt; Any:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;调用指定的工具&quot;&quot;&quot;</span></span><br><span class="line">        config = self.servers.get(server_name)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> config:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f&quot;服务器 <span class="subst">&#123;server_name&#125;</span> 不存在&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 准备环境变量</span></span><br><span class="line">            env = os.environ.copy()</span><br><span class="line">            <span class="keyword">if</span> config.env:</span><br><span class="line">                env.update(config.env)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 创建服务器参数</span></span><br><span class="line">            server_params = StdioServerParameters(</span><br><span class="line">                command=config.command,</span><br><span class="line">                args=config.args,</span><br><span class="line">                env=env</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 使用 async with 上下文管理器（双层嵌套）</span></span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> stdio_client(server_params) <span class="keyword">as</span> (read, write):</span><br><span class="line">                <span class="keyword">async</span> <span class="keyword">with</span> ClientSession(read, write) <span class="keyword">as</span> session:</span><br><span class="line">                    <span class="keyword">await</span> session.initialize()</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 调用工具</span></span><br><span class="line">                    result = <span class="keyword">await</span> session.call_tool(tool_name, arguments)</span><br><span class="line">                    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            console.print(<span class="string">f&quot;[red]✗ 调用工具 <span class="subst">&#123;tool_name&#125;</span> 失败: <span class="subst">&#123;e&#125;</span>[/red]&quot;</span>)</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extract_text_content</span>(<span class="params">self, content_list: List[Any]</span>) -&gt; str:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;从 MCP 响应中提取文本内容&quot;&quot;&quot;</span></span><br><span class="line">        text_parts: List[str] = []</span><br><span class="line">        <span class="keyword">for</span> content <span class="keyword">in</span> content_list:</span><br><span class="line">            <span class="keyword">if</span> isinstance(content, TextContent):</span><br><span class="line">                text_parts.append(content.text)</span><br><span class="line">            <span class="keyword">elif</span> hasattr(content, <span class="string">&#x27;text&#x27;</span>):</span><br><span class="line">                text_parts.append(str(content.text))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 处理其他类型的内容</span></span><br><span class="line">                text_parts.append(str(content))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;\n&quot;</span>.join(text_parts) <span class="keyword">if</span> text_parts <span class="keyword">else</span> <span class="string">&quot;✅ 操作完成，但没有返回文本内容&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">process_user_input</span>(<span class="params">self, user_input: str</span>) -&gt; str:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;处理用户输入并返回最终响应&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建工具定义</span></span><br><span class="line">        openai_tools = self.build_openai_tools()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 第一次调用 - 让 LLM 决定是否需要使用工具</span></span><br><span class="line">            messages = [</span><br><span class="line">                &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;你是一个智能助手，可以使用各种 MCP 工具来帮助用户完成任务。如果不需要使用工具，直接返回回答。&quot;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: user_input&#125;</span><br><span class="line">            ]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 调用 OpenAI API</span></span><br><span class="line">            kwargs = &#123;</span><br><span class="line">                <span class="string">&quot;model&quot;</span>: <span class="string">&quot;deepseek-chat&quot;</span>,</span><br><span class="line">                <span class="string">&quot;messages&quot;</span>: messages,</span><br><span class="line">                <span class="string">&quot;temperature&quot;</span>: <span class="number">0.7</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 只有当有工具时才添加 tools 参数</span></span><br><span class="line">            <span class="keyword">if</span> openai_tools:</span><br><span class="line">                kwargs[<span class="string">&quot;tools&quot;</span>] = openai_tools</span><br><span class="line">                kwargs[<span class="string">&quot;tool_choice&quot;</span>] = <span class="string">&quot;auto&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 使用 loading 特效</span></span><br><span class="line">            <span class="keyword">with</span> Live(Spinner(<span class="string">&quot;dots&quot;</span>, text=<span class="string">&quot;[blue]正在思考...[/blue]&quot;</span>), console=console, refresh_per_second=<span class="number">10</span>):</span><br><span class="line">                response = <span class="keyword">await</span> self.openai_client.chat.completions.create(**kwargs)  <span class="comment"># type: ignore</span></span><br><span class="line">            message = response.choices[<span class="number">0</span>].message</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 检查是否有工具调用</span></span><br><span class="line">            <span class="keyword">if</span> hasattr(message, <span class="string">&#x27;tool_calls&#x27;</span>) <span class="keyword">and</span> message.tool_calls:  <span class="comment"># type: ignore</span></span><br><span class="line">                <span class="comment"># 添加助手消息到历史</span></span><br><span class="line">                messages.append(&#123;  <span class="comment"># type: ignore</span></span><br><span class="line">                    <span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;content&quot;</span>: message.content,</span><br><span class="line">                    <span class="string">&quot;tool_calls&quot;</span>: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="string">&quot;id&quot;</span>: tc.id,</span><br><span class="line">                            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;function&quot;</span>: &#123;</span><br><span class="line">                                <span class="string">&quot;name&quot;</span>: tc.function.name,</span><br><span class="line">                                <span class="string">&quot;arguments&quot;</span>: tc.function.arguments</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">for</span> tc <span class="keyword">in</span> message.tool_calls  <span class="comment"># type: ignore</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 执行每个工具调用</span></span><br><span class="line">                <span class="keyword">for</span> tool_call <span class="keyword">in</span> message.tool_calls:</span><br><span class="line">                    function_name = tool_call.function.name  <span class="comment"># type: ignore</span></span><br><span class="line">                    arguments = json.loads(tool_call.function.arguments)  <span class="comment"># type: ignore</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 解析服务器名称和工具名称</span></span><br><span class="line">                    server_name, tool_name = self.parse_tool_name(function_name)  <span class="comment"># type: ignore</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        <span class="comment"># 使用 loading 特效调用工具</span></span><br><span class="line">                        <span class="keyword">with</span> Live(Spinner(<span class="string">&quot;dots&quot;</span>, text=<span class="string">f&quot;[cyan]正在调用 <span class="subst">&#123;server_name&#125;</span>.<span class="subst">&#123;tool_name&#125;</span>...[/cyan]&quot;</span>), console=console, refresh_per_second=<span class="number">10</span>):</span><br><span class="line">                            result = <span class="keyword">await</span> self.call_tool(server_name, tool_name, arguments)</span><br><span class="line"></span><br><span class="line">                        <span class="comment"># 从 MCP 响应中提取文本内容</span></span><br><span class="line">                        result_content = self.extract_text_content(result.content)</span><br><span class="line">                        <span class="comment"># 添加工具调用结果</span></span><br><span class="line">                        messages.append(&#123;</span><br><span class="line">                            <span class="string">&quot;role&quot;</span>: <span class="string">&quot;tool&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;tool_call_id&quot;</span>: tool_call.id,</span><br><span class="line">                            <span class="string">&quot;content&quot;</span>: result_content</span><br><span class="line">                        &#125;)</span><br><span class="line">                        console.print(<span class="string">f&quot;[green]✓ <span class="subst">&#123;server_name&#125;</span>.<span class="subst">&#123;tool_name&#125;</span> 调用成功[/green]&quot;</span>)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                        <span class="comment"># 添加错误信息</span></span><br><span class="line">                        messages.append(&#123;</span><br><span class="line">                            <span class="string">&quot;role&quot;</span>: <span class="string">&quot;tool&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;tool_call_id&quot;</span>: tool_call.id,</span><br><span class="line">                            <span class="string">&quot;content&quot;</span>: <span class="string">f&quot;错误: <span class="subst">&#123;str(e)&#125;</span>&quot;</span></span><br><span class="line">                        &#125;)</span><br><span class="line">                        console.print(<span class="string">f&quot;[red]✗ <span class="subst">&#123;server_name&#125;</span>.<span class="subst">&#123;tool_name&#125;</span> 调用失败: <span class="subst">&#123;e&#125;</span>[/red]&quot;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 获取最终响应</span></span><br><span class="line">                <span class="keyword">with</span> Live(Spinner(<span class="string">&quot;dots&quot;</span>, text=<span class="string">&quot;[blue]正在生成最终响应...[/blue]&quot;</span>), console=console, refresh_per_second=<span class="number">10</span>):</span><br><span class="line">                    final_response = <span class="keyword">await</span> self.openai_client.chat.completions.create(</span><br><span class="line">                        model=<span class="string">&quot;deepseek-chat&quot;</span>,</span><br><span class="line">                        messages=messages,  <span class="comment"># type: ignore</span></span><br><span class="line">                        temperature=<span class="number">0.7</span></span><br><span class="line">                    )</span><br><span class="line"></span><br><span class="line">                final_content = final_response.choices[<span class="number">0</span>].message.content</span><br><span class="line">                <span class="keyword">return</span> final_content <span class="keyword">or</span> <span class="string">&quot;抱歉，我无法生成最终回答。&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 没有工具调用，直接返回响应</span></span><br><span class="line">                <span class="keyword">return</span> message.content <span class="keyword">or</span> <span class="string">&quot;抱歉，我无法生成回答。&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            console.print(<span class="string">f&quot;[red]✗ 处理请求时出错: <span class="subst">&#123;e&#125;</span>[/red]&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;抱歉，处理您的请求时出现错误: <span class="subst">&#123;str(e)&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">interactive_loop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;交互式循环&quot;&quot;&quot;</span></span><br><span class="line">        console.print(Panel.fit(</span><br><span class="line">            <span class="string">&quot;[bold cyan]MyMCP 客户端已启动[/bold cyan]\n&quot;</span></span><br><span class="line">            <span class="string">&quot;输入您的问题，我会使用可用的 MCP 工具来帮助您。\n&quot;</span></span><br><span class="line">            <span class="string">&quot;输入 &#x27;tools&#x27; 查看可用工具\n&quot;</span></span><br><span class="line">            <span class="string">&quot;输入 &#x27;exit&#x27; 或 &#x27;quit&#x27; 退出。&quot;</span>,</span><br><span class="line">            title=<span class="string">&quot;欢迎使用 MCP 客户端&quot;</span></span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 获取用户输入</span></span><br><span class="line">                user_input = Prompt.ask(<span class="string">&quot;\n[bold green]您[/bold green]&quot;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> user_input.lower() <span class="keyword">in</span> [<span class="string">&#x27;exit&#x27;</span>, <span class="string">&#x27;quit&#x27;</span>, <span class="string">&#x27;q&#x27;</span>]:</span><br><span class="line">                    console.print(<span class="string">&quot;\n[yellow]再见！[/yellow]&quot;</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> user_input.lower() == <span class="string">&#x27;tools&#x27;</span>:</span><br><span class="line">                    self.display_tools()</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 处理用户输入</span></span><br><span class="line">                response = <span class="keyword">await</span> self.process_user_input(user_input)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 显示响应</span></span><br><span class="line">                console.print(<span class="string">&quot;\n[bold blue]助手[/bold blue]:&quot;</span>)</span><br><span class="line">                console.print(Panel(Markdown(response), border_style=<span class="string">&quot;blue&quot;</span>))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">                console.print(<span class="string">&quot;\n[yellow]已中断[/yellow]&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                console.print(<span class="string">f&quot;\n[red]错误: <span class="subst">&#123;e&#125;</span>[/red]&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;运行客户端&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 加载配置</span></span><br><span class="line">        self.load_config()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.servers:</span><br><span class="line">            console.print(<span class="string">&quot;[red]✗ 没有配置的服务器[/red]&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取所有工具</span></span><br><span class="line">        <span class="keyword">await</span> self.load_all_tools()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.all_tools:</span><br><span class="line">            console.print(<span class="string">&quot;[red]✗ 没有可用的工具[/red]&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 显示可用工具</span></span><br><span class="line">        self.display_tools()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 进入交互循环</span></span><br><span class="line">        <span class="keyword">await</span> self.interactive_loop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;主函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 检查 OpenAI API Key</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.getenv(<span class="string">&quot;OPENAI_API_KEY&quot;</span>):</span><br><span class="line">        console.print(<span class="string">&quot;[red]✗ 请设置环境变量 OPENAI_API_KEY[/red]&quot;</span>)</span><br><span class="line">        console.print(<span class="string">&quot;提示: 创建 .env 文件并添加: OPENAI_API_KEY=your-api-key&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建并运行客户端</span></span><br><span class="line">    client = MyMCPClient()</span><br><span class="line">    <span class="keyword">await</span> client.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        asyncio.run(main())</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        console.print(<span class="string">&quot;\n[yellow]程序已退出[/yellow]&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        console.print(<span class="string">f&quot;\n[red]程序错误: <span class="subst">&#123;e&#125;</span>[/red]&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>上面代码中我们首先加载 <code>mcp.json</code> 文件，配置格式和 Cursor 的一致，来获取所有我们自己配置的 MCP 服务器，比如我们配置如下所示的 <code>mcp.json</code> 文件：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mcpServers&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;weather&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;uv&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;args&quot;</span>: [<span class="string">&quot;--directory&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;run&quot;</span>, <span class="string">&quot;main.py&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;天气信息服务器 - 获取当前天气和天气预报&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;env&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;OPENWEATHER_API_KEY&quot;</span>: <span class="string">&quot;xxxx&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;filesystem&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;npx&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;args&quot;</span>: [<span class="string">&quot;-y&quot;</span>, <span class="string">&quot;@modelcontextprotocol/server-filesystem&quot;</span>, <span class="string">&quot;/tmp&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;文件系统操作服务器 - 文件读写和目录管理&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>run</code> 方法中接着我们调用 <code>load_all_tools</code> 方法加载所有的工具列表，这里的实现核心就是去调用 MCP 服务器端的工具列表，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_tools_from_server</span>(<span class="params">self, name: str, config: MCPServerConfig</span>) -&gt; List[Tool]:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;从单个服务器获取工具列表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        console.print(<span class="string">f&quot;[blue]→ 正在连接服务器: <span class="subst">&#123;name&#125;</span>[/blue]&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 准备环境变量</span></span><br><span class="line">        env = os.environ.copy()</span><br><span class="line">        <span class="keyword">if</span> config.env:</span><br><span class="line">            env.update(config.env)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建服务器参数</span></span><br><span class="line">        server_params = StdioServerParameters(</span><br><span class="line">            command=config.command,</span><br><span class="line">            args=config.args,</span><br><span class="line">            env=env</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用 async with 上下文管理器（双层嵌套）</span></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> stdio_client(server_params) <span class="keyword">as</span> (read, write):</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> ClientSession(read, write) <span class="keyword">as</span> session:</span><br><span class="line">                <span class="keyword">await</span> session.initialize()</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 获取工具列表</span></span><br><span class="line">                tools_result = <span class="keyword">await</span> session.list_tools()</span><br><span class="line">                tools = tools_result.tools</span><br><span class="line"></span><br><span class="line">                console.print(<span class="string">f&quot;[green]✓ <span class="subst">&#123;name&#125;</span>: <span class="subst">&#123;len(tools)&#125;</span> 个工具[/green]&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> tools</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        console.print(<span class="string">f&quot;[red]✗ 连接服务器 <span class="subst">&#123;name&#125;</span> 失败: <span class="subst">&#123;e&#125;</span>[/red]&quot;</span>)</span><br><span class="line">        console.print(<span class="string">f&quot;[red]  错误类型: <span class="subst">&#123;type(e).__name__&#125;</span>[/red]&quot;</span>)</span><br><span class="line">        <span class="keyword">import</span> traceback</span><br><span class="line">        console.print(<span class="string">f&quot;[red]  详细错误: <span class="subst">&#123;traceback.format_exc()&#125;</span>[/red]&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

<p>这里核心就是直接使用 MCP Python SDK 提供的客户端接口去调用 MCP 服务器获取工具列表。</p>
<p>接下来就是处理用户的输入了，这里首先我们要做的是将获取到的 MCP 工具列表转换成 OpenAI 能够识别的 function tools 格式，然后将用户的输入和工具一起发给 OpenAI 进行处理，然后根据返回结果判断是否应该调用某个工具，如果需要同样直接调用 MCP 的工具即可，最后将获得的结果一起组装发给 OpenAI 获得一个更加完整的回答结果。这整个流程不复杂，当然还有很多细节可以优化，更多的还是根据我们自己的需求进行集成。</p>
<p>现在我们可以直接测试下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python simple_client.py</span><br><span class="line">✓ 已加载 1 个 MCP 服务器配置</span><br><span class="line"></span><br><span class="line">→ 正在获取可用工具列表...</span><br><span class="line">→ 正在连接服务器: weather</span><br><span class="line">[05/25/25 11:42:51] INFO     Processing request of <span class="built_in">type</span> ListToolsRequest  server.py:551</span><br><span class="line">✓ weather: 2 个工具</span><br><span class="line">                              可用 MCP 工具</span><br><span class="line">┏━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓</span><br><span class="line">┃ 服务器  ┃ 工具名称             ┃ 描述                                 ┃</span><br><span class="line">┡━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩</span><br><span class="line">│ weather │ get_current_weather  │                                      │</span><br><span class="line">│         │                      │ 获取指定城市的当前天气信息           │</span><br><span class="line">│         │                      │                                      │</span><br><span class="line">│         │                      │ Args:                                │</span><br><span class="line">│         │                      │     city: 城市名称（英文）           │</span><br><span class="line">│         │                      │                                      │</span><br><span class="line">│         │                      │ Returns:                             │</span><br><span class="line">│         │                      │     格式化的当前天气信息             │</span><br><span class="line">│         │                      │                                      │</span><br><span class="line">│         │ get_weather_forecast │                                      │</span><br><span class="line">│         │                      │ 获取指定城市的天气预报               │</span><br><span class="line">│         │                      │                                      │</span><br><span class="line">│         │                      │ Args:                                │</span><br><span class="line">│         │                      │     city: 城市名称（英文）           │</span><br><span class="line">│         │                      │     days: 预报天数（1-5天，默认5天） │</span><br><span class="line">│         │                      │                                      │</span><br><span class="line">│         │                      │ Returns:                             │</span><br><span class="line">│         │                      │     格式化的天气预报信息             │</span><br><span class="line">│         │                      │                                      │</span><br><span class="line">└─────────┴──────────────────────┴──────────────────────────────────────┘</span><br><span class="line">╭────────────── 欢迎使用 MCP 客户端 ──────────────╮</span><br><span class="line">│ MyMCP 客户端已启动                              │</span><br><span class="line">│ 输入您的问题，我会使用可用的 MCP 工具来帮助您。 │</span><br><span class="line">│ 输入 <span class="string">&#x27;tools&#x27;</span> 查看可用工具                       │</span><br><span class="line">│ 输入 <span class="string">&#x27;exit&#x27;</span> 或 <span class="string">&#x27;quit&#x27;</span> 退出。                    │</span><br><span class="line">╰─────────────────────────────────────────────────╯</span><br><span class="line"></span><br><span class="line">您: 你好,你是谁?</span><br><span class="line">⠹ 正在思考...</span><br><span class="line"></span><br><span class="line">助手:</span><br><span class="line">╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮</span><br><span class="line">│ 你好！我是一个智能助手，可以帮助你完成各种任务，比如回答问题、查询天气、提供建议等等。如果你有任何需要，随时告诉我！ 😊                  │</span><br><span class="line">╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯</span><br><span class="line"></span><br><span class="line">您: 成都今天的天气咋样?明天适合穿裙子吗?</span><br><span class="line">⠧ 正在思考...</span><br><span class="line">⠴ 正在调用 weather.get_current_weather...[05/25/25 11:44:03] INFO     Processing request of <span class="built_in">type</span> CallToolRequest                                                        server.py:551</span><br><span class="line">⠴ 正在调用 weather.get_current_weather...</span><br><span class="line">✓ weather.get_current_weather 调用成功</span><br><span class="line">⠸ 正在调用 weather.get_weather_forecast...[05/25/25 11:44:04] INFO     Processing request of <span class="built_in">type</span> CallToolRequest                                                        server.py:551</span><br><span class="line">⠋ 正在调用 weather.get_weather_forecast...</span><br><span class="line">✓ weather.get_weather_forecast 调用成功</span><br><span class="line">⠧ 正在生成最终响应...</span><br><span class="line"></span><br><span class="line">助手:</span><br><span class="line">╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮</span><br><span class="line">│ 成都今天天气晴朗，当前温度26.9°C，湿度44%，风力较小，非常适合外出活动。                                                                  │</span><br><span class="line">│                                                                                                                                          │</span><br><span class="line">│ 明天(5月25日)天气预报：                                                                                                                  │</span><br><span class="line">│                                                                                                                                          │</span><br><span class="line">│  • 天气：多云                                                                                                                            │</span><br><span class="line">│  • 温度：26.4°C~29.3°C                                                                                                                   │</span><br><span class="line">│  • 风力：3.1 m/s                                                                                                                         │</span><br><span class="line">│  • 湿度：41%                                                                                                                             │</span><br><span class="line">│                                                                                                                                          │</span><br><span class="line">│ 建议：明天温度适中，风力不大，穿裙子完全没问题。不过建议搭配一件薄外套或防晒衣，因为多云天气紫外线可能较强。如果计划长时间在户外，可以带 │</span><br><span class="line">│ 把晴雨伞备用。                                                                                                                           │</span><br><span class="line">╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯</span><br><span class="line"></span><br><span class="line">您:</span><br></pre></td></tr></table></figure>

<p>从输出可以看到能够正常调用我们配置的 MCP 服务器提供的工具。</p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>DB-Redis-基础</title>
    <url>/posts/43753.html</url>
    <content><![CDATA[<p>Redis基础</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">配置重要参数</span><br><span class="line">stop-writes-on-bgsave-error no  <span class="comment"># 防止快照无法落盘导致无法写入 </span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://redis.io/">redis官方网站</a></li>
<li><a href="http://redis.cn/">redis中文官网</a></li>
</ul>
<h2 id="0-docker安装redis"><a href="#0-docker安装redis" class="headerlink" title="0. docker安装redis"></a>0. docker安装redis</h2><p>快速启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name redis -p 6379:6379 redis:latest redis-server --appendonly yes --requirepass <span class="string">&quot;你的密码&quot;</span></span><br></pre></td></tr></table></figure>

<p>指定配置文件启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 6379:6379 --name myredis -v /Users/waylonyan/docker-soft/redis/redis.conf:/etc/redis/redis.conf -v //Users/waylonyan/docker-soft/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes</span><br></pre></td></tr></table></figure>

<p>配置文件解释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d ：后台运行</span><br><span class="line">--name redis：服务名</span><br><span class="line">-p 6379:6379 ： 将容器6379端口映射到主机6379端口</span><br><span class="line">redis-server --appendonly yes：在容器执行redis-server启动命令，并打开redis持久化配置</span><br><span class="line">--requirepass <span class="string">&quot;你的密码&quot;</span> ：设置密码</span><br><span class="line"></span><br><span class="line"><span class="comment">########### 配置文件</span></span><br><span class="line">protected-mode no <span class="comment">#默认yes，开启保护模式，限制为本地访问</span></span><br><span class="line">daemonize no<span class="comment">#默认no，改为yes意为以守护进程方式启动，可后台运行，除非kill进程，改为yes会使配置文件方式启动redis失败</span></span><br><span class="line"><span class="comment"># databases 16 #数据库个数（可选），我修改了这个只是查看是否生效。。</span></span><br><span class="line">dir  /data <span class="comment">#输入本地redis数据库存放文件夹（可选）</span></span><br><span class="line">appendonly yes <span class="comment">#redis持久化（可选）</span></span><br><span class="line">requirepass  &#123;password&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ############# 默认用户名密码</span></span><br><span class="line">默认用户名为default</span><br></pre></td></tr></table></figure>

<p>连接redis</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 连接redis</span></span><br><span class="line">docker <span class="built_in">exec</span> -ti myredis redis-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 认证</span></span><br><span class="line">auth (用户名6.0以上默认default) 你的密码</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看ip地址</span></span><br><span class="line">docker inspect redis | grep IPAddress</span><br></pre></td></tr></table></figure>





<h2 id="一-Redis简介"><a href="#一-Redis简介" class="headerlink" title="一. Redis简介"></a>一. Redis简介</h2><p>单线程模型: 好处，永远不会出现并发安全问题</p>
<ul>
<li>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。</li>
<li>Redis是 NoSQL技术阵营中的一员，它通过多种键值数据类型来适应不同场景下的存储需求，借助一些高层级的接口使用其可以胜任，如缓存、队列系统的不同角色</li>
</ul>
<h3 id="Redis特性"><a href="#Redis特性" class="headerlink" title="Redis特性"></a>Redis特性</h3><ul>
<li>Redis 与其他 key - value 缓存产品有以下三个特点：</li>
<li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ul>
<h3 id="Redis-优势"><a href="#Redis-优势" class="headerlink" title="Redis 优势"></a>Redis 优势</h3><ul>
<li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li>
<li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>
<li>原子 – Redis的所有操作都是原子性的。</li>
<li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li>
</ul>
<h3 id="Redis应用场景"><a href="#Redis应用场景" class="headerlink" title="Redis应用场景"></a>Redis应用场景</h3><ul>
<li>用来做缓存(ehcache/memcached)——redis的所有数据是放在内存中的（内存数据库）</li>
<li>可以在某些特定应用场景下替代传统数据库——比如社交类的应用</li>
<li>在一些大型系统中，巧妙地实现一些特定的功能：session共享、购物车</li>
<li>只要你有丰富的想象力，redis可以用在可以给你无限的惊喜…….</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">永远都是<span class="number">1</span>个<span class="number">1</span>个修改</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### increase 重点</span></span><br><span class="line"><span class="comment"># 每次自增1</span></span><br><span class="line"><span class="comment"># 统计网页访问量，文章阅读量，粉丝数量，计数相关（不会存在并发安全的问题）</span></span><br><span class="line"></span><br><span class="line">conn.incr(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">res = conn.get(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> cs架构，key-value存储（没有表，各种关系）</span><br><span class="line"></span><br><span class="line">1 redis---&gt;是存储数据的软件，跟语言无关，纯内存数据库（所有数据都放在内存中）</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 速度非常快，支持的数据类型多样</span><br><span class="line">    (<span class="number">5</span>大数据类型：字符串string，列表list，字典hash，集合set，有序集合zset)</span><br><span class="line">    都支持push/pop、add/remove及取并集和差集及更丰富的操作，而且这些操作都是原子性的.</span><br><span class="line">    </span><br><span class="line"><span class="number">3</span> Memcached和redis比较</span><br><span class="line">    (<span class="number">1</span>)-redis是单线程，单进程，数据类型丰富（只针对于 redis <span class="number">6.0</span>以下）</span><br><span class="line">     -memcache多线程多进程，数据类型单一</span><br><span class="line">  (<span class="number">2</span>)redis的数据都是缓存在内存中。区别是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave(主从)同步。</span><br><span class="line">  (<span class="number">3</span>)支持主从集群，分布式</span><br><span class="line">  (<span class="number">4</span>)支持队列等特殊功能</span><br><span class="line">  </span><br><span class="line">  <span class="number">3.1</span> redis为什么单线程，单进程速度这么快？（不会有人问了）</span><br><span class="line">      <span class="number">-10</span>w，生产单机<span class="number">6</span>w左右</span><br><span class="line">        <span class="number">-1</span> 纯内存数据库</span><br><span class="line">        <span class="number">-2</span> io多路复用，epoll模型（linux上支持），windows上支持select</span><br><span class="line">        <span class="number">-3</span> 单线程单进程，避免了线程间切换(<span class="number">6.</span>x以后已经是多线程了)</span><br><span class="line">    </span><br><span class="line"><span class="number">4</span> redis：开源软件，c语言写的，早起版本<span class="number">2</span>w3千行，对windows不支持    <span class="number">6.0</span><span class="number">.6</span></span><br><span class="line">    -在不同平台编译---》可执行文件---》执行</span><br><span class="line">    -windows官方：又有大神把源码，在windows上编译--》可以允许在windows上（<span class="number">3.</span>x）</span><br></pre></td></tr></table></figure>

<h2 id="二-安装配置使用"><a href="#二-安装配置使用" class="headerlink" title="二. 安装配置使用"></a>二. 安装配置使用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载：</span></span><br><span class="line">wget http://download.redis.io/releases/redis-3.2.10.tar.gz</span><br><span class="line"><span class="comment"># 解压：</span></span><br><span class="line">tar xzf redis-3.2.10.tar.gz -C /usr/<span class="built_in">local</span></span><br><span class="line">mv redis-3.2.10 redis</span><br><span class="line"><span class="comment"># 安装：</span></span><br><span class="line"><span class="built_in">cd</span> redis</span><br><span class="line">make</span><br><span class="line"><span class="comment"># 启动：</span></span><br><span class="line">src/redis-server &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接测试：</span></span><br><span class="line">src/redis-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 环境变量配置：</span></span><br><span class="line">vim /root/.bash_profile</span><br><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/redis/src:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">source</span> /root/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接测试：</span></span><br><span class="line">redis-cli</span><br></pre></td></tr></table></figure>

<h3 id="2-0-连接数据库"><a href="#2-0-连接数据库" class="headerlink" title="2.0 连接数据库"></a>2.0 连接数据库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">1）默认连接：-h默认127.0.0.1，-p默认6379，-n默认0，-a默认无</span></span><br><span class="line"><span class="string">&gt;: redis-cli</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2）完整连接：</span></span><br><span class="line"><span class="string">&gt;: redis-cli -h ip地址 -p 端口号 -n 数据库编号 -a 密码</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3）先连接，后输入密码</span></span><br><span class="line"><span class="string">&gt;: redis-cli -h ip地址 -p 端口号 -n 数据库编号</span></span><br><span class="line"><span class="string">&gt;: auth 密码</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-切换数据库"><a href="#2-1-切换数据库" class="headerlink" title="2.1 切换数据库"></a>2.1 切换数据库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">1）在连入数据库后执行</span></span><br><span class="line"><span class="string">&gt;: select 数据库编号</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-关闭服务"><a href="#2-2-关闭服务" class="headerlink" title="2.2 关闭服务"></a>2.2 关闭服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">1）先连接数据库，再关闭redis服务</span></span><br><span class="line"><span class="string">&gt;: redis-cli -h ip地址 -p 端口号 -n 数据库编号 -a 密码</span></span><br><span class="line"><span class="string">&gt;: shutdown</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2）直接连接数据库并关闭redis服务</span></span><br><span class="line"><span class="string">&gt;: redis-cli -h ip地址 -p 端口号 -n 数据库编号 -a 密码 shutdown</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-清空redis数据库"><a href="#2-3-清空redis数据库" class="headerlink" title="2.3 清空redis数据库"></a>2.3 清空redis数据库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">1）连接数据库执行</span></span><br><span class="line"><span class="string">&gt;: flushall</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-配置文件介绍"><a href="#2-4-配置文件介绍" class="headerlink" title="2.4 配置文件介绍"></a>2.4 配置文件介绍</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">1）绑定的ip地址，多个ip用空格隔开</span></span><br><span class="line"><span class="string">bind 127.0.0.1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2）端口，默认6379，一般不做修改</span></span><br><span class="line"><span class="string">port 6379</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3）是否以守护进程启动，默认为no，一般改为yes代表后台启动（windows系统不支持）</span></span><br><span class="line"><span class="string">daemonize no</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4）定义日志级别，默认值为notice，有如下4种取值：</span></span><br><span class="line"><span class="string">    debug（记录大量日志信息，适用于开发、测试阶段）</span></span><br><span class="line"><span class="string">    verbose（较多日志信息）</span></span><br><span class="line"><span class="string">    notice（适量日志信息，使用于生产环境）</span></span><br><span class="line"><span class="string">    warning（仅有部分重要、关键信息才会被记录）</span></span><br><span class="line"><span class="string">loglevel notice</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">5）配置日志文件保持地址，默认打印在命令行终端的窗口上</span></span><br><span class="line"><span class="string">    如果填写 &quot;</span>./redis.log<span class="string">&quot; 就会在启动redis服务的终端所在目录下，用redis.log记录redis日志</span></span><br><span class="line"><span class="string">logfile &quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">eg）终端首先切断到log文件夹所在目录(一般就可以采用redis的安装目录，也可以自定义)，再启动reids服务</span></span><br><span class="line"><span class="string">logfile &quot;</span>./<span class="built_in">log</span>/redis.log<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">6）数据库个数，默认是16个，没特殊情况，不建议修改</span></span><br><span class="line"><span class="string">databases 16</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">7）数据持久化</span></span><br><span class="line"><span class="string">save 900 1  # 超过900秒有1个键值对操作，会自动调用save完成数据持久化</span></span><br><span class="line"><span class="string">save 300 10  # 超过300秒有10个键值对操作，会自动调用save完成数据持久化</span></span><br><span class="line"><span class="string">save 60 10000  # 超过60秒有10000个键值对操作，会自动调用save完成数据持久化</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">8）数据库持久化到硬盘失败，redis会立即停止接收用户数据，让用户知道redis持久化异常，避免数据灾难发生(重启redis即可)，默认为yes，不能做修改</span></span><br><span class="line"><span class="string">stop-writes-on-bgsave-error yes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">9）消耗cpu来压缩数据进行持久化，数据量小，但会消耗cpu性能，根据实际情况可以做调整</span></span><br><span class="line"><span class="string">rdbcompression yes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">10）增持cpu 10%性能销毁来完成持久化数据的校验，可以取消掉</span></span><br><span class="line"><span class="string">rdbchecksum yes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">11）持久化存储的文件名称</span></span><br><span class="line"><span class="string">dbfilename dump.rdb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">12）持久化存储文件的路径，默认是启动服务的终端所在目录</span></span><br><span class="line"><span class="string">dir ./</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">13）reids数据库密码</span></span><br><span class="line"><span class="string">requirepass 密码</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 连接配置</span></span><br><span class="line"><span class="string"># 没配置安全配置</span></span><br><span class="line"><span class="string">redis-cli -h 10.0.0.51 -p 6379</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># bind address  auth  这两个一起用  安全验证</span></span><br><span class="line"><span class="string">Bind</span></span><br><span class="line"><span class="string">指定IP进行监听 bind 10.0.0.51  127.0.0.1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">禁止protected-mode</span></span><br><span class="line"><span class="string">protected-mode yes/no （保护模式，是否只允许本地访问）</span></span><br><span class="line"><span class="string">增加requirepass  &#123;password&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在redis-cli中使用</span></span><br><span class="line"><span class="string">auth &#123;password&#125; 进行认证</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---------------------------------------------------------------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">配置安全验证</span></span><br><span class="line"><span class="string">vim  /data/6379/redis.conf   ---添加以下内容</span></span><br><span class="line"><span class="string">bind 10.0.0.51  127.0.0.1</span></span><br><span class="line"><span class="string">requirepass 123</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">重启redis生效</span></span><br><span class="line"><span class="string">127.0.0.1:6379&gt; shutdown </span></span><br><span class="line"><span class="string">not connected&gt; exit</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在线查看和修改配置</span></span><br><span class="line"><span class="string">CONFIG GET * # 一百多对建值</span></span><br><span class="line"><span class="string"># 可以查看当前数据库服务密码</span></span><br><span class="line"><span class="string">CONFIG GET requirepass</span></span><br><span class="line"><span class="string"># 设置新密码</span></span><br><span class="line"><span class="string">CONFIG SET requirepass 123456</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CONFIG SET maxmemory 128M  # 设置最大使用的内存</span></span><br><span class="line"><span class="string">CONFIG REWRITE  # 保存到配置文件</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---------------------------------------------------------------</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-redis配置文件示例"><a href="#2-2-redis配置文件示例" class="headerlink" title="2.2 redis配置文件示例"></a>2.2 redis配置文件示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本配置文件</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">daemonize NO</span><br><span class="line">protected-mode no</span><br><span class="line">requirepass 123456</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件启动</span></span><br><span class="line">7) 环境变量</span><br><span class="line"><span class="comment"># 环境变量配置：</span></span><br><span class="line">vim /root/.bash_profile</span><br><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/redis/src:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 加载</span></span><br><span class="line"><span class="built_in">source</span> /root/.bash_profile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8）配置文件相关</span><br><span class="line">egrep -v  <span class="string">&quot;^$|#&quot;</span> /usr/<span class="built_in">local</span>/redis/redis.conf   &gt; redis_sample.conf</span><br><span class="line"><span class="comment">#修改配置文件监听IP为0.0.0.0，否则只能本地登录</span></span><br><span class="line">sed -i s/<span class="built_in">bind</span>\ 127.0.0.1/<span class="built_in">bind</span>\ 0.0.0.0/g redis_sample.conf</span><br><span class="line"><span class="comment">#修改运行方式为后台运行</span></span><br><span class="line">sed -i s/daemonize\ no/daemonize\ yes/g redis_sample.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置持久化（可选）</span></span><br><span class="line">sed -i s/appendonly\ no/appendonly\ yes/g redis_sample.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制配置文件到etc目录</span></span><br><span class="line">/bin/cp -f redis_sample.conf /etc/redis.conf </span><br><span class="line"><span class="comment">#设置日志文件路径</span></span><br><span class="line">sed -i s@logfile\ \&quot;\&quot;@logfile\ \&quot;/var/<span class="built_in">log</span>/redis.log\&quot;@g /etc/redis.conf </span><br><span class="line"><span class="comment">#设置数据目录</span></span><br><span class="line">sed -i s@dir\ \./@dir\ /var/lib/redis@g /etc/redis.conf </span><br><span class="line"></span><br><span class="line"><span class="comment"># 密码</span></span><br><span class="line">requirepass  &#123;password&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据目录</span></span><br><span class="line">mkdir  /var/lib/redis</span><br><span class="line"></span><br><span class="line">启动配置文件</span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">cat &lt;&lt;EOF &gt; /etc/systemd/system/redis.service </span></span><br><span class="line"><span class="string">[Unit]</span></span><br><span class="line"><span class="string">Description=The redis-server Process Manager</span></span><br><span class="line"><span class="string">After=syslog.target network.target</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">Type=forking</span></span><br><span class="line"><span class="string">ExecStart=/usr/local/redis/src/redis-server /etc/redis.conf</span></span><br><span class="line"><span class="string">ExecStop=/usr/local/redis/src/redis-shutdown</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">system <span class="built_in">enable</span> redis</span><br><span class="line">systemctl restart redis</span><br><span class="line">systemctl status redis</span><br><span class="line"><span class="comment"># 连接测试：</span></span><br><span class="line">redis-cli</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-3-redis持久化"><a href="#2-3-redis持久化" class="headerlink" title="2.3 redis持久化"></a>2.3 redis持久化</h3><p>总结：redis持久化的方式,简单说说特点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. RDB：快照方式</span><br><span class="line">   save</span><br><span class="line">   有可能会有数据丢失</span><br><span class="line">   </span><br><span class="line">2. AOF：追加形式、安全</span><br><span class="line">   数据量较大</span><br><span class="line">   </span><br><span class="line">3. redis4.0之后出了一种混合持久化方案</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-4-RDB持久化"><a href="#2-4-RDB持久化" class="headerlink" title="2.4 RDB持久化"></a>2.4 RDB持久化</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。</span><br><span class="line">优点：速度快，适合于用做备份。主从复制依赖rdb持久化功能。</span><br><span class="line">缺点：会有数据丢失</span><br><span class="line"></span><br><span class="line">快照方式</span><br><span class="line">save</span><br><span class="line">有可能会有数据丢失</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line">配置分别表示：</span><br><span class="line">900秒（15分钟）内有1个更改</span><br><span class="line">300秒（5分钟）内有10个更改</span><br><span class="line">60秒内有        10000个更改</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-Redis-中-数据持久化SAVE和BGSAVE-区别？"><a href="#2-4-2-Redis-中-数据持久化SAVE和BGSAVE-区别？" class="headerlink" title="2.4.2 Redis 中 数据持久化SAVE和BGSAVE 区别？"></a>2.4.2 Redis 中 数据持久化SAVE和BGSAVE 区别？</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SAVE 调用 rdbSave ，阻塞 Redis 主进程，直到保存完成为止；阻塞期间，服务器不能处理客户端的任何请求。</span><br><span class="line"></span><br><span class="line">BGSAVE 则 fork 出一个子进程，子进程调用 rdbSave ，并在保存完成之后向主进程发送信号告知完成。 Redis 服务器在BGSAVE 执行期间仍然可以继续处理客户端的请求。 </span><br></pre></td></tr></table></figure>

<h3 id="2-5-AOF持久化"><a href="#2-5-AOF持久化" class="headerlink" title="2.5 AOF持久化"></a>2.5 AOF持久化</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。</span><br><span class="line">AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。</span><br><span class="line">优点：可以最大程度保证数据不丢，追加形式、安全</span><br><span class="line">缺点：日志记录量级比较大</span><br></pre></td></tr></table></figure>

<h4 id="2-5-1-AOF持久化配置"><a href="#2-5-1-AOF持久化配置" class="headerlink" title="2.5.1 AOF持久化配置"></a>2.5.1 AOF持久化配置</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br><span class="line">是否打开aof日志功能</span><br><span class="line">appendfsync always             最安全</span><br><span class="line">appendfsync everysec</span><br><span class="line">appendfsync no</span><br><span class="line">每<span class="number">1</span>个命令,都立即同步到aof</span><br><span class="line">每秒写<span class="number">1</span>次</span><br><span class="line">写入工作交给操作系统,由操作系统判断缓冲区大小,统一写入到aof.</span><br></pre></td></tr></table></figure>

<h3 id="Redis-4-0之后新增了一种持久化方式"><a href="#Redis-4-0之后新增了一种持久化方式" class="headerlink" title="Redis 4.0之后新增了一种持久化方式"></a>Redis 4.0之后新增了一种持久化方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 混合持久化</span></span><br><span class="line"></span><br><span class="line">描述：混合持久化并不是一种全新的持久化方式，而是对已有方式的优化。混合持久化只发生于 AOF 重写过程。使用了混合持久化，重写后的新 AOF 文件前半段是 RDB 格式的全量数据，后半段是 AOF 格式的增量数据。</span><br><span class="line"></span><br><span class="line">整体格式为：[RDB file][AOF tail]</span><br><span class="line"></span><br><span class="line">开启：混合持久化的配置参数为 aof-use-rdb-preamble，配置为 yes 时开启混合持久化，在 redis 4 刚引入时，默认是关闭混合持久化的，但是在 redis 5 中默认已经打开了。</span><br><span class="line"></span><br><span class="line">关闭：使用 aof-use-rdb-preamble no 配置即可关闭混合持久化。</span><br><span class="line"></span><br><span class="line">混合持久化本质是通过 AOF 后台重写（bgrewriteaof 命令）完成的，不同的是当开启混合持久化时，fork 出的子进程先将当前全量数据以 RDB 方式写入新的 AOF 文件，然后再将 AOF 重写缓冲区（aof_rewrite_buf_blocks）的增量命令以 AOF 方式写入到文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</span><br><span class="line"></span><br><span class="line">优点：结合 RDB 和 AOF 的优点, 更快的重写和恢复。</span><br><span class="line"></span><br><span class="line">缺点：AOF 文件里面的 RDB 部分不再是 AOF 格式，可读性差。</span><br><span class="line"></span><br><span class="line">相关源码在 aof.c，核心方法是：rewriteAppendOnlyFile</span><br></pre></td></tr></table></figure>







<h3 id="2-6-全局key操作"><a href="#2-6-全局key操作" class="headerlink" title="2.6 全局key操作"></a>2.6 全局key操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">KEYS *                         查看KEY支持通配符           %%%     查看所有键-类似于show tables</span><br><span class="line">DEL                                  删除给定的一个或多个key   </span><br><span class="line">EXISTS                         检查是否存在    </span><br><span class="line">RENAME                         变更KEY名 </span><br><span class="line">TYPE                              返回键所存储值的类型        %%%</span><br><span class="line">EXPIRE\ PEXPIRE             以秒\毫秒设定生存时间       %%%</span><br><span class="line">TTL\ PTTL                       以秒\毫秒为单位返回生存时间  %%%</span><br><span class="line">PERSIST                         取消生存实现设置            %%%</span><br><span class="line">     </span><br><span class="line">key:value</span><br><span class="line">key:[filed1:value1,filed2:value2]</span><br><span class="line">key:[value1,value2]</span><br></pre></td></tr></table></figure>

<h4 id="2-6-1-简单操作"><a href="#2-6-1-简单操作" class="headerlink" title="2.6.1 简单操作"></a>2.6.1 简单操作</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; KEYS *</span><br><span class="line">(empty list <span class="keyword">or</span> set)</span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; set foo bar</span><br><span class="line">OK</span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; key *</span><br><span class="line">  </span><br><span class="line">(error) ERR unknown command <span class="string">&#x27;key&#x27;</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; KEYS *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;foo&quot;</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; set foo bar1</span><br><span class="line">OK</span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; KEYS *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;foo&quot;</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; KEYS *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;foo&quot;</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; set foo bar1</span><br><span class="line">OK</span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; KEYS *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;foo&quot;</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; set foo1 bar1</span><br><span class="line">OK</span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; KEYS *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;foo1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;foo&quot;</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; DEL foo</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; KEYS *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;foo1&quot;</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; DEL foo1</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; KEYS *</span><br><span class="line">(empty list <span class="keyword">or</span> set)</span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; set foo bar</span><br><span class="line">OK</span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; KEYS *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;foo&quot;</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; EXISTS foo</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; EXISTS foo1</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; rename foo foo1</span><br><span class="line">OK</span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; EXISTS foo1</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; type foo1</span><br><span class="line">string</span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; HSET stu id <span class="number">1</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; type stu</span><br><span class="line">hash</span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; EXPIRE stu <span class="number">60</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; ttl stu</span><br><span class="line">(integer) <span class="number">58</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; ttl stu</span><br><span class="line">(integer) <span class="number">57</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; ttl stu</span><br><span class="line">(integer) <span class="number">56</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; ttl stu</span><br><span class="line">(integer) <span class="number">46</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; ttl stu</span><br><span class="line">(integer) <span class="number">45</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; ttl stu</span><br><span class="line">(integer) <span class="number">44</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; ttl stu</span><br><span class="line">(integer) <span class="number">43</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; KEYS *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;foo1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;stu&quot;</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; ttl stu</span><br><span class="line">(integer) <span class="number">26</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; ttl stu</span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; KEYS *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;foo1&quot;</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; HSET stu <span class="number">60</span></span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;hset&#x27;</span> command</span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; HSET stu id <span class="number">1</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; EXPIRE stu <span class="number">60</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; ttl stu</span><br><span class="line">(integer) <span class="number">51</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; PERSIST stu</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span>&gt; ttl stu</span><br><span class="line">(integer) <span class="number">-1</span>                                 代表永久存储</span><br></pre></td></tr></table></figure>

<h3 id="2-7-数据类型"><a href="#2-7-数据类型" class="headerlink" title="2.7 数据类型"></a>2.7 数据类型</h3><h4 id="2-7-1-string-字符串"><a href="#2-7-1-string-字符串" class="headerlink" title="2.7.1 string(字符串)"></a>2.7.1 string(字符串)</h4><p>应用场景</p>
<p>常规计数：微博数，粉丝数等。</p>
<p>操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增</span></span><br><span class="line"><span class="built_in">set</span> mykey <span class="string">&quot;test&quot;</span>               为键设置新值，并覆盖原有值</span><br><span class="line">getset mycounter 0               设置值,取值同时进行</span><br><span class="line">setex mykey 10 <span class="string">&quot;hello&quot;</span>          设置指定 Key 的过期时间为10秒,在存活时间可以获取value</span><br><span class="line">setnx mykey <span class="string">&quot;hello&quot;</span>               若该键不存在，则为键设置新值</span><br><span class="line">mset key3  <span class="string">&quot;zyx&quot;</span>  key4 <span class="string">&quot;xyz&quot;</span>      批量设置键</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删</span></span><br><span class="line">del mykey                      删除已有键</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改</span></span><br><span class="line">append mykey <span class="string">&quot;hello&quot;</span>              若该键并不存在,返回当前 Value 的长度</span><br><span class="line">                              该键已经存在，返回追加后 Value的长度</span><br><span class="line">incr mykey                   值增加1,若该key不存在,创建key,初始值设为0,增加后结果为1</span><br><span class="line">decrby  mykey  5               值减少5</span><br><span class="line">setrange mykey 20 dd              把第21和22个字节,替换为dd, 超过value长度,自动补0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查  </span></span><br><span class="line">exists mykey                     判断该键是否存在，存在返回 1，否则返回0</span><br><span class="line">get mykey                    获取Key对应的value</span><br><span class="line">strlen mykey                  获取指定 Key 的字符长度</span><br><span class="line">ttl mykey                     查看一下指定 Key 的剩余存活时间(秒数)</span><br><span class="line">getrange mykey 1 20              获取第2到第20个字节,若20超过value长度,则截取第2个和后面所有的</span><br><span class="line">mget key3 key4                   批量获取键</span><br></pre></td></tr></table></figure>

<h4 id="2-7-2-hash-最接近MySQL表结构的数据类型"><a href="#2-7-2-hash-最接近MySQL表结构的数据类型" class="headerlink" title="2.7.2 hash(最接近MySQL表结构的数据类型)"></a>2.7.2 hash(最接近MySQL表结构的数据类型)</h4><p>应用场景：</p>
<p>存储部分变更的数据，如用户信息等。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">基本上我们用的<span class="built_in">hash</span>类型比较多</span><br><span class="line">用来专门缓存mysql数据库中的一些热点数据的，热点数据都是表数据。当然是开发人员做一些处理之后灌进去</span><br></pre></td></tr></table></figure>

<p>操作:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增</span></span><br><span class="line">hset myhash field1 <span class="string">&quot;s&quot;</span>    </span><br><span class="line">若字段field1不存在,创建该键及与其关联的Hashes, Hashes中,key为field1 ,并设value为s ，若存在会覆盖原value</span><br><span class="line">hsetnx myhash field1 s    </span><br><span class="line">若字段field1不存在,创建该键及与其关联的Hashes, Hashes中,key为field1 ,并设value为s， 若字段field1存在,则无效</span><br><span class="line">hmset myhash field1 <span class="string">&quot;hello&quot;</span> field2 <span class="string">&quot;world       一次性设置多个字段</span></span><br><span class="line"><span class="string"># 删</span></span><br><span class="line"><span class="string">hdel myhash field1                       删除 myhash 键中字段名为 field1 的字段</span></span><br><span class="line"><span class="string">del myhash                              删除键</span></span><br><span class="line"><span class="string"># 改  </span></span><br><span class="line"><span class="string">hincrby myhash field 1                  给field的值加1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 查</span></span><br><span class="line"><span class="string">hget myhash field1                       获取键值为 myhash,字段为 field1 的值</span></span><br><span class="line"><span class="string">hlen myhash                               获取myhash键的字段数量</span></span><br><span class="line"><span class="string">hexists myhash field1                     判断 myhash 键中是否存在字段名为 field1 的字段</span></span><br><span class="line"><span class="string">hmget myhash field1 field2 field3          一次性获取多个字段</span></span><br><span class="line"><span class="string">hgetall myhash                           返回 myhash 键的所有字段及其值</span></span><br><span class="line"><span class="string">hkeys myhash                              获取myhash 键中所有字段的名字</span></span><br><span class="line"><span class="string">hvals myhash                               获取 myhash 键中所有字段的值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">10.0.0.51:6379&gt; HMSET zhangsan id 1001 age 20 gender man</span></span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="string">10.0.0.51:6379&gt; GET zhangsan</span></span><br><span class="line"><span class="string">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span></span><br><span class="line"><span class="string">10.0.0.51:6379&gt; HGETALL zhangsan</span></span><br><span class="line"><span class="string">1) &quot;</span>id<span class="string">&quot;</span></span><br><span class="line"><span class="string">2) &quot;</span>1001<span class="string">&quot;</span></span><br><span class="line"><span class="string">3) &quot;</span>age<span class="string">&quot;</span></span><br><span class="line"><span class="string">4) &quot;</span>20<span class="string">&quot;</span></span><br><span class="line"><span class="string">5) &quot;</span>gender<span class="string">&quot;</span></span><br><span class="line"><span class="string">6) &quot;</span>man<span class="string">&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-7-3-LIST-列表"><a href="#2-7-3-LIST-列表" class="headerlink" title="2.7.3 LIST(列表)"></a>2.7.3 LIST(列表)</h4><p>应用场景: </p>
<p><strong>消息队列系统</strong></p>
<ol>
<li><p>比如sina微博:?在Redis中我们的最新微博ID使用了常驻缓存，这是一直更新的。</p>
<p>但是做了限制不能超过5000个ID，因此获取ID的函数会一直询问Redis。</p>
<p>只有在start/count参数超出了这个范围的时候，才需要去访问数据库。?</p>
<p>系统不会像传统方式那样“刷新”缓存，Redis实例中的信息永远是一致的。</p>
<p>SQL数据库（或是硬盘上的其他类型数据库）只是在用户需要获取“很远”的数据时才会被触发，</p>
<p>而主页或第一个评论页是不会麻烦到硬盘上的数据库了。</p>
</li>
<li><p>微信朋友圈</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[e,d,c,b,a]</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> ;      下表索引</span><br></pre></td></tr></table></figure>

<p>基本操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增 </span></span><br><span class="line">lpush mykey a b              若key不存在,创建该键及与其关联的List,依次插入a ,b， 若List类型的key存在,则插入value中</span><br><span class="line">lpushx mykey2 e              若key不存在,此命令无效， 若key存在,则插入value中</span><br><span class="line">linsert mykey before a a1      在 a 的前面插入新元素 a1</span><br><span class="line">linsert mykey after e e2       在e 的后面插入新元素 e2</span><br><span class="line">rpush mykey a b             在链表尾部先插入b,在插入a</span><br><span class="line">rpushx mykey e              若key存在,在尾部插入e, 若key不存在,则无效</span><br><span class="line">rpoplpush mykey mykey2       将mykey的尾部元素弹出,再插入到mykey2 的头部(原子性的操作)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删</span></span><br><span class="line">del mykey                      删除已有键 </span><br><span class="line">lrem mykey 2 a               从头部开始找,按先后顺序,值为a的元素,删除数量为2个,若存在第3个,则不删除</span><br><span class="line">ltrim mykey 0 2              从头开始,索引为0,1,2的3个元素,其余全部删除</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改</span></span><br><span class="line">lset mykey 1 e               从头开始, 将索引为1的元素值,设置为新值 e,若索引越界,则返回错误信息</span><br><span class="line">rpoplpush mykey mykey          将 mykey 中的尾部元素移到其头部</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查</span></span><br><span class="line">lrange mykey 0 -1              取链表中的全部元素，其中0表示第一个元素,-1表示最后一个元素。</span><br><span class="line">lrange mykey 0 2            从头开始,取索引为0,1,2的元素</span><br><span class="line">lrange mykey 0 0            从头开始,取第一个元素,从第0个开始,到第0个结束</span><br><span class="line">lpop mykey                  获取头部元素,并且弹出头部元素,出栈</span><br><span class="line">lindex mykey 6              从头开始,获取索引为6的元素 若下标越界,则返回nil</span><br></pre></td></tr></table></figure>

<p>示例操作:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">10.0.0.51:6379&gt; LPUSH wechat <span class="string">&quot;today is bad day!&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">10.0.0.51:6379&gt; LPUSH wechat <span class="string">&quot;today is nice day!&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">10.0.0.51:6379&gt; LPUSH wechat <span class="string">&quot;today is good day!&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">10.0.0.51:6379&gt; LRANGE wechat 0 -1</span><br><span class="line">1) <span class="string">&quot;today is good day!&quot;</span></span><br><span class="line">2) <span class="string">&quot;today is nice day!&quot;</span></span><br><span class="line">3) <span class="string">&quot;today is bad day!&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-7-4-SET-集合类型（join-union）"><a href="#2-7-4-SET-集合类型（join-union）" class="headerlink" title="2.7.4 SET 集合类型（join union）"></a>2.7.4 SET 集合类型（join union）</h4><p>应用场景：</p>
<p>案例：?在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。</p>
<p>Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，</p>
<p>对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。</p>
<p>基本操作:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增</span></span><br><span class="line">sadd myset a b c  </span><br><span class="line">若key不存在,创建该键及与其关联的<span class="built_in">set</span>,依次插入a ,b,若key存在,则插入value中,若a 在myset中已经存在,则插入了 d 和 e 两个新成员。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删</span></span><br><span class="line">spop myset              尾部的b被移出,事实上b并不是之前插入的第一个或最后一个成员</span><br><span class="line">srem myset a d f          若f不存在, 移出 a、d ,并返回2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改</span></span><br><span class="line">smove myset myset2 a        将a从 myset 移到 myset2，</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查</span></span><br><span class="line">sismember myset a            判断 a 是否已经存在，返回值为 1 表示存在。</span><br><span class="line">smembers myset            查看<span class="built_in">set</span>中的内容</span><br><span class="line">scard myset                获取Set 集合中元素的数量</span><br><span class="line">srandmember myset          随机的返回某一成员</span><br><span class="line">sdiff myset1 myset2 myset3      1和2得到一个结果,拿这个集合和3比较,获得每个独有的值</span><br><span class="line">sdiffstore diffkey myset myset2 myset3      3个集和比较,获取独有的元素,并存入diffkey 关联的Set中</span><br><span class="line">sinter myset myset2 myset3               获得3个集合中都有的元素</span><br><span class="line">sinterstore interkey myset myset2 myset3  把交集存入interkey 关联的Set中</span><br><span class="line">sunion myset myset2 myset3               获取3个集合中的成员的并集</span><br><span class="line">sunionstore unionkey myset myset2 myset3  把并集存入unionkey 关联的Set中</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">10.0.0.51:6379&gt; sadd lxl jnl pgone baoqiang xyz mr</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">10.0.0.51:6379&gt; sadd jnl baoqiang syw oldboy zzy </span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">10.0.0.51:6379&gt; SUNION jnl lxl</span><br><span class="line">1) <span class="string">&quot;mr&quot;</span></span><br><span class="line">2) <span class="string">&quot;oldboy&quot;</span></span><br><span class="line">3) <span class="string">&quot;baoqiang&quot;</span></span><br><span class="line">4) <span class="string">&quot;jnl&quot;</span></span><br><span class="line">5) <span class="string">&quot;pgone&quot;</span></span><br><span class="line">6) <span class="string">&quot;zzy&quot;</span></span><br><span class="line">7) <span class="string">&quot;xyz&quot;</span></span><br><span class="line">8) <span class="string">&quot;syw&quot;</span></span><br><span class="line">10.0.0.51:6379&gt; SDIFF jnl lxl</span><br><span class="line">1) <span class="string">&quot;syw&quot;</span></span><br><span class="line">2) <span class="string">&quot;oldboy&quot;</span></span><br><span class="line">3) <span class="string">&quot;zzy&quot;</span></span><br><span class="line">10.0.0.51:6379&gt; SDIFF lxl jnl</span><br><span class="line">1) <span class="string">&quot;mr&quot;</span></span><br><span class="line">2) <span class="string">&quot;jnl&quot;</span></span><br><span class="line">3) <span class="string">&quot;pgone&quot;</span></span><br><span class="line">4) <span class="string">&quot;xyz&quot;</span></span><br><span class="line">10.0.0.51:6379&gt; Sinter lxl jnl</span><br><span class="line">1) <span class="string">&quot;baoqiang&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">10.0.0.51:6379&gt; SUNIONSTORE huntie lxl jnl</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line">10.0.0.51:6379&gt; SMEMBERS huntie</span><br><span class="line">1) <span class="string">&quot;oldboy&quot;</span></span><br><span class="line">2) <span class="string">&quot;jnl&quot;</span></span><br><span class="line">3) <span class="string">&quot;pgone&quot;</span></span><br><span class="line">4) <span class="string">&quot;syw&quot;</span></span><br><span class="line">5) <span class="string">&quot;zzy&quot;</span></span><br><span class="line">6) <span class="string">&quot;mr&quot;</span></span><br><span class="line">7) <span class="string">&quot;baoqiang&quot;</span></span><br><span class="line">8) <span class="string">&quot;xyz&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-7-5-SortedSet（有序集合）"><a href="#2-7-5-SortedSet（有序集合）" class="headerlink" title="2.7.5 SortedSet（有序集合）"></a>2.7.5 SortedSet（有序集合）</h4><p>应用场景：</p>
<p>排行榜应用，取TOP N操作?</p>
<p>这个需求与上面需求的不同之处在于，前面操作以时间为权重，这个是以某个条件为权重，比如按顶的次数排序，</p>
<p>这时候就需要我们的sorted set出马了，将你要排序的值设置成sorted set的score，将具体的数据设置成相应的value，</p>
<p>每次只需要执行一条ZADD命令即可。</p>
<p>基本操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增</span></span><br><span class="line">zadd myzset 2 <span class="string">&quot;two&quot;</span> 3 <span class="string">&quot;three&quot;</span>       添加两个分数分别是 2 和 3 的两个成员</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删</span></span><br><span class="line">zrem myzset one two                  删除多个成员变量,返回删除的数量</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改</span></span><br><span class="line">zincrby myzset 2 one                  将成员 one 的分数增加 2，并返回该成员更新后的分数</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查 </span></span><br><span class="line">zrange myzset 0 -1 WITHSCORES          返回所有成员和分数,不加WITHSCORES,只返回成员</span><br><span class="line">zrank myzset one                       获取成员one在Sorted-Set中的位置索引值。0表示第一个位置</span><br><span class="line">zcard myzset                        获取 myzset 键中成员的数量</span><br><span class="line">zcount myzset 1 2                   获取分数满足表达式 1 &lt;= score &lt;= 2 的成员的数量</span><br><span class="line">zscore myzset three                  获取成员 three 的分数</span><br><span class="line">zrangebyscore myzset  1 2               获取分数满足表达式 1 &lt; score &lt;= 2 的成员</span><br><span class="line"></span><br><span class="line"><span class="comment">#-inf 表示第一个成员，+inf最后一个成员</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#limit限制关键字</span></span><br><span class="line"><span class="comment">#2  3  是索引号</span></span><br><span class="line">zrangebyscore myzset -inf +inf <span class="built_in">limit</span> 2 3  返回索引是2和3的成员</span><br><span class="line">zremrangebyscore myzset 1 2           删除分数 1&lt;= score &lt;= 2 的成员，并返回实际删除的数量</span><br><span class="line">zremrangebyrank myzset 0 1              删除位置索引满足表达式 0 &lt;= rank &lt;= 1 的成员</span><br><span class="line">zrevrange myzset 0 -1 WITHSCORES           按位置索引从高到低,获取所有成员和分数</span><br><span class="line"><span class="comment">#原始成员:位置索引从小到大</span></span><br><span class="line">      one  0  </span><br><span class="line">      two  1</span><br><span class="line"><span class="comment">#执行顺序:把索引反转</span></span><br><span class="line">      位置索引:从大到小</span><br><span class="line">      one 1</span><br><span class="line">      two 0</span><br><span class="line"><span class="comment">#输出结果: two  </span></span><br><span class="line">       one</span><br><span class="line">zrevrange myzset 1 3                  获取位置索引,为1,2,3的成员</span><br><span class="line"><span class="comment">#相反的顺序:从高到低的顺序</span></span><br><span class="line">zrevrangebyscore myzset 3 0              获取分数 3&gt;=score&gt;=0的成员并以相反的顺序输出</span><br><span class="line">zrevrangebyscore myzset 4 0 <span class="built_in">limit</span> 1 2      获取索引是1和2的成员,并反转位置索引</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">10.0.0.51:6379&gt; ZADD pnb 0 abc 0 sh 0 xyz</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">10.0.0.51:6379&gt; ZINCRBY phb 100 bac</span><br><span class="line"><span class="string">&quot;100&quot;</span></span><br><span class="line">10.0.0.51:6379&gt; ZINCRBY phb 100 abc</span><br><span class="line"><span class="string">&quot;100&quot;</span></span><br><span class="line">10.0.0.51:6379&gt; ZINCRBY phb 1000 sh</span><br><span class="line"><span class="string">&quot;1000&quot;</span></span><br><span class="line">10.0.0.51:6379&gt; ZINCRBY phb 10000 xyz</span><br><span class="line"><span class="string">&quot;10000&quot;</span></span><br><span class="line">10.0.0.51:6379&gt; ZREVRANGE phb 0 -1 withscores</span><br><span class="line">1) <span class="string">&quot;xyz&quot;</span></span><br><span class="line">2) <span class="string">&quot;10000&quot;</span></span><br><span class="line">3) <span class="string">&quot;sh&quot;</span></span><br><span class="line">4) <span class="string">&quot;1000&quot;</span></span><br><span class="line">5) <span class="string">&quot;bac&quot;</span></span><br><span class="line">6) <span class="string">&quot;100&quot;</span></span><br><span class="line">7) <span class="string">&quot;abc&quot;</span></span><br><span class="line">8) <span class="string">&quot;100&quot;</span></span><br><span class="line">10.0.0.51:6379&gt; ZREVRANGE phb 0 -1 </span><br><span class="line">1) <span class="string">&quot;xyz&quot;</span></span><br><span class="line">2) <span class="string">&quot;sh&quot;</span></span><br><span class="line">3) <span class="string">&quot;bac&quot;</span></span><br><span class="line">4) <span class="string">&quot;abc&quot;</span></span><br><span class="line">10.0.0.51:6</span><br></pre></td></tr></table></figure>

<h3 id="2-8-消息队列"><a href="#2-8-消息队列" class="headerlink" title="2.8 消息队列"></a>2.8 消息队列</h3><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20210722233641312.png" alt="image-20210722233641312" style="zoom: 50%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySQL就比较需要消息队列这种模式</span><br><span class="line">12306 通过消息队列模式   排队等待处理，有效的解耦</span><br><span class="line">      验证码的方式    抵消等待时间的不满意</span><br><span class="line">每一个操作一 一 扔到后端去处理</span><br><span class="line">消息队列很少用redis去做</span><br><span class="line">kafka  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>和其他队列系统对比(kafka, rabbitmq)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 客户端再执行订阅命令之后进入了订阅状态, 只能接收 SUBSCRIBE PSUBSCRIBE UNSUBSCRIBE PUNSUBSCRIBE 四个命令</span><br><span class="line">% <span class="comment"># 2. 开启的订阅客户端, 无法接收到该频道之前的消息, 因为Redis不会对发布的消息进行持久化。</span></span><br><span class="line">3. 和专业的消息队列系统相比,Redis的发布订阅略显粗糙, 例如无法实现消息堆积和回溯。但是胜在足够简单。</span><br></pre></td></tr></table></figure>



<h3 id="2-9-发布订阅"><a href="#2-9-发布订阅" class="headerlink" title="2.9 发布订阅"></a>2.9 发布订阅</h3><p>一个发布者多个订阅者的模式</p>
<p>先订阅  后发布</p>
<img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20210722233720613.png" alt="image-20210722233720613" style="zoom: 33%;" />

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUBLISH channel msg</span><br><span class="line">    将信息 message 发送到指定的频道 channel?</span><br><span class="line">SUBSCRIBE channel [channel ...]</span><br><span class="line">    订阅频道，可以同时订阅多个频道</span><br><span class="line">UNSUBSCRIBE [channel ...]</span><br><span class="line">    取消订阅指定的频道, 如果不指定频道，则会取消订阅所有频道</span><br><span class="line">PSUBSCRIBE pattern [pattern ...]</span><br><span class="line">    订阅一个或多个符合给定模式的频道，每个模式以 * 作为匹配符，比如 it* 匹配所    有以 it 开头的频道( it.news 、 it.blog 、 it.tweets 等等)， news.* 匹配所有    以 news. 开头的频道( news.it 、 news.global.today 等等)，诸如此类</span><br><span class="line">PUNSUBSCRIBE [pattern [pattern ...]]</span><br><span class="line">    退订指定的规则, 如果没有参数则会退订所有规则</span><br><span class="line">PUBSUB subcommand [argument [argument ...]]</span><br><span class="line">    查看订阅与发布系统状态</span><br><span class="line">注意：使用发布订阅模式实现的消息队列，当有客户端订阅channel后只能收到后续发布到该频道的消息，之前发送的不会缓存，必须Provider和Consumer同时在线。 </span><br></pre></td></tr></table></figure>

<h3 id="2-10-事务"><a href="#2-10-事务" class="headerlink" title="2.10 事务"></a>2.10 事务</h3><ul>
<li><p>DISCARD</p>
<p>取消事务, 放弃执行事务块内的所有命令</p>
</li>
<li><p>EXEC</p>
<p>执行所有事务内的命令</p>
</li>
<li><p>MULTI</p>
<p>标记一个事务块 的开始</p>
</li>
<li><p>UNWATCH</p>
<p>取消watch命令对所有key 的监视</p>
</li>
<li><p>WATCH key [key …]</p>
<p>监视一个(或多个)key, 如果在事务执行之前这个(这些)key被其他命令改动, 那么事务将被打断。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20210722234655184.png" alt="image-20210722234655184"></p>
<p>基本操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">开启事务功能时（multi）</span><br><span class="line">multi </span><br><span class="line">command1      </span><br><span class="line">command2</span><br><span class="line">command3</span><br><span class="line">command4</span><br><span class="line"></span><br><span class="line">4条语句作为一个组，并没有真正执行，而是被放入同一队列中。</span><br><span class="line">如果，这是执行discard，会直接丢弃队列中所有的命令，而不是做回滚。</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span></span><br><span class="line">当执行<span class="built_in">exec</span>时，对列中所有操作，要么全成功要么全失败</span><br><span class="line"></span><br><span class="line"><span class="comment">##############################</span></span><br><span class="line">10.0.0.51:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">10.0.0.51:6379&gt; <span class="built_in">set</span> foo bar</span><br><span class="line">QUEUED</span><br><span class="line">10.0.0.51:6379&gt; <span class="built_in">set</span> foo1 bar1 </span><br><span class="line">QUEUED</span><br><span class="line">10.0.0.51:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">10.0.0.51:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">10.0.0.51:6379&gt; <span class="built_in">set</span> key v</span><br><span class="line">QUEUED</span><br><span class="line">10.0.0.51:6379&gt; <span class="built_in">set</span> key x</span><br><span class="line">QUEUED</span><br><span class="line">10.0.0.51:6379&gt; DISCARD</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h3 id="2-11-Redis事务中的锁机制-启用的是乐观锁"><a href="#2-11-Redis事务中的锁机制-启用的是乐观锁" class="headerlink" title="2.11 Redis事务中的锁机制(启用的是乐观锁)"></a>2.11 Redis事务中的锁机制(启用的是乐观锁)</h3><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20210722234824947.png" alt="image-20210722234824947" style="zoom:50%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">模拟：</span><br><span class="line">redis乐观锁实现（模拟买票）</span><br><span class="line">发布一张票</span><br><span class="line">set ticket 1</span><br><span class="line"></span><br><span class="line">窗口1：</span><br><span class="line">watch ticket</span><br><span class="line">multi</span><br><span class="line">set ticket 0       1----&gt;0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">窗口2：</span><br><span class="line">multi </span><br><span class="line">set ticket 0 </span><br><span class="line">exec </span><br><span class="line"></span><br><span class="line">窗口1：</span><br><span class="line">exec</span><br><span class="line">12306可能是乐观锁的模式</span><br></pre></td></tr></table></figure>

<h3 id="2-12-服务器管理命令"><a href="#2-12-服务器管理命令" class="headerlink" title="2.12 服务器管理命令"></a>2.12 服务器管理命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Info</span><br><span class="line">Clinet list</span><br><span class="line">Client <span class="built_in">kill</span> ip:port</span><br><span class="line">config get *</span><br><span class="line">CONFIG RESETSTAT 重置统计</span><br><span class="line">CONFIG GET/SET 动态修改</span><br><span class="line">Dbsize</span><br><span class="line">FLUSHALL 清空所有数据 </span><br><span class="line">select 1</span><br><span class="line">FLUSHDB 清空当前库</span><br><span class="line"></span><br><span class="line">MONITOR 监控实时指令</span><br><span class="line">SHUTDOWN 关闭服务器</span><br><span class="line"></span><br><span class="line">关闭数据库：</span><br><span class="line">redis-cli -a root shutdown </span><br></pre></td></tr></table></figure>

<h2 id="三-Python-连接redis"><a href="#三-Python-连接redis" class="headerlink" title="三. Python 连接redis"></a>三. Python 连接redis</h2><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install redis</span><br></pre></td></tr></table></figure>

<h5 id="直接使用"><a href="#直接使用" class="headerlink" title="直接使用"></a>直接使用</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="comment"># decode_responses=True得到的结果会自动解码（不是二进制数据）</span></span><br><span class="line">r = redis.Redis(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">6379</span>, db=<span class="number">1</span>, password=<span class="literal">None</span>, decode_responses=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h5 id="连接池使用"><a href="#连接池使用" class="headerlink" title="连接池使用"></a>连接池使用</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">6379</span>, db=<span class="number">1</span>, max_connections=<span class="number">100</span>, password=<span class="literal">None</span>, decode_responses=<span class="literal">True</span>)</span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br></pre></td></tr></table></figure>

<h5 id="缓存使用：要额外安装-django-redis"><a href="#缓存使用：要额外安装-django-redis" class="headerlink" title="缓存使用：要额外安装 django-redis"></a>缓存使用：要额外安装 django-redis</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.将缓存存储位置配置到redis中：settings.py</span></span><br><span class="line">CACHES = &#123;</span><br><span class="line">    <span class="string">&quot;default&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;BACKEND&quot;</span>: <span class="string">&quot;django_redis.cache.RedisCache&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LOCATION&quot;</span>: <span class="string">&quot;redis://127.0.0.1:6379/0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;OPTIONS&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;CLIENT_CLASS&quot;</span>: <span class="string">&quot;django_redis.client.DefaultClient&quot;</span>,</span><br><span class="line">            <span class="string">&quot;CONNECTION_POOL_KWARGS&quot;</span>: &#123;<span class="string">&quot;max_connections&quot;</span>: <span class="number">100</span>&#125;,</span><br><span class="line">            <span class="string">&quot;DECODE_RESPONSES&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">&quot;PASSWORD&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.操作cache模块直接操作缓存：views.py</span></span><br><span class="line"><span class="keyword">from</span> django.core.cache <span class="keyword">import</span> cache  <span class="comment"># 结合配置文件实现插拔式</span></span><br><span class="line"><span class="comment"># 存放token，可以直接设置过期时间</span></span><br><span class="line">cache.set(<span class="string">&#x27;token&#x27;</span>, <span class="string">&#x27;header.payload.signature&#x27;</span>, <span class="number">300</span>)</span><br><span class="line"><span class="comment"># 取出token</span></span><br><span class="line">token = cache.get(<span class="string">&#x27;token&#x27;</span>)</span><br></pre></td></tr></table></figure>





<h2 id="3-普通链接和连接池"><a href="#3-普通链接和连接池" class="headerlink" title="3 普通链接和连接池"></a>3 普通链接和连接池</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 使用python连接redis</span><br><span class="line"><span class="number">2</span> pip3 install redis</span><br><span class="line"><span class="number">3</span> 使用python代码连接redis服务端，python代码就是客户端，跟使用图形化界面是一样的</span><br><span class="line">    GUI---》可以开发出图形化界面的redis客户端</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="3-1-代码-单例模式"><a href="#3-1-代码-单例模式" class="headerlink" title="3.1 代码(单例模式)"></a>3.1 代码(单例模式)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 普通连接</span></span><br><span class="line"><span class="comment"># from redis import Redis</span></span><br><span class="line"><span class="comment"># # 拿到一个redis连接</span></span><br><span class="line"><span class="comment"># # conn=Redis()</span></span><br><span class="line"><span class="comment"># conn=Redis(host=&#x27;127.0.0.1&#x27;, port=6379)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># # 使用连接操作</span></span><br><span class="line"><span class="comment"># conn.set(&#x27;age&#x27;,&#x27;18&#x27;)</span></span><br><span class="line"><span class="comment"># conn.close()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 连接池</span></span><br><span class="line"><span class="comment"># import redis</span></span><br><span class="line"><span class="comment"># # 创建出一个连接池</span></span><br><span class="line"><span class="comment"># pool = redis.ConnectionPool(host=&#x27;127.0.0.1&#x27;, port=6379,max_connections=100)</span></span><br><span class="line"><span class="comment"># # 从连接池中拿一个连接</span></span><br><span class="line"><span class="comment"># conn = redis.Redis(connection_pool=pool)</span></span><br><span class="line"><span class="comment"># conn.set(&#x27;foo&#x27;, &#x27;Bar&#x27;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># conn.close()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际应用</span></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">from</span> redis_pool <span class="keyword">import</span> POOL  <span class="comment"># Pool是单例，</span></span><br><span class="line">conn=redis.Redis(connection_pool=POOL)</span><br><span class="line">conn.set(<span class="string">&#x27;age&#x27;</span>,<span class="number">18</span>)</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<h3 id="3-2-redis-pool-py"><a href="#3-2-redis-pool-py" class="headerlink" title="3.2 redis_pool.py"></a>3.2 redis_pool.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">POOL=redis.ConnectionPool(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">6379</span>,max_connections=<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h2 id="4-redis之string操作"><a href="#4-redis之string操作" class="headerlink" title="4 redis之string操作"></a>4 redis之string操作</h2><p>参数(nx实现分布式锁的时候会用到)</p>
<p>mset mget等批量操作(好处是减少网络IO)</p>
<p>getset 一次网络io，完成了取值和设置</p>
<p>getbit 位操作, 用途: 统计日活</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串，列表，字典</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">conn=redis.Redis()</span><br><span class="line"><span class="comment">###  1 set 的使用</span></span><br><span class="line"><span class="comment"># name:key值</span></span><br><span class="line"><span class="comment"># value：value值</span></span><br><span class="line"><span class="comment"># ex:过期时间，按秒记</span></span><br><span class="line"><span class="comment"># px：过期时间（毫秒）</span></span><br><span class="line"><span class="comment"># nx：如果设置为True，则只有name不存在时，当前set操作才执行,值存在，就修改不了，执行没效果</span></span><br><span class="line"><span class="comment"># xx：如果设置为True，则只有name存在时，当前set操作才执行，值存在才能修改，值不存在，不会设置新值</span></span><br><span class="line">conn.set(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;egon&#x27;</span>)</span><br><span class="line">conn.set(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;lqz&#x27;</span>,nx=<span class="literal">True</span>)</span><br><span class="line">conn.set(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;lqz&#x27;</span>,xx=<span class="literal">True</span>)</span><br><span class="line">conn.set(<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;18&#x27;</span>,xx=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 2 get</span></span><br><span class="line">res=conn.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">print(res)  <span class="comment"># 返回的数据是byte格式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##3 setnx(name, value)</span></span><br><span class="line"><span class="comment"># 设置值，只有name不存在时，执行设置操作（添加）,如果存在，不会修改</span></span><br><span class="line">conn.setnx(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;egon&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##4 setex(name, time,value, )</span></span><br><span class="line">conn.setex(<span class="string">&#x27;name&#x27;</span>,<span class="number">3</span>,<span class="string">&#x27;egon&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 5 mset</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># conn.mset(&#123;&#x27;name&#x27;:&#x27;lqz&#x27;,&#x27;age&#x27;:19,&#x27;sex&#x27;:&#x27;男&#x27;&#125;)</span></span><br><span class="line"><span class="comment">## 6 mget</span></span><br><span class="line"></span><br><span class="line">res=conn.mget(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">res=conn.mget([<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 7 getset(name, value)</span></span><br><span class="line"><span class="comment"># 一次网络io，完成了取值和设置</span></span><br><span class="line">res=conn.getset(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;egon&#x27;</span>)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 8 getrange(key, start, end)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前闭后闭区间</span></span><br><span class="line">res=conn.getrange(<span class="string">&#x27;name&#x27;</span>,<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 最终效果跟上面一样(但是压力在服务器上, 不在redis上; 网络io，回来的数据多少性能高低)</span></span><br><span class="line">res=conn.get(<span class="string">&#x27;name&#x27;</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">print(res[<span class="number">0</span>:<span class="number">5</span>])</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setrange(name, offset, value)</span><br><span class="line">conn.setrange(<span class="string">&#x27;name&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;tt&#x27;</span>)</span><br><span class="line">conn.setrange(<span class="string">&#x27;name&#x27;</span>,<span class="number">5</span>,<span class="string">&#x27;tt&#x27;</span>)</span><br><span class="line">conn.setrange(<span class="string">&#x27;name&#x27;</span>,<span class="number">7</span>,<span class="string">&#x27;ttttttttttttttttttttttttt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setbit(name, offset, value)</span><br><span class="line">conn.set(<span class="string">&#x27;n1&#x27;</span>,<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">#那么字符串foo的二进制表示为：01100110 01101111 01101111</span></span><br><span class="line">conn.setbit(<span class="string">&#x27;n1&#x27;</span>,<span class="number">7</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># #那么字符串foo的二进制表示为：01100111 01101111 01101111</span></span><br><span class="line">res=conn.get(<span class="string">&#x27;n1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">getbit(name, offset)</span><br><span class="line"><span class="comment"># 获取bit位的第几个位置，看是1还是0</span></span><br><span class="line">res=conn.getbit(<span class="string">&#x27;n1&#x27;</span>,<span class="number">7</span>)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment">############做独立用户统计: 统计多少个1就有多少日活</span></span><br><span class="line">数字<span class="number">1</span> 至少 <span class="number">8</span>bit, <span class="number">10000</span>占用更多。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bitcount(key, start=<span class="literal">None</span>, end=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># end:指的是bytes，前闭后闭区间 0到1 两个bytes</span></span><br><span class="line">res=conn.bitcount(<span class="string">&#x27;n1&#x27;</span>,<span class="number">0</span>,<span class="number">1</span>) </span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### incr 重点</span></span><br><span class="line"><span class="comment"># 每次自增1</span></span><br><span class="line"><span class="comment"># 统计网页访问量，文章阅读量，粉丝数量，计数相关（不会存在并发安全的问题）</span></span><br><span class="line">conn.incr(<span class="string">&#x27;age&#x27;</span>,<span class="number">-2</span>)</span><br><span class="line">res=conn.get(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.decr(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">res=conn.get(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">append</span><br><span class="line">conn.append(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;lqz&#x27;</span>)</span><br><span class="line"></span><br><span class="line">res=conn.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 总结</span></span><br><span class="line"><span class="comment"># set:超时时间，nx，xx</span></span><br><span class="line"><span class="comment"># get</span></span><br><span class="line"><span class="comment"># mset</span></span><br><span class="line"><span class="comment"># mget</span></span><br><span class="line"><span class="comment"># incr</span></span><br><span class="line"><span class="comment"># decr</span></span><br><span class="line"><span class="comment"># getrange</span></span><br><span class="line"><span class="comment"># setrange</span></span><br><span class="line"><span class="comment"># append</span></span><br></pre></td></tr></table></figure>



<h2 id="5-redis之hash操作"><a href="#5-redis之hash操作" class="headerlink" title="5 redis之hash操作"></a>5 redis之hash操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 字典（字典，在内存中如何存储的），hash类型</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">conn=redis.Redis()</span><br><span class="line"></span><br><span class="line"><span class="comment"># hset</span></span><br><span class="line"><span class="comment"># conn.hset(&#x27;userinfo&#x27;,&#x27;name&#x27;,&#x27;lqz&#x27;)</span></span><br><span class="line"><span class="comment"># conn.hset(&#x27;userinfo&#x27;,&#x27;age&#x27;,&#x27;18&#x27;)</span></span><br><span class="line"><span class="comment"># conn.hset(&#x27;userinfo&#x27;,&#x27;sex&#x27;,&#x27;男&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hmset</span></span><br><span class="line"><span class="comment"># conn.hmset(&#x27;userinfo_2&#x27;,&#123;&#x27;name&#x27;:&#x27;egon&#x27;,&#x27;age&#x27;:18,&#x27;sex&#x27;:&#x27;男&#x27;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#hget</span></span><br><span class="line"><span class="comment"># res=conn.hget(&#x27;userinfo&#x27;,&#x27;name&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hmget</span></span><br><span class="line"><span class="comment"># res=conn.hmget(&#x27;userinfo&#x27;,&#x27;age&#x27;,&#x27;name&#x27;)</span></span><br><span class="line"><span class="comment"># res=conn.hmget(&#x27;userinfo&#x27;,[&#x27;age&#x27;,&#x27;name&#x27;])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hgetall</span></span><br><span class="line"><span class="comment"># res=conn.hgetall(&#x27;userinfo&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># hlen(name)</span></span><br><span class="line"><span class="comment"># res=conn.hlen(&#x27;userinfo&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hkeys(name)</span></span><br><span class="line"><span class="comment"># res=conn.hkeys(&#x27;userinfo&#x27;)</span></span><br><span class="line"><span class="comment"># hvals(name)</span></span><br><span class="line"><span class="comment"># res=conn.hvals(&#x27;userinfo&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># hexists(name, key)</span></span><br><span class="line"><span class="comment"># res=conn.hexists(&#x27;userinfo&#x27;,&#x27;hobby&#x27;)</span></span><br><span class="line"><span class="comment"># res=conn.hexists(&#x27;userinfo&#x27;,&#x27;name&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#hdel</span></span><br><span class="line"><span class="comment"># res=conn.hdel(&#x27;userinfo&#x27;,&#x27;name&#x27;,&#x27;age&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#hincrby</span></span><br><span class="line"><span class="comment"># res=conn.hset(&#x27;userinfo&#x27;,&#x27;age&#x27;,19)</span></span><br><span class="line"><span class="comment"># conn.hincrby(&#x27;userinfo&#x27;,&#x27;age&#x27;)</span></span><br><span class="line"><span class="comment"># res=conn.hget(&#x27;userinfo&#x27;,&#x27;age&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># hscan</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for i in range(1000):</span></span><br><span class="line"><span class="comment">#     conn.hset(&#x27;test&#x27;,&#x27;test_&#x27;+str(i),str(i))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不建议使用</span></span><br><span class="line"><span class="comment"># res=conn.hgetall(&#x27;test&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不怎么用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># name，redis的name</span></span><br><span class="line"><span class="comment"># cursor，游标（基于游标分批取获取数据）</span></span><br><span class="line"><span class="comment"># match，匹配指定key，默认None 表示所有的key</span></span><br><span class="line"><span class="comment"># count，每次分片最少获取个数，默认None表示采用Redis的默认分片个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res=conn.hscan(<span class="string">&#x27;test&#x27;</span>,cursor=<span class="number">478</span>,count=<span class="number">500</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># print(len(res[1]))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hscan_iter</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># res=conn.hscan_iter(&#x27;test&#x27;,count=10)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以后要使用hgetall的时候，要使用如下方式</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> conn.hscan_iter(<span class="string">&#x27;test&#x27;</span>,count=<span class="number">10</span>):</span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(res)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 总结</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">hset</span></span><br><span class="line"><span class="string">hget</span></span><br><span class="line"><span class="string">hmset</span></span><br><span class="line"><span class="string">hmget</span></span><br><span class="line"><span class="string">hincrby</span></span><br><span class="line"><span class="string">hdel</span></span><br><span class="line"><span class="string">hexists</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">hscan_iter/hgetall 区分</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>##6 redis之list列表操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># class MyRedis():</span></span><br><span class="line"><span class="comment">#     def __enter__(self):</span></span><br><span class="line"><span class="comment">#         self.conn = redis.Redis()</span></span><br><span class="line"><span class="comment">#         return self.conn</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     def __exit__(self, exc_type, exc_val, exc_tb):</span></span><br><span class="line"><span class="comment">#         self.conn.close()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># with MyRedis() as conn:</span></span><br><span class="line"><span class="comment"># 列表操作</span></span><br><span class="line"><span class="comment"># 1 lpush(name,values)</span></span><br><span class="line"><span class="comment"># conn.lpush(&#x27;l1&#x27;,1,2,3,4,5,&#x27;lqz&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 rpush</span></span><br><span class="line"><span class="comment"># conn.rpush(&#x27;l1&#x27;,&#x27;egon&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 lpushx(name,value)</span></span><br><span class="line"><span class="comment"># 在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边</span></span><br><span class="line"><span class="comment"># conn.lpushx(&#x27;l2&#x27;,9)</span></span><br><span class="line"><span class="comment"># conn.lpushx(&#x27;l1&#x27;,9)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># llen(name)</span></span><br><span class="line"><span class="comment"># res=conn.llen(&#x27;l1&#x27;)</span></span><br><span class="line"><span class="comment"># print(res)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># linsert(name, where, refvalue, value))  在某个位置插入值</span></span><br><span class="line"><span class="comment"># where :BEFORE或AFTER,大小写都行</span></span><br><span class="line"><span class="comment"># refvalue: lqz 表示以lqz为标准（不是下标索引）</span></span><br><span class="line"><span class="comment"># conn.linsert(&#x27;l1&#x27;,&#x27;after&#x27;,&#x27;lqz&#x27;,&#x27;刘亦菲&#x27;)</span></span><br><span class="line"><span class="comment"># conn.linsert(&#x27;l1&#x27;,&#x27;before&#x27;,&#x27;lqz&#x27;,&#x27;baby&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># lset</span></span><br><span class="line"><span class="comment"># conn.lset(&#x27;l1&#x27;,0,&#x27;黄晓明&#x27;)</span></span><br><span class="line"><span class="comment"># conn.lset(&#x27;l1&#x27;,5,&#x27;老伙计&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># lrem</span></span><br><span class="line"><span class="comment"># 第二个参数count：</span></span><br><span class="line"><span class="comment"># count = 0，删除列表中所有的指定值；</span></span><br><span class="line"><span class="comment"># count=2,从前到后，删除2个；</span></span><br><span class="line"><span class="comment"># count=-2,从后向前，删除2个</span></span><br><span class="line"><span class="comment"># conn.lrem(&#x27;l1&#x27;,0,&#x27;lqz&#x27;)  # 把所有lqz都删除</span></span><br><span class="line"><span class="comment"># conn.lrem(&#x27;l1&#x27;,2,&#x27;lqz&#x27;)  # 从前往后，删除2个lqz</span></span><br><span class="line"><span class="comment"># conn.lrem(&#x27;l1&#x27;,-1,&#x27;lqz&#x27;)  # 从前往后，删除2个lqz</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># lpop</span></span><br><span class="line"><span class="comment"># res=conn.lpop(&#x27;l1&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># res=conn.rpop(&#x27;l1&#x27;)</span></span><br><span class="line"><span class="comment"># print(res)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># lindex(不删除)</span></span><br><span class="line"><span class="comment"># res=conn.lindex(&#x27;l1&#x27;,0)</span></span><br><span class="line"><span class="comment"># print(res)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># lrange   # 前闭后闭区间</span></span><br><span class="line"><span class="comment"># res = conn.lrange(&#x27;l1&#x27;, 0, 0)</span></span><br><span class="line"><span class="comment"># print(res)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ltrim</span></span><br><span class="line"><span class="comment"># res=conn.ltrim(&#x27;l1&#x27;,3,5)</span></span><br><span class="line"><span class="comment"># print(res)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># rpoplpush  需要两个列表</span></span><br><span class="line"><span class="comment"># conn.lpush(&#x27;l2&#x27;,&#x27;lqz&#x27;,&#x27;egon&#x27;)</span></span><br><span class="line"><span class="comment"># conn.rpoplpush(&#x27;l1&#x27;,&#x27;l1&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># blpop   # block:阻塞  左边弹出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># res=conn.blpop(&#x27;l1&#x27;)</span></span><br><span class="line"><span class="comment"># print(res)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">lpush</span></span><br><span class="line"><span class="string">llen</span></span><br><span class="line"><span class="string">linsert</span></span><br><span class="line"><span class="string">lset</span></span><br><span class="line"><span class="string">lrem</span></span><br><span class="line"><span class="string">lpop</span></span><br><span class="line"><span class="string">lrange  # 使用它，自定义增量迭代</span></span><br><span class="line"><span class="string">blpop </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### redis类库中没有提供对列表元素的增量迭代，借助lrange</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">conn = redis.Redis()</span><br><span class="line"><span class="comment"># res=conn.lrange(&#x27;l2&#x27;,0,9999)  # 全部取出来</span></span><br><span class="line"><span class="comment"># res=conn.lrange(&#x27;l2&#x27;,0,conn.llen(&#x27;l2&#x27;))  # 从0取到列表长度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类似于字典的hgetall，一次性全取出来，存在的问题是，因为不知道列表有多大，很有可能撑爆内存</span></span><br><span class="line"><span class="comment"># 我们实现一个增量迭代</span></span><br><span class="line"><span class="comment"># print(res)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for i in range(10000):</span></span><br><span class="line"><span class="comment">#     conn.lpush(&#x27;l_test&#x27;,&#x27;test_%s&#x27;%i)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># res=conn.lrange(&#x27;l2&#x27;,0,conn.llen(&#x27;l2&#x27;))</span></span><br><span class="line"><span class="comment"># print(res)</span></span><br><span class="line"><span class="comment"># res = conn.lrange(&#x27;l_test&#x27;, 0, 9)</span></span><br><span class="line"><span class="comment"># print(res)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># def lscan_iter(name, conn, count=10):</span></span><br><span class="line"><span class="comment">#     cursor = 0</span></span><br><span class="line"><span class="comment">#     lenght = conn.llen(name)  # 计算列表总长度</span></span><br><span class="line"><span class="comment">#     while cursor &lt; lenght:</span></span><br><span class="line"><span class="comment">#         data = conn.lrange(name, cursor, (cursor+count) - 1)</span></span><br><span class="line"><span class="comment">#         cursor += count</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         for item in data:</span></span><br><span class="line"><span class="comment">#             yield item</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lscan_iter</span>(<span class="params">name, conn, count=<span class="number">10</span></span>):</span></span><br><span class="line">    cursor = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = conn.lrange(name, cursor, (cursor+count) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            cursor += count</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">                <span class="keyword">yield</span> item</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lscan_iter(<span class="string">&#x27;l_test&#x27;</span>,conn,<span class="number">20</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<h2 id="7-redis之其它操作"><a href="#7-redis之其它操作" class="headerlink" title="7. redis之其它操作"></a>7. redis之其它操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 公共操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搭建哨兵。用了集群，这个模块就不够用了</span></span><br><span class="line"><span class="comment"># conn=redis.Redis()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># delete</span></span><br><span class="line"><span class="comment"># res=conn.delete(&#x27;l2&#x27;,&#x27;name&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#exists</span></span><br><span class="line"><span class="comment"># res=conn.exists(&#x27;l1&#x27;,&#x27;l_test&#x27;,&#x27;l2&#x27;)</span></span><br><span class="line"><span class="comment"># res=conn.exists(&#x27;l_test&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># expire</span></span><br><span class="line"><span class="comment"># res=conn.expire(&#x27;l_test&#x27;,5)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rename</span></span><br><span class="line"><span class="comment"># conn.lpush(&#x27;l1&#x27;,1,2,3)</span></span><br><span class="line"><span class="comment"># res=conn.rename(&#x27;l1&#x27;,&#x27;l2&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># res=conn.move(&#x27;l2&#x27;,3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## redis的库是隔离的</span></span><br><span class="line">conn = redis.Redis()</span><br><span class="line"><span class="comment"># res=conn.lpop(&#x27;l2&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机出一个key值</span></span><br><span class="line"><span class="comment"># res=conn.randomkey()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># conn.sadd(&#x27;choujiang&#x27;,9)</span></span><br><span class="line"><span class="comment"># conn.sadd(&#x27;choujiang&#x27;,90)</span></span><br><span class="line"><span class="comment"># conn.sadd(&#x27;choujiang&#x27;,99)</span></span><br><span class="line"><span class="comment"># print(res)</span></span><br><span class="line"><span class="comment"># res=conn.spop(&#x27;choujiang&#x27;)</span></span><br><span class="line"><span class="comment"># print(res)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># type----查看类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># res=conn.type(&#x27;choujiang&#x27;)</span></span><br><span class="line"><span class="comment"># res=conn.type(&#x27;ss&#x27;)</span></span><br><span class="line">res=conn.type(<span class="string">&#x27;zzz&#x27;</span>)</span><br><span class="line">print(res)</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<h2 id="8-管道（单实例上有效）"><a href="#8-管道（单实例上有效）" class="headerlink" title="8 管道（单实例上有效）"></a>8 管道（单实例上有效）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-不支持事务，但是通过管道模拟实现</span><br><span class="line">-批量的多个命令一次性执行</span><br><span class="line">-pipline，管道----》实现事务</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"> </span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">&#x27;10.211.55.4&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"> </span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># pipe = r.pipeline(transaction=False)</span></span><br><span class="line">pipe = r.pipeline(transaction=<span class="literal">True</span>)</span><br><span class="line">pipe.multi()</span><br><span class="line">pipe.set(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;alex&#x27;</span>)</span><br><span class="line">pipe.set(<span class="string">&#x27;role&#x27;</span>, <span class="string">&#x27;sb&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">pipe.execute()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="9-django中使用redis"><a href="#9-django中使用redis" class="headerlink" title="9 django中使用redis"></a>9 django中使用redis</h2><h3 id="9-1-通用方案"><a href="#9-1-通用方案" class="headerlink" title="9.1 通用方案"></a>9.1 通用方案</h3><h4 id="redis-pool-py"><a href="#redis-pool-py" class="headerlink" title="redis_pool.py"></a>redis_pool.py</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">POOL=redis.ConnectionPool(host=<span class="string">&#x27;127.0.0.1&#x27;</span>,port=<span class="number">6379</span>,max_connections=<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p><strong>views.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> utils.redis_pool <span class="keyword">import</span> POOL</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_redis</span>(<span class="params">request</span>):</span></span><br><span class="line">    conn=redis.Redis(connection_pool=POOL)</span><br><span class="line">    age=str(conn.get(<span class="string">&#x27;age&#x27;</span>),encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;人的年龄，从redis中取出来了是：%s&#x27;</span>%age)</span><br></pre></td></tr></table></figure>

<h3 id="9-2-django提供的方案"><a href="#9-2-django提供的方案" class="headerlink" title="9.2 django提供的方案"></a>9.2 django提供的方案</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install django-redis</span><br></pre></td></tr></table></figure>

<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># redis的配置</span></span><br><span class="line"><span class="comment">#以后django的缓存，用的就是redis，很方便使用redis的连接</span></span><br><span class="line">CACHES = &#123;</span><br><span class="line">    <span class="string">&quot;default&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;BACKEND&quot;</span>: <span class="string">&quot;django_redis.cache.RedisCache&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LOCATION&quot;</span>: <span class="string">&quot;redis://127.0.0.1:6379&quot;</span>,</span><br><span class="line">        <span class="string">&quot;OPTIONS&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;CLIENT_CLASS&quot;</span>: <span class="string">&quot;django_redis.client.DefaultClient&quot;</span>,</span><br><span class="line">            <span class="string">&quot;CONNECTION_POOL_KWARGS&quot;</span>: &#123;<span class="string">&quot;max_connections&quot;</span>: <span class="number">100</span>&#125;</span><br><span class="line">            <span class="comment"># &quot;PASSWORD&quot;: &quot;123&quot;,</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="views-py"><a href="#views-py" class="headerlink" title="views.py"></a>views.py</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django_redis <span class="keyword">import</span> get_redis_connection</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_django_redis</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 从连接池中拿到连接</span></span><br><span class="line">    conn=get_redis_connection()</span><br><span class="line"></span><br><span class="line">    age = str(conn.get(<span class="string">&#x27;age&#x27;</span>), encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> django.core.cache <span class="keyword">import</span> cache</span><br><span class="line">    cache.set(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;lqz&#x27;</span>,<span class="number">4</span>)  <span class="comment"># 往缓存中放key和value，其实放到了redis中了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cache.set(<span class="string">&#x27;xxx&#x27;</span>,test_redis)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;人的年龄是：%s&#x27;</span> % age)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>Ceph-1-基础</title>
    <url>/posts/42958.html</url>
    <content><![CDATA[<p>Ceph 基础</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">要点1：</span><br><span class="line">     如果做了ceph，服务器就不用做RAID了，做了RAID之后磁盘利用率就很低了。比如服务器有8块磁盘，可以给每一块磁盘做RAID0，8块磁盘就做8个RAID0，就是8个OSD。如果做RAID10，服务器上看就一个磁盘，10已经损耗了一半的存储空间，ceph再三副本，磁盘空间利用率就很低了。</span><br><span class="line">     pool ： 存储池</span><br><span class="line">     PG：一个pool内部可有多个PG，都是逻辑概念；</span><br><span class="line">     OSD：对象存储设备。每一个磁盘都是一个OSD，一个主机由一个或多个osd组成。</span><br><span class="line">     </span><br><span class="line">     ceph集群部署好之后，要先创建存储池才能向ceph写入数据，文件再向ceph保存之前要先进行一致性<span class="built_in">hash</span>计算，计算后悔把文件保存在某个对应的PG，此文件一个属于某个pool的一个PG，再通过PG保存到OSD上。</span><br><span class="line">     数据对象写到主OSD之后再同步给从OSD，以实现数据的高可用。</span><br></pre></td></tr></table></figure>



<h1 id="Ceph基础"><a href="#Ceph基础" class="headerlink" title="Ceph基础"></a>Ceph基础</h1><h2 id="版本介绍"><a href="#版本介绍" class="headerlink" title="版本介绍"></a>版本介绍</h2><p>稳定版本</p>
<p>J 版本 filestore 对文件系统的存储，格式化出系统能够识别的格式，量大了会出现很多问题，需要二次开发</p>
<p>L 版本 bluestore 直接操作裸盘，raid 0 ,ceph-volume 命令格式化，add ceph 到集群，所以比J 版本快很多</p>
<h3 id="Ceph版本来源介绍"><a href="#Ceph版本来源介绍" class="headerlink" title="Ceph版本来源介绍"></a>Ceph版本来源介绍</h3><p>Ceph 社区最新版本是 14，而 Ceph 12 是市面用的最广的稳定版本。<br>第一个 Ceph 版本是 0.1 ，要回溯到 2008 年 1 月。多年来，版本号方案一直没变，直到 2015 年 4 月 0.94.1 （ Hammer 的第一个修正版）发布后，为了避免 0.99 （以及 0.100 或 1.00 ？），制定了新策略。</p>
<p>x.0.z - 开发版（给早期测试者和勇士们）</p>
<p>x.1.z - 候选版（用于测试集群、高手们）</p>
<p>x.2.z - 稳定、修正版（给用户们）</p>
<p>x 将从 9 算起，它代表 Infernalis （ I 是第九个字母），这样第九个发布周期的第一个开发版就是 9.0.0 ；后续的开发版依次是 9.0.1 、 9.0.2 等等。</p>
<table>
<thead>
<tr>
<th>版本名称</th>
<th>版本号</th>
<th>发布时间</th>
</tr>
</thead>
<tbody><tr>
<td>Argonaut</td>
<td>0.48版本(LTS)</td>
<td>2012年6月3日</td>
</tr>
<tr>
<td>Bobtail</td>
<td>0.56版本(LTS)</td>
<td>2013年5月7日</td>
</tr>
<tr>
<td>Cuttlefish</td>
<td>0.61版本</td>
<td>2013年1月1日</td>
</tr>
<tr>
<td>Dumpling</td>
<td>0.67版本(LTS)</td>
<td>2013年8月14日</td>
</tr>
<tr>
<td>Emperor</td>
<td>0.72版本</td>
<td>2013年11月9</td>
</tr>
<tr>
<td>Firefly</td>
<td>0.80版本(LTS)</td>
<td>2014年5月</td>
</tr>
<tr>
<td>Giant</td>
<td>Giant</td>
<td>October 2014 - April 2015</td>
</tr>
<tr>
<td>Hammer</td>
<td>Hammer</td>
<td>April 2015 - November 2016</td>
</tr>
<tr>
<td>Infernalis</td>
<td>Infernalis</td>
<td>November 2015 - June 2016</td>
</tr>
<tr>
<td>Jewel</td>
<td>10.2.9</td>
<td>2016年4月</td>
</tr>
<tr>
<td>Kraken</td>
<td>11.2.1</td>
<td>2017年10月</td>
</tr>
<tr>
<td>Luminous</td>
<td>12.2.12</td>
<td>2017年10月</td>
</tr>
<tr>
<td>mimic</td>
<td>13.2.7</td>
<td>2018年5月</td>
</tr>
<tr>
<td>nautilus</td>
<td>14.2.5</td>
<td>2019年2月</td>
</tr>
</tbody></table>
<h3 id="mimic新版本特性"><a href="#mimic新版本特性" class="headerlink" title="mimic新版本特性"></a>mimic新版本特性</h3><ul>
<li>Bluestore<ul>
<li>ceph-osd的新后端存储BlueStore已经稳定，是新创建的OSD的默认设置。<br>BlueStore通过直接管理物理HDD或SSD而不使用诸如XFS的中间文件系统，来管理每个OSD存储的数据，这提供了更大的性能和功能。</li>
<li>BlueStore支持Ceph存储的所有的完整的数据和元数据校验。</li>
<li>BlueStore内嵌支持使用zlib，snappy或LZ4进行压缩。（Ceph还支持zstd进行RGW压缩，但由于性能原因，不为BlueStore推荐使用zstd）</li>
</ul>
</li>
<li>集群的总体可扩展性有所提高。我们已经成功测试了多达10,000个OSD的集群。</li>
<li>ceph-mgr<ul>
<li>ceph-mgr是一个新的后台进程，这是任何Ceph部署的必须部分。虽然当ceph-mgr停止时，IO可以继续，但是度量不会刷新，并且某些与度量相关的请求（例如，ceph df）可能会被阻止。我们建议您多部署ceph-mgr的几个实例来实现可靠性。</li>
<li>ceph-mgr守护进程daemon包括基于REST的API管理。注：API仍然是实验性质的，目前有一些限制，但未来会成为API管理的基础。</li>
<li>ceph-mgr还包括一个Prometheus插件。</li>
<li>ceph-mgr现在有一个Zabbix插件。使用zabbix_sender，它可以将集群故障事件发送到Zabbix Server主机。这样可以方便地监视Ceph群集的状态，并在发生故障时发送通知。</li>
</ul>
</li>
</ul>
<h2 id="ceph简介"><a href="#ceph简介" class="headerlink" title="ceph简介"></a>ceph简介</h2><ul>
<li>github: <a href="https://github.com/ceph/ceph">https://github.com/ceph/ceph</a></li>
</ul>
<p><code>Ceph</code>基于可靠的、自动化的、分布式的对象存储（Reliable,Autonomous,Distributed Object Storage,RADOS）提供了一个可无限扩展的存储集群。RADOS，顾名思义，这一层本身就是一个完整的对象存储系统，所有存储在Ceph系统中的用户数据事实上最终都是由这一层来存储的。而Ceph的高可靠、高可扩展、高性能、高自动化等特性本质上也是由这一层提供的。</p>
<ul>
<li><p>ceph 是一个对象(object)式存储系统，它把每一个待管理的数据流(文件等数据)切分为一到多个固定大小(默认4 兆)的对象数据，并以其为原子单元(原子是构成元素的最小单元)完成 数据的读写。</p>
</li>
<li><p>对象数据的底层存储服务是由多个存储主机(host)组成的存储集群，该集群也被称之为 RADOS(reliable automatic distributed object store)存储集群，即可靠的、自动化的、分布式的对象存储系统。</p>
</li>
<li><p>librados 是 RADOS 存储集群的 API，支持 C/C++/JAVA/python/ruby/php/go 等编程语言客户端。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1629213438574-db7b48e2-6e6b-4302-8a3a-464a3d407c3f.png" alt="img"></p>
<h3 id="ceph的设计思想"><a href="#ceph的设计思想" class="headerlink" title="ceph的设计思想"></a>ceph的设计思想</h3><p>Ceph 的设计旨在实现以下目标：</p>
<ol>
<li>每一组件皆可扩展</li>
<li>无单点故障</li>
<li>基于软件(而非专用设备)并且开源(无供应商锁定)</li>
<li>在现有的廉价硬件上运行</li>
<li>尽可能自动管理，减少用户干预</li>
</ol>
<h3 id="ceph的集群角色"><a href="#ceph的集群角色" class="headerlink" title="ceph的集群角色"></a>ceph的集群角色</h3><ul>
<li>官方文档: <a href="https://docs.ceph.com/en/latest/start/intro/">https://docs.ceph.com/en/latest/start/intro/</a></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1629180773849-8ce6a784-2ed8-4fef-a48f-7222bc02e726.png" alt="img"></p>
<p>一个 ceph 集群的组成部分：</p>
<p>若干的 Ceph OSD（对象存储守护程序） </p>
<p>至少需要一个 Ceph Monitors 监视器（1,3,5,7…）两个或以上的 Ceph 管理器managers，运行Ceph 文件系统客户端时，还需要高可用的 Ceph Metadata Server(文件系统元数据服务器)。<br>RADOS cluster: 由多台 host 存储服务器组成的ceph 集群 OSD(Object Storage Daemon)：每台存储服务器的磁盘组成的存储空间 Mon(Monitor)：ceph 的监视器,维护 OSD 和 PG 的集群状态，一个 ceph 集群至少要有一个 mon，可以是一三五七等等这样的奇数个。 Mgr(Manager)：负责跟踪运行时指标和 Ceph 集群的当前状态，包括存储利用率，当前性能指标和系统负载等。</p>
<h4 id="Monitor-ceph-mon-ceph-监视器"><a href="#Monitor-ceph-mon-ceph-监视器" class="headerlink" title="Monitor(ceph-mon) ceph 监视器"></a>Monitor(ceph-mon) ceph <strong>监视器</strong></h4><p>在一个主机上运行的一个守护进程，用于维护集群状态映射(maintains maps of the cluster state)，比如 ceph 集群中有多少存储池、每个存储池有多少 PG 以及存储池和 PG 的映射关系等， monitor map, manager map, the OSD map, the MDS map, and the CRUSH map，这些映射是 Ceph 守护程序相互协调所需的关键群集状态，此外监视器还负 责管理守护程序和客户端之间的身份验证(认证使用 cephX 协议)。通常至少需要三个监视器才能实现冗余和高可用性。</p>
<h4 id="Managers-ceph-mgr"><a href="#Managers-ceph-mgr" class="headerlink" title="Managers(ceph-mgr)"></a>Managers(ceph-mgr)</h4><p>在一个主机上运行的一个守护进程，Ceph Manager 守护程序（ceph-mgr）负责跟踪运行时指标和 Ceph 集群的当前状态，包括存储利用率，当前性能指标和系统负载。Ceph Manager 守护程序还托管基于 python 的模块来管理和公开 Ceph 集群信息，包括基于 Web 的 Ceph 仪表板和 REST API。高可用性通常至少需要两个管理器。</p>
<h4 id="Ceph-OSDs-对象存储守护程序-ceph-osd-j"><a href="#Ceph-OSDs-对象存储守护程序-ceph-osd-j" class="headerlink" title="Ceph OSDs(对象存储守护程序 ceph-osd)j"></a>Ceph OSDs(<strong>对象存储守护程序</strong> ceph-osd)j</h4><p>提供存储数据，操作系统上的一个磁盘就是一个 OSD 守护程序，OSD 用于处理 ceph 集群数据复制，恢复，重新平衡，并通过检查其他 Ceph OSD 守护程序的心跳来向 Ceph 监视器和管理器提供一些监视信息。通常至少需要3 个 Ceph OSD 才能实现冗余和高可用性。</p>
<h4 id="MDS-ceph-元数据服务器-ceph-mds"><a href="#MDS-ceph-元数据服务器-ceph-mds" class="headerlink" title="MDS(ceph 元数据服务器 ceph-mds)"></a>MDS(ceph <strong>元数据服务器</strong> ceph-mds)</h4><p>代表 ceph 文件系统(NFS/CIFS)存储元数据，(即 Ceph 块设备和 Ceph 对象存储不使用 MDS)</p>
<h4 id="Ceph-的管理节点"><a href="#Ceph-的管理节点" class="headerlink" title="Ceph 的管理节点"></a>Ceph <strong>的管理节点</strong></h4><ol>
<li>ceph 的常用管理接口是一组命令行工具程序，例如 rados、ceph、rbd 等命令，ceph 管理员可以从某个特定的 ceph-mon 节点执行管理操作</li>
<li>推荐使用部署专用的管理节点对 ceph 进行配置管理、升级与后期维护，方便后期权限管理，管理节点的权限只对管理人员开放，可以避免一些不必要的误操作的发生。</li>
</ol>
<h2 id="Ceph特点"><a href="#Ceph特点" class="headerlink" title="Ceph特点"></a>Ceph特点</h2><ol>
<li>支持三种 对象存储，块存储，文件存储 接口，称之为统一存储</li>
<li>采用CRUSH算法，数据分布均衡，并行度高，不需要维护固定的元数据结构</li>
<li>数据具有强一致性，确保所有副本写入完成后才返回确认，适合读多写少的场景</li>
<li>去中心化，没有固定的中心节点，集群扩展灵活</li>
</ol>
<h3 id="Ceph的主要架构"><a href="#Ceph的主要架构" class="headerlink" title="Ceph的主要架构"></a><strong>Ceph的主要架构</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/907596-20190731125159847-41552065.png" alt="img"></p>
<p><strong>&lt;1&gt;</strong> Ceph的最底层是RADOS（分布式对象存储系统），它具有可靠、智能、分布式等特性，实现高可靠、高可拓展、高性能、高自动化等功能，并最终存储用户数据。RADOS系统主要由两部分组成，分别是OSD和Monitor。<br>**&lt;2&gt;** RADOS之上是LIBRADOS，LIBRADOS是一个库，它允许应用程序通过访问该库来与RADOS系统进行交互，支持多种编程语言，比如C、C++、Python等。<br>**&lt;3&gt;** 基于LIBRADOS层开发的有三种接口，分别是RADOSGW、librbd和MDS。<br>**&lt;4&gt;** RADOSGW是一套基于当前流行的RESTFUL协议的网关，支持对象存储，兼容S3和Swift。<br>**&lt;5&gt;** librbd提供分布式的块存储设备接口，支持块存储。<br>**&lt;6&gt;** MDS提供兼容POSIX的文件系统，支持文件存储。</p>
<h3 id="Ceph的功能模块"><a href="#Ceph的功能模块" class="headerlink" title="Ceph的功能模块"></a>Ceph的功能模块</h3><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/907596-20190731125455674-473501881.png" alt="img"></p>
<p>Ceph的核心组件包括Client客户端、MON监控服务、MDS元数据服务、OSD存储服务，各组件功能如下：<br>**&lt;1&gt;** Client客户端：负责存储协议的接入，节点负载均衡。<br>**&lt;2&gt;** MON监控服务：负责监控整个集群，维护集群的健康状态，维护展示集群状态的各种图表，如OSD Map、Monitor Map、PG Map和CRUSH Map。<br>**&lt;3&gt;** MDS元数据服务：负责保存文件系统的元数据，管理目录结构。<br>**&lt;4&gt;** OSD存储服务：主要功能是存储数据、复制数据、平衡数据、恢复数据，以及与其它OSD间进行心跳检查等。一般情况下一块硬盘对应一个OSD。</p>
<h3 id="Ceph的资源划分"><a href="#Ceph的资源划分" class="headerlink" title="Ceph的资源划分"></a>Ceph的资源划分</h3><p>Ceph采用crush算法，在大规模集群下，实现数据的快速、准确存放，同时能够在硬件故障或扩展硬件设备时，做到尽可能小的数据迁移，其<strong>原理如下</strong>：<br>**&lt;1&gt;** 当用户要将数据存储到Ceph集群时，数据先被分割成多个object，(每个object一个object id，大小可设置，默认是4MB），object是Ceph存储的最小存储单元。<br>**&lt;2&gt;** 由于object的数量很多，为了有效减少了Object到OSD的索引表、降低元数据的复杂度，使得写入和读取更加灵活，引入了pg(Placement Group )：PG用来管理object，每个object通过Hash，映射到某个pg中，一个pg可以包含多个object。<br>**&lt;3&gt;** Pg再通过CRUSH计算，映射到osd中。如果是三副本的，则每个pg都会映射到三个osd，保证了数据的冗余。</p>
<p><img src="https://img2018.cnblogs.com/blog/907596/201907/907596-20190731125728096-1940075886.png" alt="img"></p>
<h3 id="Ceph内部数据存储视图"><a href="#Ceph内部数据存储视图" class="headerlink" title="Ceph内部数据存储视图"></a>Ceph内部数据存储视图</h3><p>​      在Ceph存储系统中，Cehp的基础服务架构主要包括了Object Storage Device(OSD)，Monitor和MDS。一个Cluster可逻辑上划分为多个Pool，一个 Pool由若干个逻辑 PG( Placement Group)组成，Pool内的副本数量也是可以设置的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20211120172834267.png" alt="image-20211120172834267"></p>
<p>​     Ceph底层是对象系统，所以一个文件会被切分为多个Object，每个Object会被映射到一个PG，每个PG 会映射到一组 OSD(Object Storage Device)，其中第一个OSD 是主，其余的是备，OSD间通过心跳来相互监控存活状态。引入PG概念后，OSD只和PG相关，不但简化了OSD的数据存储，而且实现了Object到OSD的动态映射，OSD的添加和故障不影响Object的映射。</p>
<h3 id="ceph存取原理介绍"><a href="#ceph存取原理介绍" class="headerlink" title="ceph存取原理介绍"></a>ceph存取原理介绍</h3><h4 id="数据高可用"><a href="#数据高可用" class="headerlink" title="数据高可用"></a>数据高可用</h4><ul>
<li>ceph存储数据的时候是一主两备份实现数据的高可用，3副本</li>
<li>ceph中的pg是把一组比较大的数据进行拆分，几个pg就拆成几份，每个pg中都是三副本；可以提高ceph的读写性能</li>
</ul>
<h4 id="ceph数据存储过程"><a href="#ceph数据存储过程" class="headerlink" title="ceph数据存储过程"></a>ceph数据存储过程</h4><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1629216778683-1e4d596f-87c1-4939-a85e-5b8c29ec4c11.png" alt="img"></p>
<ol>
<li>计算文件到对象的映射</li>
</ol>
<p>计算文件到对象的映射,假如 file 为客户端要读写的文件,得到 oid(object id) = ino + onoino:inode number (INO)，File 的元数据序列号，File 的唯一 id。 </p>
<p>ono:object number (ONO)，File 切分产生的某个 object 的序号，默认以 4M 切分一个块大小。</p>
<ol start="2">
<li>通过hash 算法计算出文件对应的 pool 中的PG(在客户端计算)</li>
</ol>
<p>通过一致性 HASH 计算 Object 到 PG， Object -&gt; PG 映射 hash(oid) &amp; mask-&gt; pgid</p>
<ol start="3">
<li>通过 CRUSH 把对象映射到 PG 中的 OSD（mon操作）</li>
</ol>
<p>通过 CRUSH 算法计算 PG 到 OSD</p>
<ol start="4">
<li><p>PG 中的主 OSD 将对象写入到硬盘 </p>
</li>
<li><p>主 OSD 将数据同步给备份 OSD,并等待备份 OSD 返回确认 </p>
</li>
<li><p>主 OSD 将写入完成返回给客户端</p>
</li>
</ol>
<h2 id="ceph安装与配置"><a href="#ceph安装与配置" class="headerlink" title="ceph安装与配置"></a>ceph安装与配置</h2><h3 id="生产环境硬件选型"><a href="#生产环境硬件选型" class="headerlink" title="生产环境硬件选型"></a>生产环境硬件选型</h3><ul>
<li><p>mon: 16c 16g 200G，至少三台，建议有条件使用物理机</p>
</li>
<li><p>mgr：32c 32g 200g， (启动对象存储)，至少两台，如果启动对象存储，配置建议翻倍</p>
</li>
<li><p>osd存储服务器： 四台以上，ssd(高IO)，实际数据三倍，万兆网卡</p>
</li>
</ul>
<h3 id="ceph-部署工具"><a href="#ceph-部署工具" class="headerlink" title="ceph 部署工具"></a>ceph 部署工具</h3><p>ceph-ansible：<a href="https://github.com/ceph/ceph-ansible">https://github.com/ceph/ceph-ansible</a> #python </p>
<p>ceph-salt：<a href="https://github.com/ceph/ceph-salt">https://github.com/ceph/ceph-salt</a></p>
<p> #python ceph-container：<a href="https://github.com/ceph/ceph-container">https://github.com/ceph/ceph-container</a></p>
<p> #shell ceph-chef：<a href="https://github.com/ceph/ceph-chef">https://github.com/ceph/ceph-chef</a></p>
<p> #Ruby cephadm: <a href="https://docs.ceph.com/en/latest/cephadm/">https://docs.ceph.com/en/latest/cephadm/</a></p>
<p> #ceph 官方在 ceph 15 版本加入的 </p>
<ul>
<li>ceph-deploy：<a href="https://github.com/ceph/ceph-deploy">https://github.com/ceph/ceph-deploy</a> #python </li>
</ul>
<p>是一个 ceph 官方维护的基于 ceph-deploy 命令行部署 ceph 集群的工具，基于 ssh 执行可以 sudo 权限的 shell 命令以及一些 python 脚本 实现 ceph 集群的部署和管理维护。 Ceph-deploy 只用于部署和管理 ceph 集群，客户端需要访问 ceph，需要部署客户端工具。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1629297285794-db8f49bd-22d8-4044-8881-3a73109db304.png" alt="img"></p>
<h3 id="机器规划"><a href="#机器规划" class="headerlink" title="机器规划"></a>机器规划</h3><table>
<thead>
<tr>
<th>主机名</th>
<th>publicIP</th>
<th>privateIP</th>
<th>角色</th>
<th>安装的软件</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>ceph-deploy</td>
<td>10.168.56.100</td>
<td>192.168.56.100</td>
<td>ceph-deplayer</td>
<td>ceph-epel,ceph-common,ceph-deploy</td>
<td>单磁盘</td>
</tr>
<tr>
<td>ceph-mon-mgr1</td>
<td>10.168.56.101</td>
<td>192.168.56.101</td>
<td>ceph-mon,ceph-mgr</td>
<td>ceph-epel,ceph-mon,ceph-mgr</td>
<td>单磁盘</td>
</tr>
<tr>
<td>ceph-mon-mgr2</td>
<td>10.168.56.102</td>
<td>192.168.56.102</td>
<td>ceph-mon,ceph-mgr</td>
<td>ceph-epel,ceph-mon,ceph-mgr</td>
<td>单磁盘</td>
</tr>
<tr>
<td>ceph-mon3</td>
<td>10.168.56.103</td>
<td>192.168.56.103</td>
<td>ceph-mon</td>
<td>ceph-epel,ceph-mon</td>
<td>单磁盘</td>
</tr>
<tr>
<td>ceph-data1</td>
<td>10.168.56.104</td>
<td>192.168.56.104</td>
<td>ceph-data</td>
<td>ceph-epel</td>
<td>单系统盘+三块数据盘</td>
</tr>
<tr>
<td>ceph-data2</td>
<td>10.168.56.105</td>
<td>192.168.56.105</td>
<td>ceph-data</td>
<td>ceph-epel</td>
<td>单系统盘+三块数据盘</td>
</tr>
<tr>
<td>ceph-data3</td>
<td>10.168.56.106</td>
<td>192.168.56.106</td>
<td>ceph-data</td>
<td>ceph-epel,ceph-common</td>
<td>单系统盘+三块数据盘</td>
</tr>
</tbody></table>
<h3 id="部署用户"><a href="#部署用户" class="headerlink" title="部署用户"></a>部署用户</h3><ul>
<li>ceph-deployer新建cephstore用户和组，不要创建ceph用户</li>
<li>所有节点都创建用户</li>
</ul>
<p>推荐使用指定的普通用户部署和运行 ceph 集群，普通用户只要能以非交互方式执行 sudo命令执行一些特权命令即可，新版的 ceph-deploy 可以指定包含 root 的在内只要可以执行 sudo 命令的用户，不过仍然推荐使用普通用户，比如 ceph、cephuser、cephadmin 这样 的用户去管理 ceph 集群。 在包含 ceph-deploy 节点的存储节点、mon 节点和 mgr 节点等创建<code>cephstore</code>用户</p>
<ul>
<li>所有节点都切换到root账户下，执行如下命令创建用户和组</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd -r -g 2022 cephstore &amp;&amp; useradd -r -m -s /bin/bash -u 2022 -g 2022 cephstore &amp;&amp; <span class="built_in">echo</span> cephstore:TestCase123 | chpasswd</span><br></pre></td></tr></table></figure>

<ul>
<li>所有节点允许cephstore用户sudo免密</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;cephstore ALL=(ALL) NOPASSWD: ALL&quot;</span> &gt;&gt; /etc/sudoers</span><br></pre></td></tr></table></figure>

<ul>
<li>在ceph-deploy实现对集群所有节点cephstore用户免密登录</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ceph-deploy:~<span class="comment"># su - cephstore</span></span><br><span class="line">cephstore@ceph-deploy:~$ ssh-keygen   <span class="comment">#生成ceph-deploy ssh密钥</span></span><br><span class="line">cephstore@ceph-deploy:~$ <span class="keyword">for</span> i <span class="keyword">in</span> 192.168.56.10&#123;0..6&#125;; <span class="keyword">do</span> ssh-copy-id cephstore@<span class="variable">$i</span>; <span class="keyword">done</span>    <span class="comment">#使用TestCase123验证即可</span></span><br></pre></td></tr></table></figure>

<h3 id="环境初始化准备"><a href="#环境初始化准备" class="headerlink" title="环境初始化准备"></a>环境初始化准备</h3><ul>
<li>时间同步</li>
<li>主机名规划与解析: 所有节点都要操作[root用户]，需要对public设置主机名解析</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt; EOF &gt;&gt; /etc/hosts</span><br><span class="line">10.168.56.100 ceph-deploy</span><br><span class="line">10.168.56.101 ceph-mon-mgr1 ceph-mon1 ceph-mgr1 </span><br><span class="line">10.168.56.102 ceph-mon-mgr2 ceph-mon2 ceph-mgr2 </span><br><span class="line">10.168.56.103 ceph-mon3</span><br><span class="line">10.168.56.104 ceph-data1</span><br><span class="line">10.168.56.105 ceph-data2 </span><br><span class="line">10.168.56.106 ceph-data3</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<ul>
<li>apt源： 推荐使用清华（环境准备文档有介绍）：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/</a></li>
<li>所有节点安装python2.7： </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install python2.7 -y</span><br><span class="line">ln -sv /usr/bin/python2.7 /usr/bin/python2</span><br></pre></td></tr></table></figure>

<ul>
<li>ceph源: 上述机器都需要加（<a href="https://docs.ceph.com/en/latest/releases/pacific/#v16-2-5-pacific%EF%BC%89">https://docs.ceph.com/en/latest/releases/pacific/#v16-2-5-pacific）</a></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1629299234738-1ca26b4a-3e63-48c1-97eb-af1604dfdbba.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt install ca-certificates</span><br><span class="line">$ wget -q -O- <span class="string">&#x27;https://mirrors.tuna.tsinghua.edu.cn/ceph/keys/release.asc&#x27;</span> | sudo apt-key add -</span><br><span class="line">$ apt-add-repository <span class="string">&#x27;deb https://mirrors.tuna.tsinghua.edu.cn/ceph/debian-octopus/ bionic main&#x27;</span></span><br><span class="line">$ apt update</span><br></pre></td></tr></table></figure>

<h3 id="ceph-deploy节点的部署与初始化"><a href="#ceph-deploy节点的部署与初始化" class="headerlink" title="ceph-deploy节点的部署与初始化"></a>ceph-deploy节点的部署与初始化</h3><ul>
<li>安装ceph-deploy</li>
</ul>
<p>注意： ubuntu20.04LTS部署ceph-deploy参考： pip3 install git+<a href="https://github.com/ceph/ceph-deploy.git">https://github.com/ceph/ceph-deploy.git</a></p>
<p>ubuntu18.04LTS部署参考：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cephstore@ceph-deploy:~$ sudo apt-cache madison ceph-deploy</span><br><span class="line">cephstore@ceph-deploy:~$ sudo apt install ceph-deploy -y</span><br></pre></td></tr></table></figure>

<h4 id="初始化mon1"><a href="#初始化mon1" class="headerlink" title="初始化mon1"></a>初始化mon1</h4><p>先初始化一个mon节点，然后再逐个添加即可</p>
<ul>
<li>重要： 在初始化之前在所有的mon节点安装ceph-mon</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install ceph-mon -y</span><br></pre></td></tr></table></figure>

<p>ceph-deploy –help </p>
<p>new：开始部署一个新的 ceph 存储集群，并生成 CLUSTER.conf 集群配置文件和 keyring认证文件。 install: 在远程主机上安装 ceph 相关的软件包, 可以通过–release 指定安装的版本。 </p>
<p>rgw：管理 RGW 守护程序(RADOSGW,对象存储网关)。 mgr：管理 MGR 守护程序(ceph-mgr,Ceph Manager DaemonCeph 管理器守护程序)。 mds：管理 MDS 守护程序(Ceph Metadata Server，ceph 源数据服务器)。 mon：管理 MON 守护程序(ceph-mon,ceph 监视器)。 gatherkeys：从指定获取提供新节点的验证 keys，这些 keys 会在添加新的 MON/OSD/MD加入的时候使用。 </p>
<p>disk：管理远程主机磁盘。 </p>
<p>osd：在远程主机准备数据磁盘，即将指定远程主机的指定磁盘添加到 ceph 集群作为osd使用。 </p>
<p>repo： 远程主机仓库管理。 </p>
<p>admin：推送 ceph 集群配置文件和 client.admin 认证文件到远程主机。 </p>
<p>config：将 ceph.conf 配置文件推送到远程主机或从远程主机拷贝。 </p>
<p>uninstall：从远端主机删除安装包。 </p>
<p>purgedata：从/var/lib/ceph 删除 ceph 数据,会删除/etc/ceph 下的内容。 </p>
<p>purge: 删除远端主机的安装包和所有数据。 </p>
<p>forgetkeys：从本地主机删除所有的验证 keyring, 包括 client.admin, monitor, bootstrap 等 </p>
<p>认证文件。 </p>
<p>pkg： 管理远端主机的安装包。 </p>
<p>calamari：安装并配置一个 calamari web 节点，calamari 是一个 web 监控平台。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ceph-deploy:~<span class="comment"># su - cephstore</span></span><br><span class="line">cephstore@ceph-deploy:~$ mkdir ceph-clusters &amp;&amp; <span class="built_in">cd</span> ceph-clusters</span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy new --cluster-network 192.168.56.0/24 --public-network 10.168.56.0/24 ceph-mon-mgr1   <span class="comment">#集群初始化,ceph-mon-mgr1这是主机名不是服务角色名，千万注意这里，大坑</span></span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ll   <span class="comment">#生成配置文件</span></span><br><span class="line">total 16</span><br><span class="line">drwxrwxr-x 2 cephstore cephstore   75 Aug 19 00:01 ./</span><br><span class="line">drwxr-xr-x 6 cephstore cephstore  163 Aug 18 23:56 ../</span><br><span class="line">-rw-rw-r-- 1 cephstore cephstore  266 Aug 19 00:01 ceph.conf</span><br><span class="line">-rw-rw-r-- 1 cephstore cephstore 6097 Aug 19 00:01 ceph-deploy-ceph.log</span><br><span class="line">-rw------- 1 cephstore cephstore   73 Aug 19 00:01 ceph.mon.keyring</span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ cat ceph.conf     <span class="comment">#查看配置文件</span></span><br><span class="line">[global]</span><br><span class="line">fsid = 668e9605-7ba1-4c5e-800e-97c076ffaa09</span><br><span class="line">public_network = 10.168.56.0/24</span><br><span class="line">cluster_network = 192.168.56.0/24</span><br><span class="line">mon_initial_members = ceph-mon1</span><br><span class="line">mon_host = 10.168.56.101</span><br><span class="line">auth_cluster_required = cephx</span><br><span class="line">auth_service_required = cephx</span><br><span class="line">auth_client_required = cephx</span><br><span class="line"></span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy mon create-initial    <span class="comment">#初始化mon节点</span></span><br></pre></td></tr></table></figure>

<h4 id="安装ceph-common并推送认证"><a href="#安装ceph-common并推送认证" class="headerlink" title="安装ceph-common并推送认证"></a>安装ceph-common并推送认证</h4><p>ceph-common管理集群</p>
<ul>
<li><p>安装此包的节点</p>
</li>
<li><ul>
<li>ceph-deploy</li>
<li>其他需要管理集群的节点: 比如ceph-data3</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ sudo apt install ceph-common -y</span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph -s</span><br><span class="line">2021-08-19T00:42:58.093+0800 7fcc913ec700 -1 auth: unable to find a keyring on /etc/ceph/ceph.client.admin.keyring,/etc/ceph/ceph.keyring,/etc/ceph/keyring,/etc/ceph/keyring.bin,: (2) No such file or directory</span><br><span class="line">2021-08-19T00:42:58.093+0800 7fcc913ec700 -1 AuthRegistry(0x7fcc8c05b2a8) no keyring found at /etc/ceph/ceph.client.admin.keyring,/etc/ceph/ceph.keyring,/etc/ceph/keyring,/etc/ceph/keyring.bin,, disabling cephx</span><br><span class="line">2021-08-19T00:42:58.093+0800 7fcc913ec700 -1 auth: unable to find a keyring on /etc/ceph/ceph.client.admin.keyring,/etc/ceph/ceph.keyring,/etc/ceph/keyring,/etc/ceph/keyring.bin,: (2) No such file or directory</span><br><span class="line">2021-08-19T00:42:58.093+0800 7fcc913ec700 -1 AuthRegistry(0x7fcc8c05f1a0) no keyring found at /etc/ceph/ceph.client.admin.keyring,/etc/ceph/ceph.keyring,/etc/ceph/keyring,/etc/ceph/keyring.bin,, disabling cephx</span><br><span class="line">2021-08-19T00:42:58.097+0800 7fcc913ec700 -1 auth: unable to find a keyring on /etc/ceph/ceph.client.admin.keyring,/etc/ceph/ceph.keyring,/etc/ceph/keyring,/etc/ceph/keyring.bin,: (2) No such file or directory</span><br><span class="line">2021-08-19T00:42:58.097+0800 7fcc913ec700 -1 AuthRegistry(0x7fcc913eb000) no keyring found at /etc/ceph/ceph.client.admin.keyring,/etc/ceph/ceph.keyring,/etc/ceph/keyring,/etc/ceph/keyring.bin,, disabling cephx</span><br><span class="line">[errno 2] RADOS object not found (error connecting to the cluster)</span><br></pre></td></tr></table></figure>

<ul>
<li>配置认证： 推送配置文件和认证的key到需要认证的客户端（在ceph-deploy节点执行）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy admin ceph-deploy ceph-data3</span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ setfacl -m u:cephstore:rw /etc/ceph/ceph.client.admin.keyring</span><br><span class="line">root@ceph-data3:~<span class="comment"># sudo setfacl -m u:cephstore:rw /etc/ceph/ceph.client.admin.keyring     </span></span><br></pre></td></tr></table></figure>

<ul>
<li>校验ceph命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ceph-data3:~<span class="comment"># ceph -s</span></span><br><span class="line">  cluster:</span><br><span class="line">    id:     668e9605-7ba1-4c5e-800e-97c076ffaa09</span><br><span class="line">    health: HEALTH_WARN</span><br><span class="line">            mon is allowing insecure global_id reclaim</span><br><span class="line"> </span><br><span class="line">  services:</span><br><span class="line">    mon: 1 daemons, quorum ceph-mon-mgr1 (age 15m)</span><br><span class="line">    mgr: no daemons active</span><br><span class="line">    osd: 0 osds: 0 up, 0 <span class="keyword">in</span></span><br><span class="line"> </span><br><span class="line">  data:</span><br><span class="line">    pools:   0 pools, 0 pgs</span><br><span class="line">    objects: 0 objects, 0 B</span><br><span class="line">    usage:   0 B used, 0 B / 0 B avail</span><br><span class="line">    pgs:</span><br></pre></td></tr></table></figure>

<h4 id="初始化mgr节点"><a href="#初始化mgr节点" class="headerlink" title="初始化mgr节点"></a>初始化mgr节点</h4><ul>
<li>在mgr节点安装好ceph-mgr</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install ceph-mgr -y</span><br></pre></td></tr></table></figure>

<ul>
<li>ceph-deploy节点初始化并加入集群</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy mgr create ceph-mon-mgr1</span><br></pre></td></tr></table></figure>

<h4 id="初始化data节点"><a href="#初始化data节点" class="headerlink" title="初始化data节点"></a>初始化data节点</h4><ul>
<li>ceph-deploy给ceph-data节点安装节点磁盘管理的软件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy install --no-adjust-repos --nogpgcheck ceph-data1 ceph-data2 ceph-data3</span><br></pre></td></tr></table></figure>

<ul>
<li>解决<code>mon is allowing insecure global_id reclaim</code>异常</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1629306578450-ad7d5631-c89a-4557-9d31-64899c9e952e.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph config <span class="built_in">set</span> mon auth_allow_insecure_global_id_reclaim <span class="literal">false</span>       <span class="comment">#ceph-common管理客户端执行</span></span><br><span class="line">ceph -s  <span class="comment">#状态解决</span></span><br></pre></td></tr></table></figure>

<ul>
<li>准备osd节点</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy install --release pacific ceph-data1 ceph-data2 ceph-data3</span><br></pre></td></tr></table></figure>

<ul>
<li>擦除磁盘</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy disk list ceph-data1   <span class="comment">#列出节点的磁盘</span></span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy disk zap ceph-data1 /dev/sdb</span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy disk zap ceph-data1 /dev/sdc</span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy disk zap ceph-data1 /dev/sdd</span><br><span class="line"></span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy disk zap ceph-data2 /dev/sdb</span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy disk zap ceph-data2 /dev/sdc</span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy disk zap ceph-data2 /dev/sdd</span><br><span class="line"></span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy disk zap ceph-data3 /dev/sdb</span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy disk zap ceph-data3 /dev/sdc</span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy disk zap ceph-data3 /dev/sdd</span><br></pre></td></tr></table></figure>

<ul>
<li>添加osd</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy osd create ceph-data1 --data /dev/sdb</span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy osd create ceph-data1 --data /dev/sdc</span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy osd create ceph-data1 --data /dev/sdd</span><br><span class="line"></span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph -s   <span class="comment">#加完三快盘之后节点就是健康的了</span></span><br><span class="line">  cluster:</span><br><span class="line">    id:     668e9605-7ba1-4c5e-800e-97c076ffaa09</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"> </span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy osd create ceph-data2 --data /dev/sdb</span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy osd create ceph-data2 --data /dev/sdc</span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy osd create ceph-data2 --data /dev/sdd</span><br><span class="line"></span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy osd create ceph-data3 --data /dev/sdb</span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy osd create ceph-data3 --data /dev/sdc</span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph-deploy osd create ceph-data3 --data /dev/sdd</span><br><span class="line"> </span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph -s    <span class="comment">#集群状态查看</span></span><br><span class="line">  cluster:</span><br><span class="line">    id:     668e9605-7ba1-4c5e-800e-97c076ffaa09</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"> </span><br><span class="line">  services:</span><br><span class="line">    mon: 1 daemons, quorum ceph-mon-mgr1 (age 55m)</span><br><span class="line">    mgr: ceph-mon-mgr1(active, since 34m)</span><br><span class="line">    osd: 7 osds: 7 up (since 48s), 7 <span class="keyword">in</span> (since 56s)</span><br><span class="line"> </span><br><span class="line">  data:</span><br><span class="line">    pools:   1 pools, 1 pgs</span><br><span class="line">    objects: 0 objects, 0 B</span><br><span class="line">    usage:   38 MiB used, 140 GiB / 140 GiB avail</span><br><span class="line">    pgs:     1 active+clean</span><br></pre></td></tr></table></figure>

<h2 id="ceph基础运维"><a href="#ceph基础运维" class="headerlink" title="ceph基础运维"></a>ceph基础运维</h2><ul>
<li>官方文档： <a href="http://docs.ceph.org.cn/rados/">http://docs.ceph.org.cn/rados/</a></li>
</ul>
<h3 id="OSD管理"><a href="#OSD管理" class="headerlink" title="OSD管理"></a>OSD管理</h3><h4 id="从RADOS删除OSD"><a href="#从RADOS删除OSD" class="headerlink" title="从RADOS删除OSD"></a>从RADOS删除OSD</h4><ul>
<li><a href="https://blog.csdn.net/baidu_26495369/article/details/80325315">https://blog.csdn.net/baidu_26495369/article/details/80325315</a></li>
<li><a href="https://blog.csdn.net/weixin_42550750/article/details/113587907">https://blog.csdn.net/weixin_42550750/article/details/113587907</a></li>
</ul>
<p>Ceph 集群中的一个 OSD 是一个 node 节点的服务进程且对应于一个物理磁盘设备，是一个专用的守护进程。在某 OSD 设备出现故障，或管理员出于管理之需确实要移除特定的 OSD设备时，需要先停止相关的守护进程，而后再进行移除操作。对于 Luminous 及其之后的版本来说，停止和移除命令的格式分别如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 停用设备：ceph osd out &#123;osd-num&#125; </span><br><span class="line">2. 停止进程：sudo systemctl stop ceph-osd@&#123;osd-num&#125; </span><br><span class="line">3. 移除设备：ceph osd purge &#123;id&#125; --yes-i-really-mean-it</span><br></pre></td></tr></table></figure>

<p> 若类似如下的 OSD 的配置信息存在于 ceph.conf 配置文件中,管理员在删除OSD之后手动将其删除。</p>
<p>不过，对于 Luminous 之前的版本来说，管理员需要依次手动执行如下步骤删除 OSD 设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 于 CRUSH 运行图中移除设备：ceph osd crush remove &#123;name&#125; </span><br><span class="line">2. 移除 OSD 的认证 key：ceph auth del osd.&#123;osd-num&#125; </span><br><span class="line">3. 最后移除 OSD 设备：ceph osd rm &#123;osd-num&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试上传与下载数据"><a href="#测试上传与下载数据" class="headerlink" title="测试上传与下载数据"></a><strong>测试上传与下载数据</strong></h3><p>存取数据时，客户端必须首先连接至 RADOS 集群上某存储池，然后根据对象名称由相关的CRUSH 规则完成数据对象寻址。于是，为了测试集群的数存取功能，这里首先创建一个用于测试的存储池 mypool，并设定其 PG 数量为 32 个</p>
<ol>
<li>创建pool： 一般一个项目一个存储池</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph osd pool create mypool 32 32</span><br><span class="line">pool <span class="string">&#x27;mypool&#x27;</span> created</span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph osd pool ls </span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph pg ls-by-pool mypool | awk <span class="string">&#x27;&#123;print $1,$2,$15&#125;&#x27;</span> <span class="comment">#验证 PG 与 PGP 组合</span></span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph osd tree     <span class="comment">#osd对应关系</span></span><br></pre></td></tr></table></figure>

<ol>
<li>上传文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ sudo rados put msg /var/<span class="built_in">log</span>/syslog --pool=mypool    <span class="comment">#上传文件</span></span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ rados ls --pool=mypool    <span class="comment">#查看上传结果</span></span><br><span class="line">msg</span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ ceph osd map mypool msg    <span class="comment">#文件信息查看</span></span><br><span class="line">osdmap e82 pool <span class="string">&#x27;mypool&#x27;</span> (3) object <span class="string">&#x27;msg&#x27;</span> -&gt; pg 3.e4c81fc1 (3.1) -&gt; up ([0,8], p0) acting ([0,8], p0)</span><br></pre></td></tr></table></figure>

<ol>
<li>下载文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ sudo rados get msg --pool=mypool /opt/a.txt    <span class="comment">#下载</span></span><br></pre></td></tr></table></figure>

<ol>
<li>删除文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ sudo rados rm msg1 --pool=mypool</span><br><span class="line">cephstore@ceph-deploy:~/ceph-clusters$ rados ls --pool=mypool</span><br></pre></td></tr></table></figure>

<h3 id="mon节点扩缩容"><a href="#mon节点扩缩容" class="headerlink" title="mon节点扩缩容"></a>mon节点扩缩容</h3><ol>
<li>mon节点扩容</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cephstore@ceph-deploy:~/ceph-cluster$ ceph-deploy mon create ceph-mon-mgr2</span><br><span class="line">cephstore@ceph-deploy:~/ceph-cluster$ ceph-deploy mon create ceph-mon3</span><br><span class="line">cephstore@ceph-deploy:~/ceph-cluster$ ceph quorum_status --format json-pretty    <span class="comment">#验证ceph-mon状态</span></span><br></pre></td></tr></table></figure>

<h3 id="mgr扩缩容"><a href="#mgr扩缩容" class="headerlink" title="mgr扩缩容"></a>mgr扩缩容</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cephstore@ceph-deploy:~/ceph-cluster$ ceph-deploy mgr create ceph-mon-mgr2</span><br><span class="line">cephstore@ceph-deploy:~/ceph-cluster$ ceph -s</span><br><span class="line">  cluster:</span><br><span class="line">    id:     c2221043-a745-49ed-b2b5-8326bb156f90</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"> </span><br><span class="line">  services:</span><br><span class="line">    mon: 3 daemons, quorum ceph-mon-mgr1,ceph-mon-mgr2,ceph-mon3 (age 7m)</span><br><span class="line">    mgr: ceph-mon-mgr1(active, since 33m), standbys: ceph-mon-mgr2</span><br><span class="line">    osd: 9 osds: 9 up (since 13m), 9 <span class="keyword">in</span> (since 14m)</span><br><span class="line"> </span><br><span class="line">  data:</span><br><span class="line">    pools:   2 pools, 33 pgs</span><br><span class="line">    objects: 0 objects, 0 B</span><br><span class="line">    usage:   64 MiB used, 180 GiB / 180 GiB avail</span><br><span class="line">    pgs:     33 active+clean</span><br></pre></td></tr></table></figure>

<h2 id="ceph集群应用基础"><a href="#ceph集群应用基础" class="headerlink" title="ceph集群应用基础"></a>ceph集群应用基础</h2><h3 id="块设备RBD"><a href="#块设备RBD" class="headerlink" title="块设备RBD"></a>块设备RBD</h3><p>RBD(RADOS Block Devices)即为块存储的一种，RBD 通过 librbd 库与 OSD 进行交互，RBD为 KVM 等虚拟化技术和云服务（如 OpenStack 和 CloudStack）提供高性能和无限可扩展性的存储后端，这些系统依赖于 libvirt 和 QEMU 实用程序与 RBD 进行集成，客户端基于librbd 库即可将 RADOS 存储集群用作块设备，不过，用于 rbd 的存储池需要事先启用 rbd功能并进行初始化。例如，下面的命令创建一个名为 myrbd 的存储池，并在启用 rbd功能后对其进行初始化</p>
<h4 id="创建RDB"><a href="#创建RDB" class="headerlink" title="创建RDB"></a>创建RDB</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cephstore@ceph-deploy:~/ceph-cluster$ ceph osd pool create myrbd 64 64    <span class="comment">#创建rbd</span></span><br><span class="line">cephstore@ceph-deploy:~/ceph-cluster$ ceph osd pool application <span class="built_in">enable</span> myrbd rbd    <span class="comment">#启用rbd</span></span><br><span class="line">cephstore@ceph-deploy:~/ceph-cluster$ rbd pool init -p myrbd     <span class="comment">#初始化rbd</span></span><br></pre></td></tr></table></figure>

<h4 id="创建并验证-img"><a href="#创建并验证-img" class="headerlink" title="创建并验证 img"></a><strong>创建并验证</strong> img</h4><p>rbd 存储池并不能直接用于块设备，而是需要事先在其中按需创建映像（image），并把映像文件作为块设备使用，rbd 命令可用于创建、查看及删除块设备相在的映像 （image），以及克隆映像、创建快照、将映像回滚到快照和查看快照等管理操作，例如：下面的命令能够创建一个名为 myimg的映像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cephstore@ceph-deploy:~/ceph-cluster$ rbd create myimg --size 5G --pool=myrbd</span><br><span class="line">cephstore@ceph-deploy:~/ceph-cluster$ rbd create myimg1 --size 3G --pool=myrbd --image-format 2 --image-feature layering</span><br><span class="line">cephstore@ceph-deploy:~/ceph-cluster$ rbd ls --pool myrbd    <span class="comment">#查看rbd</span></span><br><span class="line">cephstore@ceph-deploy:~/ceph-cluster$ rbd --image myimg --pool myrbd info      <span class="comment">#查看块存储信息</span></span><br><span class="line">cephstore@ceph-deploy:~/ceph-cluster$ ceph df    <span class="comment">#存储容量信息查看</span></span><br></pre></td></tr></table></figure>

<p>后续步骤会使用 myimg2 ，由于 centos 系统内核较低无法挂载使用，因此只开启部分特性。</p>
<p>除了 layering 其他特性需要高版本内核支持</p>
<h4 id="客户端挂载RBD块存储"><a href="#客户端挂载RBD块存储" class="headerlink" title="客户端挂载RBD块存储"></a>客户端挂载RBD块存储</h4><ul>
<li>客户端OS: centos7</li>
<li>安装ceph-common</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-client-centos7]<span class="comment"># wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</span></span><br><span class="line">[root@ceph-client-centos7]<span class="comment"># yum -y install epel-release</span></span><br><span class="line">[root@ceph-client-centos7]<span class="comment"># yum install https://mirrors.aliyun.com/ceph/rpm-octopus/el7/noarch/ceph-release-1-1.el7.noarch.rpm -y</span></span><br><span class="line">[root@ceph-client-centos7 ~]<span class="comment"># yum -y install ceph-common</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从deph-deploy拷贝认证文件和配置文件到centos7客户端</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cephstore@ceph-deploy:~/ceph-cluster$ scp ceph.conf  ceph.client.admin.keyring root@10.168.56.110:/etc/ceph/</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端映射img</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-client-centos7]<span class="comment"># rbd -p myrbd map myimg1</span></span><br><span class="line">[root@ceph-client-centos7]<span class="comment"># rbd -p myrdb map myimg</span></span><br><span class="line">rbd: sysfs write failed RBD image feature <span class="built_in">set</span> mismatch. You can <span class="built_in">disable</span> features unsupported by the kernel with <span class="string">&quot;rbd feature disable myrdb1/myimg1 object-map fast-diff deep-flatten&quot;</span>. In some cases useful info is found <span class="keyword">in</span> syslog - try <span class="string">&quot;dmesg | tail&quot;</span>. rbd: map failed: (6) No such device or address</span><br></pre></td></tr></table></figure>

<ul>
<li>格式化映射并使用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs.ext4 /dev/rbd0</span><br><span class="line">mount /dev/rbd0 /data</span><br></pre></td></tr></table></figure>

<ul>
<li>服务端验证</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph df</span><br></pre></td></tr></table></figure>

<h3 id="ceph-radosgw-RGW-对象存储"><a href="#ceph-radosgw-RGW-对象存储" class="headerlink" title="ceph radosgw(RGW)对象存储"></a><strong>ceph radosgw(RGW)对象存储</strong></h3><p>RGW 提供的是 REST 接口，客户端通过 http 与其进行交互，完成数据的增删改查等管理操作。</p>
<p>radosgw 用在需要使用 RESTful API 接口访问 ceph 数据的场合，因此在使用 RBD 即块存储得场合或者使用 cephFS 的场合可以不用启用 radosgw 功能。 </p>
<h4 id="部署-radosgw-服务："><a href="#部署-radosgw-服务：" class="headerlink" title="部署 radosgw 服务："></a>部署 radosgw 服务：</h4><ul>
<li>如果是在使用 radosgw 的场合，则以下命令将 ceph-mgr1 服务器部署为 RGW 主机</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ceph-mon-mgr1:~<span class="comment"># apt install radosgw=16.2.5-1bionic</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在deploy节点部署radoswgw服务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cephstore@ceph-deploy:~/ceph-cluster$ ceph-deploy --overwrite-conf rgw create ceph-mon-mgr1</span><br></pre></td></tr></table></figure>

<ul>
<li>ceph-mon-mgr1验证服务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ceph-mon-mgr1:~<span class="comment"># ps -aux | grep radosgw</span></span><br><span class="line">root@ceph-mon-mgr1:~<span class="comment"># netstat -tanlp | grep 7480</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1629477107487-bcad551f-5ddb-49e9-bf35-e35801221743.png" alt="img"></p>
<ul>
<li>验证ceph状态</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph df</span><br></pre></td></tr></table></figure>

<ul>
<li>验证radowsgw存储池</li>
</ul>
<p>初始化完成 radosgw 之后，会初始化默认的存储池如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cephstore@ceph-deploy:~/ceph-cluster$ ceph osd pool ls</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1629477239528-ccacbdf2-6d54-416b-aa15-98b06db0c5d6.png" alt="img"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>DB-转载-python-redis</title>
    <url>/posts/35830.html</url>
    <content><![CDATA[<p>python 操作 Redis</p>
<a id="more"></a>

<h1 id="python–redis"><a href="#python–redis" class="headerlink" title="python–redis"></a><a href="https://www.cnblogs.com/liuqingzheng/articles/9833534.html">python–redis</a></h1><h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一 简介"></a>一 简介</h2><p>redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 使用Redis有哪些好处？</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 支持丰富数据类型，支持string，list，set，sorted set，hash</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> redis相比memcached有哪些优势？</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) redis的速度比memcached快很多</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>) redis可以持久化其数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> redis常见性能问题和解决方案：</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>) 尽量避免在压力很大的主库上增加从库</span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3...</span><br><span class="line"></span><br><span class="line">这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> MySQL里有<span class="number">2000</span>w数据，redis中只存<span class="number">20</span>w的数据，如何保证redis中的数据都是热点数据</span><br><span class="line"></span><br><span class="line"> 相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。redis 提供 <span class="number">6</span>种数据淘汰策略：</span><br><span class="line"></span><br><span class="line">voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</span><br><span class="line"></span><br><span class="line">volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</span><br><span class="line"></span><br><span class="line">volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</span><br><span class="line"></span><br><span class="line">allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</span><br><span class="line"></span><br><span class="line">allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</span><br><span class="line"></span><br><span class="line">no-enviction（驱逐）：禁止驱逐数据</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> Memcache与Redis的区别都有哪些？</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>)、存储方式</span><br><span class="line"></span><br><span class="line">Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。</span><br><span class="line"></span><br><span class="line">Redis有部份存在硬盘上，这样能保证数据的持久性。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)、数据支持类型</span><br><span class="line"></span><br><span class="line">Memcache对数据类型支持相对简单。</span><br><span class="line"></span><br><span class="line">Redis有复杂的数据类型。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>），value大小</span><br><span class="line"></span><br><span class="line">redis最大可以达到<span class="number">1</span>GB，而memcache只有<span class="number">1</span>MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> Redis 常见的性能问题都有哪些？如何解决？</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="number">1</span>).Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>).Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="number">3</span>).Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>). Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>, redis 最适合的场景</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Redis最适合所有数据in-momory的场景，虽然Redis也提供持久化功能，但实际更多的是一个disk-backed的功能，跟传统意义上的持久化有比较大的差别，那么可能大家就会有疑问，似乎Redis更像一个加强版的Memcached，那么何时使用Memcached,何时使用Redis呢?</span><br><span class="line"></span><br><span class="line">       如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span> 、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</span><br><span class="line">     <span class="number">2</span> 、Redis支持数据的备份，即master-slave模式的数据备份。</span><br><span class="line">     <span class="number">3</span> 、Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）、会话缓存（Session Cache）</span><br><span class="line"></span><br><span class="line">最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？</span><br><span class="line"></span><br><span class="line">幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）、全页缓存（FPC）</span><br><span class="line"></span><br><span class="line">除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。</span><br><span class="line"></span><br><span class="line">再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。</span><br><span class="line"></span><br><span class="line">此外，对WordPress的用户来说，Pantheon有一个非常好的插件  wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）、队列</span><br><span class="line"></span><br><span class="line">Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。</span><br><span class="line"></span><br><span class="line">如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>），排行榜/计数器</span><br><span class="line"></span><br><span class="line">Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的<span class="number">10</span>个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：</span><br><span class="line"></span><br><span class="line">当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：</span><br><span class="line"></span><br><span class="line">ZRANGE user_scores <span class="number">0</span> <span class="number">10</span> WITHSCORES</span><br><span class="line"></span><br><span class="line">Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。</span><br><span class="line"></span><br><span class="line">（<span class="number">5</span>）、发布/订阅</span><br><span class="line"></span><br><span class="line">最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。</span><br><span class="line"></span><br><span class="line">Redis提供的所有特性中，我感觉这个是喜欢的人最少的一个，虽然它为用户提供如果此多功能。</span><br></pre></td></tr></table></figure>


<p><strong>支持的数据类型（5大数据类型）</strong></p>
<p><a href="https://img2018.cnblogs.com/blog/1350514/201810/1350514-20181022174851255-1938821619.png"><img src="https://img2018.cnblogs.com/blog/1350514/201810/1350514-20181022174851255-1938821619.png" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis&#x3D;&#123;</span><br><span class="line">        k1:&#39;123&#39;,      字符串</span><br><span class="line">        k2:[1,2,3,4],   列表&#x2F;数组</span><br><span class="line">        k3:&#123;1,2,3,4&#125;     集合</span><br><span class="line">        k4:&#123;name:lqz,age:12&#125;  字典&#x2F;哈希表</span><br><span class="line">        k5:&#123;(&#39;lqz&#39;,18),(&#39;egon&#39;,33)&#125;  有序集合</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>特点：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以持久化</span><br><span class="line">单线程，单进程</span><br></pre></td></tr></table></figure>

<h2 id="二-redis的安装和使用"><a href="#二-redis的安装和使用" class="headerlink" title="二 redis的安装和使用"></a>二 redis的安装和使用</h2><p><strong>linux下安装</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-3.0.6.tar.gz</span><br><span class="line">tar xzf redis-3.0.6.tar.gz</span><br><span class="line">cd redis-3.0.6</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p><strong>启动服务端</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">src&#x2F;redis-server</span><br></pre></td></tr></table></figure>

<p><strong>启动客户端</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">src&#x2F;redis-cli</span><br><span class="line">redis&gt; set foo bar</span><br><span class="line">OK</span><br><span class="line">redis&gt; get foo</span><br><span class="line">&quot;bar&quot;</span><br></pre></td></tr></table></figure>

<h2 id="三-Python操作Redis之安装和支持存储类型"><a href="#三-Python操作Redis之安装和支持存储类型" class="headerlink" title="三 Python操作Redis之安装和支持存储类型"></a>三 Python操作Redis之安装和支持存储类型</h2><p><strong>安装redis模块</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install redis</span><br></pre></td></tr></table></figure>

<h2 id="四-Python操作Redis之普通连接"><a href="#四-Python操作Redis之普通连接" class="headerlink" title="四 Python操作Redis之普通连接"></a>四 Python操作Redis之普通连接</h2><p>redis-py提供两个类Redis和StrictRedis用于实现Redis的命令，StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令，Redis是StrictRedis的子类，用于向后兼容旧版本的redis-py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import redis</span><br><span class="line"></span><br><span class="line">r &#x3D; redis.Redis(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;6379)</span><br><span class="line">r.set(&#39;foo&#39;, &#39;Bar&#39;)</span><br><span class="line">print(r.get(&#39;foo&#39;))</span><br></pre></td></tr></table></figure>

<h2 id="四-Python操作Redis之连接池"><a href="#四-Python操作Redis之连接池" class="headerlink" title="四 Python操作Redis之连接池"></a>四 Python操作Redis之连接池</h2><p>redis-py使用connection pool来管理对一个redis server的所有连接，避免每次建立、释放连接的开销。默认，每个Redis实例都会维护一个自己的连接池。可以直接建立一个连接池，然后作为参数Redis，这样就可以实现多个Redis实例共享一个连接池</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import redis</span><br><span class="line"></span><br><span class="line">pool &#x3D; redis.ConnectionPool(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;6379)</span><br><span class="line">r &#x3D; redis.Redis(connection_pool&#x3D;pool)</span><br><span class="line">r.set(&#39;foo&#39;, &#39;Bar&#39;)</span><br><span class="line">print(r.get(&#39;foo&#39;))</span><br></pre></td></tr></table></figure>



<h2 id="五-操作之String操作"><a href="#五-操作之String操作" class="headerlink" title="五 操作之String操作"></a>五 操作之String操作</h2><p>String操作，redis中的String在在内存中按照一个name对应一个value来存储。如图：</p>
<p><a href="https://img2018.cnblogs.com/blog/1350514/201810/1350514-20181022175533950-849327963.png"><img src="https://img2018.cnblogs.com/blog/1350514/201810/1350514-20181022175533950-849327963.png" alt="img"></a></p>
<p><strong>set(name, value, ex=None, px=None, nx=False, xx=False)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在Redis中设置值，默认，不存在则创建，存在则修改</span><br><span class="line">参数：</span><br><span class="line">     ex，过期时间（秒）</span><br><span class="line">     px，过期时间（毫秒）</span><br><span class="line">     nx，如果设置为True，则只有name不存在时，当前set操作才执行,值存在，就修改不了，执行没效果</span><br><span class="line">     xx，如果设置为True，则只有name存在时，当前set操作才执行，值存在才能修改，值不存在，不会设置新值</span><br></pre></td></tr></table></figure>

<p><strong>setnx(name, value)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置值，只有name不存在时，执行设置操作（添加）,如果存在，不会修改</span><br></pre></td></tr></table></figure>

<p><strong>setex(name, value, time)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置值</span><br><span class="line"># 参数：</span><br><span class="line">    # time，过期时间（数字秒 或 timedelta对象）</span><br></pre></td></tr></table></figure>

<p><strong>psetex(name, time_ms, value)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置值</span><br><span class="line"># 参数：</span><br><span class="line">    # time_ms，过期时间（数字毫秒 或 timedelta对象</span><br></pre></td></tr></table></figure>

<p><strong>mset(*args, \</strong>kwargs)**</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">批量设置值</span><br><span class="line">如：</span><br><span class="line">    mset(k1&#x3D;&#39;v1&#39;, k2&#x3D;&#39;v2&#39;)</span><br><span class="line">    或</span><br><span class="line">    mget(&#123;&#39;k1&#39;: &#39;v1&#39;, &#39;k2&#39;: &#39;v2&#39;&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>get(name)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取值</span><br></pre></td></tr></table></figure>

<p><strong>mget(keys, *args)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">批量获取</span><br><span class="line">如：</span><br><span class="line">    mget(&#39;k1&#39;, &#39;k2&#39;)</span><br><span class="line">    或</span><br><span class="line">    r.mget([&#39;k3&#39;, &#39;k4&#39;])</span><br></pre></td></tr></table></figure>

<p><strong>getset(name, value)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置新值并获取原来的值</span><br></pre></td></tr></table></figure>

<p><strong>getrange(key, start, end)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取子序列（根据字节获取，非字符）</span><br><span class="line"># 参数：</span><br><span class="line">    # name，Redis 的 name</span><br><span class="line">    # start，起始位置（字节）</span><br><span class="line">    # end，结束位置（字节）</span><br><span class="line"># 如： &quot;刘清政&quot; ，0-3表示 &quot;刘&quot;</span><br></pre></td></tr></table></figure>


<p><strong>setrange(name, offset, value)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改字符串内容，从指定字符串索引开始向后替换（新值太长时，则向后添加）</span><br><span class="line"># 参数：</span><br><span class="line">    # offset，字符串的索引，字节（一个汉字三个字节）</span><br><span class="line">    # value，要设置的值</span><br></pre></td></tr></table></figure>

<p><strong>setbit(name, offset, value)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 对name对应值的二进制表示的位进行操作</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis的name</span><br><span class="line">    # offset，位的索引（将值变换成二进制后再进行索引）</span><br><span class="line">    # value，值只能是 1 或 0</span><br><span class="line"> </span><br><span class="line"># 注：如果在Redis中有一个对应： n1 &#x3D; &quot;foo&quot;，</span><br><span class="line">        那么字符串foo的二进制表示为：01100110 01101111 01101111</span><br><span class="line">    所以，如果执行 setbit(&#39;n1&#39;, 7, 1)，则就会将第7位设置为1，</span><br><span class="line">        那么最终二进制则变成 01100111 01101111 01101111，即：&quot;goo&quot;</span><br></pre></td></tr></table></figure>


<p><strong>getbit(name, offset)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取name对应的值的二进制表示中的某位的值 （0或1）</span><br></pre></td></tr></table></figure>

<p><strong>bitcount(key, start=None, end=None)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取name对应的值的二进制表示中 1 的个数</span><br><span class="line"># 参数：</span><br><span class="line">    # key，Redis的name</span><br><span class="line">    # start，位起始位置</span><br><span class="line">    # end，位结束位置</span><br></pre></td></tr></table></figure>

<p><strong>bitop(operation, dest, *keys)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取多个值，并将值做位运算，将最后的结果保存至新的name对应的值</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # operation,AND（并） 、 OR（或） 、 NOT（非） 、 XOR（异或）</span><br><span class="line">    # dest, 新的Redis的name</span><br><span class="line">    # *keys,要查找的Redis的name</span><br><span class="line"> </span><br><span class="line"># 如：</span><br><span class="line">    bitop(&quot;AND&quot;, &#39;new_name&#39;, &#39;n1&#39;, &#39;n2&#39;, &#39;n3&#39;)</span><br><span class="line">    # 获取Redis中n1,n2,n3对应的值，然后讲所有的值做位运算（求并集），然后将结果保存 new_name 对应的值中</span><br></pre></td></tr></table></figure>


<p><strong>strlen(name)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 返回name对应值的字节长度（一个汉字3个字节）</span><br></pre></td></tr></table></figure>

<p><strong>incr(self, name, amount=1)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name,Redis的name</span><br><span class="line">    # amount,自增数（必须是整数）</span><br><span class="line"> </span><br><span class="line"># 注：同incrby</span><br></pre></td></tr></table></figure>


<p><strong>incrbyfloat(self, name, amount=1.0)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name,Redis的name</span><br><span class="line">    # amount,自增数（浮点型）</span><br></pre></td></tr></table></figure>

<p><strong>decr(self, name, amount=1)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 自减 name对应的值，当name不存在时，则创建name＝amount，否则，则自减。</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name,Redis的name</span><br><span class="line">    # amount,自减数（整数）</span><br></pre></td></tr></table></figure>

<p><strong>append(key, value)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在redis name对应的值后面追加内容</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    key, redis的name</span><br><span class="line">    value, 要追加的字符串</span><br></pre></td></tr></table></figure>

<h2 id="六-操作之Hash操作"><a href="#六-操作之Hash操作" class="headerlink" title="六 操作之Hash操作"></a>六 操作之Hash操作</h2><p>Hash操作，redis中Hash在内存中的存储格式如下图：</p>
<p><a href="https://img2018.cnblogs.com/blog/1350514/201810/1350514-20181022195454464-123231904.png"><img src="https://img2018.cnblogs.com/blog/1350514/201810/1350514-20181022195454464-123231904.png" alt="img"></a></p>
<p><strong>hset(name, key, value)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># name对应的hash中设置一个键值对（不存在，则创建；否则，修改）</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis的name</span><br><span class="line">    # key，name对应的hash中的key</span><br><span class="line">    # value，name对应的hash中的value</span><br><span class="line"> </span><br><span class="line"># 注：</span><br><span class="line">    # hsetnx(name, key, value),当name对应的hash中不存在当前key时则创建（相当于添加）</span><br></pre></td></tr></table></figure>


<p><strong>hmset(name, mapping)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的hash中批量设置键值对</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis的name</span><br><span class="line">    # mapping，字典，如：&#123;&#39;k1&#39;:&#39;v1&#39;, &#39;k2&#39;: &#39;v2&#39;&#125;</span><br><span class="line"> </span><br><span class="line"># 如：</span><br><span class="line">    # r.hmset(&#39;xx&#39;, &#123;&#39;k1&#39;:&#39;v1&#39;, &#39;k2&#39;: &#39;v2&#39;&#125;)</span><br></pre></td></tr></table></figure>


<p><strong>hget(name,key)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的hash中获取根据key获取value</span><br></pre></td></tr></table></figure>

<p><strong>hmget(name, keys, *args)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的hash中获取多个key的值</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name，reids对应的name</span><br><span class="line">    # keys，要获取key集合，如：[&#39;k1&#39;, &#39;k2&#39;, &#39;k3&#39;]</span><br><span class="line">    # *args，要获取的key，如：k1,k2,k3</span><br><span class="line"> </span><br><span class="line"># 如：</span><br><span class="line">    # r.mget(&#39;xx&#39;, [&#39;k1&#39;, &#39;k2&#39;])</span><br><span class="line">    # 或</span><br><span class="line">    # print r.hmget(&#39;xx&#39;, &#39;k1&#39;, &#39;k2&#39;)</span><br></pre></td></tr></table></figure>


<p><strong>hgetall(name)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取name对应hash的所有键值</span><br><span class="line">print(re.hgetall(&#39;xxx&#39;).get(b&#39;name&#39;))</span><br></pre></td></tr></table></figure>

<p><strong>hlen(name)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取name对应的hash中键值对的个数</span><br></pre></td></tr></table></figure>

<p><strong>hkeys(name)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取name对应的hash中所有的key的值</span><br></pre></td></tr></table></figure>

<p><strong>hvals(name)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取name对应的hash中所有的value的值</span><br></pre></td></tr></table></figure>

<p><strong>hexists(name, key)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 检查name对应的hash是否存在当前传入的key</span><br></pre></td></tr></table></figure>

<p><strong>hdel(name,*keys)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将name对应的hash中指定key的键值对删除</span><br><span class="line">print(re.hdel(&#39;xxx&#39;,&#39;sex&#39;,&#39;name&#39;))</span><br></pre></td></tr></table></figure>

<p><strong>hincrby(name, key, amount=1)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 自增name对应的hash中的指定key的值，不存在则创建key&#x3D;amount</span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis中的name</span><br><span class="line">    # key， hash对应的key</span><br><span class="line">    # amount，自增数（整数）</span><br></pre></td></tr></table></figure>

<p><strong>hincrbyfloat(name, key, amount=1.0)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 自增name对应的hash中的指定key的值，不存在则创建key&#x3D;amount</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis中的name</span><br><span class="line">    # key， hash对应的key</span><br><span class="line">    # amount，自增数（浮点数）</span><br><span class="line"> </span><br><span class="line"># 自增name对应的hash中的指定key的值，不存在则创建key&#x3D;amount</span><br></pre></td></tr></table></figure>


<p><strong>hscan(name, cursor=0, match=None, count=None)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 增量式迭代获取，对于数据大的数据非常有用，hscan可以实现分片的获取数据，并非一次性将数据全部获取完，从而放置内存被撑爆</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis的name</span><br><span class="line">    # cursor，游标（基于游标分批取获取数据）</span><br><span class="line">    # match，匹配指定key，默认None 表示所有的key</span><br><span class="line">    # count，每次分片最少获取个数，默认None表示采用Redis的默认分片个数</span><br><span class="line"> </span><br><span class="line"># 如：</span><br><span class="line">    # 第一次：cursor1, data1 &#x3D; r.hscan(&#39;xx&#39;, cursor&#x3D;0, match&#x3D;None, count&#x3D;None)</span><br><span class="line">    # 第二次：cursor2, data1 &#x3D; r.hscan(&#39;xx&#39;, cursor&#x3D;cursor1, match&#x3D;None, count&#x3D;None)</span><br><span class="line">    # ...</span><br><span class="line">    # 直到返回值cursor的值为0时，表示数据已经通过分片获取完毕</span><br></pre></td></tr></table></figure>


<p><strong>hscan_iter(name, match=None, count=None)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 利用yield封装hscan创建生成器，实现分批去redis中获取数据</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # match，匹配指定key，默认None 表示所有的key</span><br><span class="line">    # count，每次分片最少获取个数，默认None表示采用Redis的默认分片个数</span><br><span class="line"> </span><br><span class="line"># 如：</span><br><span class="line">    # for item in r.hscan_iter(&#39;xx&#39;):</span><br><span class="line">    #     print item</span><br></pre></td></tr></table></figure>


<h2 id="七-操作之List操作"><a href="#七-操作之List操作" class="headerlink" title="七 操作之List操作"></a>七 操作之List操作</h2><p>List操作，redis中的List在在内存中按照一个name对应一个List来存储。如图：</p>
<p><a href="https://img2018.cnblogs.com/blog/1350514/201810/1350514-20181022211822785-370585666.png"><img src="https://img2018.cnblogs.com/blog/1350514/201810/1350514-20181022211822785-370585666.png" alt="img"></a></p>
<p><strong>lpush(name,values)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的list中添加元素，每个新的元素都添加到列表的最左边</span><br><span class="line"> </span><br><span class="line"># 如：</span><br><span class="line">    # r.lpush(&#39;oo&#39;, 11,22,33)</span><br><span class="line">    # 保存顺序为: 33,22,11</span><br><span class="line"> </span><br><span class="line"># 扩展：</span><br><span class="line">    # rpush(name, values) 表示从右向左操作</span><br></pre></td></tr></table></figure>


<p><strong>lpushx(name,value)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边</span><br><span class="line"> </span><br><span class="line"># 更多：</span><br><span class="line">    # rpushx(name, value) 表示从右向左操作</span><br></pre></td></tr></table></figure>

<p><strong>llen(name)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># name对应的list元素的个数</span><br></pre></td></tr></table></figure>

<p><strong>linsert(name, where, refvalue, value))</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的列表的某一个值前或后插入一个新值</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis的name</span><br><span class="line">    # where，BEFORE或AFTER(小写也可以)</span><br><span class="line">    # refvalue，标杆值，即：在它前后插入数据（如果存在多个标杆值，以找到的第一个为准）</span><br><span class="line">    # value，要插入的数据</span><br></pre></td></tr></table></figure>



<p><strong>r.lset(name, index, value)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 对name对应的list中的某一个索引位置重新赋值</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis的name</span><br><span class="line">    # index，list的索引位置</span><br><span class="line">    # value，要设置的值</span><br></pre></td></tr></table></figure>



<p><strong>r.lrem(name, value, num)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的list中删除指定的值</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis的name</span><br><span class="line">    # value，要删除的值</span><br><span class="line">    # num，  num&#x3D;0，删除列表中所有的指定值；</span><br><span class="line">           # num&#x3D;2,从前到后，删除2个；</span><br><span class="line">           # num&#x3D;-2,从后向前，删除2个</span><br></pre></td></tr></table></figure>


<p><strong>lpop(name)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的列表的左侧获取第一个元素并在列表中移除，返回值则是第一个元素</span><br><span class="line"> </span><br><span class="line"># 更多：</span><br><span class="line">    # rpop(name) 表示从右向左操作</span><br></pre></td></tr></table></figure>

<p><strong>lindex(name, index)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在name对应的列表中根据索引获取列表元素</span><br></pre></td></tr></table></figure>

<p><strong>lrange(name, start, end)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的列表分片获取数据</span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis的name</span><br><span class="line">    # start，索引的起始位置</span><br><span class="line">    # end，索引结束位置  print(re.lrange(&#39;aa&#39;,0,re.llen(&#39;aa&#39;)))</span><br></pre></td></tr></table></figure>

<p><strong>ltrim(name, start, end)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的列表中移除没有在start-end索引之间的值</span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis的name</span><br><span class="line">    # start，索引的起始位置</span><br><span class="line">    # end，索引结束位置（大于列表长度，则代表不移除任何）</span><br></pre></td></tr></table></figure>

<p><strong>rpoplpush(src, dst)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边</span><br><span class="line"># 参数：</span><br><span class="line">    # src，要取数据的列表的name</span><br><span class="line">    # dst，要添加数据的列表的name</span><br></pre></td></tr></table></figure>

<p><strong>blpop(keys, timeout)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将多个列表排列，按照从左到右去pop对应列表的元素</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # keys，redis的name的集合</span><br><span class="line">    # timeout，超时时间，当元素所有列表的元素获取完之后，阻塞等待列表内有数据的时间（秒）, 0 表示永远阻塞</span><br><span class="line"> </span><br><span class="line"># 更多：</span><br><span class="line">    # r.brpop(keys, timeout)，从右向左获取数据</span><br><span class="line">爬虫实现简单分布式：多个url放到列表里，往里不停放URL，程序循环取值，但是只能一台机器运行取值，可以把url放到redis中，多台机器从redis中取值，爬取数据，实现简单分布式</span><br></pre></td></tr></table></figure>


<p><strong>brpoplpush(src, dst, timeout=0)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 从一个列表的右侧移除一个元素并将其添加到另一个列表的左侧</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # src，取出并要移除元素的列表对应的name</span><br><span class="line">    # dst，要插入元素的列表对应的name</span><br><span class="line">    # timeout，当src对应的列表中没有数据时，阻塞等待其有数据的超时时间（秒），0 表示永远阻塞</span><br></pre></td></tr></table></figure>


<p><strong>自定义增量迭代</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 由于redis类库中没有提供对列表元素的增量迭代，如果想要循环name对应的列表的所有元素，那么就需要：</span><br><span class="line">    # 1、获取name对应的所有列表</span><br><span class="line">    # 2、循环列表</span><br><span class="line"># 但是，如果列表非常大，那么就有可能在第一步时就将程序的内容撑爆，所有有必要自定义一个增量迭代的功能：</span><br><span class="line">import redis</span><br><span class="line">conn&#x3D;redis.Redis(host&#x3D;&#39;127.0.0.1&#39;,port&#x3D;6379)</span><br><span class="line"># conn.lpush(&#39;test&#39;,*[1,2,3,4,45,5,6,7,7,8,43,5,6,768,89,9,65,4,23,54,6757,8,68])</span><br><span class="line"># conn.flushall()</span><br><span class="line">def scan_list(name,count&#x3D;2):</span><br><span class="line">    index&#x3D;0</span><br><span class="line">    while True:</span><br><span class="line">        data_list&#x3D;conn.lrange(name,index,count+index-1)</span><br><span class="line">        if not data_list:</span><br><span class="line">            return</span><br><span class="line">        index+&#x3D;count</span><br><span class="line">        for item in data_list:</span><br><span class="line">            yield item</span><br><span class="line">print(conn.lrange(&#39;test&#39;,0,100))</span><br><span class="line">for item in scan_list(&#39;test&#39;,5):</span><br><span class="line">    print(&#39;---&#39;)</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>




<h2 id="八-操作之Set操作"><a href="#八-操作之Set操作" class="headerlink" title="八 操作之Set操作"></a>八 操作之Set操作</h2><p>Set操作，Set集合就是不允许重复的列表</p>
<p> <strong>sadd(name,values)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># name对应的集合中添加元素</span><br></pre></td></tr></table></figure>

<p><strong>scard(name)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取name对应的集合中元素个数</span><br></pre></td></tr></table></figure>

<p><strong>sdiff(keys, *args)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在第一个name对应的集合中且不在其他name对应的集合的元素集合</span><br></pre></td></tr></table></figure>

<p><strong>sdiffstore(dest, keys, *args)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取第一个name对应的集合中且不在其他name对应的集合，再将其新加入到dest对应的集合中</span><br></pre></td></tr></table></figure>

<p><strong>sinter(keys, *args)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取多一个name对应集合的并集</span><br></pre></td></tr></table></figure>

<p><strong>sinterstore(dest, keys, *args)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取多一个name对应集合的并集，再讲其加入到dest对应的集合中</span><br></pre></td></tr></table></figure>

<p><strong>sismember(name, value)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 检查value是否是name对应的集合的成员</span><br></pre></td></tr></table></figure>

<p><strong>smembers(name)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取name对应的集合的所有成员</span><br></pre></td></tr></table></figure>

<p><strong>smove(src, dst, value)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将某个成员从一个集合中移动到另外一个集合</span><br></pre></td></tr></table></figure>

<p><strong>spop(name)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 从集合的右侧（尾部）移除一个成员，并将其返回</span><br></pre></td></tr></table></figure>

<p><strong>srandmember(name, numbers)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 从name对应的集合中随机获取 numbers 个元素</span><br></pre></td></tr></table></figure>

<p><strong>srem(name, values)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的集合中删除某些值</span><br></pre></td></tr></table></figure>

<p><strong>srem(name, values)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的集合中删除某些值</span><br></pre></td></tr></table></figure>

<p><strong>sunion(keys, *args)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取多一个name对应的集合的并集</span><br></pre></td></tr></table></figure>

<p><strong>sunionstore(dest,keys, *args)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取多一个name对应的集合的并集，并将结果保存到dest对应的集合中</span><br></pre></td></tr></table></figure>

<p><strong>sscan(name, cursor=0, match=None, count=None)</strong><br><strong>sscan_iter(name, match=None, count=None)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 同字符串的操作，用于增量迭代分批获取元素，避免内存消耗太大</span><br></pre></td></tr></table></figure>

<p><strong>有序集合，在集合的基础上，为每元素排序；元素的排序需要根据另外一个值来进行比较，所以，对于有序集合，每一个元素有两个值，即：值和分数，分数专门用来做排序。</strong></p>
<p> <strong>zadd(name, *args, \</strong>kwargs)**</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的有序集合中添加元素</span><br><span class="line"># 如：</span><br><span class="line">     # zadd(&#39;zz&#39;, &#39;n1&#39;, 1, &#39;n2&#39;, 2)</span><br><span class="line">     # 或</span><br><span class="line">     # zadd(&#39;zz&#39;, n1&#x3D;11, n2&#x3D;22)</span><br></pre></td></tr></table></figure>

<p><strong>zcard(name)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取name对应的有序集合元素的数量</span><br></pre></td></tr></table></figure>

<p><strong>zcount(name, min, max)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取name对应的有序集合中分数 在 [min,max] 之间的个数</span><br></pre></td></tr></table></figure>

<p><strong>zincrby(name, value, amount)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 自增name对应的有序集合的 name 对应的分数</span><br></pre></td></tr></table></figure>

<p><strong>r.zrange( name, start, end, desc=False, withscores=False, score_cast_func=float)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 按照索引范围获取name对应的有序集合的元素</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis的name</span><br><span class="line">    # start，有序集合索引起始位置（非分数）</span><br><span class="line">    # end，有序集合索引结束位置（非分数）</span><br><span class="line">    # desc，排序规则，默认按照分数从小到大排序</span><br><span class="line">    # withscores，是否获取元素的分数，默认只获取元素的值</span><br><span class="line">    # score_cast_func，对分数进行数据转换的函数</span><br><span class="line"> </span><br><span class="line"># 更多：</span><br><span class="line">    # 从大到小排序</span><br><span class="line">    # zrevrange(name, start, end, withscores&#x3D;False, score_cast_func&#x3D;float)</span><br><span class="line"> </span><br><span class="line">    # 按照分数范围获取name对应的有序集合的元素</span><br><span class="line">    # zrangebyscore(name, min, max, start&#x3D;None, num&#x3D;None, withscores&#x3D;False, score_cast_func&#x3D;float)</span><br><span class="line">    # 从大到小排序</span><br><span class="line">    # zrevrangebyscore(name, max, min, start&#x3D;None, num&#x3D;None, withscores&#x3D;False, score_cast_func&#x3D;float)</span><br></pre></td></tr></table></figure>



<p><strong>zrank(name, value)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取某个值在 name对应的有序集合中的排行（从 0 开始）</span><br><span class="line"> </span><br><span class="line"># 更多：</span><br><span class="line">    # zrevrank(name, value)，从大到小排序</span><br></pre></td></tr></table></figure>

<p><strong>zrangebylex(name, min, max, start=None, num=None)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 当有序集合的所有成员都具有相同的分值时，有序集合的元素会根据成员的 值 （lexicographical ordering）来进行排序，而这个命令则可以返回给定的有序集合键 key 中， 元素的值介于 min 和 max 之间的成员</span><br><span class="line"># 对集合中的每个成员进行逐个字节的对比（byte-by-byte compare）， 并按照从低到高的顺序， 返回排序后的集合成员。 如果两个字符串有一部分内容是相同的话， 那么命令会认为较长的字符串比较短的字符串要大</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis的name</span><br><span class="line">    # min，左区间（值）。 + 表示正无限； - 表示负无限； ( 表示开区间； [ 则表示闭区间</span><br><span class="line">    # min，右区间（值）</span><br><span class="line">    # start，对结果进行分片处理，索引位置</span><br><span class="line">    # num，对结果进行分片处理，索引后面的num个元素</span><br><span class="line"> </span><br><span class="line"># 如：</span><br><span class="line">    # ZADD myzset 0 aa 0 ba 0 ca 0 da 0 ea 0 fa 0 ga</span><br><span class="line">    # r.zrangebylex(&#39;myzset&#39;, &quot;-&quot;, &quot;[ca&quot;) 结果为：[&#39;aa&#39;, &#39;ba&#39;, &#39;ca&#39;]</span><br><span class="line"> </span><br><span class="line"># 更多：</span><br><span class="line">    # 从大到小排序</span><br><span class="line">    # zrevrangebylex(name, max, min, start&#x3D;None, num&#x3D;None)</span><br></pre></td></tr></table></figure>


<p><strong>zrem(name, values)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 删除name对应的有序集合中值是values的成员</span><br><span class="line"> </span><br><span class="line"># 如：zrem(&#39;zz&#39;, [&#39;s1&#39;, &#39;s2&#39;])</span><br></pre></td></tr></table></figure>

<p><strong>zremrangebyrank(name, min, max)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 根据排行范围删除</span><br></pre></td></tr></table></figure>

<p><strong>zremrangebyscore(name, min, max)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 根据分数范围删除</span><br></pre></td></tr></table></figure>

<p><strong>zremrangebylex(name, min, max)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 根据值返回删除</span><br></pre></td></tr></table></figure>

<p><strong>zscore(name, value)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取name对应有序集合中 value 对应的分数</span><br></pre></td></tr></table></figure>

<p><strong>zinterstore(dest, keys, aggregate=None)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取两个有序集合的交集，如果遇到相同值不同分数，则按照aggregate进行操作</span><br><span class="line"># aggregate的值为:  SUM  MIN  MAX</span><br></pre></td></tr></table></figure>

<p><strong>zunionstore(dest, keys, aggregate=None)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取两个有序集合的并集，如果遇到相同值不同分数，则按照aggregate进行操作</span><br><span class="line"># aggregate的值为:  SUM  MIN  MAX</span><br></pre></td></tr></table></figure>

<p><strong>zscan(name, cursor=0, match=None, count=None, score_cast_func=float)</strong><br><strong>zscan_iter(name, match=None, count=None,score_cast_func=float)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 同字符串相似，相较于字符串新增score_cast_func，用来对分数进行操作</span><br></pre></td></tr></table></figure>

<h2 id="九-其它操作"><a href="#九-其它操作" class="headerlink" title="九 其它操作"></a>九 其它操作</h2><p><strong>delete(*names)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 根据删除redis中的任意数据类型</span><br></pre></td></tr></table></figure>

<p><strong>exists(name)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 检测redis的name是否存在</span><br></pre></td></tr></table></figure>

<p><strong>keys(pattern=’*‘)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 根据模型获取redis的name</span><br><span class="line"> </span><br><span class="line"># 更多：</span><br><span class="line">    # KEYS * 匹配数据库中所有 key 。</span><br><span class="line">    # KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。</span><br><span class="line">    # KEYS h*llo 匹配 hllo 和 heeeeello 等。</span><br><span class="line">    # KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo </span><br></pre></td></tr></table></figure>


<p><strong>expire(name ,time)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 为某个redis的某个name设置超时时间</span><br></pre></td></tr></table></figure>

<p><strong>rename(src, dst)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 对redis的name重命名为</span><br></pre></td></tr></table></figure>

<p><strong>move(name, db))</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将redis的某个值移动到指定的db下</span><br></pre></td></tr></table></figure>

<p><strong>randomkey()</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 随机获取一个redis的name（不删除）</span><br></pre></td></tr></table></figure>

<p><strong>type(name)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取name对应值的类型</span><br></pre></td></tr></table></figure>

<p><strong>scan(cursor=0, match=None, count=None)</strong><br><strong>scan_iter(match=None, count=None)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 同字符串操作，用于增量迭代获取key</span><br></pre></td></tr></table></figure>

<h2 id="十一-管道"><a href="#十一-管道" class="headerlink" title="十一 管道"></a>十一 管道</h2><p>redis-py默认在执行每次请求都会创建（连接池申请连接）和断开（归还连接池）一次连接操作，如果想要在一次请求中指定多个命令，则可以使用pipline实现一次请求指定多个命令，并且默认情况下一次pipline 是原子性操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import redis</span><br><span class="line"> </span><br><span class="line">pool &#x3D; redis.ConnectionPool(host&#x3D;&#39;10.211.55.4&#39;, port&#x3D;6379)</span><br><span class="line"> </span><br><span class="line">r &#x3D; redis.Redis(connection_pool&#x3D;pool)</span><br><span class="line"> </span><br><span class="line"># pipe &#x3D; r.pipeline(transaction&#x3D;False)</span><br><span class="line">pipe &#x3D; r.pipeline(transaction&#x3D;True)</span><br><span class="line">pipe.multi()</span><br><span class="line">pipe.set(&#39;name&#39;, &#39;alex&#39;)</span><br><span class="line">pipe.set(&#39;role&#39;, &#39;sb&#39;)</span><br><span class="line"> </span><br><span class="line">pipe.execute()</span><br></pre></td></tr></table></figure>


<h2 id="十二-Django中使用redis"><a href="#十二-Django中使用redis" class="headerlink" title="十二 Django中使用redis"></a>十二 Django中使用redis</h2><p><strong>方式一：</strong></p>
<p>utils文件夹下，建立redis_pool.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import redis</span><br><span class="line">POOL &#x3D; redis.ConnectionPool(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;6379,password&#x3D;&#39;1234&#39;,max_connections&#x3D;1000)</span><br></pre></td></tr></table></figure>

<p>视图函数中使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import redis</span><br><span class="line">from django.shortcuts import render,HttpResponse</span><br><span class="line">from utils.redis_pool import POOL</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    conn &#x3D; redis.Redis(connection_pool&#x3D;POOL)</span><br><span class="line">    conn.hset(&#39;kkk&#39;,&#39;age&#39;,18)</span><br><span class="line"></span><br><span class="line">    return HttpResponse(&#39;设置成功&#39;)</span><br><span class="line">def order(request):</span><br><span class="line">    conn &#x3D; redis.Redis(connection_pool&#x3D;POOL)</span><br><span class="line">    conn.hget(&#39;kkk&#39;,&#39;age&#39;)</span><br><span class="line"></span><br><span class="line">    return HttpResponse(&#39;获取成功&#39;)</span><br></pre></td></tr></table></figure>

<p><strong>方式二：</strong></p>
<p>安装django-redis模块</p>
<p>pip3 install django-redis</p>
<p>setting里配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># redis配置</span><br><span class="line">CACHES &#x3D; &#123;</span><br><span class="line">    &quot;default&quot;: &#123;</span><br><span class="line">        &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;,</span><br><span class="line">        &quot;LOCATION&quot;: &quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot;,</span><br><span class="line">        &quot;OPTIONS&quot;: &#123;</span><br><span class="line">            &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;,</span><br><span class="line">            &quot;CONNECTION_POOL_KWARGS&quot;: &#123;&quot;max_connections&quot;: 100&#125;</span><br><span class="line">            # &quot;PASSWORD&quot;: &quot;123&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>视图函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django_redis import get_redis_connection</span><br><span class="line">conn &#x3D; get_redis_connection(&#39;default&#39;)</span><br><span class="line">print(conn.hgetall(&#39;xxx&#39;))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>DB-转载-redis-持久化</title>
    <url>/posts/14162.html</url>
    <content><![CDATA[<p>Redis持久化</p>
<a id="more"></a>

<p><strong>如果只是缓存场景，rdb足够用</strong></p>
<p>rdb最佳配置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 两种：</span></span><br><span class="line">    -rdb：缓存</span><br><span class="line">  -aof：对数据准确性要求高一些</span><br><span class="line"><span class="comment"># rdb：触发方式三种</span></span><br><span class="line">    -手动 save</span><br><span class="line">        </span><br><span class="line">    -手动 bgsave</span><br><span class="line">    </span><br><span class="line">    -配置文件</span><br><span class="line">    配置   seconds   changes</span><br><span class="line">    save   <span class="number">900</span>        <span class="number">1</span></span><br><span class="line">    save   <span class="number">300</span>        <span class="number">10</span></span><br><span class="line">    save   <span class="number">60</span>         <span class="number">10000</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 最佳配置</span></span><br><span class="line">save <span class="number">900</span> <span class="number">1</span> </span><br><span class="line">save <span class="number">300</span> <span class="number">10</span> </span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span> </span><br><span class="line">dbfilename dump<span class="number">-3306.</span>rdb  <span class="comment">#以端口号作为文件名，可能一台机器上很多reids，不会乱</span></span><br><span class="line">dir /bigdiskpath <span class="comment">#保存路径放到一个大硬盘位置目录</span></span><br><span class="line">stop-writes-on-bgsave-error yes <span class="comment">#出现错误停止</span></span><br><span class="line">rdbcompression yes <span class="comment">#压缩</span></span><br><span class="line">rdbchecksum yes <span class="comment">#校验</span></span><br></pre></td></tr></table></figure>

<p>aof最佳配置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">客户端每写入一条命令，都记录一条日志，放到日志文件中，如果出现宕机，可以将数据完全恢复</span><br><span class="line"></span><br><span class="line"><span class="comment"># AOF 重写</span></span><br><span class="line">    本质就是把过期的，无用的，重复的，可以优化的命令，来优化</span><br><span class="line">    这样可以减少磁盘占用量，加速恢复速度</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># aof的最佳配置</span></span><br><span class="line">appendonly yes <span class="comment">#将该选项设置为yes，打开</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly-3306.aof&quot;</span> <span class="comment">#文件保存的名字</span></span><br><span class="line">appendfsync everysec <span class="comment">#采用第二种策略</span></span><br><span class="line">dir /data <span class="comment">#存放的路径</span></span><br><span class="line">no-appendfsync-on-rewrite yes</span><br></pre></td></tr></table></figure>







<h2 id="一-持久化的作用"><a href="#一-持久化的作用" class="headerlink" title="一 持久化的作用"></a>一 持久化的作用</h2><h3 id="1-1-什么是持久化"><a href="#1-1-什么是持久化" class="headerlink" title="1.1 什么是持久化"></a>1.1 什么是持久化</h3><p>redis的所有数据保存在内存中，对数据的更新将异步的保存到硬盘上</p>
<h3 id="1-2-持久化的实现方式"><a href="#1-2-持久化的实现方式" class="headerlink" title="1.2 持久化的实现方式"></a>1.2 持久化的实现方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">快照：某时某刻数据的一个完成备份，</span><br><span class="line">    -mysql的Dump</span><br><span class="line">    -redis的RDB</span><br><span class="line">写日志：任何操作记录日志，要恢复数据，只要把日志重新走一遍即可</span><br><span class="line">    -mysql的 Binlog</span><br><span class="line">    -Hhase的 HLog</span><br><span class="line">    -Redis的 AOF</span><br></pre></td></tr></table></figure>

<h2 id="二-RDB"><a href="#二-RDB" class="headerlink" title="二 RDB"></a>二 RDB</h2><h3 id="2-1-什么是RDB"><a href="#2-1-什么是RDB" class="headerlink" title="2.1 什么是RDB"></a>2.1 什么是RDB</h3><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/006tNbRwgy1ga9zt9svljj30oo0d644s.jpg" alt="image-20191226120500154"></p>
<h3 id="2-2-触发机制-主要三种方式"><a href="#2-2-触发机制-主要三种方式" class="headerlink" title="2.2 触发机制-主要三种方式"></a>2.2 触发机制-主要三种方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">save(同步)</span></span><br><span class="line"><span class="string">1 客户端执行save命令----》redis服务端----》同步创建RDB二进制文件</span></span><br><span class="line"><span class="string">2 会造成redis的阻塞（数据量非常大的时候）</span></span><br><span class="line"><span class="string">3 文件策略：如果老的RDB存在，会替换老的</span></span><br><span class="line"><span class="string">4 复杂度 o(n)</span></span><br><span class="line"><span class="string">&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">bgsave(异步，Backgroud saving started)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1 客户端执行save命令----》redis服务端----》异步创建RDB二进制文件（fork函数生成一个子进程（fork会阻塞reids），执行createRDB，执行成功，返回给reids消息）</span></span><br><span class="line"><span class="string">2 此时访问redis，会正常响应客户端</span></span><br><span class="line"><span class="string">3 文件策略：跟save相同，如果老的RDB存在，会替换老的</span></span><br><span class="line"><span class="string">4 复杂度 o(n)</span></span><br><span class="line"><span class="string">&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">自动（通过配置）</span></span><br><span class="line"><span class="string">配置   seconds   changes</span></span><br><span class="line"><span class="string">save   900        1</span></span><br><span class="line"><span class="string">save   300        10</span></span><br><span class="line"><span class="string">save   60         10000</span></span><br><span class="line"><span class="string">如果60s中改变了1w条数据，自动生成rdb</span></span><br><span class="line"><span class="string">如果300s中改变了10条数据，自动生成rdb</span></span><br><span class="line"><span class="string">如果900s中改变了1条数据，自动生成rdb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">以上三条符合任意一条，就自动生成rdb，内部使用bgsave</span></span><br><span class="line"><span class="string">&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置：</span></span><br><span class="line">save 900 1 <span class="comment">#配置一条</span></span><br><span class="line">save 300 10 <span class="comment">#配置一条</span></span><br><span class="line">save 60 10000 <span class="comment">#配置一条</span></span><br><span class="line">dbfilename dump.rdb  <span class="comment">#rdb文件的名字，默认为dump.rdb</span></span><br><span class="line">dir ./ <span class="comment">#rdb文件存在当前目录</span></span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes <span class="comment">#如果bgsave出现错误，是否停止写入，默认为yes</span></span><br><span class="line">rdbcompression yes <span class="comment">#采用压缩格式</span></span><br><span class="line">rdbchecksum yes <span class="comment">#是否对rdb文件进行校验和检验</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#最佳配置</span></span><br><span class="line">save 900 1 </span><br><span class="line">save 300 10 </span><br><span class="line">save 60 10000 </span><br><span class="line">dbfilename dump-<span class="variable">$&#123;port&#125;</span>.rdb  <span class="comment">#以端口号作为文件名，可能一台机器上很多reids，不会乱</span></span><br><span class="line">dir /bigdiskpath <span class="comment">#保存路径放到一个大硬盘位置目录</span></span><br><span class="line">stop-writes-on-bgsave-error yes <span class="comment">#出现错误停止</span></span><br><span class="line">rdbcompression yes <span class="comment">#压缩</span></span><br><span class="line">rdbchecksum yes <span class="comment">#校验</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-触发机制-不容忽略的方式"><a href="#2-3-触发机制-不容忽略的方式" class="headerlink" title="2.3 触发机制-不容忽略的方式"></a>2.3 触发机制-不容忽略的方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 全量复制 #没有执行save和bgsave没有添加rdb策略，还会生成rdb文件，如果开启主从复制，主会自动生成rdb</span><br><span class="line">2 debug reload #debug级别的重启，不会将内存中的数据清空</span><br><span class="line">3 shutdown save#关闭会出发rdb的生成</span><br></pre></td></tr></table></figure>

<h3 id="2-4-试验"><a href="#2-4-试验" class="headerlink" title="2.4 试验"></a>2.4 试验</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="三-AOF"><a href="#三-AOF" class="headerlink" title="三 AOF"></a>三 AOF</h3><h3 id="3-1-RDB问题"><a href="#3-1-RDB问题" class="headerlink" title="3.1 RDB问题"></a>3.1 RDB问题</h3><p>耗时，耗性能：</p>
<p>不可控，可能会丢失数据</p>
<h3 id="3-2-AOF介绍"><a href="#3-2-AOF介绍" class="headerlink" title="3.2 AOF介绍"></a>3.2 AOF介绍</h3><p>客户端每写入一条命令，都记录一条日志，放到日志文件中，如果出现宕机，可以将数据完全恢复</p>
<h3 id="3-3-AOF的三种策略"><a href="#3-3-AOF的三种策略" class="headerlink" title="3.3 AOF的三种策略"></a>3.3 AOF的三种策略</h3><p>日志不是直接写到硬盘上，而是先放在缓冲区，缓冲区根据一些策略，写到硬盘上</p>
<p>always：redis–》写命令刷新的缓冲区—》每条命令fsync到硬盘—》AOF文件</p>
<p>everysec（默认值）：redis——》写命令刷新的缓冲区—》每秒把缓冲区fsync到硬盘–》AOF文件</p>
<p>no:redis——》写命令刷新的缓冲区—》操作系统决定，缓冲区fsync到硬盘–》AOF文件</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>always</th>
<th>everysec</th>
<th>no</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>不丢失数据</td>
<td>每秒一次fsync，丢失1秒数据</td>
<td>不用管</td>
</tr>
<tr>
<td>缺点</td>
<td>IO开销大，一般的sata盘只有几百TPS</td>
<td>丢1秒数据</td>
<td>不可控</td>
</tr>
</tbody></table>
<h3 id="3-4-AOF-重写"><a href="#3-4-AOF-重写" class="headerlink" title="3.4 AOF 重写"></a>3.4 AOF 重写</h3><p>随着命令的逐步写入，并发量的变大， AOF文件会越来越大，通过AOF重写来解决该问题</p>
<table>
<thead>
<tr>
<th>原生AOF</th>
<th>AOF重写</th>
</tr>
</thead>
<tbody><tr>
<td>set hello world set hello java set hello hehe incr counter incr counter rpush mylist a rpush mylist b rpush mylist c 过期数据</td>
<td>set hello hehe set counter 2 rpush mylist a b c</td>
</tr>
</tbody></table>
<p>本质就是把过期的，无用的，重复的，可以优化的命令，来优化</p>
<p>这样可以减少磁盘占用量，加速恢复速度</p>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>bgrewriteaof：</p>
<p>客户端向服务端发送bgrewriteaof命令，服务端会起一个fork进程，完成AOF重写</p>
<h4 id="AOF重写配置："><a href="#AOF重写配置：" class="headerlink" title="AOF重写配置："></a>AOF重写配置：</h4><table>
<thead>
<tr>
<th>配置名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>auto-aof-rewrite-min-size</td>
<td>AOF文件重写需要尺寸</td>
</tr>
<tr>
<td>auto-aof-rewrite-percentage</td>
<td>AOF文件增长率</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>统计名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>aof_current_size</td>
<td>AOF当前尺寸（单位：字节）</td>
</tr>
<tr>
<td>aof_base_size</td>
<td>AOF上次启动和重写的尺寸（单位：字节）</td>
</tr>
</tbody></table>
<p>自动触发时机（两个条件同时满足）：</p>
<p>aof_current_size&gt;auto-aof-rewrite-min-size：当前尺寸大于重写需要尺寸</p>
<p>(aof_current_size-aof_base_size)/aof_base_size&gt;auto-aof-rewrite-percentage:（增长率）当前尺寸减去上次重写的尺寸，除以上次重写的尺寸如果大于配置中的增长率</p>
<h4 id="重写流程"><a href="#重写流程" class="headerlink" title="重写流程"></a>重写流程</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gadsmknx2sj30fy0hw78l.jpg" alt="image-20191229185839519"></p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendonly yes #将该选项设置为yes，打开</span><br><span class="line">appendfilename &quot;appendonly-$&#123;port&#125;.aof&quot; #文件保存的名字</span><br><span class="line">appendfsync everysec #采用第二种策略</span><br><span class="line">dir &#x2F;bigdiskpath #存放的路径</span><br><span class="line">no-appendfsync-on-rewrite yes #在aof重写的时候，是否要做aof的append操作，因为aof重写消耗性能，磁盘消耗，正常aof写磁盘有一定的冲突，这段期间的数据，允许丢失</span><br></pre></td></tr></table></figure>

<h3 id="3-5-AOF-重写演示"><a href="#3-5-AOF-重写演示" class="headerlink" title="3.5 AOF 重写演示"></a>3.5 AOF 重写演示</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="四-RDB和AOF的选择"><a href="#四-RDB和AOF的选择" class="headerlink" title="四 RDB和AOF的选择"></a>四 RDB和AOF的选择</h2><h3 id="4-1-rdb和aof的比较"><a href="#4-1-rdb和aof的比较" class="headerlink" title="4.1 rdb和aof的比较"></a>4.1 rdb和aof的比较</h3><table>
<thead>
<tr>
<th>命令</th>
<th>rdb</th>
<th>aof</th>
</tr>
</thead>
<tbody><tr>
<td>启动优先级</td>
<td>低</td>
<td>高(挂掉重启，会加载aof的数据)</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>丢数据</td>
<td>根据策略决定</td>
</tr>
<tr>
<td>轻重</td>
<td>重</td>
<td>轻</td>
</tr>
</tbody></table>
<h3 id="4-2-rdb最佳策略"><a href="#4-2-rdb最佳策略" class="headerlink" title="4.2 rdb最佳策略"></a>4.2 rdb最佳策略</h3><p>rdb关掉，主从操作时</p>
<p>集中管理：按天，按小时备份数据</p>
<p>主从配置，从节点打开</p>
<h3 id="4-3-aof最佳策略"><a href="#4-3-aof最佳策略" class="headerlink" title="4.3 aof最佳策略"></a>4.3 aof最佳策略</h3><p>开：缓存和存储，大部分情况都打开，</p>
<p>aof重写集中管理</p>
<p>everysec：通过每秒刷新的策略</p>
<h3 id="4-4-最佳策略"><a href="#4-4-最佳策略" class="headerlink" title="4.4 最佳策略"></a>4.4 最佳策略</h3><p>小分片：每个redis的最大内存为4g</p>
<p>缓存或存储：根据特性，使用不通策略</p>
<p>时时监控硬盘，内存，负载网络等</p>
<p>有足够内存</p>
<hr>
<h2 id="一-子进程开销和优化"><a href="#一-子进程开销和优化" class="headerlink" title="一 子进程开销和优化"></a>一 子进程开销和优化</h2><p>1 cpu</p>
<p>开销：rdb和aof文件生成，属于cpu密集型</p>
<p>优化：不做cpu绑定，不和cpu密集型的服务一起部署</p>
<p>2 内存</p>
<p>开销：fork内存开销，copy-on-write，</p>
<p>优化：单机部署尽量少重写</p>
<p>3 硬盘</p>
<p>开销：aof和rdb写入，可以结合分析工具使用</p>
<p>优化：</p>
<p>1 不要和高硬盘负载的服务部署在一起：存储服务，消息队列</p>
<p>2 在aof重写期间，不要对aof进行追加：no-appendfsync-on-rewrite=yes</p>
<p>3 根据写入量决定磁盘类型：例如ssd</p>
<p>4 单机多实例持久化考虑分盘</p>
<h2 id="二-fork操作"><a href="#二-fork操作" class="headerlink" title="二 fork操作"></a>二 fork操作</h2><p>1 fork是同步操作</p>
<p>2 与内存量嘻嘻相关：内存越大，耗时越长，跟机型也有关系</p>
<p>3 info：latest_fok_usec:查看持久化执行时间</p>
<p>改善fork</p>
<p>1 有限使用无机或高效支持fork操作的虚拟化技术</p>
<p>2 控制redis实例最大可用内存：maxmemory</p>
<p>3 合理配置linux内存分配策略</p>
<p>4 降低fork频率，例如放宽aof重写自动触发时机，不必要的全量复制</p>
<h2 id="三-aof追加阻塞"><a href="#三-aof追加阻塞" class="headerlink" title="三 aof追加阻塞"></a>三 aof追加阻塞</h2><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/006tNbRwgy1gadtfor4exj30hu0ke434.jpg" alt="image-20191229192629198"></p>
<p>aof阻塞：看日志定位</p>
<p>info Persistence：每次阻塞一次就会+1</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>DB-转载-redis-通用操作</title>
    <url>/posts/48484.html</url>
    <content><![CDATA[<p> Redis API通用操作</p>
<a id="more"></a>



<h2 id="一-通用命令"><a href="#一-通用命令" class="headerlink" title="一 通用命令"></a>一 通用命令</h2><h3 id="1-1-通用命令"><a href="#1-1-通用命令" class="headerlink" title="1.1 通用命令"></a>1.1 通用命令</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">####1-keys </span></span><br><span class="line"><span class="comment">#打印出所有key</span></span><br><span class="line">keys * </span><br><span class="line"><span class="comment">#打印出所有以he开头的key</span></span><br><span class="line">keys he*</span><br><span class="line"><span class="comment">#打印出所有以he开头，第三个字母是h到l的范围</span></span><br><span class="line">keys he[h-l]</span><br><span class="line"><span class="comment">#三位长度，以he开头，？表示任意一位</span></span><br><span class="line">keys he？</span><br><span class="line"><span class="comment">#keys命令一般不在生产环境中使用，生产环境key很多，时间复杂度为o(n),用scan命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####2-dbsize   计算key的总数</span></span><br><span class="line">dbsize <span class="comment">#redis内置了计数器，插入删除值该计数器会更改，所以可以在生产环境使用，时间复杂度是o(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###3-exists key 时间复杂度o(1)</span></span><br><span class="line"><span class="comment">#设置a</span></span><br><span class="line">set a b</span><br><span class="line"><span class="comment">#查看a是否存在</span></span><br><span class="line">exists a</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="comment">#存在返回1 不存在返回0</span></span><br><span class="line"><span class="comment">###4-del key  时间复杂度o(1)</span></span><br><span class="line">删除成功返回<span class="number">1</span>，key不存在返回<span class="number">0</span></span><br><span class="line"><span class="comment">###5-expire key seconds  时间复杂度o(1)</span></span><br><span class="line">expire name <span class="number">3</span> <span class="comment">#3s 过期</span></span><br><span class="line">ttl name  <span class="comment">#查看name还有多长时间过期</span></span><br><span class="line">persist name <span class="comment">#去掉name的过期时间</span></span><br><span class="line"><span class="comment">###6-type key  时间复杂度o(1)</span></span><br><span class="line">type name <span class="comment">#查看name类型，返回string</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 7 其他</span></span><br><span class="line">info命令：内存，cpu，主从相关</span><br><span class="line">client list  正在连接的会话</span><br><span class="line">client kill ip:端口</span><br><span class="line">dbsize  总共有多少个key</span><br><span class="line">flushall  清空所有</span><br><span class="line">flushdb  只清空当前库</span><br><span class="line">select 数字  选择某个库  总共<span class="number">16</span>个库</span><br><span class="line">monitor  记录操作日志，夯住</span><br></pre></td></tr></table></figure>

<h3 id="1-2-数据结构和内部编码"><a href="#1-2-数据结构和内部编码" class="headerlink" title="1.2 数据结构和内部编码"></a>1.2 数据结构和内部编码</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga7mt5tzjnj30q20pgn5n.jpg" alt="image-20191224110401405"></p>
<h3 id="1-3-单线程架构"><a href="#1-3-单线程架构" class="headerlink" title="1.3 单线程架构"></a>1.3 单线程架构</h3><h4 id="1-3-1-单线程架构，"><a href="#1-3-1-单线程架构，" class="headerlink" title="1.3.1 单线程架构，"></a>1.3.1 单线程架构，</h4><p>一个瞬间只会执行一条命令</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga7mzj7rpoj30wu0egq5t.jpg" alt="image-20191224111010657"></p>
<h4 id="1-3-2-单线程为什么这么快"><a href="#1-3-2-单线程为什么这么快" class="headerlink" title="1.3.2 单线程为什么这么快"></a>1.3.2 单线程为什么这么快</h4><p>1 纯内存</p>
<p>2 非阻塞IO （epoll），自身实现了事件处理，不在网络io上浪费过多时间</p>
<p>3 避免线程间切换和竞态消耗</p>
<h4 id="1-3-3-注意"><a href="#1-3-3-注意" class="headerlink" title="1.3.3 注意"></a>1.3.3 注意</h4><p>1 一次只运行一条命令</p>
<p>2 拒绝长慢命令</p>
<p> -keys，flushall,flushdb,慢的lua脚本，mutil/exec，operate，big value</p>
<p>3 其实不是单线程（在做持久化是另外的线程）</p>
<p> -fysnc file descriptor</p>
<p> -close file descriptor</p>
<h2 id="二-字符串类型"><a href="#二-字符串类型" class="headerlink" title="二 字符串类型"></a>二 字符串类型</h2><h3 id="2-1-字符串键值结构"><a href="#2-1-字符串键值结构" class="headerlink" title="2.1 字符串键值结构"></a>2.1 字符串键值结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key          value</span><br><span class="line">hello        world      可以很复杂，如json格式字符串</span><br><span class="line">counter      1          数字类型</span><br><span class="line">bits         10101010   二进制（位图）</span><br><span class="line">#字符串value不能大于512m，一般建议100k以内</span><br><span class="line">#用于缓存，计数器，分布式锁...</span><br></pre></td></tr></table></figure>

<h3 id="2-2-常用命令"><a href="#2-2-常用命令" class="headerlink" title="2.2 常用命令"></a>2.2 常用命令</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">###1---基本使用get，set，del</span></span><br><span class="line">get name       <span class="comment">#时间复杂度 o(1)</span></span><br><span class="line">set name lqz   <span class="comment">#时间复杂度 o(1)</span></span><br><span class="line"><span class="keyword">del</span> name       <span class="comment">#时间复杂度 o(1)</span></span><br><span class="line"><span class="comment">###2---其他使用incr,decr,incrby,decrby</span></span><br><span class="line">incr age  <span class="comment">#对age这个key的value值自增1</span></span><br><span class="line">decr age  <span class="comment">#对age这个key的value值自减1</span></span><br><span class="line">incrby age <span class="number">10</span>  <span class="comment">#对age这个key的value值增加10</span></span><br><span class="line">decrby age <span class="number">10</span>  <span class="comment">#对age这个key的value值减10</span></span><br><span class="line"><span class="comment">#统计网站访问量（单线程无竞争，天然适合做计数器）</span></span><br><span class="line"><span class="comment">#缓存mysql的信息（json格式）</span></span><br><span class="line"><span class="comment">#分布式id生成（多个机器同时并发着生成，不会重复）</span></span><br><span class="line"><span class="comment">###3---set，setnx，setxx</span></span><br><span class="line">set name lqz  <span class="comment">#不管key是否存在，都设置 </span></span><br><span class="line">setnx name lqz <span class="comment">#key不存在时才设置（新增操作）</span></span><br><span class="line">set name lqz nx <span class="comment">#同上</span></span><br><span class="line">set name lqz xx <span class="comment">#key存在，才设置（更新操作）</span></span><br><span class="line"><span class="comment">###4---mget mset</span></span><br><span class="line">mget key1 key2 key3     <span class="comment">#批量获取key1，key2.。。时间复杂度o(n)</span></span><br><span class="line">mset key1 value1 key2 value2 key3 value3    <span class="comment">#批量设置时间复杂度o(n)</span></span><br><span class="line"><span class="comment">#n次get和mget的区别</span></span><br><span class="line"><span class="comment">#n次get时间=n次命令时间+n次网络时间</span></span><br><span class="line"><span class="comment">#mget时间=1次网络时间+n次命令时间</span></span><br><span class="line"><span class="comment">###5---其他：getset，append，strlen</span></span><br><span class="line">getset name lqznb <span class="comment">#设置新值并返回旧值 时间复杂度o(1)</span></span><br><span class="line">append name <span class="number">666</span> <span class="comment">#将value追加到旧的value 时间复杂度o(1)</span></span><br><span class="line">strlen name  <span class="comment">#计算字符串长度(注意中文)  时间复杂度o(1)</span></span><br><span class="line"><span class="comment">###6---其他：incrybyfloat,getrange,setrange</span></span><br><span class="line">increbyfloat age <span class="number">3.5</span>  <span class="comment">#为age自增3.5，传负值表示自减 时间复杂度o(1)</span></span><br><span class="line">getrange key start end <span class="comment">#获取字符串制定下标所有的值  时间复杂度o(1)</span></span><br><span class="line">setrange key index value <span class="comment">#从指定index开始设置value值  时间复杂度o(1)</span></span><br></pre></td></tr></table></figure>

<h2 id="三-哈希类型"><a href="#三-哈希类型" class="headerlink" title="三 哈希类型"></a>三 哈希类型</h2><p>###3.1 哈希值结构</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/006tNbRwgy1ga7otagi3lj30p00f2q8l.jpg" alt="image-20191224121323414"></p>
<h3 id="3-2-重要api"><a href="#3-2-重要api" class="headerlink" title="3.2 重要api"></a>3.2 重要api</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">###1---hget,hset,hdel</span></span><br><span class="line">hget key field  <span class="comment">#获取hash key对应的field的value 时间复杂度为 o(1)</span></span><br><span class="line">hset key field value <span class="comment">#设置hash key对应的field的value值 时间复杂度为 o(1)</span></span><br><span class="line">hdel key field <span class="comment">#删除hash key对应的field的值 时间复杂度为 o(1)</span></span><br><span class="line"><span class="comment">#测试</span></span><br><span class="line">hset user:<span class="number">1</span>:info age <span class="number">23</span></span><br><span class="line">hget user:<span class="number">1</span>:info age</span><br><span class="line">hset user:<span class="number">1</span>:info name lqz</span><br><span class="line">hgetall user:<span class="number">1</span>:info</span><br><span class="line">hdel user:<span class="number">1</span>:info age</span><br><span class="line"><span class="comment">###2---hexists,hlen</span></span><br><span class="line">hexists key field  <span class="comment">#判断hash key 是否存在field 时间复杂度为 o(1)</span></span><br><span class="line">hlen key   <span class="comment">#获取hash key field的数量  时间复杂度为 o(1)</span></span><br><span class="line">hexists user:<span class="number">1</span>:info name</span><br><span class="line">hlen user:<span class="number">1</span>:info  <span class="comment">#返回数量</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">###3---hmget，hmset</span></span><br><span class="line">hmget key field1 field2 ...fieldN  <span class="comment">#批量获取hash key 的一批field对应的值  时间复杂度是o(n)</span></span><br><span class="line">hmset key field1 value1 field2 value2  <span class="comment">#批量设置hash key的一批field value 时间复杂度是o(n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###4--hgetall,hvals，hkeys</span></span><br><span class="line">hgetall key  <span class="comment">#返回hash key 对应的所有field和value  时间复杂度是o(n)</span></span><br><span class="line">hvals key   <span class="comment">#返回hash key 对应的所有field的value  时间复杂度是o(n)</span></span><br><span class="line">hkeys key   <span class="comment">#返回hash key对应的所有field  时间复杂度是o(n)</span></span><br><span class="line"><span class="comment">###小心使用hgetall</span></span><br><span class="line"><span class="comment">##1 计算网站每个用户主页的访问量</span></span><br><span class="line">hincrby user:<span class="number">1</span>:info pageview count</span><br><span class="line"><span class="comment">##2 缓存mysql的信息，直接设置hash格式</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-hash-vs-string"><a href="#3-3-hash-vs-string" class="headerlink" title="3.3 hash vs string"></a>3.3 hash vs string</h3><h4 id="3-3-1相似的api"><a href="#3-3-1相似的api" class="headerlink" title="3.3.1相似的api"></a>3.3.1相似的api</h4><table>
<thead>
<tr>
<th>get</th>
<th>hget</th>
</tr>
</thead>
<tbody><tr>
<td>set /sentnx</td>
<td>hset hsetnx</td>
</tr>
<tr>
<td>del</td>
<td>hdel</td>
</tr>
<tr>
<td>incr incrby dear decrby</td>
<td>hincrby</td>
</tr>
<tr>
<td>mset</td>
<td>hmset</td>
</tr>
<tr>
<td>mget</td>
<td>hmget</td>
</tr>
</tbody></table>
<h4 id="3-3-2-缓存三种方案"><a href="#3-3-2-缓存三种方案" class="headerlink" title="3.3.2 缓存三种方案"></a>3.3.2 缓存三种方案</h4><p>直接json格式字符串</p>
<p>每个字段一个key</p>
<p>使用hash操作</p>
<h3 id="3-4-其他操作"><a href="#3-4-其他操作" class="headerlink" title="3.4 其他操作"></a>3.4 其他操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##其他操作 hsetnx，hincrby，hincrbyfloat</span><br><span class="line">hsetnx key field value #设置hash key对应field的value（如果field已存在，则失败），时间复杂度o(1)</span><br><span class="line">hincrby key field intCounter #hash key 对英的field的value自增intCounter 时间复杂度o(1)</span><br><span class="line">hincrbyfloat key field floatCounter #hincrby 浮点数 时间复杂度o(1)</span><br></pre></td></tr></table></figure>

<h2 id="四-列表类型"><a href="#四-列表类型" class="headerlink" title="四 列表类型"></a>四 列表类型</h2><h3 id="4-1-列表特点"><a href="#4-1-列表特点" class="headerlink" title="4.1 列表特点"></a>4.1 列表特点</h3><p>有序队列，可以从左侧添加，右侧添加，可以重复，可以从左右两边弹出</p>
<h4 id="4-2-API操作"><a href="#4-2-API操作" class="headerlink" title="4.2 API操作"></a>4.2 API操作</h4><h5 id="4-2-1-插入操作"><a href="#4-2-1-插入操作" class="headerlink" title="4.2.1 插入操作"></a>4.2.1 插入操作</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#rpush 从右侧插入</span><br><span class="line">rpush key value1 value2 ...valueN  #时间复杂度为o(1~n)</span><br><span class="line">#lpush 从左侧插入</span><br><span class="line">#linsert</span><br><span class="line">linsert key before|after value newValue   #从元素value的前或后插入newValue 时间复杂度o(n) ，需要遍历列表</span><br><span class="line">linsert listkey before b java</span><br><span class="line">linsert listkey after b php</span><br></pre></td></tr></table></figure>

<h5 id="4-2-2-删除操作"><a href="#4-2-2-删除操作" class="headerlink" title="4.2.2 删除操作"></a>4.2.2 删除操作</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lpop key #从列表左侧弹出一个item 时间复杂度o(1)</span><br><span class="line"></span><br><span class="line">rpop key #从列表右侧弹出一个item 时间复杂度o(1)</span><br><span class="line"></span><br><span class="line">lrem key count value</span><br><span class="line">#根据count值，从列表中删除所有value相同的项 时间复杂度o(n)</span><br><span class="line">1 count&gt;0 从左到右，删除最多count个value相等的项</span><br><span class="line">2 count&lt;0 从右向左，删除最多 Math.abs(count)个value相等的项</span><br><span class="line">3 count&#x3D;0 删除所有value相等的项</span><br><span class="line">lrem listkey 0 a #删除列表中所有值a</span><br><span class="line">lrem listkey -1 c #从右侧删除1个c</span><br><span class="line"></span><br><span class="line">ltrim key start end #按照索引范围修剪列表 o(n)</span><br><span class="line">ltrim listkey 1 4 #只保留下表1--4的元素</span><br></pre></td></tr></table></figure>

<h4 id="4-2-3-查询操作"><a href="#4-2-3-查询操作" class="headerlink" title="4.2.3 查询操作"></a>4.2.3 查询操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lrange key start end #包含end获取列表指定索引范围所有item  o(n)</span><br><span class="line">lrange listkey 0 2</span><br><span class="line">lrange listkey 1 -1 #获取第一个位置到倒数第一个位置的元素</span><br><span class="line"></span><br><span class="line">lindex key index #获取列表指定索引的item  o(n)</span><br><span class="line">lindex listkey 0</span><br><span class="line">lindex listkey -1</span><br><span class="line"></span><br><span class="line">llen key #获取列表长度</span><br></pre></td></tr></table></figure>

<h4 id="4-2-3-修改操作"><a href="#4-2-3-修改操作" class="headerlink" title="4.2.3 修改操作"></a>4.2.3 修改操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lset key index newValue #设置列表指定索引值为newValue o(n)</span><br><span class="line">lset listkey 2 ppp #把第二个位置设为ppp</span><br></pre></td></tr></table></figure>

<h3 id="4-3-实战"><a href="#4-3-实战" class="headerlink" title="4.3 实战"></a>4.3 实战</h3><p>实现timeLine功能，时间轴，微博关注的人，按时间轴排列，在列表中放入关注人的微博的即可</p>
<h3 id="4-4-其他操作"><a href="#4-4-其他操作" class="headerlink" title="4.4 其他操作"></a>4.4 其他操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blpop key timeout #lpop的阻塞版，timeout是阻塞超时时间，timeout&#x3D;0为拥有不阻塞 o(1)</span><br><span class="line">brpop key timeout #rpop的阻塞版，timeout是阻塞超时时间，timeout&#x3D;0为拥有不阻塞 o(1)</span><br><span class="line"></span><br><span class="line">#要实现栈的功能</span><br><span class="line">lpush+lpop</span><br><span class="line">#实现队列功能</span><br><span class="line">lpush+rpop</span><br><span class="line">#固定大小的列表</span><br><span class="line">lpush+ltrim</span><br><span class="line">#消息队列</span><br><span class="line">lpush+brpop</span><br></pre></td></tr></table></figure>

<h2 id="五-集合类型"><a href="#五-集合类型" class="headerlink" title="五 集合类型"></a>五 集合类型</h2><h3 id="5-1-特点"><a href="#5-1-特点" class="headerlink" title="5.1 特点"></a>5.1 特点</h3><p>无序，无重复，集合间操作（交叉并补）</p>
<h3 id="5-2-API操作"><a href="#5-2-API操作" class="headerlink" title="5.2 API操作"></a>5.2 API操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sadd key element #向集合key添加element（如果element存在，添加失败） o(1)</span><br><span class="line"></span><br><span class="line">srem key element #从集合中的element移除掉 o(1)</span><br><span class="line"></span><br><span class="line">scard key #计算集合大小</span><br><span class="line"></span><br><span class="line">sismember key element #判断element是否在集合中</span><br><span class="line"></span><br><span class="line">srandmember key count #从集合中随机取出count个元素，不会破坏集合中的元素</span><br><span class="line"></span><br><span class="line">spop key #从集合中随机弹出一个元素</span><br><span class="line"></span><br><span class="line">smembers key #获取集合中所有元素 ，无序，小心使用，会阻塞住 </span><br><span class="line"></span><br><span class="line">sdiff user:1:follow user:2:follow  #计算user:1:follow和user:2:follow的差集</span><br><span class="line"></span><br><span class="line">sinter user:1:follow user:2:follow  #计算user:1:follow和user:2:follow的交集</span><br><span class="line">          </span><br><span class="line">sunion user:1:follow user:2:follow  #计算user:1:follow和user:2:follow的并集</span><br><span class="line">                </span><br><span class="line">sdiff|sinter|suion + store destkey... #将差集，交集，并集结果保存在destkey集合中</span><br></pre></td></tr></table></figure>

<h3 id="5-3-实战"><a href="#5-3-实战" class="headerlink" title="5.3 实战"></a>5.3 实战</h3><p>抽奖系统 ：通过spop来弹出用户的id，活动取消，直接删除</p>
<p>点赞，点踩，喜欢等，用户如果点了赞，就把用户id放到该条记录的集合中</p>
<p>标签：给用户/文章等添加标签，sadd user:1:tags 标签1 标签2 标签3</p>
<p>给标签添加用户，关注该标签的人有哪些</p>
<p>共同好友：集合间的操作</p>
<h4 id="5-4-总结"><a href="#5-4-总结" class="headerlink" title="5.4 总结"></a>5.4 总结</h4><p>sadd:可以做标签相关</p>
<p>spop/srandmember:可以做随机数相关</p>
<p>sadd/sinter：社交相关</p>
<h2 id="六-有序集合类型"><a href="#六-有序集合类型" class="headerlink" title="六 有序集合类型"></a>六 有序集合类型</h2><h3 id="6-1-特点"><a href="#6-1-特点" class="headerlink" title="6.1 特点"></a>6.1 特点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#有一个分值字段，来保证顺序</span><br><span class="line">key                  score                value</span><br><span class="line">user:ranking           1                   lqz</span><br><span class="line">user:ranking           99                  lqz2</span><br><span class="line">user:ranking           88                  lqz3</span><br><span class="line">#集合有序集合</span><br><span class="line">集合：无重复元素，无序，element</span><br><span class="line">有序集合：无重复元素，有序，element+score</span><br><span class="line">#列表和有序集合</span><br><span class="line">列表：可以重复，有序，element</span><br><span class="line">有序集合：无重复元素，有序，element+score</span><br></pre></td></tr></table></figure>

<h3 id="6-2-API使用"><a href="#6-2-API使用" class="headerlink" title="6.2 API使用"></a>6.2 API使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zadd key score element #score可以重复，可以多个同时添加，element不能重复 o(logN) </span><br><span class="line"></span><br><span class="line">zrem key element #删除元素，可以多个同时删除 o(1)</span><br><span class="line"></span><br><span class="line">zscore key element #获取元素的分数 o(1)</span><br><span class="line"></span><br><span class="line">zincrby key increScore element #增加或减少元素的分数  o(1)</span><br><span class="line"></span><br><span class="line">zcard key #返回元素总个数 o(1)</span><br><span class="line"></span><br><span class="line">zrank key element #返回element元素的排名（从小到大排）</span><br><span class="line"></span><br><span class="line">zrange key 0 -1 #返回排名，不带分数  o(log(n)+m) n是元素个数，m是要获取的值</span><br><span class="line">zrange player:rank 0 -1 withscores #返回排名，带分数</span><br><span class="line"></span><br><span class="line">zrangebyscore key minScore maxScore #返回指定分数范围内的升序元素 o(log(n)+m) n是元素个数，m是要获取的值</span><br><span class="line">zrangebyscore user:1:ranking 90 210 withscores #获取90分到210分的元素</span><br><span class="line"></span><br><span class="line">zcount key minScore maxScore #返回有序集合内在指定分数范围内的个数 o(log(n)+m)</span><br><span class="line"></span><br><span class="line">zremrangebyrank key start end #删除指定排名内的升序元素 o(log(n)+m)</span><br><span class="line">zremrangebyrank user:1:rangking 1 2 #删除升序排名中1到2的元素</span><br><span class="line">        </span><br><span class="line">zremrangebyscore key minScore maxScore #删除指定分数内的升序元素 o(log(n)+m)</span><br><span class="line">zremrangebyscore user:1:ranking 90 210 #删除分数90到210之间的元素</span><br></pre></td></tr></table></figure>

<h3 id="6-3-实战"><a href="#6-3-实战" class="headerlink" title="6.3 实战"></a>6.3 实战</h3><p>排行榜：音乐排行榜，销售榜，关注榜，游戏排行榜</p>
<h3 id="6-4-其他操作"><a href="#6-4-其他操作" class="headerlink" title="6.4 其他操作"></a>6.4 其他操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zrevrank #从高到低排序</span><br><span class="line">zrevrange #从高到低排序取一定范围</span><br><span class="line">zrevrangebyscore #返回指定分数范围内的降序元素</span><br><span class="line">zinterstore #对两个有序集合交集</span><br><span class="line">zunionstore #对两个有序集合求并集</span><br></pre></td></tr></table></figure>

<h3 id="6-5-总结"><a href="#6-5-总结" class="headerlink" title="6.5 总结"></a>6.5 总结</h3><table>
<thead>
<tr>
<th>操作类型</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>基本操作</td>
<td>zadd/ zrem/ zcard/ zincrby/ zscore</td>
</tr>
<tr>
<td>范围操作</td>
<td>zrange/ zrangebyscore/ zcount/ zremrangebyrank</td>
</tr>
<tr>
<td>集合操作</td>
<td>zunionstore/ zinterstore</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>DB-转载-redis-高级用法</title>
    <url>/posts/48365.html</url>
    <content><![CDATA[<p> Redis 高级用法</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 乐观锁 悲观锁</span><br><span class="line"></span><br><span class="line">悲观锁: 认为这次更改会被别人改掉 (一开始就加锁，用完就释放)</span><br><span class="line">乐观锁: 认为这次更改不会被别人改掉(不加锁，执行的时候判断这个值有没有被改掉，如果被改掉我就不改了；如没改掉我再改)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 悲观锁的更改一定会成功，乐观锁的更改不一定会成功。</span></span><br><span class="line"></span><br><span class="line">MySQL 实现悲观锁，  select <span class="keyword">for</span> update; insert / update ;   commit提交之后， 这个锁就释放了。</span><br><span class="line">MySQL 实现乐观锁   select 查出商品状态: 比如=<span class="number">1</span> ; insert 数据; update 的时候多加的条件where xx=刚查的状态</span><br><span class="line">  </span><br><span class="line">Redis只能实现乐观锁：https://www.cnblogs.com/liuqingzheng/p/<span class="number">9997092.</span>html</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># pipeline与事务</span></span><br><span class="line">    -pipeline每次只能作用在一个Redis的节点上（如果做了集群，就没有pipline了）</span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  模拟乐观锁</span></span><br><span class="line"><span class="string">        # 在开启事务之前，先watch</span></span><br><span class="line"><span class="string">        wathc age</span></span><br><span class="line"><span class="string">        multi</span></span><br><span class="line"><span class="string">        decr age</span></span><br><span class="line"><span class="string">        exec</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # 另一台机器</span></span><br><span class="line"><span class="string">        mutil</span></span><br><span class="line"><span class="string">        decr age</span></span><br><span class="line"><span class="string">        exec  # 先执行，上面的执行就会失败(乐观锁，被wathc的事务不会执行成功)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  </span><br><span class="line"><span class="number">2.</span> 消息队列和发布订阅的区别</span><br><span class="line">消息队列: 有生产者消费者，生产者的东西放到消息队列中, 消费者消费的时候只有抢到的那个人能消费掉。其他人消费不到</span><br><span class="line">发布订阅: 有一个发布的人, 他们发布的所有关注的人都能收到</span><br></pre></td></tr></table></figure>



<h2 id="一-慢查询"><a href="#一-慢查询" class="headerlink" title="一 慢查询"></a>一 慢查询</h2><h3 id="1-1-生命周期"><a href="#1-1-生命周期" class="headerlink" title="1.1 生命周期"></a>1.1 生命周期</h3><p>我们配置一个时间，如果查询时间超过了我们设置的时间，我们就认为这是一个慢查询.</p>
<p>慢查询发生在第三阶段</p>
<p>客户端超时不一定慢查询，但慢查询是客户端超时的一个可能因素</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/006tNbRwgy1ga8r6p7tpej30z80k2afq.jpg" alt="image-20191225102102218"></p>
<h3 id="1-2-两个配置"><a href="#1-2-两个配置" class="headerlink" title="1.2 两个配置"></a>1.2 两个配置</h3><h4 id="1-2-1-slowlog-max-len"><a href="#1-2-1-slowlog-max-len" class="headerlink" title="1.2.1 slowlog-max-len"></a>1.2.1 slowlog-max-len</h4><p>慢查询是一个先进先出的队列</p>
<p>固定长度</p>
<p>保存在内存中</p>
<h4 id="1-2-2-slowlog-max-len"><a href="#1-2-2-slowlog-max-len" class="headerlink" title="1.2.2 slowlog-max-len"></a>1.2.2 slowlog-max-len</h4><p>慢查询阈值（单位：微秒）</p>
<p>slowlog-log-slower-than=0，记录所有命令</p>
<p>slowlog-log-slower-than &lt;0,不记录任何命令</p>
<h4 id="1-2-3-配置方法"><a href="#1-2-3-配置方法" class="headerlink" title="1.2.3 配置方法"></a>1.2.3 配置方法</h4><p><strong>1 默认配置</strong></p>
<p>config get slowlog-max-len=128</p>
<p>Config get slowly-log-slower-than=10000</p>
<p><strong>2 修改配置文件重启</strong></p>
<p><strong>3 动态配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置记录所有命令</span><br><span class="line">config set slowlog-log-slower-than 0</span><br><span class="line"># 最多记录100条</span><br><span class="line">config set slowlog-max-len 100</span><br><span class="line"># 持久化到本地配置文件</span><br><span class="line">config rewrite</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">config set slowlog-max-len 1000</span><br><span class="line">config set slowlog-log-slower-than 1000</span><br><span class="line">&#39;&#39;&#39;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-三个命令"><a href="#1-3-三个命令" class="headerlink" title="1.3 三个命令"></a>1.3 三个命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slowlog get [n]  #获取慢查询队列</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">日志由4个属性组成：</span><br><span class="line">1）日志的标识id</span><br><span class="line">2）发生的时间戳</span><br><span class="line">3）命令耗时</span><br><span class="line">4）执行的命令和参数</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">slowlog len #获取慢查询队列长度</span><br><span class="line"></span><br><span class="line">slowlog reset #清空慢查询队列</span><br></pre></td></tr></table></figure>

<h3 id="1-4-经验"><a href="#1-4-经验" class="headerlink" title="1.4 经验"></a>1.4 经验</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 slowlog-max-len 不要设置过大，默认10ms，通常设置1ms</span><br><span class="line">2 slowlog-log-slower-than不要设置过小，通常设置1000左右</span><br><span class="line">3 理解命令生命周期</span><br><span class="line">4 定期持久化慢查询</span><br></pre></td></tr></table></figure>

<h2 id="二-pipeline与事务"><a href="#二-pipeline与事务" class="headerlink" title="二 pipeline与事务"></a>二 pipeline与事务</h2><h3 id="2-1-什么是pipeline-管道"><a href="#2-1-什么是pipeline-管道" class="headerlink" title="2.1 什么是pipeline(管道)"></a>2.1 什么是pipeline(管道)</h3><p>Redis的pipeline(管道)功能在命令行中没有，但redis是支持pipeline的，而且在各个语言版的client中都有相应的实现</p>
<p>将一批命令，批量打包，在redis服务端批量计算(执行)，然后把结果批量返回</p>
<p>1次pipeline(n条命令)=1次网络时间+n次命令时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipeline期间将“独占”链接，此期间将不能进行非“管道”类型的其他操作，直到pipeline关闭；如果你的pipeline的指令集很庞大，为了不干扰链接中的其他操作，你可以为pipeline操作新建Client链接，让pipeline和其他正常操作分离在2个client中。不过pipeline事实上所能容忍的操作个数，和socket-output缓冲区大小&#x2F;返回结果的数据尺寸都有很大的关系；同时也意味着每个redis-server同时所能支撑的pipeline链接的个数，也是有限的，这将受限于server的物理内存或网络接口的缓冲能力</span><br></pre></td></tr></table></figure>

<h3 id="2-2-客户端实现"><a href="#2-2-客户端实现" class="headerlink" title="2.2 客户端实现"></a>2.2 客户端实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import redis</span><br><span class="line">pool &#x3D; redis.ConnectionPool(host&#x3D;&#39;10.211.55.4&#39;, port&#x3D;6379)</span><br><span class="line">r &#x3D; redis.Redis(connection_pool&#x3D;pool)</span><br><span class="line"># pipe &#x3D; r.pipeline(transaction&#x3D;False)</span><br><span class="line">#创建pipeline</span><br><span class="line">pipe &#x3D; r.pipeline(transaction&#x3D;True)</span><br><span class="line">#开启事务</span><br><span class="line">pipe.multi()</span><br><span class="line">pipe.set(&#39;name&#39;, &#39;lqz&#39;)</span><br><span class="line">#其他代码，可能出异常</span><br><span class="line"></span><br><span class="line">pipe.set(&#39;role&#39;, &#39;nb&#39;)</span><br><span class="line"> </span><br><span class="line">pipe.execute()</span><br></pre></td></tr></table></figure>

<h3 id="2-3-与原生操作对比"><a href="#2-3-与原生操作对比" class="headerlink" title="2.3 与原生操作对比"></a>2.3 与原生操作对比</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过pipeline提交的多次命令，在服务端执行的时候，可能会被拆成多次执行，而mget等操作，是一次性执行的，所以，pipeline执行的命令并非原子性的</span><br></pre></td></tr></table></figure>

<h3 id="2-4-使用建议"><a href="#2-4-使用建议" class="headerlink" title="2.4 使用建议"></a>2.4 使用建议</h3><p>1 注意每次pipeline携带的数据量</p>
<p>2 pipeline每次只能作用在一个Redis的节点上</p>
<p>3 M(mset，mget….)操作和pipeline的区别</p>
<h3 id="2-5-原生事务操作"><a href="#2-5-原生事务操作" class="headerlink" title="2.5 原生事务操作"></a>2.5 原生事务操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1 mutil  开启事务，放到管道中一次性执行</span><br><span class="line">multi   # 开启事务</span><br><span class="line">set name lqz</span><br><span class="line">set age 18</span><br><span class="line">exec</span><br><span class="line"></span><br><span class="line"># 2 模拟事务</span><br><span class="line"># 在开启事务之前，先watch</span><br><span class="line">wathc age</span><br><span class="line">multi</span><br><span class="line">decr age</span><br><span class="line">exec</span><br><span class="line"></span><br><span class="line"># 另一台机器</span><br><span class="line">mutil</span><br><span class="line">decr age</span><br><span class="line">exec  # 先执行，上面的执行就会失败(乐观锁，被wathc的事务不会执行成功)</span><br></pre></td></tr></table></figure>

<h2 id="三-发布订阅"><a href="#三-发布订阅" class="headerlink" title="三 发布订阅"></a>三 发布订阅</h2><h3 id="3-1-角色"><a href="#3-1-角色" class="headerlink" title="3.1 角色"></a>3.1 角色</h3><p><strong>发布者/订阅者/频道</strong></p>
<p>发布者发布了消息，所有的订阅者都可以收到，就是生产者消费者模型（后订阅了，无法获取历史消息）</p>
<h3 id="3-2-模型"><a href="#3-2-模型" class="headerlink" title="3.2 模型"></a>3.2 模型</h3><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/006tNbRwgy1ga923qyr2uj31xp0u0jwt.jpg" alt="image-20191225163659941"></p>
<h3 id="3-3-API"><a href="#3-3-API" class="headerlink" title="3.3 API"></a>3.3 API</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">publish channel message #发布命令</span><br><span class="line">publish souhu:tv &quot;hello world&quot; #在souhu:tv频道发布一条hello world  返回订阅者个数</span><br><span class="line"></span><br><span class="line">subscribe [channel] #订阅命令，可以订阅一个或多个</span><br><span class="line">subscribe souhu:tv  #订阅sohu:tv频道</span><br><span class="line"></span><br><span class="line">unsubscribe [channel] #取消订阅一个或多个频道</span><br><span class="line">unsubscribe sohu:tv  #取消订阅sohu:tv频道</span><br><span class="line">    </span><br><span class="line">psubscribe [pattern...] #订阅模式匹配</span><br><span class="line">psubscribe c*  #订阅以c开头的频道</span><br><span class="line"></span><br><span class="line">unpsubscribe [pattern...] #按模式退订指定频道</span><br><span class="line"></span><br><span class="line">pubsub channels #列出至少有一个订阅者的频道,列出活跃的频道</span><br><span class="line"></span><br><span class="line">pubsub numsub [channel...] #列出给定频道的订阅者数量</span><br><span class="line"></span><br><span class="line">pubsub numpat #列出被订阅模式的数量</span><br></pre></td></tr></table></figure>

<h3 id="3-4-发布订阅和消息队列"><a href="#3-4-发布订阅和消息队列" class="headerlink" title="3.4 发布订阅和消息队列"></a>3.4 发布订阅和消息队列</h3><p>发布订阅数全收到，消息队列有个抢的过程，只有一个抢到</p>
<h2 id="四-Bitmap位图"><a href="#四-Bitmap位图" class="headerlink" title="四 Bitmap位图"></a>四 Bitmap位图</h2><h3 id="4-1-位图是什么"><a href="#4-1-位图是什么" class="headerlink" title="4.1 位图是什么"></a>4.1 位图是什么</h3><p>下面是字符串big对应的二进制（b是98）</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga93bk259dj313y0isajp.jpg" alt="image-20191225172053447"></p>
<h3 id="4-2-相关命令"><a href="#4-2-相关命令" class="headerlink" title="4.2 相关命令"></a>4.2 相关命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set hello big #放入key位hello 值为big的字符串</span><br><span class="line">getbit hello 0 #取位图的第0个位置，返回0</span><br><span class="line">getbit hello 1 #取位图的第1个位置，返回1 如上图</span><br><span class="line"></span><br><span class="line">##我们可以直接操纵位</span><br><span class="line">setbit key offset value #给位图指定索引设置值</span><br><span class="line">setbit hello 7 1 #把hello的第7个位置设为1 这样，big就变成了cig</span><br><span class="line"></span><br><span class="line">setbit test 50 1 #test不存在，在key为test的value的第50位设为1，那其他位都以0补</span><br><span class="line"></span><br><span class="line">bitcount key [start end] #获取位图指定范围(start到end,单位为字节,注意按字节一个字节8个bit为，如果不指定就是获取全部)位值为1的个数</span><br><span class="line"></span><br><span class="line">bitop op destkey key [key...] #做多个Bitmap的and(交集)&#x2F;or(并集)&#x2F;not(非)&#x2F;xor(异或)，操作并将结果保存在destkey中 </span><br><span class="line">bitop and after_lqz lqz lqz2 #把lqz和lqz2按位与操作，放到after_lqz中</span><br><span class="line"></span><br><span class="line">bitpos key targetBit start end #计算位图指定范围(start到end，单位为字节，如果不指定是获取全部)第一个偏移量对应的值等于targetBit的位置</span><br><span class="line">bitpos lqz 1 #big 对应位图中第一个1的位置，在第二个位置上，由于从0开始返回1</span><br><span class="line">bitpos lqz 0 #big 对应位图中第一个0的位置，在第一个位置上，由于从0开始返回0</span><br><span class="line">bitpos lqz 1 1 2 #返回9：返回从第一个字节到第二个字节之间 第一个1的位置，看上图，为9</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/006tNbRwgy1ga93gnif6ej310q0iuwpy.jpg" alt="image-20191225172547661"></p>
<h3 id="4-3-独立用户统计"><a href="#4-3-独立用户统计" class="headerlink" title="4.3 独立用户统计"></a>4.3 独立用户统计</h3><p>1 使用set和Bitmap对比</p>
<p>2 1亿用户，5千万独立（1亿用户量，约5千万人访问，统计活跃用户数量）</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>每个userid占用空间</th>
<th>需要存储用户量</th>
<th>全部内存量</th>
</tr>
</thead>
<tbody><tr>
<td>set</td>
<td>32位(假设userid是整形，占32位)</td>
<td>5千万</td>
<td>32位*5千万=200MB</td>
</tr>
<tr>
<td>bitmap</td>
<td>1位</td>
<td>1亿</td>
<td>1位*1亿=12.5MB</td>
</tr>
</tbody></table>
<p>假设有10万独立用户，使用位图还是占用12.5mb，使用set需要32位*1万=4MB</p>
<h3 id="4-5-总结"><a href="#4-5-总结" class="headerlink" title="4.5 总结"></a>4.5 总结</h3><p>1 位图类型是string类型，最大512M</p>
<p>2 使用setbit时偏移量如果过大，会有较大消耗</p>
<p>3 位图不是绝对好用，需要合理使用</p>
<h2 id="五-HyperLogLog"><a href="#五-HyperLogLog" class="headerlink" title="五 HyperLogLog"></a>五 HyperLogLog</h2><h3 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h3><p>基于HyperLogLog算法：极小的空间完成独立数量统计</p>
<p>本质还是字符串</p>
<h3 id="5-2-三个命令"><a href="#5-2-三个命令" class="headerlink" title="5.2 三个命令"></a>5.2 三个命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pfadd key element #向hyperloglog添加元素,可以同时添加多个</span><br><span class="line">pfcount key #计算hyperloglog的独立总数</span><br><span class="line">pfmerge destroy sourcekey1 sourcekey2#合并多个hyperloglog，把sourcekey1和sourcekey2合并为destroy</span><br><span class="line"></span><br><span class="line">pfadd uuids &quot;uuid1&quot; &quot;uuid2&quot; &quot;uuid3&quot; &quot;uuid4&quot; #向uuids中添加4个uuid</span><br><span class="line">pfcount uuids #返回4</span><br><span class="line">pfadd uuids &quot;uuid1&quot; &quot;uuid5&quot;#有一个之前存在了，其实只把uuid5添加了</span><br><span class="line">pfcount uuids #返回5</span><br><span class="line"></span><br><span class="line">pfadd uuids1 &quot;uuid1&quot; &quot;uuid2&quot; &quot;uuid3&quot; &quot;uuid4&quot;</span><br><span class="line">pfadd uuids2 &quot;uuid3&quot; &quot;uuid4&quot; &quot;uuid5&quot; &quot;uuid6&quot;</span><br><span class="line">pfmerge uuidsall uuids1 uuids2 #合并</span><br><span class="line">pfcount uuidsall #统计个数 返回6</span><br></pre></td></tr></table></figure>

<h3 id="5-3-内存消耗-amp-总结"><a href="#5-3-内存消耗-amp-总结" class="headerlink" title="5.3 内存消耗&amp;总结"></a>5.3 内存消耗&amp;总结</h3><p>百万级别独立用户统计，百万条数据只占15k</p>
<p>错误率 0.81%</p>
<p>无法取出单条数据，只能统计个数</p>
<h2 id="六-GEO"><a href="#六-GEO" class="headerlink" title="六 GEO"></a>六 GEO</h2><h3 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1 介绍"></a>6.1 介绍</h3><p>GEO（地理信息定位）：存储经纬度，计算两地距离，范围等</p>
<p>北京：116.28，39.55</p>
<p>天津：117.12，39.08</p>
<p>可以计算天津到北京的距离，天津周围50km的城市，外卖等</p>
<h3 id="6-2-5个城市纬度"><a href="#6-2-5个城市纬度" class="headerlink" title="6.2 5个城市纬度"></a>6.2 5个城市纬度</h3><table>
<thead>
<tr>
<th>城市</th>
<th>经度</th>
<th>纬度</th>
<th>简称</th>
</tr>
</thead>
<tbody><tr>
<td>北京</td>
<td>116.28</td>
<td>39.55</td>
<td>beijing</td>
</tr>
<tr>
<td>天津</td>
<td>117.12</td>
<td>39.08</td>
<td>tianjin</td>
</tr>
<tr>
<td>石家庄</td>
<td>114.29</td>
<td>38.02</td>
<td>shijiazhuang</td>
</tr>
<tr>
<td>唐山</td>
<td>118.01</td>
<td>39.38</td>
<td>tangshan</td>
</tr>
<tr>
<td>保定</td>
<td>115.29</td>
<td>38.51</td>
<td>baoding</td>
</tr>
</tbody></table>
<h3 id="6-3-相关命令"><a href="#6-3-相关命令" class="headerlink" title="6.3 相关命令"></a>6.3 相关命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">geoadd key longitude latitude member #增加地理位置信息</span><br><span class="line">geoadd cities:locations 116.28 39.55 beijing #把北京地理信息天津到cities:locations中</span><br><span class="line">geoadd cities:locations 117.12 39.08 tianjin</span><br><span class="line">geoadd cities:locations 114.29 38.02 shijiazhuang</span><br><span class="line">geoadd cities:locations 118.01 39.38 tangshan</span><br><span class="line">geoadd cities:locations 115.29 38.51 baoding</span><br><span class="line">    </span><br><span class="line">geopos key member #获取地理位置信息</span><br><span class="line">geopos cities:locations beijing #获取北京地理信息</span><br><span class="line"></span><br><span class="line">geodist key member1 member2 [unit]#获取两个地理位置的距离 unit:m(米) km(千米) mi(英里) ft(尺)</span><br><span class="line">geodist cities:locations beijing tianjin km #北京到天津的距离，89公里</span><br><span class="line"></span><br><span class="line">georadius key logitude latitude radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key][storedist key]</span><br><span class="line"></span><br><span class="line">georadiusbymember key member radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key][storedist key]</span><br><span class="line">#获取指定位置范围内的地理位置信息集合</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">withcoord:返回结果中包含经纬度</span><br><span class="line">withdist：返回结果中包含距离中心节点位置</span><br><span class="line">withhash：返回解雇中包含geohash</span><br><span class="line">COUNT count：指定返回结果的数量</span><br><span class="line">asc|desc：返回结果按照距离中心店的距离做升序&#x2F;降序排列</span><br><span class="line">store key：将返回结果的地理位置信息保存到指定键</span><br><span class="line">storedist key：将返回结果距离中心点的距离保存到指定键</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">georadiusbymember cities:locations beijing 150 km</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">1) &quot;beijing&quot;</span><br><span class="line">2) &quot;tianjin&quot;</span><br><span class="line">3) &quot;tangshan&quot;</span><br><span class="line">4) &quot;baoding&quot;</span><br><span class="line">&#39;&#39;&#39;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-总结"><a href="#6-4-总结" class="headerlink" title="6.4 总结"></a>6.4 总结</h3><p>3.2以后版本才有</p>
<p>geo本质时zset类型</p>
<p>可以使用zset的删除，删除指定member：zrem cities:locations beijing</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>DB-Redis-集群</title>
    <url>/posts/56604.html</url>
    <content><![CDATA[<p>Redis集群(主从复制/ sentinel/ 哨兵) +  缓存使用优化</p>
<a id="more"></a>

<h2 id="一-主从复制"><a href="#一-主从复制" class="headerlink" title="一. 主从复制"></a>一. 主从复制</h2><h3 id="一-场景"><a href="#一-场景" class="headerlink" title="一. 场景:"></a>一. 场景:</h3><p>一主一从，一主多从</p>
<p>1.做读写分离</p>
<p>2.做数据副本,持久化的另一种方式</p>
<p>3.机器故障；容量瓶颈；QPS瓶颈</p>
<p>3.负载均衡，配合读写分离，有主节点提供写服务，从节点提供读服务，分担服务器负载，尤其在写少读多的情况下，通过多个从节点分担读负载，可以大大提高redis服务器的并发量和负载。</p>
<p>4.高可用的基石，主从复制是哨兵和集群能够实施的基础，因此我们可以说主从复制是高可用的基石。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">一个master可以有多个slave</span><br><span class="line">一个slave只能有一个master</span><br><span class="line">数据流向是单向的，从master到slave</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/20200530220558236.png" alt="在这里插入图片描述"></p>
<h3 id="1-1-原理（主从复制不依赖主库是否开持久化，但是不开持久化会有问题）"><a href="#1-1-原理（主从复制不依赖主库是否开持久化，但是不开持久化会有问题）" class="headerlink" title="1.1 原理（主从复制不依赖主库是否开持久化，但是不开持久化会有问题）"></a>1.1 原理（主从复制不依赖主库是否开持久化，但是不开持久化会有问题）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 副本库通过slaveof 127.0.0.1 6379命令,连接主库,并发送SYNC给主库 </span><br><span class="line">2. 主库收到SYNC,会立即触发BGSAVE,后台保存RDB,发送给副本库</span><br><span class="line">3. 副本库接收后会应用RDB快照</span><br><span class="line">4. 主库会陆续将中间产生的新的操作,保存并发送给副本库</span><br><span class="line">5. 到此,我们主复制集就正常工作了</span><br><span class="line">6. 再此以后,主库只要发生新的操作,都会以命令传播的形式自动发送给副本库.</span><br><span class="line">7. 所有复制相关信息,从info信息中都可以查到.即使重启任何节点,他的主从关系依然都在.</span><br><span class="line">8. 如果发生主从关系断开时,从库数据没有任何损坏,在下次重连之后,从库发送PSYNC给主库</span><br><span class="line">9. 主库只会将从库缺失部分的数据同步给从库应用,达到快速恢复主从的目的</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/20200531233524414.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/20200601170651307.png" alt="img"></p>
<h3 id="1-2-主库是否要开启持久化"><a href="#1-2-主库是否要开启持久化" class="headerlink" title="1.2 主库是否要开启持久化"></a>1.2 主库是否要开启持久化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">如果不开有可能，主库重启操作，造成所有主从数据丢失！</span><br><span class="line"></span><br><span class="line">注意：当不开启持久化功能的时候，数据正常实时的复制到从库上，主库宕机，选择一个从库作为主库</span><br><span class="line"><span class="comment"># 主库未宕机，是重启，主从关系还有，所有从节点的数据全部丢失</span></span><br><span class="line"></span><br><span class="line">解决方案:  <span class="number">1.</span> 如果没开持久化: 一旦主库失去连接，踢出去，不复制主库 <span class="comment"># 从库切为主库</span></span><br><span class="line">                   slaveof no one</span><br><span class="line">          <span class="number">2.</span> 主库打开持久化功能, 恢复之后，所有的从节点进行全量复制</span><br><span class="line">https://blog.csdn.net/fangkang7/article/details/<span class="number">106429654</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-辅助配置（主从数据一致性配置）"><a href="#1-3-辅助配置（主从数据一致性配置）" class="headerlink" title="1.3 辅助配置（主从数据一致性配置）"></a>1.3 辅助配置（主从数据一致性配置）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">min-slaves-to-write 1</span><br><span class="line">min-slaves-max-lag 3</span><br><span class="line"><span class="comment">#那么在从服务器的数量少于1个，或者三个从服务器的延迟（lag）值都大于或等于3秒时，主服务器将拒绝执行写命令</span></span><br><span class="line"></span><br><span class="line">min-slaves-to-write &lt;number of slaves&gt;   最少有多少个从库完成写入，才认为主从复制完成了</span><br><span class="line">min-slaves-max-lag &lt;number of seconds&gt;   当前网络延时状况，至少要少于多少秒，否则认为主从复制没有完成</span><br></pre></td></tr></table></figure>

<h3 id="二-配置"><a href="#二-配置" class="headerlink" title="二 配置"></a>二 配置</h3><h3 id="2-1-slave-命令"><a href="#2-1-slave-命令" class="headerlink" title="2.1 slave 命令"></a>2.1 slave 命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6380是从，6379是主</span><br><span class="line"></span><br><span class="line">在6380上执行（去从库配置，配置主库）</span><br><span class="line"></span><br><span class="line">slaveof 127.0.0.1 6379 #异步</span><br><span class="line">slaveof no one #取消复制，不会把之前的数据清除</span><br></pre></td></tr></table></figure>

<h3 id="2-2-配置文件"><a href="#2-2-配置文件" class="headerlink" title="2.2 配置文件"></a>2.2 配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">slaveof ip port <span class="comment">#配置从节点ip和端口</span></span><br><span class="line">slave-read-only yes <span class="comment">#从节点只读，因为可读可写，数据会乱</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir -p redis1/conf redis1/data redis2/conf redis2/data redis3/conf redis3/data</span></span><br><span class="line"><span class="string">vim redis.conf</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">daemonize no</span></span><br><span class="line"><span class="string">pidfile redis.pid</span></span><br><span class="line"><span class="string">bind 0.0.0.0</span></span><br><span class="line"><span class="string">protected-mode no</span></span><br><span class="line"><span class="string">port 6379</span></span><br><span class="line"><span class="string">timeout 0</span></span><br><span class="line"><span class="string">logfile redis.log</span></span><br><span class="line"><span class="string">dbfilename dump.rdb</span></span><br><span class="line"><span class="string">dir /data</span></span><br><span class="line"><span class="string">slaveof 10.0.0.101 6379</span></span><br><span class="line"><span class="string">slave-read-only yes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">cp redis.conf /home/redis2/conf/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">docker run -p 6379:6379 --name redis_6379 -v /home/redis1/conf/redis.conf:/etc/redis/redis.conf -v /home/redis1/data:/data -d redis redis-server /etc/redis/redis.conf</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">docker run -p 6378:6379 --name redis_6378 -v /home/redis2/conf/redis.conf:/etc/redis/redis.conf -v /home/redis2/data:/data -d redis redis-server /etc/redis/redis.conf</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">docker run -p 6377:6379 --name redis_6377 -v /home/redis3/conf/redis.conf:/etc/redis/redis.conf -v /home/redis3/data:/data -d redis redis-server /etc/redis/redis.conf</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">info replication</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;</span><span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="四-故障处理"><a href="#四-故障处理" class="headerlink" title="四 故障处理"></a>四 故障处理</h3><p>slave故障</p>
<p>master故障</p>
<h3 id="五-复制常见问题"><a href="#五-复制常见问题" class="headerlink" title="五 复制常见问题"></a>五 复制常见问题</h3><p>1 读写分离</p>
<p>读流量分摊到从节点</p>
<p>可能遇到问题：复制数据延迟，读到过期数据，从节点故障</p>
<p>2 主从配置不一致</p>
<p>maxmemory不一致：丢失数据</p>
<p>数据结构优化参数：主节点做了优化，从节点没有设置优化，会出现一些问题</p>
<p>3 规避全量复制</p>
<p>第一次全量复制，不可避免：小主节点，低峰(夜间)</p>
<p>节点运行id不匹配：主节点重启(运行id变化)</p>
<p>复制挤压缓冲区不足：增大复制缓冲区大小，rel_backlog_size</p>
<p>4 规避复制风暴</p>
<p>单主节点复制风暴，主节点重启，所有从节点复制</p>
<h2 id="二-redis-sentinel-哨兵"><a href="#二-redis-sentinel-哨兵" class="headerlink" title="二.redis-sentinel 哨兵"></a>二.redis-sentinel 哨兵</h2><h3 id="一-主从复制问题"><a href="#一-主从复制问题" class="headerlink" title="一 主从复制问题"></a>一 主从复制问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#主从复制存在的问题：</span><br><span class="line">#1 主从复制，主节点发生故障，需要做故障转移，可以手动转移：让其中一个slave变成master</span><br><span class="line">#2 主从复制，只能主写数据，所以写能力和存储能力有限</span><br></pre></td></tr></table></figure>



<h3 id="二-哨兵作用-哨兵的三个作用监控、通知、自动转移故障"><a href="#二-哨兵作用-哨兵的三个作用监控、通知、自动转移故障" class="headerlink" title="二 哨兵作用(哨兵的三个作用监控、通知、自动转移故障)"></a>二 哨兵作用(哨兵的三个作用<code>监控、通知、自动转移故障</code>)</h3><p>可以做故障判断，故障转移，通知客户端（其实是一个进程），客户端直接连接sentinel的地址</p>
<ul>
<li>监控<br>监控谁？支持主从结构的工作一个是主节点一个是从节点，那肯定就是监控这俩个了。<br>监控主节点和从节点是否正常运行<br>检测主节点是否存活，主节点和从节点运行情况<br>通知</li>
<li>哨兵检测的服务器出现问题时，会向其他的哨兵发送通知，哨兵之间就相当于一个微信群，每个哨兵发现的问题都会发在这个群里。</li>
<li>自动故障转移<br>当检测到主节点宕机后，断开与宕机主节点连接的所有从节点，在从节点中选取一个作为主节点，然后将其他的从节点连接到这个最新主节点的上。并且告知客户端最新的服务器地址。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gadzuhodicj30oe0dc0y9.jpg" alt="image-20191229230823911"></p>
<p>1 多个sentinel发现并确认master有问题</p>
<p>2 选举触一个sentinel作为领导</p>
<p>3 选取一个slave作为新的master</p>
<p>4 通知其余slave成为新的master的slave</p>
<p>5 通知客户端主从变化</p>
<p>6 等待老的master复活成为新master的slave</p>
<h3 id="三-安装配置"><a href="#三-安装配置" class="headerlink" title="三 安装配置"></a>三 安装配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 配置开启主从节点</span><br><span class="line">2 配置开启sentinel监控主节点（sentinel是特殊的redis）</span><br><span class="line">3 应该是多台机器</span><br><span class="line"><span class="comment">#配置开启sentinel监控主节点</span></span><br><span class="line">mkdir -p redis4/conf redis4/data redis5/conf redis5/data redis6/data redis6/conf</span><br><span class="line"></span><br><span class="line">vi sentinel.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">dir data</span><br><span class="line">protected-mode no</span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">logfile <span class="string">&quot;redis_sentinel.log&quot;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run -p 26379:26379 --name redis_26379 -v /home/redis4/conf/sentinel.conf:/etc/redis/sentinel.conf -v /home/redis4/data:/data -d redis redis-sentinel /etc/redis/sentinel.conf</span><br><span class="line"></span><br><span class="line">docker run -p 26378:26379 --name redis_26378 -v /home/redis5/conf/sentinel.conf:/etc/redis/sentinel.conf -v /home/redis5/data:/data -d redis redis-sentinel /etc/redis/sentinel.conf</span><br><span class="line"></span><br><span class="line">docker run -p 26377:26379 --name redis_26377 -v /home/redis6/conf/sentinel.conf:/etc/redis/sentinel.conf -v /home/redis6/data:/data -d redis redis-sentinel /etc/redis/sentinel.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redis-sentinel sentinel.conf</span><br><span class="line"></span><br><span class="line">info</span><br><span class="line">配置会重写，自动发现slave</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br><span class="line">告诉sentinel去监听地址为ip:port的一个master，这里的master-name可以自定义，quorum是一个数字，指明当有多少个sentinel认为一个master失效时，master才算真正失效</span><br><span class="line"></span><br><span class="line">sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br><span class="line">设置连接master和slave时的密码，注意的是sentinel不能分别为master和slave设置不同的密码，因此master和slave的密码应该设置相同。</span><br><span class="line"></span><br><span class="line">sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt; </span><br><span class="line">这个配置项指定了需要多少失效时间，一个master才会被这个sentinel主观地认为是不可用的。 单位是毫秒，默认为30秒</span><br><span class="line"></span><br><span class="line">sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt; </span><br><span class="line">这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"></span><br><span class="line">sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="line">failover-timeout 可以用在以下这些方面：     </span><br><span class="line">1. 同一个sentinel对同一个master两次failover之间的间隔时间。   </span><br><span class="line">2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。    </span><br><span class="line">3.当想要取消一个正在进行的failover所需要的时间。    </span><br><span class="line">4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了。</span><br><span class="line">1 搭一个一主两从</span><br><span class="line"><span class="comment">#创建三个配置文件：</span></span><br><span class="line"><span class="comment">#第一个是主配置文件</span></span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis.pid</span><br><span class="line">port 6379</span><br><span class="line">dir <span class="string">&quot;/opt/soft/redis/data&quot;</span></span><br><span class="line">logfile “6379.log”</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二个是从配置文件</span></span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis2.pid</span><br><span class="line">port 6378</span><br><span class="line">dir <span class="string">&quot;/opt/soft/redis/data2&quot;</span></span><br><span class="line">logfile “6378.log”</span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line">slave-read-only yes</span><br><span class="line"><span class="comment">#第三个是从配置文件</span></span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis3.pid</span><br><span class="line">port 6377</span><br><span class="line">dir <span class="string">&quot;/opt/soft/redis/data3&quot;</span></span><br><span class="line">logfile “6377.log”</span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line">slave-read-only yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#把三个redis服务都启动起来</span></span><br><span class="line">./src/redis-server redis_6379.conf</span><br><span class="line">./src/redis-server redis_6378.conf</span><br><span class="line">./src/redis-server redis_6377.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2 搭建哨兵</span><br><span class="line"><span class="comment"># sentinel.conf这个文件</span></span><br><span class="line"><span class="comment"># 把哨兵也当成一个redis服务器</span></span><br><span class="line">创建三个配置文件分别叫sentinel_26379.conf sentinel_26378.conf  sentinel_26377.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前路径下创建 data1 data2 data3 个文件夹</span></span><br><span class="line"><span class="comment">#内容如下(需要修改端口，文件地址日志文件名字)</span></span><br><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">dir ./data3</span><br><span class="line">protected-mode no</span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">logfile <span class="string">&quot;redis_sentinel3.log&quot;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动三个哨兵</span></span><br><span class="line">./src/redis-sentinel sentinel_26379.conf</span><br><span class="line">./src/redis-sentinel sentinel_26378.conf</span><br><span class="line">./src/redis-sentinel sentinel_26377.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 登陆哨兵</span></span><br><span class="line">./src/redis-cli -p 26377</span><br><span class="line"><span class="comment"># 输入 info</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看哨兵的配置文件被修改了，自动生成的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主动停掉主redis 6379，哨兵会自动选择一个从库作为主库</span></span><br><span class="line">redis-cli -p 6379</span><br><span class="line">shutdown</span><br><span class="line"><span class="comment">#等待原来的主库启动，该主库会变成从库</span></span><br></pre></td></tr></table></figure>

<h3 id="四-客户端连接"><a href="#四-客户端连接" class="headerlink" title="四 客户端连接"></a>四 客户端连接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import redis</span><br><span class="line">from redis.sentinel import Sentinel</span><br><span class="line"></span><br><span class="line"># 连接哨兵服务器(主机名也可以用域名)</span><br><span class="line"># 10.0.0.101:26379</span><br><span class="line">sentinel &#x3D; Sentinel([(&#39;10.0.0.101&#39;, 26379),</span><br><span class="line">                     (&#39;10.0.0.101&#39;, 26378),</span><br><span class="line">                     (&#39;10.0.0.101&#39;, 26377)</span><br><span class="line">             ],</span><br><span class="line">                    socket_timeout&#x3D;5)</span><br><span class="line"></span><br><span class="line">print(sentinel)</span><br><span class="line"># 获取主服务器地址</span><br><span class="line">master &#x3D; sentinel.discover_master(&#39;mymaster&#39;)</span><br><span class="line">print(master)</span><br><span class="line"></span><br><span class="line"># 获取从服务器地址</span><br><span class="line">slave &#x3D; sentinel.discover_slaves(&#39;mymaster&#39;)</span><br><span class="line">print(slave)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 读写分离</span><br><span class="line"># 获取主服务器进行写入</span><br><span class="line"># master &#x3D; sentinel.master_for(&#39;mymaster&#39;, socket_timeout&#x3D;0.5)</span><br><span class="line"># w_ret &#x3D; master.set(&#39;foo&#39;, &#39;bar&#39;)</span><br><span class="line"></span><br><span class="line"># slave &#x3D; sentinel.slave_for(&#39;mymaster&#39;, socket_timeout&#x3D;0.5)</span><br><span class="line"># r_ret &#x3D; slave.get(&#39;foo&#39;)</span><br><span class="line"># print(r_ret)</span><br></pre></td></tr></table></figure>

<h3 id="五-实现原理"><a href="#五-实现原理" class="headerlink" title="五 实现原理"></a>五 实现原理</h3><h4 id="1-监控工作流程"><a href="#1-监控工作流程" class="headerlink" title="1. 监控工作流程"></a>1. 监控工作流程</h4><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/20200603153429516.png" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>哨兵发送info指令，并且保存所有哨兵状态，主节点和从节点的信息</span><br><span class="line"><span class="number">2.</span>主节点会记录redis实例的信息，主节点记录的信息跟哨兵记录的信息看起来是一样的，实际上还是有点区别哈。</span><br><span class="line"><span class="number">3.</span>哨兵会根据在主节点拿到的从节点信息，给对应的从节点也发送info指令</span><br><span class="line"><span class="number">4.</span>接着哨兵<span class="number">2</span>来了，同样的也会给主节点发送info指令，并且建立cmd连接</span><br><span class="line"><span class="number">5.</span>这个时候哨兵<span class="number">2</span>也会保存跟哨兵<span class="number">1</span>一样的信息，只不过是保存的哨兵信息是<span class="number">2</span>个。</span><br><span class="line"><span class="number">6.</span>这个时候为了每个哨兵的信息都一致它们之间建立了一个发布订阅。为了哨兵之间的信息长期对称它们之间也会互发ping命令。</span><br><span class="line"><span class="number">7.</span>当再来一个哨兵<span class="number">3</span>时，也会做同样的事情，给主节点和从节点发送info。并且跟哨兵<span class="number">1</span>和哨兵<span class="number">2</span>建立连接。</span><br></pre></td></tr></table></figure>

<h4 id="2-通知工作流程"><a href="#2-通知工作流程" class="headerlink" title="2. 通知工作流程"></a>2. 通知工作流程</h4><p>Sentinel会给主从的所有节点发送命令获取其状态，并且会把信息发布到哨兵的订阅里。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/20200603160407526.png" alt="img"></p>
<h4 id="3-故障转移原理（本文重点）"><a href="#3-故障转移原理（本文重点）" class="headerlink" title="3. 故障转移原理（本文重点）"></a>3. 故障转移原理（本文重点）</h4><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/20200603163500204.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>哨兵会一直给主节点发送publish sentinel ：hello，直到哨兵报出sdown，这个词这会是有不是有点熟悉了。没错就是我们上文中把主节点断开后哨兵服务端报出的信息。哨兵报出主节点sdown后还没有完，哨兵还会往内网里发布消息说明这个主节点挂了。发送的指令是sentinel <span class="keyword">is</span>-master-down-by-address-port</span><br><span class="line"><span class="number">2.</span>其余的哨兵接收到指令后，主节点挂了吗？让我去看看到底挂没挂。发送的信息也是hello。其余的哨兵也会发送他们收到的信息并且发送指令sentinel <span class="keyword">is</span>-master-down-by-address-port到自己的内网，确认一下第一个发送sentinel <span class="keyword">is</span>-master-down-by-address-port的哨兵说你说的对，这个家伙确实挂了。当所有人都认为主节点挂了后就会修改其状态为odown。当一个哨兵认为主节点挂了标记的是sdown，当半数哨兵都认为挂了其标记的状态是odown。这也就是配置哨兵为什么配置单数的原因。</span><br><span class="line"><span class="number">3.</span>对于一个哨兵认为主节点挂了称之为主观下线，半数哨兵认为主节点挂了称之为客官下线。</span><br><span class="line"><span class="number">4.</span>一旦被认为主节点客官下线后，哨兵就会进行下一步操作</span><br></pre></td></tr></table></figure>

<p>这时哨兵已经检测到问题所在了，那么到底是那个哨兵去负责推选新的主节点呢！不能是张三也去，李四也去，王五也去，这样就乱套了、于是就需要在所有的哨兵里选出领头的，那么是如何选的呢！请看下图。</p>
<p>这个时候呢！五个sentinel就在一起开会了，所有的哨兵都在一个内网中，然后他们会做一件事情就是五个sentinel会同时发送指令sentinel is-master-down-by-address-port并且携带上自己竞选次数和runid。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/20200603164854686.png" alt="在这里插入图片描述"></p>
<p>每个sentinel既是参选者也是投票者，每个sentinel都有一票，信封就代表自己的投票权。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/20200603165131230.png" alt="在这里插入图片描述"></p>
<p>当sentinel1和sentinel4同时把指令发送到群里准备竞选时，sentinel2这个时候就说我先接到谁的指令就把票投给谁。假如sentinel1发的早，那么sentinel2的票就会投给sentinel1。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/20200603165912284.png" alt="在这里插入图片描述"></p>
<p>按照这样的规则一直发起投票直到有一个sentinel的票数为总sentinel数量的一半之多。假设说是sentinel1的票数满足总哨兵数量的一半之多后，sentinel1就会当选。这个时候就进行到了下一个阶段。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/20200603170155706.png" alt="在这里插入图片描述"></p>
<p>在上边哨兵已经选出了sentinel1为代表去所有的从节点找出一个作为主节点。这个挑选主节点不是随便拿一个是有一定的规则的。</p>
<p>先把不在线的干掉</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/20200603173148510.png" alt="在这里插入图片描述"></p>
<p>响应慢的干掉，sentinel会给所有的redis发送信息，响应速度慢的就会被干掉</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/20200603173408822.png" alt="在这里插入图片描述"></p>
<p>与原主节点断开时间最久的干掉，这里由于演示不够用了，所有新增了一个slave5，没有任何意义哈！</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/20200603173831345.png" alt="在这里插入图片描述"></p>
<p>以上三个点都判断结束后还有salve4和slave5，就会根据优先原则来进行筛选。</p>
<p>首先会根据优先级，如果优先级一样在进行其他判断<br>判断offset偏移量，判断数据同步性，假如说slave4的offset为90 slave5偏移量为100 那么哨兵就会认为slave4的网络是不是有问题啊！于是就会选slave5为新的主节点。那如果说是slave4和slave5的offset相同呢！还有最后一个判断<br>最后一步就是判断runid了，也就是职场中的论资排辈了，也就说根据runid的创建时间来判断，时间早的上位。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/20200603174710311.png" alt="在这里插入图片描述"></p>
<p>选出新的主节点后就要对所有的节点发送指令了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/2020060317550042.png" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">首先进行监控，并且所有的哨兵同步信息</span><br><span class="line"></span><br><span class="line">哨兵向订阅里边发布信息</span><br><span class="line"></span><br><span class="line">故障转移</span><br><span class="line"></span><br><span class="line">哨兵发现主节点下线</span><br><span class="line">哨兵开启投票竞选负责人</span><br><span class="line">由负责人推选新的主节点</span><br><span class="line">新的主节点断开原主节点，并且其他的从节点连接新的主节点，原主节点上线后作为从节点连接。</span><br></pre></td></tr></table></figure>



<h3 id="六-常见问题"><a href="#六-常见问题" class="headerlink" title="六 常见问题"></a>六 常见问题</h3><h2 id="三-redis-cluster"><a href="#三-redis-cluster" class="headerlink" title="三.redis-cluster"></a>三.redis-cluster</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">https://blog.csdn.net/fangkang7/article/details/<span class="number">106560672</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">一. 高性能： </span><br><span class="line">  <span class="number">1</span>、在多分片节点中，将<span class="number">16384</span>个槽位，均匀分布到多个分片节点中</span><br><span class="line">  <span class="number">2</span>、存数据时，将key做crc16(key),然后和<span class="number">16384</span>进行取模，得出槽位值（<span class="number">0</span><span class="number">-16383</span>之间）</span><br><span class="line">  <span class="number">3</span>、key ---hash运算-----落到后端槽位 根据计算得出的槽位值，找到相对应的分片节点的主节点，存储到相应槽位上</span><br><span class="line">  <span class="number">4</span>、如果客户端当时连接的节点不是将来要存储的分片节点，分片集群会将客户端连接切换至真正存储节点进行数据存储</span><br><span class="line">二.高可用：</span><br><span class="line">在搭建集群时，会为每一个分片的主节点，对应一个从节点，实现slaveof的功能，同时当主节点down，实现类似于sentinel的自动failover的功能。</span><br><span class="line">三. 规划、搭建过程：</span><br><span class="line">  <span class="number">6</span>个redis实例，一般会放到<span class="number">3</span>台硬件服务器</span><br><span class="line">  注：在企业规划中，一个分片的两个分到不同的物理机，防止硬件主机宕机造成的整个分片数据丢失。</span><br><span class="line">  端口号：<span class="number">7000</span><span class="number">-7005</span></span><br></pre></td></tr></table></figure>





<h3 id="一-Redis-Cluser介绍背景（分库分表就两种方案-顺序和hash-redis-cluster使用的是虚拟槽-）"><a href="#一-Redis-Cluser介绍背景（分库分表就两种方案-顺序和hash-redis-cluster使用的是虚拟槽-）" class="headerlink" title="一 Redis Cluser介绍背景（分库分表就两种方案 顺序和hash(redis-cluster使用的是虚拟槽)）"></a>一 Redis Cluser介绍背景（分库分表就两种方案 顺序和hash(redis-cluster使用的是虚拟槽)）</h3><p>增加和删除节点注意窗口期，因为涉及到槽位迁移，重新分配。</p>
<h4 id="1-1问题"><a href="#1-1问题" class="headerlink" title="1.1问题"></a>1.1问题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 存在问题 </span><br><span class="line">1 并发量：单机redis qps为10w&#x2F;s,但是我们可能需要百万级别的并发量</span><br><span class="line">2 数据量：机器内存16g--256g，如果存500g数据呢？</span><br></pre></td></tr></table></figure>

<h4 id="1-2-解决"><a href="#1-2-解决" class="headerlink" title="1.2 解决"></a>1.2 解决</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 解决：加机器，分布式</span><br><span class="line">redis cluster 在2015年的 3.0 版本加入了，满足分布式的需求</span><br></pre></td></tr></table></figure>

<h3 id="二-数据分布（分布式数据库）"><a href="#二-数据分布（分布式数据库）" class="headerlink" title="二 数据分布（分布式数据库）"></a>二 数据分布（分布式数据库）</h3><h4 id="2-1-存在问题"><a href="#2-1-存在问题" class="headerlink" title="2.1 存在问题"></a>2.1 存在问题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设全量的数据非常大，500g，单机已经无法满足，我们需要进行分区，分到若干个子集中</span><br></pre></td></tr></table></figure>

<h4 id="2-2-分区方式"><a href="#2-2-分区方式" class="headerlink" title="2.2 分区方式"></a>2.2 分区方式</h4><table>
<thead>
<tr>
<th>分布方式</th>
<th>特点</th>
<th>产品</th>
</tr>
</thead>
<tbody><tr>
<td>哈希分布</td>
<td>数据分散度高，建值分布于业务无关，无法顺序访问，支持批量操作</td>
<td>一致性哈希memcache，redis cluster，其他缓存产品</td>
</tr>
<tr>
<td>顺序分布</td>
<td>数据分散度易倾斜，建值业务相关，可顺序访问，支持批量操作</td>
<td>BigTable，HBase</td>
</tr>
</tbody></table>
<h5 id="2-2-1-顺序分区"><a href="#2-2-1-顺序分区" class="headerlink" title="2.2.1 顺序分区"></a>2.2.1 顺序分区</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 原理：100个数据分到3个节点上 1--33第一个节点；34--66第二个节点；67--100第三个节点（很多关系型数据库使用此种方式）</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-哈希分区"><a href="#2-2-2-哈希分区" class="headerlink" title="2.2.2 哈希分区"></a>2.2.2 哈希分区</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 原理：hash分区： 节点取余 ，假设3台机器， hash(key)%3,落到不同节点上</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-1-节点取余分区"><a href="#2-2-2-1-节点取余分区" class="headerlink" title="2.2.2 .1 节点取余分区"></a>2.2.2 .1 节点取余分区</h5><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gicfyki8z3j31z40s0e55.jpg" alt="image-20200811120153068"></p>
<p>节点扩容，添加一个节点，存在问题，很多数据需要偏移，总偏移量要大于80%</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gicfz99dh4j30x80u0dy9.jpg" alt="image-20200811120704296"></p>
<p>推荐翻倍扩容，由3变成6，数据量迁移为50%，比80%降低</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gicfzd2rulj31q80u04qp.jpg" alt="image-20200811120815523"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 总结：</span><br><span class="line">客户端分片，通过hash+取余</span><br><span class="line">节点伸缩，数据节点关系发生变化，导致影响数据迁移过大</span><br><span class="line">迁移数量和添加节点数量有关：建议翻倍扩容</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-2-一致性哈希分区"><a href="#2-2-2-2-一致性哈希分区" class="headerlink" title="2.2.2 .2 一致性哈希分区"></a>2.2.2 .2 一致性哈希分区</h5><p>每个节点负责一部分数据，对key进行hash，得到结果在node1和node2之间，就放到node2中，顺时针查找</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gicfzhs7wtj31i40u04e7.jpg" alt="image-20200811121233804"></p>
<p>假设添加一个新节点node5，现在只需要迁移一小部分数据，不会影响node3和node4的数据，只会迁移node1和node2的数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gicfzlkae8j30u00vagwo.jpg" alt="image-20200811121518855"></p>
<p>节点比较多的话合适，假设有1000个节点，加一个只要迁移千分之一的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#总结：</span><br><span class="line">客户端分片：哈希+顺时针（优化取余）</span><br><span class="line">节点伸缩：只影响临近节点，但是还有数据迁移的情况</span><br><span class="line">伸缩：保证最小迁移数据和无法保证负载均衡（这样总共5个节点，数据就不均匀了），翻倍扩容可以实现负载均衡</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-3-虚拟槽分区"><a href="#2-2-2-3-虚拟槽分区" class="headerlink" title="2.2.2 .3 虚拟槽分区"></a>2.2.2 .3 虚拟槽分区</h5><p>预设虚拟槽：每个槽映射一个数据子集，一般比节点数大</p>
<p>良好的哈希函数：如CRC16</p>
<p>服务端管理节点、槽、数据：如redis cluster（槽的范围0–16383）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5个节点，把16384个槽平均分配到每个节点，客户端会把数据发送给任意一个节点，通过CRC16对key进行哈希对16383进行取余，算出当前key属于哪部分槽，属于哪个节点，每个节点都会记录是不是负责这部分槽，如果是负责的，进行保存，如果槽不在自己范围内，redis cluster是共享消息的模式，它知道哪个节点负责哪些槽，返回结果，让客户端找对应的节点去存</span><br><span class="line">服务端管理节点，槽，关系</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gicfzpidedj31sa0ss7v2.jpg" alt="image-20200811190745066"></p>
<h3 id="三-集群搭建"><a href="#三-集群搭建" class="headerlink" title="三 集群搭建"></a>三 集群搭建</h3><h4 id="3-1-单机架构"><a href="#3-1-单机架构" class="headerlink" title="3. 1 单机架构"></a>3. 1 单机架构</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gicfzu8mifj318m0qqwni.jpg" alt="image-20200811191353220"></p>
<h4 id="3-2-分布式架构"><a href="#3-2-分布式架构" class="headerlink" title="3.2 分布式架构"></a>3.2 分布式架构</h4><p>每个节点之间相互通信，都负责读写，客户端去存，如果不是当前节点，会返回应该存到哪个节点</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gicfzygmc8j30na0qmdso.jpg" alt="image-20200811191435244"></p>
<h4 id="3-3-Redis-Cluster架构"><a href="#3-3-Redis-Cluster架构" class="headerlink" title="3.3 Redis Cluster架构"></a>3.3 Redis Cluster架构</h4><p>节点，meet，指派槽，复制，高可用</p>
<h5 id="meet解释"><a href="#meet解释" class="headerlink" title="meet解释"></a>meet解释</h5><p>A meet一下C，C回复一下，A meet一下B ，B回复一下，这样B和C也能相互感知，A，B，C之间就可以相关交互数据，所有节点共享消息</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gicg03n445j31460rugwv.jpg" alt="image-20200811192029280"></p>
<h5 id="指派槽"><a href="#指派槽" class="headerlink" title="指派槽"></a>指派槽</h5><p>总共有16384个槽，平均分配到每个节点上</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gicg07cegpj31i10u01kx.jpg" alt="image-20200811192334455"></p>
<h4 id="3-4-原生安装"><a href="#3-4-原生安装" class="headerlink" title="3.4 原生安装"></a>3.4 原生安装</h4><p>1 配置开启节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 配置</span></span><br><span class="line">port <span class="variable">$&#123;port&#125;</span></span><br><span class="line">daemonize yes</span><br><span class="line">dir <span class="string">&quot;/opt/redis/redis/data/&quot;</span></span><br><span class="line">logfile <span class="string">&quot;<span class="variable">$&#123;port&#125;</span>.log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#masterauth  集群搭建时，主的密码</span></span><br><span class="line">cluster-enabled yes  <span class="comment"># 开启cluster</span></span><br><span class="line">cluster-node-timeout 15000 <span class="comment"># 故障转移，超时时间 15s</span></span><br><span class="line">cluster-config-file nodes-<span class="variable">$&#123;port&#125;</span>.conf  <span class="comment"># 给cluster节点增加一个自己的配置文件</span></span><br><span class="line">cluster-require-full-coverage yes  <span class="comment">#只要集群中有一个故障了，整个就不对外提供服务了，这个实际不合理，假设有50个节点，一个节点故障了，所有不提供服务了；，需要设置成no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 开启6个节点</span></span><br><span class="line">redis-server redis-7000.conf</span><br><span class="line">redis-server redis-7001.conf</span><br><span class="line">redis-server redis-7002.conf</span><br><span class="line">redis-server redis-7003.conf</span><br><span class="line">redis-server redis-7004.conf</span><br><span class="line">redis-server redis-7005.conf</span><br></pre></td></tr></table></figure>

<p>2 meet(相互通信)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7001</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7002</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7003</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7004</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7005</span><br></pre></td></tr></table></figure>

<p>3 指派槽</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster addslots &#123;0...5461&#125;</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster addslots &#123;5462...10922&#125;</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster addslots &#123;10923...16383&#125;</span><br></pre></td></tr></table></figure>

<p>4 主从</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cluster replicate node-id</span></span><br><span class="line"><span class="comment"># 让7003复制7000</span></span><br><span class="line">redis-cli -h 127.0.0.1 -p 7003 cluster replicate <span class="variable">$&#123;node-id-7000&#125;</span></span><br><span class="line">redis-cli -h 127.0.0.1 -p 7004 cluster replicate <span class="variable">$&#123;node-id-7001&#125;</span></span><br><span class="line">redis-cli -h 127.0.0.1 -p 7005 cluster replicate <span class="variable">$&#123;node-id-7002&#125;</span></span><br><span class="line"><span class="comment"># 实操</span></span><br><span class="line"><span class="built_in">cd</span> /opt/soft/redis/config</span><br><span class="line">vim redis-7000.conf</span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line">port 7000</span><br><span class="line">daemonize yes</span><br><span class="line">dir <span class="string">&quot;/opt/soft/redis/data/&quot;</span></span><br><span class="line">logfile <span class="string">&quot;7000.log&quot;</span></span><br><span class="line">dbfilename <span class="string">&quot;dump-7000.rdb&quot;</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-7000.conf</span><br><span class="line">cluster-require-full-coverage yes </span><br><span class="line"><span class="comment"># 快速生成其他配置</span></span><br><span class="line">sed <span class="string">&#x27;s/7000/7001/g&#x27;</span> redis-7000.conf &gt; redis-7001.conf</span><br><span class="line">sed <span class="string">&#x27;s/7000/7002/g&#x27;</span> redis-7000.conf &gt; redis-7002.conf</span><br><span class="line">sed <span class="string">&#x27;s/7000/7003/g&#x27;</span> redis-7000.conf &gt; redis-7003.conf</span><br><span class="line">sed <span class="string">&#x27;s/7000/7004/g&#x27;</span> redis-7000.conf &gt; redis-7004.conf</span><br><span class="line">sed <span class="string">&#x27;s/7000/7005/g&#x27;</span> redis-7000.conf &gt; redis-7005.conf</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">./src/redis-server ./config/redis-7000.conf</span><br><span class="line">ps -ef |grep redis</span><br><span class="line">./src/redis-server ./config/redis-7001.conf</span><br><span class="line">./src/redis-server ./config/redis-7002.conf</span><br><span class="line">./src/redis-server ./config/redis-7003.conf</span><br><span class="line">./src/redis-server ./config/redis-7004.conf</span><br><span class="line">./src/redis-server ./config/redis-7005.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接其中一个，set数据（失败，因为没有分配槽）</span></span><br><span class="line">redis-cli -p 7000</span><br><span class="line"><span class="built_in">set</span> hello world <span class="comment">#报错</span></span><br><span class="line"><span class="comment"># config文件夹下出现了：nodes-7000.conf，查看一下可以看到节点的id</span></span><br><span class="line"><span class="comment"># 也可以：</span></span><br><span class="line">redis-cli -p 7000 cluster nodes</span><br><span class="line"><span class="comment"># 也可以:查看更详细信息</span></span><br><span class="line">redis-cli -p 7000 cluster info</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 节点握手（meet操作）</span></span><br><span class="line"><span class="comment"># 7000和7001 握手</span></span><br><span class="line">redis-cli -p 7000 cluster meet 127.0.0.1 7001</span><br><span class="line"><span class="comment"># 查看握手情况</span></span><br><span class="line">redis-cli -p 7000 cluster nodes <span class="comment"># 可以看到已经达成了握手</span></span><br><span class="line">redis-cli -p 7002 cluster nodes <span class="comment"># 没有握手，还是孤立</span></span><br><span class="line"><span class="comment"># 继续握手</span></span><br><span class="line">redis-cli -p 7000 cluster meet 127.0.0.1 7002</span><br><span class="line">redis-cli -p 7000 cluster meet 127.0.0.1 7003</span><br><span class="line">redis-cli -p 7000 cluster meet 127.0.0.1 7004</span><br><span class="line">redis-cli -p 7000 cluster meet 127.0.0.1 7005</span><br><span class="line"><span class="comment"># 查看最后结果</span></span><br><span class="line">redis-cli -p 7000 cluster info  <span class="comment"># 可以看到6个节点握手成功了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 当前还是不可以读写，还没分配槽</span></span><br><span class="line">redis-cli -p 7000 cluster addslots 0 <span class="comment"># 给7000分配第0个槽</span></span><br><span class="line"><span class="comment"># 这样一个个设置太麻烦，咱们写个脚本执行</span></span><br><span class="line">mkdir script</span><br><span class="line"><span class="built_in">cd</span> script</span><br><span class="line">vim addslots.sh</span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line">start=<span class="variable">$1</span></span><br><span class="line">end=<span class="variable">$2</span></span><br><span class="line">port=<span class="variable">$3</span></span><br><span class="line"><span class="keyword">for</span> slot <span class="keyword">in</span> `seq <span class="variable">$&#123;start&#125;</span> <span class="variable">$&#123;end&#125;</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;slot:<span class="variable">$&#123;slot&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 保存退出，测试</span></span><br><span class="line">sh addslots.sh 0 4096 7000</span><br><span class="line"><span class="comment"># 写具体命令</span></span><br><span class="line">start=<span class="variable">$1</span></span><br><span class="line">end=<span class="variable">$2</span></span><br><span class="line">port=<span class="variable">$3</span></span><br><span class="line"><span class="keyword">for</span> slot <span class="keyword">in</span> `seq <span class="variable">$&#123;start&#125;</span> <span class="variable">$&#123;end&#125;</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;slot:<span class="variable">$&#123;slot&#125;</span>&quot;</span></span><br><span class="line">  redis-cli -p <span class="variable">$&#123;port&#125;</span> cluster addslots <span class="variable">$&#123;slot&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line">sh addslots.sh 0 5641 7000</span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">redis-cli -p 7000</span><br><span class="line">cluster info</span><br><span class="line">cluster nodes</span><br><span class="line"><span class="comment"># 继续分槽</span></span><br><span class="line">sh addslots.sh 5641 10922 7001</span><br><span class="line">sh addslots.sh 10923  16383 7002</span><br><span class="line"><span class="comment"># 查看集群状态</span></span><br><span class="line">redis-cli -p 7000 cluster info</span><br><span class="line"></span><br><span class="line"><span class="comment">##  配置主从</span></span><br><span class="line"><span class="comment"># 7003是7000的从</span></span><br><span class="line"><span class="comment"># 7004是7001的从</span></span><br><span class="line"><span class="comment"># 7005是7002的从</span></span><br><span class="line">redis-cli -p 7003 cluster replicate 7000id</span><br><span class="line">redis-cli -p 7004 cluster replicate 7001id</span><br><span class="line">redis-cli -p 7005 cluster replicate 7002id</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看</span></span><br><span class="line">redis-cli -p 7000 cluster info</span><br><span class="line">redis-cli -p 7000 cluster nodes</span><br><span class="line">redis-cli -p 7000 cluster slots <span class="comment"># 查看槽的信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存放数据</span></span><br><span class="line">redis-cli -c -p 7000</span><br><span class="line"><span class="built_in">set</span> hello world <span class="comment"># 可以成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 生产环境建议 三台机器，主从不放在同一台机器上</span></span><br></pre></td></tr></table></figure>

<h4 id="3-5-官方工具安装（Ruby脚本）"><a href="#3-5-官方工具安装（Ruby脚本）" class="headerlink" title="]3.5 官方工具安装（Ruby脚本）"></a>]3.5 官方工具安装（Ruby脚本）</h4><h5 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载编译安装ruby</span></span><br><span class="line">wget https://cache.ruby-lang.org/pub/ruby/2.5/ruby-2.5.8.tar.gz</span><br><span class="line">tar -zxvf ruby-2.5.8.tar.gz</span><br><span class="line"><span class="built_in">cd</span> ruby</span><br><span class="line">./configure -prefix=/usr/<span class="built_in">local</span>/ruby</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/ruby</span><br><span class="line">cp bin/ruby /usr/<span class="built_in">local</span>/bin  <span class="comment"># ruby类似于python3</span></span><br><span class="line">cp bin/gem /usr/<span class="built_in">local</span>/bin   <span class="comment"># gem类似于pip</span></span><br><span class="line"></span><br><span class="line">ruby -v <span class="comment"># 检查版本</span></span><br><span class="line"><span class="comment"># 安装rubygem redis</span></span><br><span class="line"><span class="comment">### 更换gem源</span></span><br><span class="line">gem sources -l</span><br><span class="line"><span class="comment"># 移除https://rubygems.org源</span></span><br><span class="line">gem sources --remove https://rubygems.org/</span><br><span class="line"><span class="comment"># 增加https://gems.ruby-china.com/源</span></span><br><span class="line">gem sources -a https://gems.ruby-china.com/</span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">gem sources -l</span><br><span class="line"><span class="comment">## 安装gem redis</span></span><br><span class="line">gem install redis -v 3.3.3</span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">gem list check redis gem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装redis-trib.rb</span></span><br><span class="line"><span class="built_in">cd</span> /opt/soft/redis/src</span><br><span class="line">./redis-trib.rb 弃用了，需要使用</span><br><span class="line"><span class="comment"># 1 表示给每个主节点配置一个从节点</span></span><br><span class="line">redis-cli --cluster create --cluster-replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</span><br><span class="line">yes</span><br></pre></td></tr></table></figure>

<h3 id="四-集群伸缩"><a href="#四-集群伸缩" class="headerlink" title="四 集群伸缩"></a>四 集群伸缩</h3><h4 id="伸缩原理"><a href="#伸缩原理" class="headerlink" title="伸缩原理"></a>伸缩原理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 加入节点，删除节点：槽和数据在节点之间的移动</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gicg1469xqj31uc0tk7u6.jpg" alt="image-20200811235039641"></p>
<h4 id="集群扩容"><a href="#集群扩容" class="headerlink" title="集群扩容"></a>集群扩容</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 作用：为它迁移槽和数据实现扩容  作为从节点负责故障转移</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1  准备新节点</span></span><br><span class="line">-集群模式</span><br><span class="line">-配置和其他节点统一</span><br><span class="line">-启动后是孤儿节点</span><br><span class="line">sed <span class="string">&#x27;s/7000/7006/g&#x27;</span> redis-7000.conf &gt; redis-7006.conf</span><br><span class="line">sed <span class="string">&#x27;s/7000/7007/g&#x27;</span> redis-7000.conf &gt; redis-7007.conf</span><br><span class="line">redis-server conf/redis-7006.conf</span><br><span class="line">redis-server conf/redis-7007.conf</span><br><span class="line"><span class="comment"># 孤立状态re</span></span><br><span class="line">redis-cli -p 7006 cluster nodes</span><br><span class="line"><span class="comment">#2  加入集群</span></span><br><span class="line"><span class="comment">### 方式一</span></span><br><span class="line">在7000上执行</span><br><span class="line">redis-cli -p 7000 cluster meet 127.0.0.1 7006</span><br><span class="line">redis-cli -p 7000 cluster meet 127.0.0.1 7007</span><br><span class="line"><span class="comment">### 方式二</span></span><br><span class="line">redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000</span><br><span class="line">redis-cli --cluster add-node 127.0.0.1:7007 127.0.0.1:7000</span><br><span class="line"><span class="comment"># 查看配置</span></span><br><span class="line">cluster nodes</span><br><span class="line"><span class="comment"># 把7007做为7006的从</span></span><br><span class="line">redis-cli -p 7007 cluster replicate 7006的id</span><br><span class="line"><span class="comment">#3  迁移槽和数据</span></span><br><span class="line">  <span class="comment"># 槽迁移计划</span></span><br><span class="line">  <span class="comment"># 迁移数据</span></span><br><span class="line">  <span class="comment"># 添加从节点</span></span><br><span class="line">  </span><br><span class="line"> <span class="comment"># 我们不操作原生，直接使用redis-trip</span></span><br><span class="line">redis-cli --cluster reshard 127.0.0.1:7000 </span><br><span class="line"><span class="comment">#打印当前集群状态</span></span><br><span class="line"><span class="comment"># 希望迁移多少个槽：4096</span></span><br><span class="line"><span class="comment"># 希望那个id是接收的：7006的id</span></span><br><span class="line"><span class="comment"># 传入source id ：all</span></span><br><span class="line"><span class="comment"># yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">redis-cli -p 7000 cluster nodes</span><br><span class="line">redis-cli -p 7000 cluster slots</span><br><span class="line"><span class="comment">## 其他：</span></span><br><span class="line">-如果想给7000再加一个从节点怎么弄？</span><br><span class="line"><span class="comment"># 启动起7006，meet一下，让7006复制7000</span></span><br><span class="line">redis-cli -p 7000 cluster meet 127.0.0.1 7006</span><br><span class="line">redis-cli -p 7006 cluster replicate e03fb9a259cd314e9a23e17573d07c477d3242f7</span><br></pre></td></tr></table></figure>

<h4 id="集群缩容"><a href="#集群缩容" class="headerlink" title="集群缩容"></a>集群缩容</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下线迁槽（把7006的1366个槽迁移到7000上）</span></span><br><span class="line">redis-cli --cluster reshard --cluster-from 7006的id --cluster-to 7000的id --cluster-slots 1366 127.0.0.1:7000</span><br><span class="line">yes</span><br><span class="line"></span><br><span class="line">redis-cli --cluster reshard --cluster-from 7006的id --cluster-to 7001的id --cluster-slots 1366 127.0.0.1:7001</span><br><span class="line">yes</span><br><span class="line">redis-cli --cluster reshard --cluster-from 7006的id --cluster-to 7002的id --cluster-slots 1365 127.0.0.1:7002</span><br><span class="line">yes</span><br><span class="line"><span class="comment"># 忘记节点，关闭节点</span></span><br><span class="line">redis-cli --cluster del-node 127.0.0.1:7000 要下线的7007id  <span class="comment"># 先下从，再下主，因为先下主会触发故障转移</span></span><br><span class="line">redis-cli --cluster del-node 127.0.0.1:7000 要下线的7006id </span><br><span class="line"><span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关掉其中一个主，另一个从立马变成主顶上， 重启停止的主，发现变成了从</span></span><br></pre></td></tr></table></figure>

<h3 id="五-客户端连接"><a href="#五-客户端连接" class="headerlink" title="五 客户端连接"></a>五 客户端连接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -c -p 7000  <span class="comment"># -c表示集群模式</span></span><br><span class="line"><span class="built_in">set</span> hello world  <span class="comment"># ok</span></span><br><span class="line">cluster keyslot php</span><br><span class="line"><span class="comment"># 9244</span></span><br><span class="line"><span class="built_in">set</span> php sb <span class="comment"># 不命中，会返回7001，自动跳转到7001上  不加-c，只会返回错误，不会去执行7001上保存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># rediscluster</span></span><br><span class="line"><span class="comment"># pip3 install redis-py-cluster</span></span><br><span class="line">from rediscluster import RedisCluster</span><br><span class="line">startup_nodes = [&#123;<span class="string">&quot;host&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;port&quot;</span>: <span class="string">&quot;7000&quot;</span>&#125;,&#123;<span class="string">&quot;host&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;port&quot;</span>: <span class="string">&quot;7001&quot;</span>&#125;,&#123;<span class="string">&quot;host&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;port&quot;</span>: <span class="string">&quot;7002&quot;</span>&#125;]</span><br><span class="line"><span class="comment"># rc = RedisCluster(startup_nodes=startup_nodes,decode_responses=True)</span></span><br><span class="line">rc = RedisCluster(startup_nodes=startup_nodes)</span><br><span class="line">rc.set(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(rc.get(<span class="string">&quot;foo&quot;</span>))</span><br></pre></td></tr></table></figure>

<h3 id="六-集群原理"><a href="#六-集群原理" class="headerlink" title="六 集群原理"></a>六 集群原理</h3><p>move重定向</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gicg19v43hj31pl0u01ea.jpg" alt="image-20200812003219180"></p>
<p>槽命中</p>
<p>cluster keyslot hello 可以计算出槽的值</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gicg1dtp92j31te0q27hv.jpg" alt="image-20200812003318203"></p>
<p>槽不命中：moved异常</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gicg1i8mu1j31r80u07nz.jpg" alt="image-20200812003446448"></p>
<h3 id="七-补充"><a href="#七-补充" class="headerlink" title="七 补充"></a>七 补充</h3><h4 id="7-1-5-0以后集群搭建"><a href="#7-1-5-0以后集群搭建" class="headerlink" title="7.1 5.0以后集群搭建"></a>7.1 5.0以后集群搭建</h4><p>Redis Cluster 在5.0之后取消了ruby脚本 <strong>redis-trib.rb</strong>的支持（手动命令行添加集群的方式不变），集合到redis-cli里，避免了再安装ruby的相关环境。直接使用redis-clit的参数–cluster 来取代</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster <span class="built_in">help</span></span><br><span class="line">Cluster Manager Commands:</span><br><span class="line">  create         host1:port1 ... hostN:portN   <span class="comment">#创建集群</span></span><br><span class="line">                 --cluster-replicas &lt;arg&gt;      <span class="comment">#从节点个数</span></span><br><span class="line">  check          host:port                     <span class="comment">#检查集群</span></span><br><span class="line">                 --cluster-search-multiple-owners <span class="comment">#检查是否有槽同时被分配给了多个节点</span></span><br><span class="line">  info           host:port                     <span class="comment">#查看集群状态</span></span><br><span class="line">  fix            host:port                     <span class="comment">#修复集群</span></span><br><span class="line">                 --cluster-search-multiple-owners <span class="comment">#修复槽的重复分配问题</span></span><br><span class="line">  reshard        host:port                     <span class="comment">#指定集群的任意一节点进行迁移slot，重新分slots</span></span><br><span class="line">                 --cluster-from &lt;arg&gt;          <span class="comment">#需要从哪些源节点上迁移slot，可从多个源节点完成迁移，以逗号隔开，传递的是节点的node id，还可以直接传递--from all，这样源节点就是集群的所有节点，不传递该参数的话，则会在迁移过程中提示用户输入</span></span><br><span class="line">                 --cluster-to &lt;arg&gt;            <span class="comment">#slot需要迁移的目的节点的node id，目的节点只能填写一个，不传递该参数的话，则会在迁移过程中提示用户输入</span></span><br><span class="line">                 --cluster-slots &lt;arg&gt;         <span class="comment">#需要迁移的slot数量，不传递该参数的话，则会在迁移过程中提示用户输入。</span></span><br><span class="line">                 --cluster-yes                 <span class="comment">#指定迁移时的确认输入</span></span><br><span class="line">                 --cluster-timeout &lt;arg&gt;       <span class="comment">#设置migrate命令的超时时间</span></span><br><span class="line">                 --cluster-pipeline &lt;arg&gt;      <span class="comment">#定义cluster getkeysinslot命令一次取出的key数量，不传的话使用默认值为10</span></span><br><span class="line">                 --cluster-replace             <span class="comment">#是否直接replace到目标节点</span></span><br><span class="line">  rebalance      host:port                                      <span class="comment">#指定集群的任意一节点进行平衡集群节点slot数量 </span></span><br><span class="line">                 --cluster-weight &lt;node1=w1...nodeN=wN&gt;         <span class="comment">#指定集群节点的权重</span></span><br><span class="line">                 --cluster-use-empty-masters                    <span class="comment">#设置可以让没有分配slot的主节点参与，默认不允许</span></span><br><span class="line">                 --cluster-timeout &lt;arg&gt;                        <span class="comment">#设置migrate命令的超时时间</span></span><br><span class="line">                 --cluster-simulate                             <span class="comment">#模拟rebalance操作，不会真正执行迁移操作</span></span><br><span class="line">                 --cluster-pipeline &lt;arg&gt;                       <span class="comment">#定义cluster getkeysinslot命令一次取出的key数量，默认值为10</span></span><br><span class="line">                 --cluster-threshold &lt;arg&gt;                      <span class="comment">#迁移的slot阈值超过threshold，执行rebalance操作</span></span><br><span class="line">                 --cluster-replace                              <span class="comment">#是否直接replace到目标节点</span></span><br><span class="line">  add-node       new_host:new_port existing_host:existing_port  <span class="comment">#添加节点，把新节点加入到指定的集群，默认添加主节点</span></span><br><span class="line">                 --cluster-slave                                <span class="comment">#新节点作为从节点，默认随机一个主节点</span></span><br><span class="line">                 --cluster-master-id &lt;arg&gt;                      <span class="comment">#给新节点指定主节点</span></span><br><span class="line">  del-node       host:port node_id                              <span class="comment">#删除给定的一个节点，成功后关闭该节点服务</span></span><br><span class="line">  call           host:port <span class="built_in">command</span> arg arg .. arg               <span class="comment">#在集群的所有节点执行相关命令</span></span><br><span class="line">  <span class="built_in">set</span>-timeout    host:port milliseconds                         <span class="comment">#设置cluster-node-timeout</span></span><br><span class="line">  import         host:port                                      <span class="comment">#将外部redis数据导入集群</span></span><br><span class="line">                 --cluster-from &lt;arg&gt;                           <span class="comment">#将指定实例的数据导入到集群</span></span><br><span class="line">                 --cluster-copy                                 <span class="comment">#migrate时指定copy</span></span><br><span class="line">                 --cluster-replace                              <span class="comment">#migrate时指定replace</span></span><br><span class="line">  <span class="built_in">help</span>           </span><br><span class="line"></span><br><span class="line">For check, fix, reshard, del-node, <span class="built_in">set</span>-timeout you can specify the host and port of any working node <span class="keyword">in</span> the cluster.</span><br></pre></td></tr></table></figure>

<p>① 创建集群主节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster create 192.168.163.132:6379 192.168.163.132:6380 192.168.163.132:6381</span><br></pre></td></tr></table></figure>

<p>② 创建集群主从节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/redis-cli --cluster create 192.168.163.132:6379 192.168.163.132:6380 192.168.163.132:6381 192.168.163.132:6382 192.168.163.132:6383 192.168.163.132:6384 --cluster-replicas 1</span><br></pre></td></tr></table></figure>

<p>说明：–cluster-replicas 参数为数字，1表示每个主节点需要1个从节点。</p>
<p>通过该方式创建的带有从节点的机器不能够自己手动指定主节点，所以如果需要指定的话，需要自己手动指定，先使用①或③创建好主节点后，再通过④来处理。</p>
<p>③ 添加集群主节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster add-node 192.168.163.132:6382 192.168.163.132:6379</span><br></pre></td></tr></table></figure>

<p>说明：为一个指定集群添加节点，需要先连到该集群的任意一个节点IP（192.168.163.132:6379），再把新节点加入。该2个参数的顺序有要求：新加入的节点放前</p>
<p>④ 添加集群从节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster add-node 192.168.163.132:6382 192.168.163.132:6379 --cluster-slave --cluster-master-id 117457eab5071954faab5e81c3170600d5192270</span><br></pre></td></tr></table></figure>

<p>说明：把6382节点加入到6379节点的集群中，并且当做node_id为 117457eab5071954faab5e81c3170600d5192270 的从节点。如果不指定 <strong>–cluster-master-id</strong> 会随机分配到任意一个主节点。</p>
<p>⑤ 删除节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster del-node 192.168.163.132:6384 f6a6957421b80409106cb36be3c7ba41f3b603ff</span><br></pre></td></tr></table></figure>

<p>说明：指定IP、端口和node_id 来删除一个节点，从节点可以直接删除，主节点不能直接删除，删除之后，该节点会被shutdown。</p>
<p>注意：当被删除掉的节点重新起来之后不能自动加入集群，但其和主的复制还是正常的，也可以通过该节点看到集群信息（通过其他正常节点已经看不到该被del-node节点的信息）。</p>
<p>如果想要再次加入集群，则需要先在该节点执行cluster reset，再用add-node进行添加，进行增量同步复制。</p>
<p>到此，目前整个集群的状态如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192.168.163.132:6379&gt; cluster nodes</span><br><span class="line">815da8448f5d5a304df0353ca10d8f9b77016b28 192.168.163.132:6380@16380 master - 0 1569748297177 2 connected 5461-10922</span><br><span class="line">0c21b6cee354594a23f4d5abf0d01b48bdc96d55 192.168.163.132:6383@16383 slave 56005b9413cbf225783906307a2631109e753f8f 0 1569748295000 4 connected</span><br><span class="line">3a1d04983ab6c4ae853f9602dd922d4ebadc4dbf 192.168.163.132:6382@16382 slave 815da8448f5d5a304df0353ca10d8f9b77016b28 0 1569748295000 5 connected</span><br><span class="line">117457eab5071954faab5e81c3170600d5192270 192.168.163.132:6379@16379 myself,master - 0 1569748297000 1 connected 0-5460</span><br><span class="line">56005b9413cbf225783906307a2631109e753f8f 192.168.163.132:6381@16381 master - 0 1569748295000 3 connected 10923-16383</span><br><span class="line">f6a6957421b80409106cb36be3c7ba41f3b603ff 192.168.163.132:6384@16384 slave 117457eab5071954faab5e81c3170600d5192270 0 1569748298185 6 connected</span><br></pre></td></tr></table></figure>

<p>⑥ 检查集群</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster check 192.168.163.132:6384 --cluster-search-multiple-owners</span><br></pre></td></tr></table></figure>

<p>说明：任意连接一个集群节点，进行集群状态检查</p>
<p>⑦ 集群信息查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster info 192.168.163.132:6384</span><br></pre></td></tr></table></figure>

<p>说明：检查key、slots、从节点个数的分配情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;redis-cli --cluster info 192.168.163.132:6384</span><br><span class="line">192.168.163.132:6380 (815da844...) -&gt; 0 keys | 5462 slots | 1 slaves.</span><br><span class="line">192.168.163.132:6381 (56005b94...) -&gt; 0 keys | 5461 slots | 1 slaves.</span><br><span class="line">192.168.163.132:6379 (117457ea...) -&gt; 2 keys | 5461 slots | 1 slaves.</span><br><span class="line">[OK] 2 keys in 3 masters.</span><br><span class="line">0.00 keys per slot on average.</span><br></pre></td></tr></table></figure>

<p>⑧ 修复集群</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster fix 192.168.163.132:6384 --cluster-search-multiple-owners</span><br></pre></td></tr></table></figure>

<p>说明：修复集群和槽的重复分配问题</p>
<p>⑨ 设置集群的超时时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster set-timeout 192.168.163.132:6382 10000</span><br></pre></td></tr></table></figure>

<p>说明：连接到集群的任意一节点来设置集群的超时时间参数cluster-node-timeout</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster <span class="built_in">set</span>-timeout 192.168.163.132:6382 10000</span><br><span class="line">&gt;&gt;&gt; Reconfiguring node timeout <span class="keyword">in</span> every cluster node...</span><br><span class="line">*** New timeout <span class="built_in">set</span> <span class="keyword">for</span> 192.168.163.132:6382</span><br><span class="line">*** New timeout <span class="built_in">set</span> <span class="keyword">for</span> 192.168.163.132:6384</span><br><span class="line">*** New timeout <span class="built_in">set</span> <span class="keyword">for</span> 192.168.163.132:6383</span><br><span class="line">*** New timeout <span class="built_in">set</span> <span class="keyword">for</span> 192.168.163.132:6379</span><br><span class="line">*** New timeout <span class="built_in">set</span> <span class="keyword">for</span> 192.168.163.132:6381</span><br><span class="line">*** New timeout <span class="built_in">set</span> <span class="keyword">for</span> 192.168.163.132:6380</span><br><span class="line">&gt;&gt;&gt; New node timeout <span class="built_in">set</span>. 6 OK, 0 ERR.</span><br></pre></td></tr></table></figure>

<p>⑩ 集群中执行相关命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster call 192.168.163.132:6381 config set requirepass cc</span><br><span class="line">redis-cli -a cc --cluster call 192.168.163.132:6381 config set masterauth cc</span><br><span class="line">redis-cli -a cc --cluster call 192.168.163.132:6381 config rewrite</span><br></pre></td></tr></table></figure>

<p>说明：连接到集群的任意一节点来对整个集群的所有节点进行设置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster call 192.168.163.132:6381 config <span class="built_in">set</span> cluster-node-timeout 12000</span><br><span class="line">&gt;&gt;&gt; Calling config <span class="built_in">set</span> cluster-node-timeout 12000</span><br><span class="line">192.168.163.132:6381: OK</span><br><span class="line">192.168.163.132:6383: OK</span><br><span class="line">192.168.163.132:6379: OK</span><br><span class="line">192.168.163.132:6384: OK</span><br><span class="line">192.168.163.132:6382: OK</span><br><span class="line">192.168.163.132:6380: OK</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>到此，相关集群的基本操作已经介绍完，现在说明集群迁移的相关操作。</p>
<h4 id="迁移相关"><a href="#迁移相关" class="headerlink" title="迁移相关"></a>迁移相关</h4><p>① <strong>在线迁移slot</strong> ：在线把集群的一些slot从集群原来slot节点迁移到新的节点，即可以完成集群的在线横向扩容和缩容。有2种方式进行迁移</p>
<p>一是根据提示来进行操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">直接连接到集群的任意一节点</span><br><span class="line">redis-cli -a cc --cluster reshard 192.168.163.132:6379</span><br></pre></td></tr></table></figure>

<p>信息如下：</p>
<p>二是根据参数进行操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -a cc --cluster reshard 192.168.163.132:6379 --cluster-from 117457eab5071954faab5e81c3170600d5192270 --cluster-to 815da8448f5d5a304df0353ca10d8f9b77016b28 --cluster-slots 10 --cluster-yes --cluster-timeout 5000 --cluster-pipeline 10 --cluster-replace</span><br></pre></td></tr></table></figure>

<p>说明：连接到集群的任意一节点来对指定节点指定数量的slot进行迁移到指定的节点。</p>
<p>② 平衡（rebalance）<strong>slot</strong> ：</p>
<p>1）平衡集群中各个节点的slot数量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -a cc --cluster rebalance 192.168.163.132:6379</span><br></pre></td></tr></table></figure>

<p>2）根据集群中各个节点设置的权重等平衡slot数量（不执行，只模拟）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -a cc --cluster rebalance --cluster-weight 117457eab5071954faab5e81c3170600d5192270&#x3D;5 815da8448f5d5a304df0353ca10d8f9b77016b28&#x3D;4 56005b9413cbf225783906307a2631109e753f8f&#x3D;3 --cluster-simulate 192.168.163.132:6379</span><br></pre></td></tr></table></figure>

<p>③ 导入集群</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster import 192.168.163.132:6379 --cluster-from 192.168.163.132:9021 --cluster-replace</span><br></pre></td></tr></table></figure>

<p>说明：外部Redis实例（9021）导入到集群中的任意一节点。</p>
<p>注意：测试下来发现参数–cluster-replace没有用，如果集群中已经包含了某个key，在导入的时候会失败，不会覆盖，只有清空集群key才能导入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*** Importing 97847 keys from DB 0</span><br><span class="line">Migrating 9223372011174675807 to 192.168.163.132:6381: Source 192.168.163.132:9021 replied with error:</span><br><span class="line">ERR Target instance replied with error: BUSYKEY Target key name already exists</span><br></pre></td></tr></table></figure>

<p>并且发现如果集群设置了密码，也会导入失败，需要设置集群密码为空才能进行导入（call）。通过monitor（9021）的时候发现，在migrate的时候需要密码进行auth认证。</p>
<h2 id="一-缓存的收益与成本"><a href="#一-缓存的收益与成本" class="headerlink" title="一 缓存的收益与成本"></a>一 缓存的收益与成本</h2><h3 id="1-1-受益"><a href="#1-1-受益" class="headerlink" title="1.1 受益"></a>1.1 受益</h3><blockquote>
<p>1 加速读写</p>
<p>2 降低后端负载：后端服务器通过前端缓存降低负载，业务端使用redis降低后端mysql负载</p>
</blockquote>
<h3 id="1-2-成本"><a href="#1-2-成本" class="headerlink" title="1.2 成本"></a>1.2 成本</h3><blockquote>
<p>1 数据不一致：缓存层和数据层有时间窗口不一致，和更新策略有关</p>
<p>2 代码维护成本：多了一层缓存逻辑</p>
<p>3 运维成本：比如使用了Redis Cluster</p>
</blockquote>
<h3 id="1-3-使用场景"><a href="#1-3-使用场景" class="headerlink" title="1.3 使用场景"></a>1.3 使用场景</h3><blockquote>
<p>1 降低后端负载：对高消耗的sql，join结果集/分组统计的结果做缓存</p>
<p>2 加速请求响应：利用redis优化io响应时间</p>
<p>3 大量写合并为批量写：如计数器先redis累加再批量写入db</p>
</blockquote>
<h2 id="二-缓存更新策略"><a href="#二-缓存更新策略" class="headerlink" title="二 缓存更新策略"></a>二 缓存更新策略</h2><blockquote>
<p>1 LRU/LFU/FIFO算法剔除：例如maxmemory-policy(到了最大内存，对应的应对策略)</p>
<p> LRU -Least Recently Used,没有被使用时间最长的</p>
<p> LFU -Least Frequenty User,一定时间段内使用次数最少的</p>
<p> FIFO -First In First Out</p>
<p> LIRS (Low Inter-reference Recency Set)是一个页替换算法，相比于LRU(Least Recently Used)和很多其他的替换算法，LIRS具有较高的性能。这是通过使用两次访问同一页之间的距离（本距离指中间被访问了多少非重复块）作为一种尺度去动态地将访问页排序，从而去做一个替换的选择</p>
<p>配置文件中设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;# LRU配置</span><br><span class="line">&gt;maxmemory-policy:volatile-lru</span><br><span class="line">&gt;（1）noeviction: 如果内存使用达到了maxmemory，client还要继续写入数据，那么就直接报错给客户端</span><br><span class="line">&gt;（2）allkeys-lru: 就是我们常说的LRU算法，移除掉最近最少使用的那些keys对应的数据，ps最长用的策略</span><br><span class="line">&gt;（3）volatile-lru: 也是采取LRU算法，但是仅仅针对那些设置了指定存活时间（TTL）的key才会清理掉</span><br><span class="line">&gt;（4）allkeys-random: 随机选择一些key来删除掉</span><br><span class="line">&gt;（5）volatile-random: 随机选择一些设置了TTL的key来删除掉</span><br><span class="line">&gt;（6）volatile-ttl: 移除掉部分keys，选择那些TTL时间比较短的keys</span><br><span class="line">&gt;# LFU配置 Redis4.0之后为maxmemory_policy淘汰策略添加了两个LFU模式：</span><br><span class="line">&gt;volatile-lfu：对有过期时间的key采用LFU淘汰算法</span><br><span class="line">&gt;allkeys-lfu：对全部key采用LFU淘汰算法</span><br><span class="line">&gt;# 还有2个配置可以调整LFU算法：</span><br><span class="line">&gt;lfu-log-factor 10</span><br><span class="line">&gt;lfu-decay-time 1</span><br><span class="line">&gt;# lfu-log-factor可以调整计数器counter的增长速度，lfu-log-factor越大，counter增长的越慢。</span><br><span class="line">&gt;# lfu-decay-time是一个以分钟为单位的数值，可以调整counter的减少速度</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>2 超时剔除：例如expire，设置过期时间</p>
<p>3 主动更新：开发控制生命周期</p>
</blockquote>
<table>
<thead>
<tr>
<th>策略</th>
<th>一致性</th>
<th>维护成本</th>
</tr>
</thead>
<tbody><tr>
<td>LRU/LIRS算法剔除</td>
<td>最差</td>
<td>低</td>
</tr>
<tr>
<td>超时剔除</td>
<td>较差</td>
<td>低</td>
</tr>
<tr>
<td>主动更新</td>
<td>强</td>
<td>高</td>
</tr>
</tbody></table>
<p>1 低一致性：最大内存和淘汰策略</p>
<p>2 高一致性：超时剔除和主动更新结合，最大内存和淘汰策略兜底</p>
<h2 id="三-缓存粒度控制"><a href="#三-缓存粒度控制" class="headerlink" title="三 缓存粒度控制"></a>三 缓存粒度控制</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gduwyfg8mgj30bm0dsjt6.jpg" alt="image-20200416002406930"></p>
<blockquote>
<p>1 从mysql获取用户信息：select * from user where id=100</p>
<p>2 设置用户信息缓存：set user:100 <code>select * from user where id=100</code></p>
<p>3 缓存粒度：</p>
<p> 缓存全部属性</p>
<p> 缓存部分重要属性</p>
</blockquote>
<p>1 通用性：全量属性更好</p>
<p>2 占用空间：部分属性更好</p>
<p>3 代码维护：表面上全量属性更好</p>
<h2 id="四-缓存穿透，缓存击穿，缓存雪崩"><a href="#四-缓存穿透，缓存击穿，缓存雪崩" class="headerlink" title="四 缓存穿透，缓存击穿，缓存雪崩"></a>四 缓存穿透，缓存击穿，缓存雪崩</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###  缓存穿透</span><br><span class="line">#描述：</span><br><span class="line">缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</span><br><span class="line">#解决方案：</span><br><span class="line">1 接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；</span><br><span class="line">2 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</span><br><span class="line">3 通过布隆过滤器实现</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 缓存击穿</span><br><span class="line">#描述：</span><br><span class="line">缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</span><br><span class="line">#解决方案：</span><br><span class="line">设置热点数据永远不过期。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">### 缓存雪崩</span><br><span class="line">#描述：</span><br><span class="line">缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，        缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</span><br><span class="line"># 解决方案：</span><br><span class="line">1 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</span><br><span class="line">2 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。</span><br><span class="line">3 设置热点数据永远不过期。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>DRF-01-drf入门规范</title>
    <url>/posts/48921.html</url>
    <content><![CDATA[<p>DRF入门规范</p>
<a id="more"></a>

<h2 id="一-Web应用模式"><a href="#一-Web应用模式" class="headerlink" title="一 Web应用模式"></a>一 Web应用模式</h2><p>在开发Web应用中，有两种应用模式：</p>
<h3 id="1-1-前后端不分离"><a href="#1-1-前后端不分离" class="headerlink" title="1.1 前后端不分离"></a>1.1 前后端不分离</h3><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gggfnzeg2xj31k80smjv1.jpg" alt="前后端不分离"></p>
<h3 id="1-2-前后端分离"><a href="#1-2-前后端分离" class="headerlink" title="1.2 前后端分离"></a>1.2 前后端分离</h3><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gggfo3sdg9j31aw0u0jxr.jpg" alt="前后端分离"></p>
<h2 id="二-API接口"><a href="#二-API接口" class="headerlink" title="二 API接口"></a>二 API接口</h2><p>为了在团队内部形成共识、防止个人习惯差异引起的混乱，我们需要找到一种大家都觉得很好的接口实现规范，而且这种规范能够让后端写的接口，用途一目了然，减少双方之间的合作成本。</p>
<p>通过网络，规定了前后台信息交互规则的url链接，也就是前后台信息交互的<strong>媒介</strong></p>
<p>Web API接口和一般的url链接还是有区别的，Web API接口简单概括有下面四大特点</p>
<ul>
<li><p>url：长得像返回数据的url链接</p>
<ul>
<li><a href="https://api.map.baidu.com/place/v2/search">https://api.map.baidu.com/place/v2/search</a></li>
</ul>
</li>
<li><p>请求方式：get、post、put、patch、delete</p>
<ul>
<li>采用get方式请求上方接口</li>
</ul>
</li>
<li><p>请求参数：json或xml格式的key-value类型数据</p>
<ul>
<li>ak：6E823f587c95f0148c19993539b99295</li>
<li>region：上海</li>
<li>query：肯德基</li>
<li>output：json</li>
</ul>
</li>
<li><p>响应结果：json或xml格式的数据</p>
<ul>
<li><p>上方请求参数的output参数值决定了响应数据的格式</p>
</li>
<li><p>数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xml格式</span></span><br><span class="line">https://api.map.baidu.com/place/v2/search?ak=6E823f587c95f0148c19993539b99295&amp;region=%E4%B8%8A%E6%B5%B7&amp;query=%E8%82%AF%E5%BE%B7%E5%9F%BA&amp;output=xml</span><br><span class="line"><span class="comment">#json格式</span></span><br><span class="line">https://api.map.baidu.com/place/v2/search?ak=6E823f587c95f0148c19993539b99295&amp;region=%E4%B8%8A%E6%B5%B7&amp;query=%E8%82%AF%E5%BE%B7%E5%9F%BA&amp;output=json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;status&quot;</span>:<span class="number">0</span>,</span><br><span class="line">      <span class="string">&quot;message&quot;</span>:<span class="string">&quot;ok&quot;</span>,</span><br><span class="line">    <span class="string">&quot;results&quot;</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>:<span class="string">&quot;肯德基(罗餐厅)&quot;</span>,</span><br><span class="line">            <span class="string">&quot;location&quot;</span>:&#123;</span><br><span class="line">                <span class="string">&quot;lat&quot;</span>:<span class="number">31.415354</span>,</span><br><span class="line">                <span class="string">&quot;lng&quot;</span>:<span class="number">121.357339</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;address&quot;</span>:<span class="string">&quot;月罗路2380号&quot;</span>,</span><br><span class="line">            <span class="string">&quot;province&quot;</span>:<span class="string">&quot;上海市&quot;</span>,</span><br><span class="line">            <span class="string">&quot;city&quot;</span>:<span class="string">&quot;上海市&quot;</span>,</span><br><span class="line">            <span class="string">&quot;area&quot;</span>:<span class="string">&quot;宝山区&quot;</span>,</span><br><span class="line">            <span class="string">&quot;street_id&quot;</span>:<span class="string">&quot;339ed41ae1d6dc320a5cb37c&quot;</span>,</span><br><span class="line">            <span class="string">&quot;telephone&quot;</span>:<span class="string">&quot;(021)56761006&quot;</span>,</span><br><span class="line">            <span class="string">&quot;detail&quot;</span>:<span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;uid&quot;</span>:<span class="string">&quot;339ed41ae1d6dc320a5cb37c&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">          ...</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="三-接口测试工具：Postman"><a href="#三-接口测试工具：Postman" class="headerlink" title="三 接口测试工具：Postman"></a>三 接口测试工具：Postman</h2><p>Postman是一款接口调试工具，是一款免费的可视化软件，同时支持各种操作系统平台，是测试接口的首选工具。</p>
<p>Postman可以直接从<a href="https://www.getpostman.com/downloads/">官网：https://www.getpostman.com/downloads/</a>下载获得，然后进行傻瓜式安装。</p>
<ul>
<li>工作面板</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gghkqmyw0hj31c00u0q86.jpg" alt="img"></p>
<ul>
<li>简易的get请求</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gghkqqjxuyj31c00u0jyr.jpg" alt="img"></p>
<ul>
<li>简易的post请求</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gghkqtwl29j31c00u0ahe.jpg" alt="img"></p>
<ul>
<li>案例：请求百度地图接口</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gghkqxuagsj31c00u0qcu.jpg" alt="img"></p>
<h2 id="四-RESTful-API规范"><a href="#四-RESTful-API规范" class="headerlink" title="四 RESTful API规范"></a>四 RESTful API规范</h2><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1gggfoaosexg30io08xaae.gif" alt="restful"></p>
<p>REST全称是Representational State Transfer，中文意思是表述（编者注：通常译为表征性状态转移）。 它首次出现在2000年Roy Fielding的博士论文中。</p>
<p>RESTful是一种定义Web API接口的设计风格，尤其适用于前后端分离的应用模式中。</p>
<p>这种风格的理念认为后端开发任务就是提供数据的，对外提供的是数据资源的访问接口，所以在定义接口时，客户端访问的URL路径就表示这种要操作的数据资源。</p>
<p>事实上，我们可以使用任何一个框架都可以实现符合restful规范的API接口。</p>
<h3 id="4-1-数据的安全保障"><a href="#4-1-数据的安全保障" class="headerlink" title="4.1 数据的安全保障"></a>4.1 数据的安全保障</h3><ul>
<li><p>url链接一般都采用https协议进行传输</p>
<p>注：采用https协议，可以提高数据交互过程中的安全性</p>
</li>
</ul>
<h3 id="4-2-接口特征表现"><a href="#4-2-接口特征表现" class="headerlink" title="4.2 接口特征表现"></a>4.2 接口特征表现</h3><ul>
<li><p>用api关键字标识接口url：</p>
<ul>
<li><a href="https://api.baidu.com/">https://api.baidu.com</a></li>
<li><a href="https://www.baidu.com/api">https://www.baidu.com/api</a></li>
</ul>
<p>注：看到api字眼，就代表该请求url链接是完成前后台数据交互的</p>
</li>
</ul>
<h3 id="4-3-多数据版本共存"><a href="#4-3-多数据版本共存" class="headerlink" title="4.3 多数据版本共存"></a>4.3 多数据版本共存</h3><ul>
<li><p>在url链接中标识数据版本</p>
<ul>
<li><a href="https://api.baidu.com/v1">https://api.baidu.com/v1</a></li>
<li><a href="https://api.baidu.com/v2">https://api.baidu.com/v2</a></li>
</ul>
<p>注：url链接中的v1、v2就是不同数据版本的体现（只有在一种数据资源有多版本情况下）</p>
</li>
</ul>
<h3 id="4-4-数据即是资源，均使用名词（可复数）"><a href="#4-4-数据即是资源，均使用名词（可复数）" class="headerlink" title="4.4 数据即是资源，均使用名词（可复数）"></a>4.4 数据即是资源，均使用名词（可复数）</h3><ul>
<li><p>接口一般都是完成前后台数据的交互，交互的数据我们称之为资源</p>
<ul>
<li><a href="https://api.baidu.com/users">https://api.baidu.com/users</a></li>
<li><a href="https://api.baidu.com/books">https://api.baidu.com/books</a></li>
<li><a href="https://api.baidu.com/book">https://api.baidu.com/book</a></li>
</ul>
<p>注：一般提倡用资源的复数形式，在url链接中奖励不要出现操作资源的动词，错误示范：<a href="https://api.baidu.com/delete-user">https://api.baidu.com/delete-user</a></p>
</li>
<li><p>特殊的接口可以出现动词，因为这些接口一般没有一个明确的资源，或是动词就是接口的核心含义</p>
<ul>
<li><a href="https://api.baidu.com/place/search">https://api.baidu.com/place/search</a></li>
<li><a href="https://api.baidu.com/login">https://api.baidu.com/login</a></li>
</ul>
</li>
</ul>
<h3 id="4-5-资源操作由请求方式决定（method）"><a href="#4-5-资源操作由请求方式决定（method）" class="headerlink" title="4.5 资源操作由请求方式决定（method）"></a>4.5 资源操作由请求方式决定（method）</h3><ul>
<li>操作资源一般都会涉及到增删改查，我们提供请求方式来标识增删改查动作<ul>
<li><a href="https://api.baidu.com/books">https://api.baidu.com/books</a> - get请求：获取所有书</li>
<li><a href="https://api.baidu.com/books/1">https://api.baidu.com/books/1</a> - get请求：获取主键为1的书</li>
<li><a href="https://api.baidu.com/books">https://api.baidu.com/books</a> - post请求：新增一本书书</li>
<li><a href="https://api.baidu.com/books/1">https://api.baidu.com/books/1</a> - put请求：整体修改主键为1的书</li>
<li><a href="https://api.baidu.com/books/1">https://api.baidu.com/books/1</a> - patch请求：局部修改主键为1的书</li>
<li><a href="https://api.baidu.com/books/1">https://api.baidu.com/books/1</a> - delete请求：删除主键为1的书</li>
</ul>
</li>
</ul>
<h3 id="4-6-过滤，通过在url上传参的形式传递搜索条件"><a href="#4-6-过滤，通过在url上传参的形式传递搜索条件" class="headerlink" title="4.6 过滤，通过在url上传参的形式传递搜索条件"></a>4.6 过滤，通过在url上传参的形式传递搜索条件</h3><ul>
<li><a href="https://api.example.com/v1/zoos?limit=10%EF%BC%9A%E6%8C%87%E5%AE%9A%E8%BF%94%E5%9B%9E%E8%AE%B0%E5%BD%95%E7%9A%84%E6%95%B0%E9%87%8F">https://api.example.com/v1/zoos?limit=10：指定返回记录的数量</a></li>
<li><a href="https://api.example.com/v1/zoos?offset=10%EF%BC%9A%E6%8C%87%E5%AE%9A%E8%BF%94%E5%9B%9E%E8%AE%B0%E5%BD%95%E7%9A%84%E5%BC%80%E5%A7%8B%E4%BD%8D%E7%BD%AE">https://api.example.com/v1/zoos?offset=10：指定返回记录的开始位置</a></li>
<li><a href="https://api.example.com/v1/zoos?page=2&amp;per_page=100%EF%BC%9A%E6%8C%87%E5%AE%9A%E7%AC%AC%E5%87%A0%E9%A1%B5%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%AF%8F%E9%A1%B5%E7%9A%84%E8%AE%B0%E5%BD%95%E6%95%B0">https://api.example.com/v1/zoos?page=2&amp;per_page=100：指定第几页，以及每页的记录数</a></li>
<li><a href="https://api.example.com/v1/zoos?sortby=name&amp;order=asc%EF%BC%9A%E6%8C%87%E5%AE%9A%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E6%8C%89%E7%85%A7%E5%93%AA%E4%B8%AA%E5%B1%9E%E6%80%A7%E6%8E%92%E5%BA%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%8E%92%E5%BA%8F%E9%A1%BA%E5%BA%8F">https://api.example.com/v1/zoos?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序</a></li>
<li><a href="https://api.example.com/v1/zoos?animal_type_id=1%EF%BC%9A%E6%8C%87%E5%AE%9A%E7%AD%9B%E9%80%89%E6%9D%A1%E4%BB%B6">https://api.example.com/v1/zoos?animal_type_id=1：指定筛选条件</a></li>
</ul>
<h3 id="4-7-响应状态码"><a href="#4-7-响应状态码" class="headerlink" title="4.7 响应状态码"></a>4.7 响应状态码</h3><h4 id="4-7-1-正常响应"><a href="#4-7-1-正常响应" class="headerlink" title="4.7.1 正常响应"></a>4.7.1 正常响应</h4><ul>
<li>响应状态码2xx<ul>
<li>200：常规请求</li>
<li>201：创建成功</li>
</ul>
</li>
</ul>
<h4 id="4-7-2-重定向响应"><a href="#4-7-2-重定向响应" class="headerlink" title="4.7.2 重定向响应"></a>4.7.2 重定向响应</h4><ul>
<li>响应状态码3xx<ul>
<li>301：永久重定向</li>
<li>302：暂时重定向</li>
</ul>
</li>
</ul>
<h4 id="4-7-3-客户端异常"><a href="#4-7-3-客户端异常" class="headerlink" title="4.7.3 客户端异常"></a>4.7.3 客户端异常</h4><ul>
<li>响应状态码4xx<ul>
<li>403：请求无权限</li>
<li>404：请求路径不存在</li>
<li>405：请求方法不存在</li>
</ul>
</li>
</ul>
<h4 id="4-7-4-服务器异常"><a href="#4-7-4-服务器异常" class="headerlink" title="4.7.4 服务器异常"></a>4.7.4 服务器异常</h4><ul>
<li>响应状态码5xx<ul>
<li>500：服务器异常</li>
</ul>
</li>
</ul>
<h3 id="4-8-错误处理，应返回错误信息，error当做key"><a href="#4-8-错误处理，应返回错误信息，error当做key" class="headerlink" title="4.8 错误处理，应返回错误信息，error当做key"></a>4.8 错误处理，应返回错误信息，error当做key</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    error: &quot;无权限操作&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-9-返回结果，针对不同操作，服务器向用户返回的结果应该符合以下规范"><a href="#4-9-返回结果，针对不同操作，服务器向用户返回的结果应该符合以下规范" class="headerlink" title="4.9 返回结果，针对不同操作，服务器向用户返回的结果应该符合以下规范"></a>4.9 返回结果，针对不同操作，服务器向用户返回的结果应该符合以下规范</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;collection：返回资源对象的列表（数组）</span><br><span class="line">GET &#x2F;collection&#x2F;resource：返回单个资源对象</span><br><span class="line">POST &#x2F;collection：返回新生成的资源对象</span><br><span class="line">PUT &#x2F;collection&#x2F;resource：返回完整的资源对象</span><br><span class="line">PATCH &#x2F;collection&#x2F;resource：返回完整的资源对象</span><br><span class="line">DELETE &#x2F;collection&#x2F;resource：返回一个空文档</span><br></pre></td></tr></table></figure>

<h3 id="4-10-需要url请求的资源需要访问资源的请求链接"><a href="#4-10-需要url请求的资源需要访问资源的请求链接" class="headerlink" title="4.10 需要url请求的资源需要访问资源的请求链接"></a>4.10 需要url请求的资源需要访问资源的请求链接</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"># Hypermedia API，RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么</span><br><span class="line">&#123;</span><br><span class="line">      <span class="attr">&quot;status&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;ok&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;results&quot;</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;肯德基(罗餐厅)&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;img&quot;</span>: <span class="string">&quot;https://image.baidu.com/kfc/001.png&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">          ...</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较好的接口返回</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"># 响应数据要有状态码、状态信息以及数据本身</span><br><span class="line">&#123;</span><br><span class="line">      <span class="attr">&quot;status&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;ok&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;results&quot;</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;肯德基(罗餐厅)&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;location&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;lat&quot;</span>:<span class="number">31.415354</span>,</span><br><span class="line">                <span class="attr">&quot;lng&quot;</span>:<span class="number">121.357339</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;address&quot;</span>:<span class="string">&quot;月罗路2380号&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;province&quot;</span>:<span class="string">&quot;上海市&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;city&quot;</span>:<span class="string">&quot;上海市&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;area&quot;</span>:<span class="string">&quot;宝山区&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;street_id&quot;</span>:<span class="string">&quot;339ed41ae1d6dc320a5cb37c&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;telephone&quot;</span>:<span class="string">&quot;(021)56761006&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;detail&quot;</span>:<span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;uid&quot;</span>:<span class="string">&quot;339ed41ae1d6dc320a5cb37c&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">          ...</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四-序列化"><a href="#四-序列化" class="headerlink" title="四 序列化"></a>四 序列化</h2><p>api接口开发，最核心最常见的一个过程就是序列化，所谓序列化就是把<strong>数据转换格式</strong>，序列化可以分两个阶段：</p>
<p><strong>序列化</strong>： 把我们识别的数据转换成指定的格式提供给别人。</p>
<p>例如：我们在django中获取到的数据默认是模型对象，但是模型对象数据无法直接提供给前端或别的平台使用，所以我们需要把数据进行序列化，变成字符串或者json数据，提供给别人。</p>
<p><strong>反序列化</strong>：把别人提供的数据转换/还原成我们需要的格式。</p>
<p>例如：前端js提供过来的json数据，对于python而言就是字符串，我们需要进行反序列化换成模型类对象，这样我们才能把数据保存到数据库中。</p>
<h2 id="五-Django-Rest-Framework"><a href="#五-Django-Rest-Framework" class="headerlink" title="五 Django Rest_Framework"></a>五 Django Rest_Framework</h2><p>核心思想: 缩减编写api接口的代码</p>
<p>Django REST framework是一个建立在Django基础之上的Web 应用开发框架，可以快速的开发REST API接口应用。在REST framework中，提供了序列化器Serialzier的定义，可以帮助我们简化序列化与反序列化的过程，不仅如此，还提供丰富的类视图、扩展类、视图集来简化视图的编写工作。REST framework还提供了认证、权限、限流、过滤、分页、接口文档等功能支持。REST framework提供了一个API 的Web可视化界面来方便查看测试接口。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggggn3x4saj31fi0g4gph.jpg" alt="drf_logo"></p>
<p>官方文档：<a href="https://www.django-rest-framework.org/">https://www.django-rest-framework.org/</a></p>
<p>github: <a href="https://github.com/encode/django-rest-framework/tree/master">https://github.com/encode/django-rest-framework/tree/master</a></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>提供了定义序列化器Serializer的方法，可以快速根据 Django ORM 或者其它库自动序列化/反序列化；</li>
<li>提供了丰富的类视图、Mixin扩展类，简化视图的编写；</li>
<li>丰富的定制层级：函数视图、类视图、视图集合到自动生成 API，满足各种需要；</li>
<li>多种身份认证和权限认证方式的支持；[jwt]</li>
<li>内置了限流系统；</li>
<li>直观的 API web 界面；</li>
<li>可扩展性，插件丰富</li>
</ul>
<h2 id="六-环境安装与配置"><a href="#六-环境安装与配置" class="headerlink" title="六 环境安装与配置"></a>六 环境安装与配置</h2><p>DRF需要以下依赖：</p>
<ul>
<li>Python (2.7, 3.2, 3.3, 3.4, 3.5, 3.6)</li>
<li>Django (1.10, 1.11, 2.0)</li>
</ul>
<p><strong>DRF是以Django扩展应用的方式提供的，所以我们可以直接利用已有的Django环境而无需从新创建。（若没有Django环境，需要先创建环境安装Django）</strong></p>
<h3 id="6-1-安装DRF"><a href="#6-1-安装DRF" class="headerlink" title="6.1 安装DRF"></a>6.1 安装DRF</h3><p>前提是已经安装了django，建议安装在虚拟环境</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkvirtualenv drfdemo -p python3</span></span><br><span class="line"><span class="comment"># pip install django</span></span><br><span class="line"></span><br><span class="line">pip install djangorestframework</span><br><span class="line">pip install pymysql</span><br></pre></td></tr></table></figure>

<h4 id="6-1-1-创建django项目"><a href="#6-1-1-创建django项目" class="headerlink" title="6.1.1 创建django项目"></a>6.1.1 创建django项目</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cd ~/Desktop</span><br><span class="line">django-admin startproject drfdemo</span><br></pre></td></tr></table></figure>

<p>使用pycharm打开项目，设置虚拟环境的解析器，并修改manage.py中的后缀参数。</p>
<h3 id="6-2-添加rest-framework应用"><a href="#6-2-添加rest-framework应用" class="headerlink" title="6.2 添加rest_framework应用"></a>6.2 添加rest_framework应用</h3><p>在<strong>settings.py</strong>的<strong>INSTALLED_APPS</strong>中添加’rest_framework’。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;rest_framework&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>接下来就可以使用DRF提供的功能进行api接口开发了。在项目中如果使用rest_framework框架实现API接口，主要有以下三个步骤：</p>
<ul>
<li>将请求的数据（如JSON格式）转换为模型类对象</li>
<li>操作数据库</li>
<li>将模型类对象转换为响应的数据（如JSON格式）</li>
</ul>
<p>接下来，我们快速体验下四天后我们学习完成drf以后的开发代码。接下来代码不需要理解，看步骤。</p>
<h3 id="6-3-体验drf完全简写代码的过程（了解）"><a href="#6-3-体验drf完全简写代码的过程（了解）" class="headerlink" title="6.3 体验drf完全简写代码的过程（了解）"></a>6.3 体验drf完全简写代码的过程（了解）</h3><h4 id="6-3-1-创建模型操作类"><a href="#6-3-1-创建模型操作类" class="headerlink" title="6.3.1. 创建模型操作类"></a>6.3.1. 创建模型操作类</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="comment"># 模型字段</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>,verbose_name=<span class="string">&quot;姓名&quot;</span>)</span><br><span class="line">    sex = models.BooleanField(default=<span class="number">1</span>,verbose_name=<span class="string">&quot;性别&quot;</span>)</span><br><span class="line">    age = models.IntegerField(verbose_name=<span class="string">&quot;年龄&quot;</span>)</span><br><span class="line">    class_null = models.CharField(max_length=<span class="number">5</span>,verbose_name=<span class="string">&quot;班级编号&quot;</span>)</span><br><span class="line">    description = models.TextField(max_length=<span class="number">1000</span>,verbose_name=<span class="string">&quot;个性签名&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table=<span class="string">&quot;tb_student&quot;</span></span><br><span class="line">        verbose_name = <span class="string">&quot;学生&quot;</span></span><br><span class="line">        verbose_name_plural = verbose_name</span><br></pre></td></tr></table></figure>

<p>为了方便测试，所以我们可以先创建一个数据库。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">create database students charset=utf8;</span><br></pre></td></tr></table></figure>

<h5 id="6-3-1-1-执行数据迁移"><a href="#6-3-1-1-执行数据迁移" class="headerlink" title="6.3.1.1 执行数据迁移"></a>6.3.1.1 执行数据迁移</h5><p>把students子应用添加到INSTALL_APPS中</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggggnfes9gj30na07pq50-20210603201443076.jpg" alt="1557023819604"></p>
<p>初始化数据库连接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">安装pymysql</span><br><span class="line">pip install pymysql</span><br></pre></td></tr></table></figure>

<p>主引用中<code>__init__.py</code>设置使用pymysql作为数据库驱动</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure>

<p>settings.py配置文件中设置mysql的账号密码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="comment"># &#x27;default&#x27;: &#123;</span></span><br><span class="line">    <span class="comment">#     &#x27;ENGINE&#x27;: &#x27;django.db.backends.sqlite3&#x27;,</span></span><br><span class="line">    <span class="comment">#     &#x27;NAME&#x27;: os.path.join(BASE_DIR, &#x27;db.sqlite3&#x27;),</span></span><br><span class="line">    <span class="comment"># &#125;,</span></span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&quot;students&quot;</span>,</span><br><span class="line">        <span class="string">&quot;HOST&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;PORT&quot;</span>: <span class="number">3306</span>,</span><br><span class="line">        <span class="string">&quot;USER&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">        <span class="string">&quot;PASSWORD&quot;</span>:<span class="string">&quot;123&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终端下，执行数据迁移。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<p>错误列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行数据迁移 python manage.py makemigrations 报错如下：</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggggnmwcygj30ro08j0xb.jpg" alt="1557024349366"></p>
<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注释掉 backends&#x2F;mysql&#x2F;base.py中的35和36行代码。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggggnrlrh4j30ri040abp.jpg" alt="1557025991751"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 执行数据迁移发生以下错误：</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggggnvurajj30rc07v41a.jpg" alt="1557026113769"></p>
<p>解决方法：</p>
<p>backends/mysql/operations.py146行里面新增一个行代码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggggnzzyggj30s704rmz0.jpg" alt="1557026224431"></p>
<h4 id="6-3-2-创建序列化器"><a href="#6-3-2-创建序列化器" class="headerlink" title="6.3.2. 创建序列化器"></a>6.3.2. 创建序列化器</h4><p>例如，在django项目中创建学生子应用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py startapp students</span><br></pre></td></tr></table></figure>

<p>在syudents应用目录中新建serializers.py用于保存该应用的序列化器。</p>
<p>创建一个StudentModelSerializer用于序列化与反序列化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建序列化器类，回头会在试图中被调用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentModelSerializer</span>(<span class="params">serializers.ModelSerializer</span>):</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Student</span><br><span class="line">        fields = <span class="string">&quot;__all__&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>model</strong> 指明该序列化器处理的数据字段从模型类BookInfo参考生成</li>
<li><strong>fields</strong> 指明该序列化器包含模型类中的哪些字段，’<strong>all</strong>‘指明包含所有字段</li>
</ul>
<h4 id="6-3-3-编写视图"><a href="#6-3-3-编写视图" class="headerlink" title="6.3.3. 编写视图"></a>6.3.3. 编写视图</h4><p>在students应用的views.py中创建视图StudentViewSet，这是一个视图集合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ModelViewSet</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Student</span><br><span class="line"><span class="keyword">from</span> .serializers <span class="keyword">import</span> StudentModelSerializer</span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentViewSet</span>(<span class="params">ModelViewSet</span>):</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>queryset</strong> 指明该视图集在查询数据时使用的查询集</li>
<li><strong>serializer_class</strong> 指明该视图在进行序列化或反序列化时使用的序列化器</li>
</ul>
<h4 id="6-3-4-定义路由"><a href="#6-3-4-定义路由" class="headerlink" title="6.3.4. 定义路由"></a>6.3.4. 定义路由</h4><p>在students应用的urls.py中定义路由信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"><span class="keyword">from</span> rest_framework.routers <span class="keyword">import</span> DefaultRouter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 路由列表</span></span><br><span class="line">urlpatterns = []</span><br><span class="line"></span><br><span class="line">router = DefaultRouter()  <span class="comment"># 可以处理视图的路由器</span></span><br><span class="line">router.register(<span class="string">&#x27;students&#x27;</span>, views.StudentViewSet)  <span class="comment"># 向路由器中注册视图集</span></span><br><span class="line"></span><br><span class="line">urlpatterns += router.urls  <span class="comment"># 将路由器中的所以路由信息追到到django的路由列表中</span></span><br></pre></td></tr></table></figure>

<p>最后把students子应用中的路由文件加载到总路由文件中.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">&quot;stu/&quot;</span>,include(<span class="string">&quot;students.urls&quot;</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="6-3-5-运行测试"><a href="#6-3-5-运行测试" class="headerlink" title="6.3.5. 运行测试"></a>6.3.5. 运行测试</h4><p>运行当前程序（与运行Django一样）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure>

<p>在浏览器中输入网址127.0.0.1:8000，可以看到DRF提供的API Web浏览页面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggggo7yztej30zl0c7gmg.jpg" alt="1557027948031"></p>
<p>1）点击链接127.0.0.1:8000/stu/students 可以访问<strong>获取所有数据的接口</strong>，呈现如下页面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggggobtfhkj30zf0i20u0.jpg" alt="1557027878963"></p>
<p>2）在页面底下表单部分填写学生信息，可以访问<strong>添加新学生的接口</strong>，保存学生信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggggog4ptxj30yq0hgt9h.jpg" alt="1557027999506"></p>
<p>点击POST后，返回如下页面信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggggojnhflj30z70ekjsd.jpg" alt="1557028072470"></p>
<p>3）在浏览器中输入网址127.0.0.1:8000/stu/students/5/，可以访问<strong>获取单一学生信息的接口</strong>（id为5的学生），呈现如下页面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggggooinxwj30z80hdabb.jpg" alt="1557028115925"></p>
<p>4）在页面底部表单中填写学生信息，可以访问<strong>修改学生的接口</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggggoujf51j30w50awwet.jpg" alt="1557028168350"></p>
<p>点击PUT，返回如下页面信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggggoza9rbj30x20bx752.jpg" alt="1557028208243"></p>
<p>5）点击DELETE按钮，可以访问<strong>删除学生的接口</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggggp3eceqj30zt08tt9o.jpg" alt="1557028242637"></p>
<p>返回，如下页面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggggp74kyuj30ze0al3zd.jpg" alt="1557028266190"></p>
<h2 id="七-CBV源码分析"><a href="#七-CBV源码分析" class="headerlink" title="七 CBV源码分析"></a>七 CBV源码分析</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 视图层</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render, HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBVTest</span>(<span class="params">View</span>):</span></span><br><span class="line">    <span class="comment"># 通过调度(dispatch)分发请求</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        super().dispatch(request, *args, **kwargs)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&#x27;cbv.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;cbv post method&#x27;</span>)</span><br><span class="line">&lt;!-- 模板层 --&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;/cbv/&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;usr&quot;</span>&gt;</span><br><span class="line">    &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 路由层</span></span><br><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r&#x27;^cbv/&#x27;</span>, views.CBVTest.as_view()),</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 执行完一定要是个函数内存地址 ---&gt; as_View之后就是view的函数内存地址，然后view(把request对象传过去)</span></span><br><span class="line"><span class="comment"># 请求来了 路由匹配上--&gt;view(request)--&gt;self.disapatch(request, *args, **kwargs)</span></span><br><span class="line">- disapatch--&gt; 把请求方法转成小写--&gt; 通过反射，去对象中找，get方法，有加括号执行，并且把request传进去了</span><br></pre></td></tr></table></figure>

<h2 id="八-drf基本使用及request源码分析"><a href="#八-drf基本使用及request源码分析" class="headerlink" title="八 drf基本使用及request源码分析"></a>八 drf基本使用及request源码分析</h2><h3 id="8-1-APIView的使用"><a href="#8-1-APIView的使用" class="headerlink" title="8.1 APIView的使用"></a>8.1 APIView的使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1）安装drf：pip3 install djangorestframework</span></span><br><span class="line"><span class="comment"># 2）settings.py注册app：INSTALLED_APPS = [..., &#x27;rest_framework&#x27;]</span></span><br><span class="line"><span class="comment"># 3）基于cbv完成满足RSSTful规范的接口</span></span><br><span class="line"><span class="comment"># 视图层</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line">user_list = [&#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>&#125;, &#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>&#125;]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Users</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;</span><br><span class="line">            <span class="string">&#x27;status&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;ok&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;results&#x27;</span>: user_list</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># request对formdata，urlencoded，json三个格式参数均能解析</span></span><br><span class="line">        name = request.data.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        id = len(user_list) + <span class="number">1</span></span><br><span class="line">        user = &#123;<span class="string">&#x27;id&#x27;</span>: id, <span class="string">&#x27;name&#x27;</span>: name&#125;</span><br><span class="line">        user_list.append(user)</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;</span><br><span class="line">            <span class="string">&#x27;status&#x27;</span>: <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;ok&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;results&#x27;</span>: user</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="comment"># 路由层</span></span><br><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r&#x27;^users/&#x27;</span>, views.Users.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="8-2-APIView和Request对象源码分析"><a href="#8-2-APIView和Request对象源码分析" class="headerlink" title="8.2 APIView和Request对象源码分析"></a>8.2 APIView和Request对象源码分析</h2><h4 id="8-2-1-APIView"><a href="#8-2-1-APIView" class="headerlink" title="8.2.1 APIView"></a>8.2.1 APIView</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;booksapiview/&#x27;</span>, views.BooksAPIView.as_view()),  </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># as_view()</span></span><br><span class="line">    <span class="comment"># 核心走了父类as_view</span></span><br><span class="line">    view = super(APIView, cls).as_view(**initkwargs)</span><br><span class="line">    <span class="comment"># 返回的是局部禁用csrf认证的view视图函数</span></span><br><span class="line">    <span class="keyword">return</span> csrf_exempt(view)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># dispatch(self, request, *args, **kwargs)</span></span><br><span class="line">    <span class="comment"># 二次封装request对象</span></span><br><span class="line">    request = self.initialize_request(request, *args, **kwargs)</span><br><span class="line">    <span class="comment"># 自定义request规则</span></span><br><span class="line">    self.initial(request, *args, **kwargs)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># initialize_request(self, request, *args, **kwargs)</span></span><br><span class="line">    <span class="comment"># 原生request封装在request._request</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># initial(self, request, *args, **kwargs)</span></span><br><span class="line">    <span class="comment"># 认证</span></span><br><span class="line">    self.perform_authentication(request)</span><br><span class="line">    <span class="comment"># 权限</span></span><br><span class="line">    self.check_permissions(request)</span><br><span class="line">    <span class="comment"># 频率</span></span><br><span class="line">    self.check_throttles(request)</span><br></pre></td></tr></table></figure>

<h4 id="8-2-2-Request对象"><a href="#8-2-2-Request对象" class="headerlink" title="8.2.2 Request对象"></a>8.2.2 Request对象</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.request <span class="keyword">import</span> Request</span><br><span class="line"><span class="comment"># 只要继承了APIView，视图中的request对象，都是新的，上面那个request对象了。</span></span><br><span class="line"><span class="comment"># 老的request，在新的request._request </span></span><br><span class="line"><span class="comment"># 以后使用request对象，就像使用之前的request是一模一样，因为重写了__getattr__方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, attr</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> getattr(self._request, attr) <span class="comment"># 通过反射，取原生的request对象，取出属性和方法</span></span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">return</span> self.__getattribute__(attr)</span><br><span class="line">          </span><br><span class="line"><span class="comment"># request.data 感觉是个数据属性，其实是个方法，@property 修饰了</span></span><br><span class="line">它是一个字典，post不管使用什么编码，传过来的数据都在request.data里</span><br><span class="line"></span><br><span class="line"><span class="comment"># get请求过来的数据，在哪里取？</span></span><br><span class="line">request.GET</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query_params</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        More semantically correct name for request.GET.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._request.GET</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 视图类中</span></span><br><span class="line">    print(request.query_params) <span class="comment"># get请求，地址中的参数</span></span><br><span class="line">    <span class="comment"># 原来在</span></span><br><span class="line">    print(request.GET)</span><br><span class="line">    </span><br><span class="line"><span class="comment">###############################################################################################</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        </span><br><span class="line">        self.args = args</span><br><span class="line">        self.kwargs = kwargs</span><br><span class="line">        <span class="comment"># 重新包装了一个request对象，以后再用的request对象，就是新的request对象</span></span><br><span class="line">        request = self.initialize_request(request, *args, **kwargs)</span><br><span class="line">        self.request = request</span><br><span class="line">        self.headers = self.default_response_headers  <span class="comment"># deprecate?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 三大认证模块（新的request）</span></span><br><span class="line">            self.initial(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Get the appropriate handler method</span></span><br><span class="line">            <span class="keyword">if</span> request.method.lower() <span class="keyword">in</span> self.http_method_names:</span><br><span class="line">                handler = getattr(self, request.method.lower(),</span><br><span class="line">                                  self.http_method_not_allowed)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                handler = self.http_method_not_allowed</span><br><span class="line">            <span class="comment"># 响应模块</span></span><br><span class="line">            response = handler(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">          <span class="comment"># 异常模块</span></span><br><span class="line">            response = self.handle_exception(exc)</span><br><span class="line">        <span class="comment"># 渲染模块</span></span><br><span class="line">        self.response = self.finalize_response(request, response, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> self.response</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># APIView的initial方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initial</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 认证组件：叫验用户  - 游客  合法用户   非法用户</span></span><br><span class="line">        <span class="comment"># 游客：代表校验通过，直接进入下一步校验（权限校验））</span></span><br><span class="line">        <span class="comment"># 合法用户：代表校验通过将用户存储在request.user中，再进入下一步校验（权限校验）</span></span><br><span class="line">        <span class="comment"># 非法用户：代表校验失败，返回异常，返回403</span></span><br><span class="line"></span><br><span class="line">        self.perform_authentication(request)</span><br><span class="line">        <span class="comment"># 权限组件：校验用户权限，必须登录，所有用户，登录读写游客只读，自定义用户角色。</span></span><br><span class="line">        <span class="comment"># 认证通过：可以进入下一步校验（频率认证）</span></span><br><span class="line">        <span class="comment"># 认证失败：抛出异常，返回403</span></span><br><span class="line">        self.check_permissions(request)</span><br><span class="line">        <span class="comment"># 频率组件：限制视图接口中被访问的频率次数- 限制条件（IP，id，唯一键）频率周期时间（s,m,h）频率的次数（3/s）</span></span><br><span class="line">        <span class="comment"># 没有达到限次，正常访问接口</span></span><br><span class="line">        <span class="comment"># 达到限次，限时时间内不能访问，限制时间达到后，可以重新访问</span></span><br><span class="line">        self.check_throttles(request)</span><br></pre></td></tr></table></figure>

<p>总结：请求来了把request重新包装了；经过self.initial，做了权限频率认证，过了之后，又回去然后执行get post 函数方法；然后拿到了一个response对象（里面的方法会判断是否为Response对象，补充《<code>Response</code>，使用该类构造响应对象时，响应的具体数据内容会被转换（render渲染）成符合前端需求的类型》如果是Response对象，会渲染一些东西；如果不是直接返回response）；APIVIew中的response包装了返回页面或者JSON格式。DRF请求过程就是通过APIView控制的。</p>
<p>请求来了把request重新包装了；经过self.initial，做了权限频率认证；响应走的时候，又进行了包装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">只需要记住  拿数据</span><br><span class="line">POST ： request.data </span><br><span class="line">GET:   request.query_params</span><br><span class="line">文件:   request.FILES</span><br></pre></td></tr></table></figure>





<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggggzi3mjxj30hc0t0aga.jpg" alt="image-20200705223439308"></p>
]]></content>
      <categories>
        <category>DRF</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>DRF-05-路由组件</title>
    <url>/posts/27141.html</url>
    <content><![CDATA[<p>路由Routers</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.路由</span></span><br><span class="line"><span class="comment"># 2.3中写法</span></span><br><span class="line">  - django传统的路由(CBV路由), </span><br><span class="line">  path(<span class="string">&#x27;test/&#x27;</span>, views.TestView.as_view()),</span><br><span class="line">  - 只要继承ViewSetMixin: path(<span class="string">&#x27;books/&#x27;</span>, views.BookViewSet.as_view(&#123;<span class="string">&#x27;get&#x27;</span>:<span class="string">&#x27;list&#x27;</span>, <span class="string">&#x27;post&#x27;</span>:<span class="string">&#x27;create&#x27;</span>&#125;))</span><br><span class="line">  - 自动生成路由</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">###### 只有视图继承 ViewSetMixin+ 9个视图子类 (原因是视图子类有对应的list create 等等方法),才能用router。 </span></span><br><span class="line"><span class="comment">###### 推荐用  include  可以加 前缀，比如 /api/v1</span></span><br></pre></td></tr></table></figure>



<h1 id="前提-重点"><a href="#前提-重点" class="headerlink" title="前提  #######重点"></a>前提  #######重点</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.自动生成路由的前提:</span></span><br><span class="line">(<span class="number">1</span>) 只有视图继承 ViewSetMixin + <span class="number">9</span>个视图子类；才能用router。 </span><br><span class="line">              = ViewSetMixin + GenericAPIView或APIView + 扩展类 （扩展类需配合GenericAPIView使用）</span><br><span class="line">(原因是视图子类有数据库对应的方法+ 对应的list create 方法, 而SimpleRouter自动生成的映射关系是&#123;<span class="string">&#x27;get&#x27;</span>:<span class="string">&#x27;list&#x27;</span>, <span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;create&#x27;</span>&#125;,&#123;<span class="string">&#x27;get&#x27;</span>:<span class="string">&#x27;retrieve&#x27;</span>, <span class="string">&#x27;put&#x27;</span>:<span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>:<span class="string">&#x27;destroy&#x27;</span>&#125;)</span><br><span class="line">如果想自动生成路由，那就需要有对应的方法:</span><br><span class="line">比如 ModelViewSet: GenericViewSet(GenericAPIView + ViewsetMixin) + <span class="number">5</span>个扩展类ListModelMixin(提供了list，create等方法....)</span><br><span class="line">比如ViewsetMixin + ListAPIView 可以自动生成路由: ViewsetMixin重写了as_view有了映射关系，分发时找方法，找到了list方法。</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)可以用装饰器自动生成路由的前提</span><br><span class="line">    ViewSetMixin+视图类（APIView。。。） -----&gt; 实际是通过装饰器修改了SimpleRouter里面的默认映射关系</span><br><span class="line">  </span><br><span class="line"><span class="comment">############### -- -- - --- - - - - -#############</span></span><br><span class="line"><span class="comment"># 2.推荐用  include  可以加 前缀，比如 /api/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目url配置</span></span><br><span class="line">eg:</span><br><span class="line">path(<span class="string">&#x27;&#x27;</span>, include(<span class="string">&#x27;app01.urls&#x27;</span>))</span><br><span class="line"></span><br><span class="line">后续可以这种形式</span><br><span class="line">path(<span class="string">&#x27;api/&#x27;</span>, include(<span class="string">&#x27;app01.urls&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h1 id="一-路由Routers"><a href="#一-路由Routers" class="headerlink" title="一 路由Routers"></a>一 路由Routers</h1><p>对于视图集ViewSet，我们除了可以自己手动指明请求方式与动作action之间的对应关系外，还可以使用Routers来帮助我们快速实现路由信息。</p>
<p>REST framework提供了两个router</p>
<ul>
<li><strong>SimpleRouter</strong></li>
<li><strong>DefaultRouter</strong></li>
</ul>
<h2 id="1-1-使用方法"><a href="#1-1-使用方法" class="headerlink" title="1.1 使用方法"></a>1.1 使用方法</h2><p>1） 创建router对象，并注册视图集，例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> routers</span><br><span class="line"></span><br><span class="line">router = routers.SimpleRouter()</span><br><span class="line">router.register(<span class="string">r&#x27;router_stu&#x27;</span>, StudentModelViewSet, base_name=<span class="string">&#x27;student&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>register(prefix, viewset, base_name)</p>
<ul>
<li>prefix 该视图集的路由前缀</li>
<li>viewset 视图集</li>
<li>base_name 路由别名的前缀</li>
</ul>
<p>如上述代码会形成的路由如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">^books/$    name: book-list</span><br><span class="line">^books/&#123;pk&#125;/$   name: book-detail</span><br></pre></td></tr></table></figure>

<p>2）添加路由数据</p>
<p>可以有两种方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">]</span><br><span class="line">urlpatterns += router.urls</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, include(router.urls))</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这样可以加前缀</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-代码演示"><a href="#1-2-代码演示" class="headerlink" title="1.2 代码演示"></a>1.2 代码演示</h2><p>使用路由类给视图集生成了路由地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 必须是继承ModelViewSet的视图类才能自动生成路由</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ModelViewSet,ReadOnlyModelViewSet</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentModelViewSet</span>(<span class="params">ModelViewSet</span>):</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line">        <span class="comment"># 这种方法不会自动生成，需要用action配置</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;学生登录功能&quot;&quot;&quot;</span></span><br><span class="line">        print(self.action)</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&quot;message&quot;</span>:<span class="string">&quot;登录成功&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>路由代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, re_path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;使用drf提供路由类router给视图集生成路由列表&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 实例化路由类</span></span><br><span class="line"><span class="comment"># drf提供一共提供了两个路由类给我们使用,他们用法一致,功能几乎一样</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.routers <span class="keyword">import</span> DefaultRouter</span><br><span class="line">router = DefaultRouter()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注册视图集</span></span><br><span class="line"><span class="comment"># router.register(&quot;路由前缀&quot;,视图集类)</span></span><br><span class="line">router.register(<span class="string">&quot;router_stu&quot;</span>,views.StudentModelViewSet)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把生成的路由列表追加到urlpatterns</span></span><br><span class="line">print( router.urls )</span><br><span class="line">urlpatterns += router.urls</span><br></pre></td></tr></table></figure>

<p>上面的代码就成功生成了路由地址[增/删/改/查一条/查多条的功能]，但是不会自动我们在视图集自定义方法的路由。</p>
<p>所以我们如果也要给自定义方法生成路由，则需要进行action动作的声明。</p>
<h2 id="1-2-视图集中附加action的声明"><a href="#1-2-视图集中附加action的声明" class="headerlink" title="1.2 视图集中附加action的声明"></a>1.2 视图集中附加action的声明</h2><p>作用: <strong>视图类中继承视图类(APIView等)+ViewSetMixin 自定义的方法 添加路由</strong> </p>
<p>在视图集中，如果想要让Router自动帮助我们为自定义的动作生成路由信息，需要使用<code>rest_framework.decorators.action</code>装饰器。</p>
<p>以action装饰器装饰的方法名会作为action动作名，与list、retrieve等同。</p>
<p>action装饰器可以接收两个参数：</p>
<ul>
<li><p><strong>methods</strong>: 声明该action对应的请求方式，列表传递</p>
</li>
<li><p>detail</p>
<p>: 声明该action的路径是否与单一资源对应，及是否是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xxx/&lt;pk&gt;/action方法名/</span><br></pre></td></tr></table></figure>

<ul>
<li>True 带pk 表示路径格式是<code>xxx/&lt;pk&gt;/action方法名/</code></li>
<li>False 不带pk 表示路径格式是<code>xxx/action方法名/</code></li>
</ul>
</li>
<li><p>urlpath</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># url_path 定义action方法名</span><br><span class="line">@action(methods&#x3D;[&#39;GET&#39;], detail&#x3D;True, url_path&#x3D;&#39;xxx&#39;)</span><br><span class="line">^books&#x2F;(?P&lt;pk&gt;[^&#x2F;.]+)&#x2F;xxx&#x2F;$</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ModelViewSet</span><br><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> action</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentModelViewSet</span>(<span class="params">ModelViewSet</span>):</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line"></span><br><span class="line">    <span class="comment"># methods 设置当前方法允许哪些http请求访问当前视图方法</span></span><br><span class="line">    <span class="comment"># detail 设置当前视图方法是否是操作一个数据</span></span><br><span class="line">    <span class="comment"># detail为True，表示路径名格式应该为 router_stu/&#123;pk&#125;/login/</span></span><br><span class="line"><span class="meta">    @action(methods=[&#x27;get&#x27;], detail=False)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;msg&#x27;</span>:<span class="string">&#x27;登陆成功&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @action(methods=[&#x27;put&#x27;], detail=True)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_new_5</span>(<span class="params">self, request,pk</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;msg&#x27;</span>:<span class="string">&#x27;获取5条数据成功&#x27;</span>&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># @action(methods=[&#x27;get&#x27;], detail=False)</span></span><br><span class="line">detail=<span class="literal">False</span></span><br><span class="line">生成的路由 /students/login/</span><br><span class="line"></span><br><span class="line">detail=<span class="literal">True</span></span><br><span class="line">生成的路由 /students/pk/get_new_5/</span><br><span class="line"></span><br><span class="line">如果有url参数，则生成的路由不再试方法名称了，而是url提供的参数</span><br><span class="line"><span class="comment"># @action(methods=[&#x27;put&#x27;], detail=True, url_path=&#x27;new_5&#x27;)</span></span><br><span class="line">生层的路由 /students/pk/new_5/</span><br></pre></td></tr></table></figure>

<p>由路由器自动为此视图集自定义action方法形成的路由会是如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^router_stu&#x2F;&#123;pk&#125;&#x2F;get_new_5&#x2F;$    name: router_stu-get_new_5</span><br><span class="line">^router_stu&#x2F;login&#x2F;$   name: router_stu-login</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggjybu91d2j30zq054gmj.jpg" alt="image-20200708225123044"></p>
<h2 id="1-3-路由router形成URL的方式"><a href="#1-3-路由router形成URL的方式" class="headerlink" title="1.3 路由router形成URL的方式"></a>1.3 路由router形成URL的方式</h2><p>1） SimpleRouter</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggghbmrvbij31940gwdj7.jpg" alt="SimpleRouter"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggjy4td5wlj30oy03gt94.jpg" alt="image-20200708224438048"></p>
<p>2）DefaultRouter</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggghbqkmx1j318y0j4wii.jpg" alt="DefaultRouter"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggjy44i1y3j30v607otaa.jpg" alt="image-20200708224355882"></p>
<p>DefaultRouter与SimpleRouter的区别是，DefaultRouter会多附带一个默认的API根视图，返回一个包含所有列表视图的超链接响应数据。</p>
]]></content>
      <categories>
        <category>DRF</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>DRF-03-请求与响应</title>
    <url>/posts/53666.html</url>
    <content><![CDATA[<p>Rquest 和 Response</p>
<a id="more"></a>


<h1 id="一-请求与响应"><a href="#一-请求与响应" class="headerlink" title="一 请求与响应"></a>一 请求与响应</h1><h2 id="1-1-Request"><a href="#1-1-Request" class="headerlink" title="1.1 Request"></a>1.1 Request</h2><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.request <span class="keyword">import</span> Request</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, request, parsers=None, authenticators=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 negotiator=None, parser_context=None</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> isinstance(request, HttpRequest), (</span><br><span class="line">            <span class="string">&#x27;The `request` argument must be an instance of &#x27;</span></span><br><span class="line">            <span class="string">&#x27;`django.http.HttpRequest`, not `&#123;&#125;.&#123;&#125;`.&#x27;</span></span><br><span class="line">            .format(request.__class__.__module__, request.__class__.__name__)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 二次封装request，将原生request作为drf request对象的_request属性</span></span><br><span class="line">        self._request = request</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, attr</span>):</span></span><br><span class="line">      <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> getattr(self._request, attr)</span><br><span class="line">      <span class="keyword">except</span> AttributeError:</span><br><span class="line">        <span class="keyword">return</span> self.__getattribute__(attr)</span><br><span class="line">      </span><br><span class="line"><span class="comment"># 请求对象.data: 前端以三种编码方式传入的数据，都可以取出来</span></span><br><span class="line"><span class="comment"># 请求对象.query_params 与Django 标准的request.GET相同，只是更换了更正确的名称。</span></span><br></pre></td></tr></table></figure>

<p>REST framework 传入视图的request对象不再是Django默认的HttpRequest对象，而是REST framework提供的扩展了HttpRequest类的<strong>Request</strong>类的对象。</p>
<p>REST framework 提供了<strong>Parser</strong>解析器，在接收到请求后会自动根据Content-Type指明的请求数据类型（如url-encoded 或者form-date表单等）将请求数据进行parse解析，解析为类字典**[QueryDict]<strong>对象保存到</strong>Request<strong>对象中。如JSON，解析为</strong>字典**保存在对象中。</p>
<p><strong>Request对象的数据是自动根据前端发送数据的格式进行解析之后的结果。</strong></p>
<p>无论前端发送的哪种格式的数据，我们都可以以统一的方式读取数据。</p>
<h3 id="1-1-1-1-常用属性"><a href="#1-1-1-1-常用属性" class="headerlink" title="1.1.1.1 常用属性"></a>1.1.1.1 常用属性</h3><h5 id="1）-data"><a href="#1）-data" class="headerlink" title="1）.data"></a>1）.data</h5><p><code>request.data</code> 返回解析之后的请求体数据。类似于Django中标准的<code>request.POST</code>和 <code>request.FILES</code>属性，但提供如下特性：</p>
<ul>
<li>包含了解析之后的文件和非文件数据</li>
<li>包含了对POST、PUT、PATCH请求方式解析后的数据</li>
<li>利用了REST framework的parsers解析器，不仅支持表单类型数据，也支持JSON数据</li>
</ul>
<h5 id="2）-query-params"><a href="#2）-query-params" class="headerlink" title="2）.query_params"></a>2）.query_params</h5><p><code>request.query_params</code>与Django标准的<code>request.GET</code>相同，只是更换了更正确的名称而已。</p>
<h2 id="1-2-Response"><a href="#1-2-Response" class="headerlink" title="1.2 Response"></a>1.2 Response</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rest_framework.response.Response</span><br></pre></td></tr></table></figure>

<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.response imoport Response</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data=None, status=None,</span></span></span><br><span class="line"><span class="function"><span class="params">             template_name=None, headers=None,</span></span></span><br><span class="line"><span class="function"><span class="params">             exception=False, content_type=None</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># data: 你想要返回的数据，字典</span></span><br><span class="line"><span class="comment"># status: 返回的状态码，默认是200</span></span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status <span class="comment"># 所有的状态码都定义成了常量，直接用即可</span></span><br><span class="line"><span class="comment"># template_name 渲染的模板名字(自定义模板), 不需要了解</span></span><br><span class="line"><span class="comment"># headers: 响应头，可以往响应头里放东西，就是一个字符串</span></span><br><span class="line"><span class="comment"># content_type: 响应的编码格式，application/json 和 text/html</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 浏览器响应成浏览器格式，postman响应成json格式，通过配置实现的(默认配置)</span></span><br><span class="line"><span class="comment"># 不管是postman 还是浏览器，都返回json格式数据</span></span><br><span class="line"><span class="comment"># drf有默认的配置文件--&gt;先从自己类中找(局部)--&gt;项目settings去找(全局)--&gt; 找不到采用默认的</span></span><br><span class="line">   - 局部使用: 对某个视图有效</span><br><span class="line">   - 全局使用：全局的视图(默认)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">全局配置：settings.py</span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;DEFAULT_RENDERER_CLASSES&#x27;</span>: (  <span class="comment"># 默认响应渲染类</span></span><br><span class="line">        <span class="string">&#x27;rest_framework.renderers.JSONRenderer&#x27;</span>,  <span class="comment"># json渲染器</span></span><br><span class="line">        <span class="string">&#x27;rest_framework.renderers.BrowsableAPIRenderer&#x27;</span>,  <span class="comment"># 浏览API渲染器</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">局部配置:</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestView</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    renderer_classes = [JSONRenderer]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        print(request)</span><br><span class="line">        <span class="keyword">return</span> Response(data=&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;WaylonYan&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>&#125;, status=status.HTTP_200_OK, headers=&#123;<span class="string">&#x27;xxx&#x27;</span>:<span class="number">111</span>&#125;)</span><br></pre></td></tr></table></figure>





<p>REST framework提供了一个响应类<code>Response</code>，使用该类构造响应对象时，响应的具体数据内容会被转换（render渲染）成符合前端需求的类型。</p>
<p>REST framework提供了<code>Renderer</code> 渲染器，用来根据请求头中的<code>Accept</code>（接收数据类型声明）来自动转换响应数据到对应格式。如果前端请求中未进行Accept声明，则会采用默认方式处理响应数据，我们可以通过配置来修改默认响应格式。</p>
<p>可以在<strong>rest_framework.settings</strong>查找所有的drf默认配置项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK &#x3D; &#123;</span><br><span class="line">    &#39;DEFAULT_RENDERER_CLASSES&#39;: (  # 默认响应渲染类</span><br><span class="line">        &#39;rest_framework.renderers.JSONRenderer&#39;,  # json渲染器</span><br><span class="line">        &#39;rest_framework.renderers.BrowsableAPIRenderer&#39;,  # 浏览API渲染器</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-2-1-构造方式"><a href="#1-1-2-1-构造方式" class="headerlink" title="1.1.2.1 构造方式"></a>1.1.2.1 构造方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Response(data, status&#x3D;None, template_name&#x3D;None, headers&#x3D;None, content_type&#x3D;None)</span><br></pre></td></tr></table></figure>

<p><code>data</code>数据不要是render处理之后的数据，只需传递python的内建类型数据即可，REST framework会使用<code>renderer</code>渲染器处理<code>data</code>。</p>
<p><code>data</code>不能是复杂结构的数据，如Django的模型类对象，对于这样的数据我们可以使用<code>Serializer</code>序列化器序列化处理后（转为了Python字典类型）再传递给<code>data</code>参数。</p>
<p>参数说明：</p>
<ul>
<li><code>data</code>: 为响应准备的序列化处理后的数据；</li>
<li><code>status</code>: 状态码，默认200；</li>
<li><code>template_name</code>: 模板名称，如果使用<code>HTMLRenderer</code> 时需指明；</li>
<li><code>headers</code>: 用于存放响应头信息的字典；</li>
<li><code>content_type</code>: 响应数据的Content-Type，通常此参数无需传递，REST framework会根据前端所需类型数据来设置该参数。</li>
</ul>
<h3 id="1-1-2-2-常用属性"><a href="#1-1-2-2-常用属性" class="headerlink" title="1.1.2.2 常用属性"></a>1.1.2.2 常用属性</h3><p>错误：response.data.get(‘detail’)</p>
<h5 id="1）-data-1"><a href="#1）-data-1" class="headerlink" title="1）.data"></a>1）.data</h5><p>传给response对象的序列化后，但尚未render处理的数据</p>
<h5 id="2）-status-code"><a href="#2）-status-code" class="headerlink" title="2）.status_code"></a>2）.status_code</h5><p>状态码的数字</p>
<h5 id="3）-content"><a href="#3）-content" class="headerlink" title="3）.content"></a>3）.content</h5><p>经过render处理后的响应数据</p>
<h3 id="1-1-2-3-状态码"><a href="#1-1-2-3-状态码" class="headerlink" title="1.1.2.3 状态码"></a>1.1.2.3 状态码</h3><p>为了方便设置状态码，REST framewrok在<code>rest_framework.status</code>模块中提供了常用状态码常量。</p>
<h5 id="1）信息告知-1xx"><a href="#1）信息告知-1xx" class="headerlink" title="1）信息告知 - 1xx"></a>1）信息告知 - 1xx</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP_100_CONTINUE</span><br><span class="line">HTTP_101_SWITCHING_PROTOCOLS</span><br></pre></td></tr></table></figure>

<h5 id="2）成功-2xx"><a href="#2）成功-2xx" class="headerlink" title="2）成功 - 2xx"></a>2）成功 - 2xx</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP_200_OK</span><br><span class="line">HTTP_201_CREATED</span><br><span class="line">HTTP_202_ACCEPTED</span><br><span class="line">HTTP_203_NON_AUTHORITATIVE_INFORMATION</span><br><span class="line">HTTP_204_NO_CONTENT</span><br><span class="line">HTTP_205_RESET_CONTENT</span><br><span class="line">HTTP_206_PARTIAL_CONTENT</span><br><span class="line">HTTP_207_MULTI_STATUS</span><br></pre></td></tr></table></figure>

<h5 id="3）重定向-3xx"><a href="#3）重定向-3xx" class="headerlink" title="3）重定向 - 3xx"></a>3）重定向 - 3xx</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP_300_MULTIPLE_CHOICES</span><br><span class="line">HTTP_301_MOVED_PERMANENTLY</span><br><span class="line">HTTP_302_FOUND</span><br><span class="line">HTTP_303_SEE_OTHER</span><br><span class="line">HTTP_304_NOT_MODIFIED</span><br><span class="line">HTTP_305_USE_PROXY</span><br><span class="line">HTTP_306_RESERVED</span><br><span class="line">HTTP_307_TEMPORARY_REDIRECT</span><br></pre></td></tr></table></figure>

<h5 id="4）客户端错误-4xx"><a href="#4）客户端错误-4xx" class="headerlink" title="4）客户端错误 - 4xx"></a>4）客户端错误 - 4xx</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP_400_BAD_REQUEST</span><br><span class="line">HTTP_401_UNAUTHORIZED</span><br><span class="line">HTTP_402_PAYMENT_REQUIRED</span><br><span class="line">HTTP_403_FORBIDDEN</span><br><span class="line">HTTP_404_NOT_FOUND</span><br><span class="line">HTTP_405_METHOD_NOT_ALLOWED</span><br><span class="line">HTTP_406_NOT_ACCEPTABLE</span><br><span class="line">HTTP_407_PROXY_AUTHENTICATION_REQUIRED</span><br><span class="line">HTTP_408_REQUEST_TIMEOUT</span><br><span class="line">HTTP_409_CONFLICT</span><br><span class="line">HTTP_410_GONE</span><br><span class="line">HTTP_411_LENGTH_REQUIRED</span><br><span class="line">HTTP_412_PRECONDITION_FAILED</span><br><span class="line">HTTP_413_REQUEST_ENTITY_TOO_LARGE</span><br><span class="line">HTTP_414_REQUEST_URI_TOO_LONG</span><br><span class="line">HTTP_415_UNSUPPORTED_MEDIA_TYPE</span><br><span class="line">HTTP_416_REQUESTED_RANGE_NOT_SATISFIABLE</span><br><span class="line">HTTP_417_EXPECTATION_FAILED</span><br><span class="line">HTTP_422_UNPROCESSABLE_ENTITY</span><br><span class="line">HTTP_423_LOCKED</span><br><span class="line">HTTP_424_FAILED_DEPENDENCY</span><br><span class="line">HTTP_428_PRECONDITION_REQUIRED</span><br><span class="line">HTTP_429_TOO_MANY_REQUESTS</span><br><span class="line">HTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE</span><br><span class="line">HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS</span><br></pre></td></tr></table></figure>

<h5 id="5）服务器错误-5xx"><a href="#5）服务器错误-5xx" class="headerlink" title="5）服务器错误 - 5xx"></a>5）服务器错误 - 5xx</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP_500_INTERNAL_SERVER_ERROR</span><br><span class="line">HTTP_501_NOT_IMPLEMENTED</span><br><span class="line">HTTP_502_BAD_GATEWAY</span><br><span class="line">HTTP_503_SERVICE_UNAVAILABLE</span><br><span class="line">HTTP_504_GATEWAY_TIMEOUT</span><br><span class="line">HTTP_505_HTTP_VERSION_NOT_SUPPORTED</span><br><span class="line">HTTP_507_INSUFFICIENT_STORAGE</span><br><span class="line">HTTP_511_NETWORK_AUTHENTICATION_REQUIRED</span><br></pre></td></tr></table></figure>



<h3 id="封装Response对象"><a href="#封装Response对象" class="headerlink" title="封装Response对象"></a>封装Response对象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APIResponse</span>(<span class="params">Response</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, code=<span class="number">100</span>, msg=<span class="string">&#x27;成功&#x27;</span>, result=None, status=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 template_name=None, headers=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 exception=False, content_type=None, **kwargs</span>):</span></span><br><span class="line">        response_dic = &#123;<span class="string">&#x27;code&#x27;</span>: code, <span class="string">&#x27;msg&#x27;</span>: msg&#125;</span><br><span class="line">        <span class="keyword">if</span> result:</span><br><span class="line">            response_dic = &#123;<span class="string">&#x27;code&#x27;</span>: status, <span class="string">&#x27;msg&#x27;</span>: msg, <span class="string">&#x27;data&#x27;</span>: result&#125;</span><br><span class="line">        response_dic.update(kwargs)</span><br><span class="line"></span><br><span class="line">        super(APIResponse, self).__init__(data=response_dic, status=status,</span><br><span class="line">                                          template_name=template_name, headers=headers,</span><br><span class="line">                                          exception=exception, content_type=content_type)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>DRF</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>DRF-02-序列化组件</title>
    <url>/posts/29589.html</url>
    <content><![CDATA[<p>序列化组件 serializers - (Serializer , ModelSerializer)<br>高级用法: source和serializers.SerializerMethodField() </p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1 Serializer类，需要序列化什么，必须写一个类继承；想要序列化什么字段，就在里面写字段，source的作用（很多字段类）</span></span><br><span class="line"><span class="comment">#2 序列化queryset(列表) 对象和真正的对象，（many=True，instance=要序列化的对象）</span></span><br><span class="line"><span class="comment">#3 反序列化 instance=要序列化的对象，data=request.data</span></span><br><span class="line"><span class="comment">#4 字段验证，序列化类中，给字段加属性，局部和全局钩子函数，字段属性的validators=[check_author]</span></span><br><span class="line"><span class="comment">#5 当在视图中调用 序列化对象.is_valid()  boo_ser.is_valid(raise_exception=True) 只要验证不通过，直接抛异常。</span></span><br><span class="line"><span class="comment">#6 修改保存--&gt;调用序列化对象.save(),重写Serializer类的update方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, instance, validated_data</span>):</span></span><br><span class="line">        <span class="comment"># instance是book这个对象</span></span><br><span class="line">        <span class="comment"># validated_data是校验后的数据</span></span><br><span class="line">        instance.name = validated_data.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        instance.price = validated_data.get(<span class="string">&#x27;price&#x27;</span>)</span><br><span class="line">        instance.author = validated_data.get(<span class="string">&#x27;author&#x27;</span>)</span><br><span class="line">        instance.publish = validated_data.get(<span class="string">&#x27;publish&#x27;</span>)</span><br><span class="line">        instance.save() <span class="comment"># book.save()  orm提供的方法</span></span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 必须要返回instance的原因是 给序列化的时候用  ser.data 返回的时候才有值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#7 序列化得到字典--&gt;序列化对象.data</span></span><br><span class="line"><span class="comment">#8 自定义一个Response对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResponse</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.status = <span class="number">100</span></span><br><span class="line">        self.msg = <span class="string">&#x27;成功&#x27;</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_dict</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__dict__</span><br><span class="line"><span class="comment">#9 反序列化的新增  序列化类(data=request.data),如果只传data，当调用序列化对象.save(),会触发序列化类中的create方法执行；当传了instance和data时，调用序列化对象.save()，会触发序列化类的update()方法执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#10 重写create方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">self, validated_data</span>):</span></span><br><span class="line">        instance = models.Book.objects.create(**validated_data)</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line"><span class="comment">#11 ModelSerializer跟Model做了一个对应</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookModelSerializer</span>(<span class="params">serializers.ModelSerializer</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_price</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    publish = serialiazer.CharField(source=<span class="string">&#x27;publish.name&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Book  <span class="comment"># 对应models.py中的模型</span></span><br><span class="line">        </span><br><span class="line">        fields = <span class="string">&#x27;__all__&#x27;</span></span><br><span class="line">        <span class="comment"># fields = (&#x27;name&#x27;, &#x27;price&#x27;)  # 只序列化指定的字段</span></span><br><span class="line">        <span class="comment"># exclude = (&#x27;name&#x27;,) # 写谁，排除谁。跟fields不能都写</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 已经弃用了</span></span><br><span class="line">        <span class="comment"># read_only_fields = (&#x27;price&#x27;,)</span></span><br><span class="line">        <span class="comment"># write_only_fields = (&#x27;author&#x27;,)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用extra_kwargs 替用了</span></span><br><span class="line">        extra_kwargs = &#123;  <span class="comment"># 类似于这种形式</span></span><br><span class="line">            <span class="string">&#x27;author&#x27;</span>: &#123;<span class="string">&#x27;write_only&#x27;</span>: <span class="literal">True</span>&#125;,</span><br><span class="line">            <span class="string">&#x27;price&#x27;</span>: &#123;<span class="string">&#x27;write_only&#x27;</span>:<span class="literal">True</span>, <span class="string">&#x27;max_length&#x27;</span>:<span class="number">16</span>, <span class="string">&#x27;min_length&#x27;</span>:<span class="number">4</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">#12 如果在ModelSerializer中写一个局部钩子或者全局钩子，如何写？</span></span><br><span class="line">   - 跟之前一模一样</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">#13 many=True  能够序列化多条的原因 --&gt; __new__是在__init__之前执行的，造出一个空对象---&gt; 是ListModelSerializer的对象</span></span><br><span class="line"><span class="comment">#14 接口：统一子类的行为</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">####</span></span><br><span class="line"><span class="number">1.</span> 自己封装一个response对象，CommmonResponse对象，使用方法</span><br><span class="line"><span class="keyword">return</span> CommmonResponse(<span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;成功&#x27;</span>, boo_ser.data)</span><br></pre></td></tr></table></figure>



<p>ser.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> rest_framework.exceptions <span class="keyword">import</span> ValidationError</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> app01.models <span class="keyword">import</span> Book</span><br><span class="line"><span class="comment"># 继承Serializer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookSerializer</span>(<span class="params">serializers.Serializer</span>):</span></span><br><span class="line">    id = serializers.CharField(read_only=<span class="literal">True</span>)</span><br><span class="line">    name = serializers.CharField(max_length=<span class="number">16</span>, min_length=<span class="number">4</span>)</span><br><span class="line">    price = serializers.CharField(write_only=<span class="literal">True</span>)</span><br><span class="line">    author = serializers.CharField()</span><br><span class="line">    publish = serializers.CharField()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 局部钩子</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_price</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="comment"># 价格大于10，校验不通过</span></span><br><span class="line">        <span class="comment"># print(data)</span></span><br><span class="line">        <span class="comment"># print(type(data))  # str</span></span><br><span class="line">        <span class="keyword">if</span> float(data) &gt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValidationError(<span class="string">&#x27;价格不能小于10&#x27;</span>)</span><br><span class="line">        <span class="comment"># return data</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 全局钩子</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span>(<span class="params">self, validate_data</span>):</span></span><br><span class="line">        print(validate_data)</span><br><span class="line">        author = validate_data.get(<span class="string">&#x27;author&#x27;</span>)</span><br><span class="line">        publish = validate_data.get(<span class="string">&#x27;publish&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> author == publish:</span><br><span class="line">            <span class="keyword">raise</span> ValidationError(<span class="string">&#x27;作者名字和出版社一样了&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> validate_data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, instance, validated_data</span>):</span></span><br><span class="line">        <span class="comment"># instance是book这个对象</span></span><br><span class="line">        <span class="comment"># validated_data是校验后的数据</span></span><br><span class="line">        instance.name = validated_data.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        instance.price = validated_data.get(<span class="string">&#x27;price&#x27;</span>)</span><br><span class="line">        instance.author = validated_data.get(<span class="string">&#x27;author&#x27;</span>)</span><br><span class="line">        instance.publish = validated_data.get(<span class="string">&#x27;publish&#x27;</span>)</span><br><span class="line">        instance.save() <span class="comment"># book.save()  orm提供的方法</span></span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">self, validated_data</span>):</span></span><br><span class="line">        instance = models.Book.objects.create(**validated_data)</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookModelSerializer</span>(<span class="params">serializers.ModelSerializer</span>):</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Book  <span class="comment"># 对应models.py中的模型</span></span><br><span class="line">        fields = <span class="string">&#x27;__all__&#x27;</span></span><br><span class="line">        <span class="comment"># fields = (&#x27;name&#x27;, &#x27;price&#x27;)</span></span><br><span class="line">        <span class="comment"># exclude = (&#x27;name&#x27;,)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 已经弃用了</span></span><br><span class="line">        <span class="comment"># read_only_fields = (&#x27;price&#x27;,)</span></span><br><span class="line">        <span class="comment"># write_only_fields = (&#x27;author&#x27;,)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用extra_kwargs 替用了 （id字段不行）</span></span><br><span class="line">        extra_kwargs = &#123;</span><br><span class="line">            <span class="string">&#x27;author&#x27;</span>: &#123;<span class="string">&#x27;write_only&#x27;</span>: <span class="literal">True</span>&#125;,</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>views.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> app01.models <span class="keyword">import</span> Book</span><br><span class="line"><span class="keyword">from</span> app01.ser <span class="keyword">import</span> BookSerializer</span><br><span class="line"><span class="keyword">from</span> app01.ser <span class="keyword">import</span> BookModelSerializer</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response  <span class="comment"># drf提供的响应对象</span></span><br><span class="line"><span class="keyword">from</span> utils.Myresponse <span class="keyword">import</span> MyResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookView</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request, pk</span>):</span></span><br><span class="line"></span><br><span class="line">        book = Book.objects.filter(id=pk).first()</span><br><span class="line">        <span class="comment"># 序列化谁，就把谁传过来</span></span><br><span class="line">        book_ser = BookSerializer(book)</span><br><span class="line">        <span class="comment"># boo_ser.data 序列化对象.data 就是序列化后的字典</span></span><br><span class="line">        <span class="keyword">return</span> Response(book_ser.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, request, pk</span>):</span></span><br><span class="line">        <span class="comment"># response_msg = &#123;&#x27;status&#x27;: 100, &#x27;msg&#x27;: &#x27;成功&#x27;&#125;</span></span><br><span class="line">        response = MyResponse()</span><br><span class="line">        <span class="comment"># 找到这个对象</span></span><br><span class="line">        book = Book.objects.filter(id=pk).first()</span><br><span class="line">        <span class="comment"># 得到一个实例化的对象</span></span><br><span class="line">        book_ser = BookSerializer(instance=book, data=request.data)</span><br><span class="line">        <span class="comment"># 数据验证(回想form表单)</span></span><br><span class="line">        <span class="keyword">if</span> book_ser.is_valid():  <span class="comment"># 返回true表示验证通过</span></span><br><span class="line">            book_ser.save()</span><br><span class="line">            response.data = book_ser.data</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            response.status = <span class="number">101</span></span><br><span class="line">            response.msg = <span class="string">&#x27;数据校验失败&#x27;</span></span><br><span class="line">            response.data = book_ser.errors</span><br><span class="line">            <span class="comment"># response_msg[&#x27;status&#x27;] = 101</span></span><br><span class="line">            <span class="comment"># response_msg[&#x27;msg&#x27;] = &#x27;数据校验失败&#x27;</span></span><br><span class="line">            <span class="comment"># response_msg[&#x27;data&#x27;] = book_ser.errors</span></span><br><span class="line">        <span class="keyword">return</span> Response(response.get_dict)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self, request, pk</span>):</span></span><br><span class="line">        response = MyResponse()</span><br><span class="line">        book_obj = Book.objects.filter(id=pk)</span><br><span class="line">        <span class="keyword">if</span> book_obj:</span><br><span class="line">            book_obj.delete()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            response.status = <span class="number">101</span></span><br><span class="line">            response.msg = <span class="string">&#x27;数据不存在&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> Response(response.get_dict)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询所有</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BooksView</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        response = MyResponse()</span><br><span class="line">        book_queryset = Book.objects.all()</span><br><span class="line">        book_ser = BookSerializer(instance=book_queryset, many=<span class="literal">True</span>)</span><br><span class="line">        response.data = book_ser.data</span><br><span class="line">        <span class="keyword">return</span> Response(response.get_dict)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        response = MyResponse()</span><br><span class="line">        <span class="comment"># 修改才有instance，新增没有;如果按位置参数传，就会给instance，报错了。</span></span><br><span class="line">        book_ser = BookSerializer(data=request.data)</span><br><span class="line">        <span class="keyword">if</span> book_ser.is_valid():</span><br><span class="line">            book_ser.save()</span><br><span class="line">            response.data = book_ser.data</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            response.status = <span class="number">102</span></span><br><span class="line">            response.msg = <span class="string">&#x27;校验失败&#x27;</span></span><br><span class="line">            response.data = book_ser.errors</span><br><span class="line">        <span class="keyword">return</span> Response(response.get_dict)</span><br></pre></td></tr></table></figure>

<p>Url.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    re_path(<span class="string">&#x27;^books/(?P&lt;pk&gt;\d+)&#x27;</span>, views.BookView.as_view()),</span><br><span class="line">    path(<span class="string">&#x27;books/&#x27;</span>, views.BooksView.as_view()),</span><br><span class="line">]</span><br><span class="line">    <span class="comment"># 路由分发</span></span><br></pre></td></tr></table></figure>

<h2 id="解释-保存和修改的时候为什么一定重写update和create方法"><a href="#解释-保存和修改的时候为什么一定重写update和create方法" class="headerlink" title="解释: 保存和修改的时候为什么一定重写update和create方法?"></a>解释: 保存和修改的时候为什么一定重写update和create方法?</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">因为序列化类  和  模型表 并不是 一一对应关系</span><br><span class="line">序列化类1 可以给 模型1 用，也可以给 模型2 用。</span><br><span class="line"></span><br><span class="line">保存的时候并不知道你要保存和更改哪个表，所以需要重写</span><br></pre></td></tr></table></figure>





<h1 id="一-序列化器-Serializer"><a href="#一-序列化器-Serializer" class="headerlink" title="一 序列化器-Serializer"></a>一 序列化器-Serializer</h1><p>作用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 序列化,序列化器会把模型对象转换成字典,经过response以后变成json字符串</span><br><span class="line">2. 反序列化,把客户端发送过来的数据,经过request以后变成字典,序列化器可以把字典转成模型</span><br><span class="line">3. 反序列化,完成数据校验功能</span><br></pre></td></tr></table></figure>

<h2 id="1-1-定义序列化器"><a href="#1-1-定义序列化器" class="headerlink" title="1.1 定义序列化器"></a>1.1 定义序列化器</h2><p>Django REST framework中的Serializer使用类来定义，须继承自rest_framework.serializers.Serializer。</p>
<p>接下来，为了方便演示序列化器的使用，我们先创建一个新的子应用sers</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py startapp sers</span><br></pre></td></tr></table></figure>

<p>我们已有了一个数据库模型类students/Student</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line"># Create your models here.</span><br><span class="line">class Student(models.Model):</span><br><span class="line">    # 模型字段</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;100,verbose_name&#x3D;&quot;姓名&quot;,help_text&#x3D;&quot;提示文本:账号不能为空！&quot;)</span><br><span class="line">    sex &#x3D; models.BooleanField(default&#x3D;True,verbose_name&#x3D;&quot;性别&quot;)</span><br><span class="line">    age &#x3D; models.IntegerField(verbose_name&#x3D;&quot;年龄&quot;)</span><br><span class="line">    class_null &#x3D; models.CharField(max_length&#x3D;5,verbose_name&#x3D;&quot;班级编号&quot;)</span><br><span class="line">    description &#x3D; models.TextField(verbose_name&#x3D;&quot;个性签名&quot;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        db_table&#x3D;&quot;tb_student&quot;</span><br><span class="line">        verbose_name &#x3D; &quot;学生&quot;</span><br><span class="line">        verbose_name_plural &#x3D; verbose_name</span><br></pre></td></tr></table></figure>

<p>我们想为这个模型类提供一个序列化器，可以定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest_framework import serializers</span><br><span class="line"></span><br><span class="line"># 声明序列化器，所有的序列化器都要直接或者间接继承于 Serializer</span><br><span class="line"># 其中，ModelSerializer是Serializer的子类，ModelSerializer在Serializer的基础上进行了代码简化</span><br><span class="line">class StudentSerializer(serializers.Serializer):</span><br><span class="line">    &quot;&quot;&quot;学生信息序列化器&quot;&quot;&quot;</span><br><span class="line">    # 1. 需要进行数据转换的字段</span><br><span class="line">    id &#x3D; serializers.IntegerField()</span><br><span class="line">    name &#x3D; serializers.CharField()</span><br><span class="line">    age &#x3D; serializers.IntegerField()</span><br><span class="line">    sex &#x3D; serializers.BooleanField()</span><br><span class="line">    description &#x3D; serializers.CharField()</span><br><span class="line"></span><br><span class="line">    # 2. 如果序列化器集成的是ModelSerializer，则需要声明调用的模型信息</span><br><span class="line"></span><br><span class="line">    # 3. 验证代码</span><br><span class="line"></span><br><span class="line">    # 4. 编写添加和更新模型的代码</span><br></pre></td></tr></table></figure>

<p><strong>注意：serializer不是只能为数据库模型类定义，也可以为非数据库模型类的数据定义。</strong>serializer是独立于数据库之外的存在。</p>
<p><strong>常用字段类型</strong>：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>字段构造方式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>BooleanField</strong></td>
<td>BooleanField()</td>
</tr>
<tr>
<td><strong>NullBooleanField</strong></td>
<td>NullBooleanField()</td>
</tr>
<tr>
<td><strong>CharField</strong></td>
<td>CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)</td>
</tr>
<tr>
<td><strong>EmailField</strong></td>
<td>EmailField(max_length=None, min_length=None, allow_blank=False)</td>
</tr>
<tr>
<td><strong>RegexField</strong></td>
<td>RegexField(regex, max_length=None, min_length=None, allow_blank=False)</td>
</tr>
<tr>
<td><strong>SlugField</strong></td>
<td>SlugField(max<em>length=50, min_length=None, allow_blank=False) 正则字段，验证正则模式 [a-zA-Z0-9</em>-]+</td>
</tr>
<tr>
<td><strong>URLField</strong></td>
<td>URLField(max_length=200, min_length=None, allow_blank=False)</td>
</tr>
<tr>
<td><strong>UUIDField</strong></td>
<td>UUIDField(format=’hex_verbose’) format: 1) <code>&#39;hex_verbose&#39;</code> 如<code>&quot;5ce0e9a5-5ffa-654b-cee0-1238041fb31a&quot;</code> 2） <code>&#39;hex&#39;</code> 如 <code>&quot;5ce0e9a55ffa654bcee01238041fb31a&quot;</code> 3）<code>&#39;int&#39;</code> - 如: <code>&quot;123456789012312313134124512351145145114&quot;</code> 4）<code>&#39;urn&#39;</code> 如: <code>&quot;urn:uuid:5ce0e9a5-5ffa-654b-cee0-1238041fb31a&quot;</code></td>
</tr>
<tr>
<td><strong>IPAddressField</strong></td>
<td>IPAddressField(protocol=’both’, unpack_ipv4=False, **options)</td>
</tr>
<tr>
<td><strong>IntegerField</strong></td>
<td>IntegerField(max_value=None, min_value=None)</td>
</tr>
<tr>
<td><strong>FloatField</strong></td>
<td>FloatField(max_value=None, min_value=None)</td>
</tr>
<tr>
<td><strong>DecimalField</strong></td>
<td>DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None) max_digits: 最多位数 decimal_palces: 小数点位置</td>
</tr>
<tr>
<td><strong>DateTimeField</strong></td>
<td>DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None)</td>
</tr>
<tr>
<td><strong>DateField</strong></td>
<td>DateField(format=api_settings.DATE_FORMAT, input_formats=None)</td>
</tr>
<tr>
<td><strong>TimeField</strong></td>
<td>TimeField(format=api_settings.TIME_FORMAT, input_formats=None)</td>
</tr>
<tr>
<td><strong>DurationField</strong></td>
<td>DurationField()</td>
</tr>
<tr>
<td><strong>ChoiceField</strong></td>
<td>ChoiceField(choices) choices与Django的用法相同</td>
</tr>
<tr>
<td><strong>MultipleChoiceField</strong></td>
<td>MultipleChoiceField(choices)</td>
</tr>
<tr>
<td><strong>FileField</strong></td>
<td>FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)</td>
</tr>
<tr>
<td><strong>ImageField</strong></td>
<td>ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)</td>
</tr>
<tr>
<td><strong>ListField</strong></td>
<td>ListField(child=, min_length=None, max_length=None)</td>
</tr>
<tr>
<td><strong>DictField</strong></td>
<td>DictField(child=)</td>
</tr>
</tbody></table>
<p><strong>选项参数：</strong></p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>max_length</strong></td>
<td>最大长度</td>
</tr>
<tr>
<td><strong>min_lenght</strong></td>
<td>最小长度</td>
</tr>
<tr>
<td><strong>allow_blank</strong></td>
<td>是否允许为空</td>
</tr>
<tr>
<td><strong>trim_whitespace</strong></td>
<td>是否截断空白字符</td>
</tr>
<tr>
<td><strong>max_value</strong></td>
<td>最小值</td>
</tr>
<tr>
<td><strong>min_value</strong></td>
<td>最大值</td>
</tr>
</tbody></table>
<p>通用参数：</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>read_only</strong></td>
<td>表明该字段仅用于序列化输出，默认False</td>
</tr>
<tr>
<td><strong>write_only</strong></td>
<td>表明该字段仅用于反序列化输入，默认False</td>
</tr>
<tr>
<td><strong>required</strong></td>
<td>表明该字段在反序列化时必须输入，默认True</td>
</tr>
<tr>
<td><strong>default</strong></td>
<td>反序列化时使用的默认值</td>
</tr>
<tr>
<td><strong>allow_null</strong></td>
<td>表明该字段是否允许传入None，默认False</td>
</tr>
<tr>
<td><strong>validators</strong></td>
<td>该字段使用的验证器</td>
</tr>
<tr>
<td><strong>error_messages</strong></td>
<td>包含错误编号与错误信息的字典</td>
</tr>
<tr>
<td><strong>label</strong></td>
<td>用于HTML展示API页面时，显示的字段名称</td>
</tr>
<tr>
<td><strong>help_text</strong></td>
<td>用于HTML展示API页面时，显示的字段帮助提示信息</td>
</tr>
</tbody></table>
<h2 id="1-2-创建Serializer对象"><a href="#1-2-创建Serializer对象" class="headerlink" title="1.2 创建Serializer对象"></a>1.2 创建Serializer对象</h2><p>定义好Serializer类后，就可以创建Serializer对象了。</p>
<p>Serializer的构造方法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Serializer(instance&#x3D;None, data&#x3D;empty, **kwarg)</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>1）用于序列化时，将模型类对象传入<strong>instance</strong>参数</p>
<p>2）用于反序列化时，将要被反序列化的数据传入<strong>data</strong>参数</p>
<p>3）除了instance和data参数外，在构造Serializer对象时，还可通过<strong>context</strong>参数额外添加数据，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">serializer &#x3D; AccountSerializer(account, context&#x3D;&#123;&#39;request&#39;: request&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>通过context参数附加的数据，可以通过Serializer对象的context属性获取。</strong></p>
<ol>
<li>使用序列化器的时候一定要注意，序列化器声明了以后，不会自动执行，需要我们在视图中进行调用才可以。</li>
<li>序列化器无法直接接收数据，需要我们在视图中创建序列化器对象时把使用的数据传递过来。</li>
<li>序列化器的字段声明类似于我们前面使用过的表单系统。</li>
<li>开发restful api时，序列化器会帮我们把模型数据转换成字典.</li>
<li>drf提供的视图会帮我们把字典转换成json,或者把客户端发送过来的数据转换字典.</li>
</ol>
<h2 id="1-3-序列化器的使用"><a href="#1-3-序列化器的使用" class="headerlink" title="1.3 序列化器的使用"></a>1.3 序列化器的使用</h2><p>序列化器的使用分两个阶段：</p>
<ol>
<li>在客户端请求时，使用序列化器可以完成对数据的反序列化。</li>
<li>在服务器响应时，使用序列化器可以完成对数据的序列化。</li>
</ol>
<h3 id="1-3-1-序列化"><a href="#1-3-1-序列化" class="headerlink" title="1.3.1 序列化"></a>1.3.1 序列化</h3><h4 id="1-3-1-1-基本使用"><a href="#1-3-1-1-基本使用" class="headerlink" title="1.3.1.1 基本使用"></a>1.3.1.1 基本使用</h4><p>1） 先查询出一个学生对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> students.models <span class="keyword">import</span> Student</span><br><span class="line"></span><br><span class="line">student = Student.objects.get(id=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>2） 构造序列化器对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .serializers <span class="keyword">import</span> StudentSerializer</span><br><span class="line"></span><br><span class="line">serializer = StudentSerializer(instance=student)</span><br></pre></td></tr></table></figure>

<p>3）获取序列化数据</p>
<p>通过data属性可以获取序列化后的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">serializer.data</span><br><span class="line"># &#123;&#39;id&#39;: 4, &#39;name&#39;: &#39;小张&#39;, &#39;age&#39;: 18, &#39;sex&#39;: True, &#39;description&#39;: &#39;猴赛雷&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>完整视图代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"><span class="keyword">from</span> students.models <span class="keyword">import</span> Student</span><br><span class="line"><span class="keyword">from</span> .serializers <span class="keyword">import</span> StudentSerializer</span><br><span class="line"><span class="keyword">from</span> django.http.response <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentView</span>(<span class="params">View</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用序列化器序列化转换单个模型数据&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request,pk</span>):</span></span><br><span class="line">        <span class="comment"># 获取数据</span></span><br><span class="line">        student = Student.objects.get(pk=pk)</span><br><span class="line">        <span class="comment"># 数据转换[序列化过程]</span></span><br><span class="line">        serializer = StudentSerializer(instance=student)</span><br><span class="line">        print(serializer.data)</span><br><span class="line">        <span class="comment"># 响应数据</span></span><br><span class="line">        <span class="keyword">return</span> JsonResponse(serializer.data)</span><br></pre></td></tr></table></figure>

<p>4）如果要被序列化的是包含多条数据的查询集QuerySet，可以通过添加<strong>many=True</strong>参数补充说明</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;使用序列化器序列化转换多个模型数据&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span></span><br><span class="line">    <span class="comment"># 获取数据</span></span><br><span class="line">    student_list = Student.objects.all()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 转换数据[序列化过程]</span></span><br><span class="line">    <span class="comment"># 如果转换多个模型对象数据，则需要加上many=True</span></span><br><span class="line">    serializer = StudentSerializer(instance=student_list,many=<span class="literal">True</span>)</span><br><span class="line">    print( serializer.data ) <span class="comment"># 序列化器转换后的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 响应数据给客户端</span></span><br><span class="line">    <span class="comment"># 返回的json数据，如果是列表，则需要声明safe=False</span></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(serializer.data,safe=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问结果：</span></span><br><span class="line"><span class="comment"># [OrderedDict([(&#x27;id&#x27;, 1), (&#x27;name&#x27;, &#x27;xiaoming&#x27;), (&#x27;age&#x27;, 20), (&#x27;sex&#x27;, True), (&#x27;description&#x27;, &#x27;测试&#x27;)]), OrderedDict([(&#x27;id&#x27;, 2), (&#x27;name&#x27;, &#x27;xiaohui&#x27;), (&#x27;age&#x27;, 22), (&#x27;sex&#x27;, True), (&#x27;description&#x27;, &#x27;后面来的测试&#x27;)]), OrderedDict([(&#x27;id&#x27;, 4), (&#x27;name&#x27;, &#x27;小张&#x27;), (&#x27;age&#x27;, 18), (&#x27;sex&#x27;, True), (&#x27;description&#x27;, &#x27;猴赛雷&#x27;)])]</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-1-2-高级用法（source-和-SerializerMethodField-只读的时候使用-有配套方法）"><a href="#1-3-1-2-高级用法（source-和-SerializerMethodField-只读的时候使用-有配套方法）" class="headerlink" title="1.3.1.2 高级用法（source 和 SerializerMethodField(只读的时候使用) 有配套方法）"></a>1.3.1.2 高级用法（source 和 SerializerMethodField(<strong>只读的时候使用</strong>) 有配套方法）</h4><p><strong>ChoiceField</strong> 用于只写，非常方便  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># source和serializers.SerializerMethodField()的用法</span></span><br><span class="line"><span class="comment">## source的使用</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># 隐藏了book对象 传过来， 如果字段对应关系写成 xxx  ，那就是book.xxx （要通过source字段改）</span></span><br><span class="line"><span class="string"># 相当于 book.title  book.price book.publish</span></span><br><span class="line"><span class="string"># 外键字段默认调用model里class 的__str__方法</span></span><br><span class="line"><span class="string"># source 后可以接属性或者是方法（方法的话需要在对应的models模型类中定义）</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 可以改名字  xxx = serializers.CharField(source=<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line"><span class="number">2.</span> 可以.点跨表 publish = serializers.CharField(source=<span class="string">&#x27;publish.email&#x27;</span>) <span class="comment"># book.publish.email</span></span><br><span class="line"><span class="number">3.</span> 可以执行方法 pub_date = serializers.CharField(source=<span class="string">&#x27;test&#x27;</span>) test是Book模型中的方法</span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookSerializer</span>(<span class="params">serializers.Serializer</span>):</span></span><br><span class="line">    <span class="comment"># 隐藏了book对象</span></span><br><span class="line">    <span class="comment"># book.title</span></span><br><span class="line">    <span class="comment"># book.price</span></span><br><span class="line">    <span class="comment"># book.publish</span></span><br><span class="line">    <span class="comment"># 默认调用model里class 的__str__方法</span></span><br><span class="line">    <span class="comment"># source 后可以接属性或者是方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># id = serializers.CharField(read_only=True)</span></span><br><span class="line">    xxx = serializers.CharField(source=<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line">    price = serializers.CharField()</span><br><span class="line">    pub_date = serializers.CharField()</span><br><span class="line">    publish = serializers.CharField(source=<span class="string">&#x27;publish.email&#x27;</span>) <span class="comment"># book.publish.email</span></span><br><span class="line">    <span class="comment"># authors = serializers.CharField()  # app02.Author.None</span></span><br><span class="line"></span><br><span class="line">    authors = serializers.SerializerMethodField() <span class="comment"># 有个配套方法:SerializerMethodField get_字段名，返回值是要显示的东西</span></span><br><span class="line">    <span class="comment"># return  什么返回就是什么</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_authors</span>(<span class="params">self, instance</span>):</span></span><br><span class="line">        <span class="comment"># book对象</span></span><br><span class="line">        authors = instance.authors.all()  <span class="comment"># 取出所有作者对象</span></span><br><span class="line">        ll = []</span><br><span class="line">        <span class="keyword">for</span> author <span class="keyword">in</span> authors:</span><br><span class="line">            ll.append(&#123;<span class="string">&#x27;name&#x27;</span>:author.name, <span class="string">&#x27;age&#x27;</span>:author.age&#125;)</span><br><span class="line">        <span class="keyword">return</span> ll</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># models </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    title=models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    price=models.IntegerField()</span><br><span class="line">    pub_date=models.DateField(null=<span class="literal">True</span>)</span><br><span class="line">    publish=models.ForeignKey(<span class="string">&quot;Publish&quot;</span>,on_delete=models.CASCADE,null=<span class="literal">True</span>)</span><br><span class="line">    authors=models.ManyToManyField(<span class="string">&quot;Author&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.title</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;lqz is big&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## SerializerMethodField</span></span><br><span class="line"><span class="number">1.</span> 需要有个配套方法: get_字段名，返回值是要显示的东西</span><br><span class="line">    </span><br><span class="line">authors = serializers.SerializerMethodField() <span class="comment"># 有个配套方法: get_字段名，返回值是要显示的东西</span></span><br><span class="line"><span class="comment"># return  什么返回就是什么, 需要传个参数insane，就是book对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_authors</span>(<span class="params">self, instance</span>):</span></span><br><span class="line">   <span class="comment"># book对象</span></span><br><span class="line">   authors = instance.authors.all()  <span class="comment"># 取出所有作者对象</span></span><br><span class="line">   ll = []</span><br><span class="line">   <span class="keyword">for</span> author <span class="keyword">in</span> authors:</span><br><span class="line">     ll.append(&#123;<span class="string">&#x27;name&#x27;</span>:author.name, <span class="string">&#x27;age&#x27;</span>:author.age&#125;)</span><br><span class="line">     <span class="keyword">return</span> ll</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># models.py</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    title=models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    price=models.IntegerField()</span><br><span class="line">    pub_date=models.DateField()</span><br><span class="line">    publish=models.ForeignKey(<span class="string">&quot;Publish&quot;</span>,on_delete=models.CASCADE,null=<span class="literal">True</span>)</span><br><span class="line">    authors=models.ManyToManyField(<span class="string">&quot;Author&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.title</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publish</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name=models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    email=models.EmailField()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name=models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    age=models.IntegerField()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"><span class="comment"># ser.py</span></span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> app01.models <span class="keyword">import</span> Book</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookSerializers</span>(<span class="params">serializers.Serializer</span>):</span></span><br><span class="line">    id=serializers.CharField(read_only=<span class="literal">True</span>)</span><br><span class="line">    title=serializers.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    price=serializers.IntegerField()</span><br><span class="line">    pub_date=serializers.DateField()</span><br><span class="line">    <span class="comment"># publish=serializers.CharField(source=&quot;publish.name&quot;,read_only=True)</span></span><br><span class="line">    publish=serializers.CharField(source=<span class="string">&quot;publish.name&quot;</span>,default=<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">    <span class="comment">#authors=serializers.CharField(source=&quot;authors.all&quot;)</span></span><br><span class="line">    authors=serializers.SerializerMethodField(read_only=<span class="literal">True</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_authors</span>(<span class="params">self,obj</span>):</span></span><br><span class="line">        temp=[]</span><br><span class="line">        <span class="keyword">for</span> author <span class="keyword">in</span> obj.authors.all():</span><br><span class="line">            temp.append(author.name)</span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">self, validated_data</span>):</span></span><br><span class="line">        print(validated_data)</span><br><span class="line">        publish_id=validated_data.get(<span class="string">&#x27;publish&#x27;</span>).get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        print(publish_id)</span><br><span class="line">        <span class="keyword">del</span> validated_data[<span class="string">&#x27;publish&#x27;</span>]</span><br><span class="line">        <span class="keyword">return</span> Book.objects.create(publish_id=publish_id,**validated_data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, instance, validated_data</span>):</span></span><br><span class="line">        print(validated_data.get(<span class="string">&#x27;aa&#x27;</span>))</span><br><span class="line">        instance.title = validated_data.get(<span class="string">&#x27;title&#x27;</span>, instance.title)</span><br><span class="line">        instance.price = validated_data.get(<span class="string">&#x27;price&#x27;</span>, instance.price)</span><br><span class="line">        instance.pub_date = validated_data.get(<span class="string">&#x27;pub_date&#x27;</span>, instance.pub_date)</span><br><span class="line">        print(validated_data.get(<span class="string">&#x27;publish&#x27;</span>, instance.publish))</span><br><span class="line">        instance.publish_id = validated_data.get(<span class="string">&#x27;publish&#x27;</span>, instance.publish).get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        instance.save()</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,HttpResponse</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpRequest</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> app01.models <span class="keyword">import</span> Book</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> app01.ser <span class="keyword">import</span> BookSerializers</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookViewSet</span>(<span class="params">APIView</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request,*args,**kwargs</span>):</span></span><br><span class="line">        book_list=Book.objects.all()</span><br><span class="line">        <span class="comment"># 序列化方式3:</span></span><br><span class="line">        bs=BookSerializers(book_list,many=<span class="literal">True</span>)     <span class="comment">#many=True代表有多条数据，如果只有一条数据，many=False</span></span><br><span class="line">        <span class="keyword">return</span> Response(bs.data)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self,request,*args,**kwargs</span>):</span></span><br><span class="line"></span><br><span class="line">        bs=BookSerializers(data=request.data)</span><br><span class="line">        <span class="comment"># 只要验证不通过，直接抛异常，一般不这样写</span></span><br><span class="line">        bs.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># print(bs.validated_data)</span></span><br><span class="line">        bs.save()</span><br><span class="line">        <span class="keyword">return</span> Response(bs.data)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookDetailView</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request,pk</span>):</span></span><br><span class="line">        book_obj=models.Book.objects.filter(pk=pk).first()</span><br><span class="line">        bs=BookSerializers(book_obj,many=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(bs.data)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self,request,pk</span>):</span></span><br><span class="line">        book_obj = models.Book.objects.filter(pk=pk).first()</span><br><span class="line"></span><br><span class="line">        bs=BookSerializers(instance=book_obj,data=request.data,partial=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> bs.is_valid():</span><br><span class="line">            bs.save(aa=<span class="string">&quot;lqz&quot;</span>) <span class="comment"># update</span></span><br><span class="line">            <span class="keyword">return</span> Response(bs.data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(bs.errors)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self,request,pk</span>):</span></span><br><span class="line">        models.Book.objects.filter(pk=pk).delete()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment"># urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,re_path</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">&#x27;books/&#x27;</span>, views.BookViewSet.as_view()),</span><br><span class="line">    re_path(<span class="string">&#x27;books/(?P&lt;pk&gt;\d+)/&#x27;</span>, views.BookDetailView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="1-3-1-3-modelserializer-实现添加外键，添加多对多"><a href="#1-3-1-3-modelserializer-实现添加外键，添加多对多" class="headerlink" title="1.3.1.3 modelserializer 实现添加外键，添加多对多"></a>1.3.1.3 modelserializer 实现添加外键，添加多对多</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 前端传数据</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="string">&quot;publish&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;authors&quot;</span>: [<span class="number">1</span>],</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;阿萨德12&quot;</span>,</span><br><span class="line">    <span class="string">&quot;price&quot;</span>: <span class="string">&quot;55.34&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 序列化类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookSerializer</span>(<span class="params">serializers.ModelSerializer</span>):</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Book</span><br><span class="line">        fields = <span class="string">&#x27;__all__&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># publish = serializers.CharField(source=&#x27;publish.name&#x27;)</span></span><br><span class="line"></span><br><span class="line">        extra_kwargs = &#123;</span><br><span class="line">            <span class="string">&quot;publish&quot;</span>: &#123;<span class="string">&#x27;write_only&#x27;</span>: <span class="literal">True</span>&#125;,</span><br><span class="line">            <span class="string">&quot;authors&quot;</span>: &#123;<span class="string">&#x27;write_only&#x27;</span>: <span class="literal">True</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    publish_name = serializers.CharField(source=<span class="string">&#x27;publish.name&#x27;</span>, read_only=<span class="literal">True</span>)</span><br><span class="line">    authors_name = serializers.SerializerMethodField(source=<span class="string">&#x27;authors&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_authors_name</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">for</span> author <span class="keyword">in</span> obj.authors.all():</span><br><span class="line">            temp.append(author.name)</span><br><span class="line">        <span class="keyword">return</span> temp</span><br></pre></td></tr></table></figure>





<p>注意：</p>
<p>source 如果是字段，会显示字段，如果是方法，会执行方法，不用加括号（authors=serializers.CharField(source=’authors.all’)）</p>
<p>如在模型中定义一个方法，直接可以在在source指定执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    user_type_choices = (</span><br><span class="line">        (<span class="number">1</span>,<span class="string">&#x27;普通用户&#x27;</span>),</span><br><span class="line">        (<span class="number">2</span>,<span class="string">&#x27;VIP&#x27;</span>),</span><br><span class="line">        (<span class="number">3</span>,<span class="string">&#x27;SVIP&#x27;</span>),</span><br><span class="line">    )</span><br><span class="line">    user_type = models.IntegerField(choices=user_type_choices)</span><br><span class="line"></span><br><span class="line">    username = models.CharField(max_length=<span class="number">32</span>,unique=<span class="literal">True</span>)</span><br><span class="line">    password = models.CharField(max_length=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#视图</span></span><br><span class="line">ret=models.UserInfo.objects.filter(pk=<span class="number">1</span>).first()</span><br><span class="line">aa=ret.get_user_type_display()</span><br><span class="line"></span><br><span class="line"><span class="comment">#serializer</span></span><br><span class="line">xx=serializers.CharField(source=<span class="string">&#x27;get_user_type_display&#x27;</span>)</span><br></pre></td></tr></table></figure>





<h3 id="1-3-2-反序列化"><a href="#1-3-2-反序列化" class="headerlink" title="1.3.2 反序列化"></a>1.3.2 反序列化</h3><h4 id="1-3-2-1-数据验证"><a href="#1-3-2-1-数据验证" class="headerlink" title="1.3.2.1 数据验证"></a>1.3.2.1 数据验证</h4><p>使用序列化器进行反序列化时，需要对数据进行验证后，才能获取验证成功的数据或保存成模型类对象。</p>
<p>在获取反序列化的数据前，必须调用**is_valid()**方法进行验证，验证成功返回True，否则返回False。</p>
<p>验证失败，可以通过序列化器对象的<strong>errors</strong>属性获取错误信息，返回字典，包含了字段和字段的错误。如果是非字段错误，可以通过修改REST framework配置中的<strong>NON_FIELD_ERRORS_KEY</strong>来控制错误字典中的键名。</p>
<p>验证成功，可以通过序列化器对象的<strong>validated_data</strong>属性获取数据。</p>
<p>在定义序列化器时，指明每个字段的序列化类型和选项参数，本身就是一种验证行为。</p>
<p>如我们前面定义过的BookInfoSerializer</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoSerializer</span>(<span class="params">serializers.Serializer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span></span><br><span class="line">    id = serializers.IntegerField(label=<span class="string">&#x27;ID&#x27;</span>, read_only=<span class="literal">True</span>)</span><br><span class="line">    btitle = serializers.CharField(label=<span class="string">&#x27;名称&#x27;</span>, max_length=<span class="number">20</span>)</span><br><span class="line">    bpub_date = serializers.DateField(label=<span class="string">&#x27;发布日期&#x27;</span>, required=<span class="literal">False</span>)</span><br><span class="line">    bread = serializers.IntegerField(label=<span class="string">&#x27;阅读量&#x27;</span>, required=<span class="literal">False</span>)</span><br><span class="line">    bcomment = serializers.IntegerField(label=<span class="string">&#x27;评论量&#x27;</span>, required=<span class="literal">False</span>)</span><br><span class="line">    image = serializers.ImageField(label=<span class="string">&#x27;图片&#x27;</span>, required=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>通过构造序列化器对象，并将要反序列化的数据传递给data构造参数，进而进行验证</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> booktest.serializers <span class="keyword">import</span> BookInfoSerializer</span><br><span class="line">    data = &#123;<span class="string">&#x27;bpub_date&#x27;</span>: <span class="number">123</span>&#125;</span><br><span class="line">    serializer = BookInfoSerializer(data=data)</span><br><span class="line">    serializer.is_valid()  <span class="comment"># 返回False</span></span><br><span class="line">    serializer.errors</span><br><span class="line">    <span class="comment"># &#123;&#x27;btitle&#x27;: [ErrorDetail(string=&#x27;This field is required.&#x27;, code=&#x27;required&#x27;)], &#x27;bpub_date&#x27;: [ErrorDetail(string=&#x27;Date has wrong format. Use one of these formats instead: YYYY[-MM[-DD]].&#x27;, code=&#x27;invalid&#x27;)]&#125;</span></span><br><span class="line">    serializer.validated_data  <span class="comment"># &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;btitle&#x27;</span>: <span class="string">&#x27;python&#x27;</span>&#125;</span><br><span class="line">serializer = BookInfoSerializer(data=data)</span><br><span class="line">serializer.is_valid()  <span class="comment"># True</span></span><br><span class="line">serializer.errors  <span class="comment"># &#123;&#125;</span></span><br><span class="line">serializer.validated_data  <span class="comment">#  OrderedDict([(&#x27;btitle&#x27;, &#x27;python&#x27;)])</span></span><br></pre></td></tr></table></figure>

<p>is_valid()方法还可以在验证失败时抛出异常serializers.ValidationError，可以通过传递<strong>raise_exception=True</strong>参数开启，REST framework接收到此异常，会向前端返回HTTP 400 Bad Request响应。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Return a 400 response if the data was invalid.</span><br><span class="line">serializer.is_valid(raise_exception&#x3D;True)</span><br></pre></td></tr></table></figure>

<p>如果觉得这些还不够，需要再补充定义验证行为，可以使用以下三种方法：</p>
<h5 id="1-validate-字段名"><a href="#1-validate-字段名" class="headerlink" title="1) validate_字段名"></a>1) validate_字段名</h5><p>对<code>&lt;field_name&gt;</code>字段进行验证，如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoSerializer</span>(<span class="params">serializers.Serializer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_btitle</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;django&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> value.lower():</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(<span class="string">&quot;图书不是关于Django的&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from booktest.serializers import BookInfoSerializer</span><br><span class="line">data &#x3D; &#123;&#39;btitle&#39;: &#39;python&#39;&#125;</span><br><span class="line">serializer &#x3D; BookInfoSerializer(data&#x3D;data)</span><br><span class="line">serializer.is_valid()  # False   </span><br><span class="line">serializer.errors</span><br><span class="line">#  &#123;&#39;btitle&#39;: [ErrorDetail(string&#x3D;&#39;图书不是关于Django的&#39;, code&#x3D;&#39;invalid&#39;)]&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-validate"><a href="#2-validate" class="headerlink" title="2) validate"></a>2) validate</h5><p>在序列化器中需要同时对多个字段进行比较验证时，可以定义validate方法来验证，如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># attrs表示请求中所有的字段和值，类型为字典;必须校验后返回，源码里面明确写了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoSerializer</span>(<span class="params">serializers.Serializer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span>(<span class="params">self, attrs</span>):</span></span><br><span class="line">        bread = attrs[<span class="string">&#x27;bread&#x27;</span>]</span><br><span class="line">        bcomment = attrs[<span class="string">&#x27;bcomment&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> bread &lt; bcomment:</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(<span class="string">&#x27;阅读量小于评论量&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> attrs</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> booktest.serializers <span class="keyword">import</span> BookInfoSerializer</span><br><span class="line">data = &#123;<span class="string">&#x27;btitle&#x27;</span>: <span class="string">&#x27;about django&#x27;</span>, <span class="string">&#x27;bread&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;bcomment&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line">s = BookInfoSerializer(data=data)</span><br><span class="line">s.is_valid()  <span class="comment"># False</span></span><br><span class="line">s.errors</span><br><span class="line"><span class="comment">#  &#123;&#x27;non_field_errors&#x27;: [ErrorDetail(string=&#x27;阅读量小于评论量&#x27;, code=&#x27;invalid&#x27;)]&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="3-validators"><a href="#3-validators" class="headerlink" title="3) validators"></a>3) validators</h5><p>在字段中添加validators选项参数，也可以补充验证行为，如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">about_django</span>(<span class="params">value</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;django&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> value.lower():</span><br><span class="line">        <span class="keyword">raise</span> serializers.ValidationError(<span class="string">&quot;图书不是关于Django的&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoSerializer</span>(<span class="params">serializers.Serializer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span></span><br><span class="line">    id = serializers.IntegerField(label=<span class="string">&#x27;ID&#x27;</span>, read_only=<span class="literal">True</span>)</span><br><span class="line">    btitle = serializers.CharField(label=<span class="string">&#x27;名称&#x27;</span>, max_length=<span class="number">20</span>, validators=[about_django])</span><br><span class="line">    bpub_date = serializers.DateField(label=<span class="string">&#x27;发布日期&#x27;</span>, required=<span class="literal">False</span>)</span><br><span class="line">    bread = serializers.IntegerField(label=<span class="string">&#x27;阅读量&#x27;</span>, required=<span class="literal">False</span>)</span><br><span class="line">    bcomment = serializers.IntegerField(label=<span class="string">&#x27;评论量&#x27;</span>, required=<span class="literal">False</span>)</span><br><span class="line">    image = serializers.ImageField(label=<span class="string">&#x27;图片&#x27;</span>, required=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> booktest.serializers <span class="keyword">import</span> BookInfoSerializer</span><br><span class="line">data = &#123;<span class="string">&#x27;btitle&#x27;</span>: <span class="string">&#x27;python&#x27;</span>&#125;</span><br><span class="line">serializer = BookInfoSerializer(data=data)</span><br><span class="line">serializer.is_valid()  <span class="comment"># False   </span></span><br><span class="line">serializer.errors</span><br><span class="line"><span class="comment">#  &#123;&#x27;btitle&#x27;: [ErrorDetail(string=&#x27;图书不是关于Django的&#x27;, code=&#x27;invalid&#x27;)]&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-2-反序列化-保存数据"><a href="#1-3-2-2-反序列化-保存数据" class="headerlink" title="1.3.2.2 反序列化-保存数据"></a>1.3.2.2 反序列化-保存数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># # 必须要返回instance的原因是 给序列化的时候用  ser.data 返回的时候才有值</span></span><br></pre></td></tr></table></figure>



<p>前面的验证数据成功后,我们可以使用序列化器来完成数据反序列化的过程.这个过程可以把数据转成模型类对象.</p>
<p>可以通过实现create()和update()两个方法来实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoSerializer</span>(<span class="params">serializers.Serializer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">self, validated_data</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;新建&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> BookInfo(**validated_data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, instance, validated_data</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;更新，instance为要更新的对象实例&quot;&quot;&quot;</span></span><br><span class="line">        instance.btitle = validated_data.get(<span class="string">&#x27;btitle&#x27;</span>, instance.btitle)</span><br><span class="line">        instance.bpub_date = validated_data.get(<span class="string">&#x27;bpub_date&#x27;</span>, instance.bpub_date)</span><br><span class="line">        instance.bread = validated_data.get(<span class="string">&#x27;bread&#x27;</span>, instance.bread)</span><br><span class="line">        instance.bcomment = validated_data.get(<span class="string">&#x27;bcomment&#x27;</span>, instance.bcomment)</span><br><span class="line">        <span class="keyword">return</span> instance</span><br></pre></td></tr></table></figure>

<p>如果需要在返回数据对象的时候，也将数据保存到数据库中，则可以进行如下修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoSerializer</span>(<span class="params">serializers.Serializer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">self, validated_data</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;新建&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> BookInfo.objects.create(**validated_data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, instance, validated_data</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;更新，instance为要更新的对象实例&quot;&quot;&quot;</span></span><br><span class="line">        instance.btitle = validated_data.get(<span class="string">&#x27;btitle&#x27;</span>, instance.btitle)</span><br><span class="line">        instance.bpub_date = validated_data.get(<span class="string">&#x27;bpub_date&#x27;</span>, instance.bpub_date)</span><br><span class="line">        instance.bread = validated_data.get(<span class="string">&#x27;bread&#x27;</span>, instance.bread)</span><br><span class="line">        instance.bcomment = validated_data.get(<span class="string">&#x27;bcomment&#x27;</span>, instance.bcomment)</span><br><span class="line">        instance.save()</span><br><span class="line">        <span class="keyword">return</span> instance</span><br></pre></td></tr></table></figure>

<p>实现了上述两个方法后，在反序列化数据的时候，就可以通过save()方法返回一个数据对象实例了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">book &#x3D; serializer.save()</span><br></pre></td></tr></table></figure>

<p>如果创建序列化器对象的时候，没有传递instance实例，则调用save()方法的时候，create()被调用，相反，如果传递了instance实例，则调用save()方法的时候，update()被调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from db.serializers import BookInfoSerializer</span><br><span class="line">data &#x3D; &#123;&#39;btitle&#39;: &#39;封神演义&#39;&#125;</span><br><span class="line">serializer &#x3D; BookInfoSerializer(data&#x3D;data)</span><br><span class="line">serializer.is_valid()  # True</span><br><span class="line">serializer.save()  # &lt;BookInfo: 封神演义&gt;</span><br><span class="line"></span><br><span class="line">from db.models import BookInfo</span><br><span class="line">book &#x3D; BookInfo.objects.get(id&#x3D;2)</span><br><span class="line">data &#x3D; &#123;&#39;btitle&#39;: &#39;倚天剑&#39;&#125;</span><br><span class="line">serializer &#x3D; BookInfoSerializer(book, data&#x3D;data)</span><br><span class="line">serializer.is_valid()  # True</span><br><span class="line">serializer.save()  # &lt;BookInfo: 倚天剑&gt;</span><br><span class="line">book.btitle  # &#39;倚天剑&#39;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-3-附加说明"><a href="#1-3-2-3-附加说明" class="headerlink" title="1.3.2.3 附加说明"></a>1.3.2.3 附加说明</h4><p>1） 在对序列化器进行save()保存时，可以额外传递数据，这些数据可以在create()和update()中的validated_data参数获取到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># request.user 是django中记录当前登录用户的模型对象</span><br><span class="line">serializer.save(owner&#x3D;request.user)</span><br></pre></td></tr></table></figure>

<p>2）默认序列化器必须传递所有required的字段，否则会抛出验证异常。但是我们可以使用partial参数来允许部分字段更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Update &#96;comment&#96; with partial data</span><br><span class="line">serializer &#x3D; CommentSerializer(comment, data&#x3D;&#123;&#39;content&#39;: u&#39;foo bar&#39;&#125;, partial&#x3D;True)</span><br></pre></td></tr></table></figure>

<h3 id="1-3-3-模型类序列化器"><a href="#1-3-3-模型类序列化器" class="headerlink" title="1.3.3 模型类序列化器"></a>1.3.3 模型类序列化器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.字段是通过表模型映射过来的</span><br><span class="line">2.可以重写字段</span><br><span class="line">3.可以扩写字段（表模型中没有的字段）</span><br><span class="line">4.反序列化时，字段自己的校验规则，映射了表模型的</span><br><span class="line">5.局部钩子和全局钩子完全一样</span><br><span class="line">6.  wirte_only和read_only</span><br><span class="line">    # 反序列化时候使用，  序列化时候不用</span><br><span class="line">    # name&#x3D;serializers.CharField(write_only&#x3D;True)</span><br><span class="line"></span><br><span class="line">    # 序列化的时候使用，反序列化不用</span><br><span class="line">    # name&#x3D;serializers.CharField(read_only&#x3D;True)</span><br><span class="line">7.extra_kwargs</span><br><span class="line">        # 额外给字段传递参数，类似于</span><br><span class="line">        # name &#x3D; serializers.CharField(write_only&#x3D;True,&#39;max_length&#39;:8)</span><br><span class="line">        extra_kwargs&#x3D;&#123;&#39;name&#39;:&#123;&#39;write_only&#39;:True,&#39;max_length&#39;:8&#125;&#125;</span><br></pre></td></tr></table></figure>



<p>如果我们想要使用序列化器对应的是Django的模型类，DRF为我们提供了ModelSerializer模型类序列化器来帮助我们快速创建一个Serializer类。</p>
<p>ModelSerializer与常规的Serializer相同，但提供了：</p>
<ul>
<li>基于模型类自动生成一系列字段</li>
<li>基于模型类自动为Serializer生成validators，比如unique_together</li>
<li>包含默认的create()和update()的实现</li>
</ul>
<h4 id="1-3-3-1-定义"><a href="#1-3-3-1-定义" class="headerlink" title="1.3.3.1 定义"></a>1.3.3.1 定义</h4><p>比如我们创建一个BookInfoSerializer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BookInfoSerializer(serializers.ModelSerializer):</span><br><span class="line">    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; BookInfo</span><br><span class="line">        fields &#x3D; &#39;__all__&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li>model 指明参照哪个模型类</li>
<li>fields 指明为模型类的哪些字段生成</li>
</ul>
<p>我们可以在python manage.py shell中查看自动生成的BookInfoSerializer的具体实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from booktest.serializers import BookInfoSerializer</span><br><span class="line">&gt;&gt;&gt; serializer &#x3D; BookInfoSerializer()</span><br><span class="line">&gt;&gt;&gt; serializer</span><br><span class="line">BookInfoSerializer():</span><br><span class="line">    id &#x3D; IntegerField(label&#x3D;&#39;ID&#39;, read_only&#x3D;True)</span><br><span class="line">    btitle &#x3D; CharField(label&#x3D;&#39;名称&#39;, max_length&#x3D;20)</span><br><span class="line">    bpub_date &#x3D; DateField(allow_null&#x3D;True, label&#x3D;&#39;发布日期&#39;, required&#x3D;False)</span><br><span class="line">    bread &#x3D; IntegerField(label&#x3D;&#39;阅读量&#39;, max_value&#x3D;2147483647, min_value&#x3D;-2147483648, required&#x3D;False)</span><br><span class="line">    bcomment &#x3D; IntegerField(label&#x3D;&#39;评论量&#39;, max_value&#x3D;2147483647, min_value&#x3D;-2147483648, required&#x3D;False)</span><br><span class="line">    image &#x3D; ImageField(allow_null&#x3D;True, label&#x3D;&#39;图片&#39;, max_length&#x3D;100, required&#x3D;False)</span><br></pre></td></tr></table></figure>

<h4 id="1-3-3-2-指定字段"><a href="#1-3-3-2-指定字段" class="headerlink" title="1.3.3.2 指定字段"></a>1.3.3.2 指定字段</h4><ol>
<li>使用<strong>fields</strong>来明确字段，<code>__all__</code>表名包含所有字段，也可以写明具体哪些字段，如</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BookInfoSerializer(serializers.ModelSerializer):</span><br><span class="line">    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; BookInfo</span><br><span class="line">        fields &#x3D; (&#39;id&#39;, &#39;btitle&#39;, &#39;bpub_date&#39;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用<strong>exclude</strong>可以明确排除掉哪些字段</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BookInfoSerializer(serializers.ModelSerializer):</span><br><span class="line">    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; BookInfo</span><br><span class="line">        exclude &#x3D; (&#39;image&#39;,)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>显示指明字段，如：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class HeroInfoSerializer(serializers.ModelSerializer):</span><br><span class="line">    hbook &#x3D; BookInfoSerializer()</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; HeroInfo</span><br><span class="line">        fields &#x3D; (&#39;id&#39;, &#39;hname&#39;, &#39;hgender&#39;, &#39;hcomment&#39;, &#39;hbook&#39;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>指明只读字段</li>
</ol>
<p>可以通过<strong>read_only_fields</strong>指明只读字段，即仅用于序列化输出的字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BookInfoSerializer(serializers.ModelSerializer):</span><br><span class="line">    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; BookInfo</span><br><span class="line">        fields &#x3D; (&#39;id&#39;, &#39;btitle&#39;, &#39;bpub_date&#39;， &#39;bread&#39;, &#39;bcomment&#39;)</span><br><span class="line">        read_only_fields &#x3D; (&#39;id&#39;, &#39;bread&#39;, &#39;bcomment&#39;)</span><br></pre></td></tr></table></figure>

<h4 id="1-3-3-3-添加额外参数选项"><a href="#1-3-3-3-添加额外参数选项" class="headerlink" title="1.3.3.3 添加额外参数选项"></a>1.3.3.3 添加额外参数选项</h4><p>我们可以使用<strong>extra_kwargs</strong>参数为ModelSerializer添加或修改原有的选项参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BookInfoSerializer(serializers.ModelSerializer):</span><br><span class="line">    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; BookInfo</span><br><span class="line">        fields &#x3D; (&#39;id&#39;, &#39;btitle&#39;, &#39;bpub_date&#39;, &#39;bread&#39;, &#39;bcomment&#39;)</span><br><span class="line">        extra_kwargs &#x3D; &#123;</span><br><span class="line">            &#39;bread&#39;: &#123;&#39;min_value&#39;: 0, &#39;required&#39;: True&#125;,</span><br><span class="line">            &#39;bcomment&#39;: &#123;&#39;min_value&#39;: 0, &#39;required&#39;: True&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"># BookInfoSerializer():</span><br><span class="line">#    id &#x3D; IntegerField(label&#x3D;&#39;ID&#39;, read_only&#x3D;True)</span><br><span class="line">#    btitle &#x3D; CharField(label&#x3D;&#39;名称&#39;, max_length&#x3D;20)</span><br><span class="line">#    bpub_date &#x3D; DateField(allow_null&#x3D;True, label&#x3D;&#39;发布日期&#39;, required&#x3D;False)</span><br><span class="line">#    bread &#x3D; IntegerField(label&#x3D;&#39;阅读量&#39;, max_value&#x3D;2147483647, min_value&#x3D;0, required&#x3D;True)</span><br><span class="line">#    bcomment &#x3D; IntegerField(label&#x3D;&#39;评论量&#39;, max_value&#x3D;2147483647, min_value&#x3D;0, required&#x3D;True)</span><br></pre></td></tr></table></figure>

<h4 id="1-3-3-4-直接指定模型类中的方法"><a href="#1-3-3-4-直接指定模型类中的方法" class="headerlink" title="1.3.3.4 直接指定模型类中的方法"></a>1.3.3.4 直接指定模型类中的方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoSerializer</span>(<span class="params">serializers.ModelSerializer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = BookInfo</span><br><span class="line">        fields = (<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;pub_date&#x27;</span>, <span class="string">&#x27;read&#x27;</span>, <span class="string">&#x27;comment&#x27;</span>, <span class="string">&#x27;publish_name&#x27;</span>)</span><br><span class="line"></span><br><span class="line">publish_name 就是定义在models中的方法</span><br><span class="line"></span><br><span class="line">Book models 中</span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">publish_name</span>(<span class="params">self</span>)</span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">self</span>.<span class="title">publish</span>.<span class="title">name</span></span></span><br></pre></td></tr></table></figure>





<h2 id="1-4-局部全局校验源码分析"><a href="#1-4-局部全局校验源码分析" class="headerlink" title="1.4 局部全局校验源码分析"></a>1.4 局部全局校验源码分析</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#is_valid----&gt;self.run_validation-(执行Serializer的run_validation)--&gt;self.to_internal_value(data)---（执行Serializer的run_validation：485行）</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gghkhucudgj315w0rmqv5.jpg" alt="image-20200706212122698"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gghkj4qalrj31yg0qo1kz.jpg" alt="image-20200706212239321"></p>
<h2 id="1-5-序列化组件源码分析many-true"><a href="#1-5-序列化组件源码分析many-true" class="headerlink" title="1.5 序列化组件源码分析many=true"></a>1.5 序列化组件源码分析many=true</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对象的生成，--&gt; 先调用类的__new__方法，生成空对象。</span><br><span class="line">对象--&gt; 类名（）加括号，触发类的__init__()</span><br><span class="line">类的__new__ 方法控制对象的生成</span><br><span class="line"></span><br><span class="line">序列化组件，先调用__new__方法，生成空对象。如果many&#x3D;True，生成ListSerializer对象，如果为False，生成Serializer对象</span><br><span class="line">序列化对象.data方法--调用父类data方法---调用对象自己的to_representation（自定义的序列化类无此方法，去父类找）</span><br><span class="line">Aerializer类里有to_representation方法，for循环执行attribute &#x3D; field.get_attribute(instance)</span><br><span class="line">再去Field类里去找get_attribute方法，self.source_attrs就是被切分的source，然后执行get_attribute方法，source_attrs</span><br><span class="line">当参数传过去，判断是方法就加括号执行，是属性就把值取出来</span><br></pre></td></tr></table></figure>





<h2 id="1-6-重写ChoiceField，支持选项参数或者value提交请求操作数据"><a href="#1-6-重写ChoiceField，支持选项参数或者value提交请求操作数据" class="headerlink" title="1.6 重写ChoiceField，支持选项参数或者value提交请求操作数据"></a>1.6 重写ChoiceField，支持选项参数或者value提交请求操作数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 重写ChoiceField</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChoiceField</span>(<span class="params">serializers.ChoiceField</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;重写ChoiceField&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_representation</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回状态名称&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> obj == <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> self.allow_blank:</span><br><span class="line">            <span class="keyword">return</span> obj</span><br><span class="line">        <span class="keyword">return</span> self._choices[obj]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_internal_value</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;支持choice的key 或value名称的写入&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self._choices:</span><br><span class="line">            <span class="comment"># 这样无论用户POST上来但是CHOICES的 Key 还是Value 都能被接受</span></span><br><span class="line">            <span class="keyword">if</span> i == data <span class="keyword">or</span> self._choices[i] == data:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">raise</span> serializers.ValidationError(<span class="string">&quot;Acceptable values are &#123;0&#125;.&quot;</span>.format(list(self._choices.values())))</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment"># serializer类中写</span></span><br><span class="line">goods_status = ChoiceField(choices=(</span><br><span class="line">                                        (<span class="number">0</span>, <span class="string">&#x27;下架&#x27;</span>),</span><br><span class="line">                                        (<span class="number">1</span>, <span class="string">&#x27;出售中&#x27;</span>)</span><br><span class="line">                                       ),</span><br><span class="line">                                required=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 可以支持 0 1 传值修改创建数据，也支持下架，出售中 修改数据。</span></span><br><span class="line"><span class="comment">### 同时支持 不允许操作其他选项 比如2 3 4 </span></span><br></pre></td></tr></table></figure>

<p>引用博客地址：</p>
<p><a href="https://www.cnblogs.com/yoyoketang/p/14347488.html">https://www.cnblogs.com/yoyoketang/p/14347488.html</a></p>
<h2 id="1-7-原生django-封装request-POST和body数据到request-data"><a href="#1-7-原生django-封装request-POST和body数据到request-data" class="headerlink" title="1.7 原生django 封装request.POST和body数据到request.data"></a>1.7 原生django 封装request.POST和body数据到request.data</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 装饰器</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transferdata</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">          res = json.loads(request.body)</span><br><span class="line">          request.data = res</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">          request.data = request.POST</span><br><span class="line">        res = func(request, *args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="1-to-internal-value-反序列化-和to-representation-序列化"><a href="#1-to-internal-value-反序列化-和to-representation-序列化" class="headerlink" title="1. to_internal_value(反序列化)和to_representation(序列化)"></a>1. to_internal_value(反序列化)和to_representation(序列化)</h2><blockquote>
<p>一般当前模型里面没有这个属性的时候，用to_representation处理一下序列化返回</p>
</blockquote>
<p>ser.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> idcs.serializers <span class="keyword">import</span> IdcSerializer</span><br><span class="line"><span class="keyword">from</span> idcs.models <span class="keyword">import</span> IDC</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Cabinet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CabinetSerializer</span>(<span class="params">serializers.Serializer</span>):</span></span><br><span class="line">    idc = serializers.PrimaryKeyRelatedField(many=<span class="literal">False</span>, queryset=IDC.objects.all())</span><br><span class="line">    name = serializers.CharField(required=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_representation</span>(<span class="params">self, instance</span>):</span></span><br><span class="line">        idc_obj = instance.idc</span><br><span class="line">        ret = super(CabinetSerializer, self).to_representation(instance)</span><br><span class="line">        ret[<span class="string">&quot;idc&quot;</span>] = &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: idc_obj.id,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: idc_obj.name</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_internal_value</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        反序列化第一步: 拿到提交过来的原始数据：QueryDict ==&gt; request.GET request.POST</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        print(data)</span><br><span class="line">        <span class="keyword">return</span> super(CabinetSerializer, self).to_internal_value(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">self, validated_data</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> serializers.ValidationError(<span class="string">&quot;create error&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> Cabinet.objects.create(**validated_data)</span><br></pre></td></tr></table></figure>

<p>Views.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ModelViewSet</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Cabinet</span><br><span class="line"><span class="keyword">from</span> cabinet.serializer <span class="keyword">import</span> CabinetSerializer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CabinetModelViewSet</span>(<span class="params">ModelViewSet</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    retrieve:</span></span><br><span class="line"><span class="string">        返回指定机柜信息</span></span><br><span class="line"><span class="string">    list:</span></span><br><span class="line"><span class="string">        返回机柜列表</span></span><br><span class="line"><span class="string">    update:</span></span><br><span class="line"><span class="string">        更新机柜信息</span></span><br><span class="line"><span class="string">    destroy:</span></span><br><span class="line"><span class="string">        删除机柜记录</span></span><br><span class="line"><span class="string">    create:</span></span><br><span class="line"><span class="string">        创建机柜C记录</span></span><br><span class="line"><span class="string">    partial_update:</span></span><br><span class="line"><span class="string">        更新部分字段</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    queryset = Cabinet.objects.all()</span><br><span class="line">    serializer_class = CabinetSerializer</span><br></pre></td></tr></table></figure>

<p>序列化过程： Serializer类–&gt; to_reporesentation</p>
<p>反序列化过程: web提交数据–&gt; request.GET BODY, POST –&gt; to_internal_value —&gt; field字段验证 –&gt; 局部钩子validate_字段–&gt;validate全局验证(整条数据业务逻辑关系验证)–&gt;action(create,update)</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20220105063105146.png" alt="image-20220105063105146"></p>
<h3 id="2-PrimaryKeyRealatedField"><a href="#2-PrimaryKeyRealatedField" class="headerlink" title="2.PrimaryKeyRealatedField"></a>2.PrimaryKeyRealatedField</h3><p>理解：pkfield </p>
<p>主键关联的字段，反序列化的时候也没问题，传id即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CabinetSerializer(serializers.Serializer):</span><br><span class="line">    idc &#x3D; serializers.PrimaryKeyRelatedField(many&#x3D;False, queryset&#x3D;IDC.objects.all())</span><br><span class="line">    idc &#x3D; serializers.SerializerMethodField()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>DRF</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>DRF-06-认证权限频率</title>
    <url>/posts/11207.html</url>
    <content><![CDATA[<p>认证权限频率</p>
<a id="more"></a>

<h1 id="0-1-认证类的写法"><a href="#0-1-认证类的写法" class="headerlink" title="0.1 认证类的写法"></a>0.1 认证类的写法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 认证的实现</span></span><br><span class="line">  <span class="number">1.</span> 写一个类，继承BaseAuthentication，重写 authenticate(self, request):</span><br><span class="line">        <span class="comment"># 认证逻辑，如果认真通过，返回两个值，一个值最终给了request.user, </span></span><br><span class="line">        <span class="comment"># 如果认证失败，抛出AuthenticationFailed(继承APIException)异常                                                                                                                                                                                                                                                                                               </span></span><br><span class="line">  <span class="number">2.</span> 如果认证通过后不赋值任何信息， 直接<span class="keyword">return</span> <span class="literal">None</span>即可</span><br><span class="line">  <span class="number">3.</span> 使用</span><br><span class="line">  (<span class="number">1</span>)全局使用 </span><br><span class="line">  <span class="comment"># 全局使用，在settings.py中配置</span></span><br><span class="line">  REST_FRAMEWORK = &#123;</span><br><span class="line">      <span class="string">&quot;DEFAULT_AUTHENTICATION_CLASSES&quot;</span>:[<span class="string">&quot;app01.app_auth.MyAuthentication&quot;</span>],</span><br><span class="line">  &#125;</span><br><span class="line">  (<span class="number">2</span>)局部使用</span><br><span class="line">  authentication_classes = [MyAuthentication]</span><br><span class="line">  (<span class="number">3</span>)局部禁用</span><br><span class="line">  authentication_classes = []</span><br></pre></td></tr></table></figure>

<h1 id="0-2-认证的源码分析"><a href="#0-2-认证的源码分析" class="headerlink" title="0.2 认证的源码分析"></a>0.2 认证的源码分析</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># APIView ---&gt; disapatch方法 --&gt; self.initial(request, *args, **kwargs) --&gt; 有认证，权限，频率；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">######################## 认证源码 ########################</span></span><br><span class="line">1. diaptach--&gt;self.initial --&gt; self.perform_authentication(request) # 就一句话 </span><br><span class="line">2. ---&gt; request.user # 就需要去Request类中找user方法</span><br><span class="line">3. ---&gt; Request类中的user方法 ,刚开始来，判断没有_user属性, 走self._authenticate()</span><br><span class="line">4. ---&gt; 核心，就是 Request类的 def  _authenticate(self):</span><br><span class="line">  ----&gt; for  self.authticaors 是在视图类views中配置的一个个的认证类: authentication_class = [认证类1, 认证类2]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_authenticate</span>(<span class="params">self</span>):</span></span><br><span class="line">  <span class="comment"># 遍历拿到一个个(认证器)认证类的对象, 进行认证</span></span><br><span class="line">  <span class="comment"># self.authticaors配置的一堆认证类产生的认证类对象组成的 list</span></span><br><span class="line">  <span class="keyword">for</span> authenticator <span class="keyword">in</span> self.authenticators:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      <span class="comment"># 认证器(对象)调用认证方法authenticate(认证类对象self, request请求对象)</span></span><br><span class="line">      <span class="comment"># 返回值: 登录的用户与认证的信息组成的 tuple</span></span><br><span class="line">      <span class="comment"># 该方法被try包裹，代表该方法会抛异常，抛异常就代表认证失败</span></span><br><span class="line">      user_auth_tuple = authenticator.authenticate(self)</span><br><span class="line">      <span class="keyword">except</span> exceptions.APIException:</span><br><span class="line">        self._not_authenticated()</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">        <span class="comment"># 返回值处理</span></span><br><span class="line">        <span class="keyword">if</span> user_auth_tuple <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">          self._authenticator = authenticator</span><br><span class="line">          <span class="comment"># 如何有返回值，就将 登录用户 与 登录认证 分别保存到 request.user request.auth</span></span><br><span class="line">          self.user, self.auth = user_auth_tuple</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 如果返回值user_auth_tuple为空，代表认证通过，但是没有登录用户与登录认证信息，代表游客</span></span><br><span class="line">        self._not_authenticated()</span><br><span class="line">        </span><br><span class="line"><span class="comment">###########_authenticate 中的 authenticators 是 在Request类__init__初始化时 传进来的---&gt; 什么时候初始化的 --&gt; APIView 中 disapatch 包装的时候 ——&gt; self.initialize_request(request, *args, **kwargs)--&gt; </span></span><br><span class="line"><span class="comment"># 返回一个request对象</span></span><br><span class="line">        <span class="keyword">return</span> Request(</span><br><span class="line">            request, <span class="comment"># 原生的request</span></span><br><span class="line">            parsers=self.get_parsers(),</span><br><span class="line">----&gt;       authenticators=self.get_authenticators(), # 就是一个列表放了类的对象，被传到了</span><br><span class="line">            negotiator=self.get_content_negotiator(),</span><br><span class="line">            parser_context=parser_context</span><br><span class="line">        )</span><br><span class="line">----&gt;APIView 中 get_authenticators 方法 ---&gt;  return [auth() for auth in self.authentication_classes]  ---&gt; authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES</span><br><span class="line"></span><br><span class="line">上面的 [auth() <span class="keyword">for</span> auth <span class="keyword">in</span> self.authentication_classes] </span><br><span class="line"><span class="comment"># 列表中是一堆对象，对象是: 视图类中配置的 authentication_classes = [类名] </span></span><br><span class="line"><span class="comment">## ---&gt; 这些对象返回到了 上面 APIView 的 return Request当中(上面)</span></span><br><span class="line"><span class="comment">## ---&gt; 然后被传到了 Request类__init__ ， 然后传到了 Request类 中二次封装  self.authenticators = authenticators or ()  ---&gt; 然后拿到了authenticators 就回到了最核心的上面的for循环了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="0-3-认证组件的使用-有需要注意事项"><a href="#0-3-认证组件的使用-有需要注意事项" class="headerlink" title="0.3 认证组件的使用(有需要注意事项)"></a>0.3 认证组件的使用(有需要注意事项)</h1><p> – 需要注意: 如果配置多个认证类，要把返回两个值的放到最后，否则不执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写一个认证类, 继承BaseAuthentication，重写drf authenticate(self, request), 校验成功返回两个值，一个是user对象，第二个是token；</span></span><br><span class="line">   -- 需要注意: 如果配置多个认证类，要把返回两个值的放到最后，否则不执行</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework.authentication <span class="keyword">import</span> BaseAuthentication</span><br><span class="line"><span class="keyword">from</span> rest_framework.exceptions <span class="keyword">import</span> AuthenticationFailed</span><br><span class="line"><span class="keyword">from</span> app01.models <span class="keyword">import</span> UserToken</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAuthentication</span>(<span class="params">BaseAuthentication</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="comment"># 认证逻辑，如果认真通过，返回两个值</span></span><br><span class="line">        <span class="comment"># 如果认证失败，抛出AuthenticationFailed异常</span></span><br><span class="line">        token = request.GET.get(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> token:</span><br><span class="line">            user_token = UserToken.objects.filter(token=token).first()</span><br><span class="line">            <span class="comment"># 认证通过</span></span><br><span class="line">            <span class="keyword">if</span> user_token:</span><br><span class="line">                <span class="keyword">return</span> user_token.user, token</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> AuthenticationFailed(<span class="string">&#x27;认证失败&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> AuthenticationFailed(<span class="string">&#x27;请求地址需要携带token&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"><span class="comment"># 可以有多个认证，从左至右依次执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局使用，在settings.py中配置</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&quot;DEFAULT_AUTHENTICATION_CLASSES&quot;</span>:[<span class="string">&quot;app01.app_auth.MyAuthentication&quot;</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 局部使用（在视图类上写）</span></span><br><span class="line">authentication_classes = [MyAuthentication]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 局部禁用认证</span></span><br><span class="line">authentication_classes = []</span><br></pre></td></tr></table></figure>



<p>为了方便接下来的学习，我们创建一个新的子应用 opt</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py startapp opt</span><br></pre></td></tr></table></figure>

<p>因为接下来的功能中需要使用到登陆功能，所以我们使用django内置admin站点并创建一个管理员.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python3 manage.py makemigrations</span><br><span class="line">python3 manage.py migrate</span><br><span class="line">python3 manage.py createsuperuser</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggipou4rkjj30ry059772.jpg" alt="1557276390641"></p>
<p>创建管理员以后，访问admin站点，先修改站点的语言配置</p>
<p>settings.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LANGUAGE_CODE = <span class="string">&#x27;zh-hans&#x27;</span>   <span class="comment"># 中文</span></span><br><span class="line"></span><br><span class="line">TIME_ZONE = <span class="string">&#x27;Asia/Shanghai&#x27;</span> <span class="comment"># 时区是亚洲上海</span></span><br><span class="line"></span><br><span class="line">USE_I18N = <span class="literal">True</span> <span class="comment"># 国际化</span></span><br><span class="line"></span><br><span class="line">USE_L10N = <span class="literal">True</span> <span class="comment"># 本地化</span></span><br><span class="line"></span><br><span class="line">USE_TZ = <span class="literal">False</span>  <span class="comment"># 不使用默认的UTC时间，使用TIME_ZONE指定的上海UTC时间</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggipoy3fdhj30nh05rq3a.jpg" alt="1553043081445"></p>
<p>访问admin 站点效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggipp0vaa8j311y0awjs4.jpg" alt="1553043054133"></p>
<h1 id="一-认证Authentication"><a href="#一-认证Authentication" class="headerlink" title="一 认证Authentication"></a>一 认证Authentication</h1><h2 id="1-1-自定义认证方案"><a href="#1-1-自定义认证方案" class="headerlink" title="1.1 自定义认证方案"></a>1.1 自定义认证方案</h2><h3 id="1-1-1-编写models"><a href="#1-1-1-编写models" class="headerlink" title="1.1.1 编写models"></a>1.1.1 编写models</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># models.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    username=models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    password=models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    user_type=models.IntegerField(choices=((<span class="number">1</span>,<span class="string">&#x27;超级用户&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;普通用户&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;二笔用户&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserToken</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    user=models.OneToOneField(to=<span class="string">&#x27;User&#x27;</span>)</span><br><span class="line">    token=models.CharField(max_length=<span class="number">64</span>)</span><br></pre></td></tr></table></figure>

<h3 id="1-1-2-新建认证类"><a href="#1-1-2-新建认证类" class="headerlink" title="1.1.2 新建认证类"></a>1.1.2 新建认证类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.authentication <span class="keyword">import</span> BaseAuthentication</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TokenAuth</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        token = request.GET.get(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">        token_obj = models.UserToken.objects.filter(token=token).first()</span><br><span class="line">        <span class="keyword">if</span> token_obj:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> AuthenticationFailed(<span class="string">&#x27;认证失败&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate_header</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h3 id="1-1-3-编写视图"><a href="#1-1-3-编写视图" class="headerlink" title="1.1.3 编写视图"></a>1.1.3 编写视图</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_random</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">import</span> hashlib</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    md=hashlib.md5()</span><br><span class="line">    md.update(bytes(str(time.time()),encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    md.update(bytes(name,encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> md.hexdigest()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self,reuquest</span>):</span></span><br><span class="line">        back_msg=&#123;<span class="string">&#x27;status&#x27;</span>:<span class="number">1001</span>,<span class="string">&#x27;msg&#x27;</span>:<span class="literal">None</span>&#125;</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            name=reuquest.data.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">            pwd=reuquest.data.get(<span class="string">&#x27;pwd&#x27;</span>)</span><br><span class="line">            user=models.User.objects.filter(username=name,password=pwd).first()</span><br><span class="line">            <span class="keyword">if</span> user:</span><br><span class="line">                token=get_random(name)</span><br><span class="line">                models.UserToken.objects.update_or_create(user=user,defaults=&#123;<span class="string">&#x27;token&#x27;</span>:token&#125;)</span><br><span class="line">                back_msg[<span class="string">&#x27;status&#x27;</span>]=<span class="string">&#x27;1000&#x27;</span></span><br><span class="line">                back_msg[<span class="string">&#x27;msg&#x27;</span>]=<span class="string">&#x27;登录成功&#x27;</span></span><br><span class="line">                back_msg[<span class="string">&#x27;token&#x27;</span>]=token</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                back_msg[<span class="string">&#x27;msg&#x27;</span>] = <span class="string">&#x27;用户名或密码错误&#x27;</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            back_msg[<span class="string">&#x27;msg&#x27;</span>]=str(e)</span><br><span class="line">        <span class="keyword">return</span> Response(back_msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Course</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    authentication_classes = [TokenAuth, ]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;post&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="1-1-4-全局使用"><a href="#1-1-4-全局使用" class="headerlink" title="1.1.4 全局使用"></a>1.1.4 全局使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK=&#123;</span><br><span class="line">    <span class="string">&quot;DEFAULT_AUTHENTICATION_CLASSES&quot;</span>:[<span class="string">&quot;app01.service.auth.Authentication&quot;</span>,]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-5-局部使用"><a href="#1-1-5-局部使用" class="headerlink" title="1.1.5 局部使用"></a>1.1.5 局部使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#局部使用，只需要在视图类里加入：</span></span><br><span class="line">authentication_classes = [TokenAuth, ]</span><br></pre></td></tr></table></figure>

<h2 id="1-2-内置认证方案-需要配合权限使用"><a href="#1-2-内置认证方案-需要配合权限使用" class="headerlink" title="1.2 内置认证方案(需要配合权限使用)"></a>1.2 内置认证方案(需要配合权限使用)</h2><p>可以在配置文件中配置全局默认的认证方案</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;</span>: (</span><br><span class="line">        <span class="string">&#x27;rest_framework.authentication.SessionAuthentication&#x27;</span>,  <span class="comment"># session认证</span></span><br><span class="line">        <span class="string">&#x27;rest_framework.authentication.BasicAuthentication&#x27;</span>,   <span class="comment"># 基本认证</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以在每个视图中通过设置authentication_classess属性来设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.authentication <span class="keyword">import</span> SessionAuthentication, BasicAuthentication</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleView</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="comment"># 类属性</span></span><br><span class="line">    authentication_classes = [SessionAuthentication, BasicAuthentication]</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>认证失败会有两种可能的返回值：</p>
<ul>
<li>401 Unauthorized 未认证</li>
<li>403 Permission Denied 权限被禁止</li>
</ul>
<h1 id="二-权限Permissions"><a href="#二-权限Permissions" class="headerlink" title="二 权限Permissions"></a>二 权限Permissions</h1><p><font color=red><strong>权限要和认证联合用 才起作用</strong></font></p>
<p>权限控制可以限制用户对于视图的访问和对于具体数据对象的访问。</p>
<ul>
<li>在执行视图的dispatch()方法前，会先进行视图访问权限的判断</li>
<li>在通过get_object()获取具体对象时，会进行模型对象访问权限的判断</li>
</ul>
<h2 id="2-1-自定义权限"><a href="#2-1-自定义权限" class="headerlink" title="2.1 自定义权限"></a>2.1 自定义权限</h2><h3 id="2-1-1-编写权限类"><a href="#2-1-1-编写权限类" class="headerlink" title="2.1.1 编写权限类"></a>2.1.1 编写权限类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 限制只有超级用户能访问</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> BasePermission</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPermission</span>(<span class="params">BasePermission</span>):</span></span><br><span class="line">    message = <span class="string">&#x27;不是超级用户，查看不了&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_permission</span>(<span class="params">self, request, view</span>):</span></span><br><span class="line">        <span class="comment"># user_type = request.user.get_user_type_display()</span></span><br><span class="line">        <span class="comment"># if user_type == &#x27;超级用户&#x27;:</span></span><br><span class="line">        <span class="comment"># 权限在认证之后，所以能取到user</span></span><br><span class="line">        user_type = request.user.user_type</span><br><span class="line">        print(user_type)</span><br><span class="line">        <span class="keyword">if</span> user_type == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-全局使用"><a href="#2-1-2-全局使用" class="headerlink" title="2.1.2 全局使用"></a>2.1.2 全局使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK=&#123;</span><br><span class="line">    <span class="string">&quot;DEFAULT_AUTHENTICATION_CLASSES&quot;</span>:[<span class="string">&quot;app01.service.auth.Authentication&quot;</span>,],</span><br><span class="line">    <span class="string">&quot;DEFAULT_PERMISSION_CLASSES&quot;</span>:[<span class="string">&quot;app01.service.permissions.SVIPPermission&quot;</span>,]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-3-局部使用"><a href="#2-1-3-局部使用" class="headerlink" title="2.1.3 局部使用"></a>2.1.3 局部使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 局部使用只需要在视图类里加入：</span></span><br><span class="line">permission_classes = [UserPermission,]</span><br></pre></td></tr></table></figure>

<h3 id="2-1-4-说明"><a href="#2-1-4-说明" class="headerlink" title="2.1.4 说明"></a>2.1.4 说明</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">如需自定义权限，需继承rest_framework.permissions.BasePermission父类，并实现以下两个任何一个方法或全部</span><br><span class="line">- `.has_permission(self, request, view)`</span><br><span class="line">  是否可以访问视图， view表示当前视图对象</span><br><span class="line"></span><br><span class="line">- `.has_object_permission(self, request, view, obj)`</span><br><span class="line">  是否可以访问数据对象， view表示当前视图， obj为数据对象</span><br></pre></td></tr></table></figure>

<h2 id="2-2-内置权限"><a href="#2-2-内置权限" class="headerlink" title="2.2 内置权限"></a>2.2 内置权限</h2><h3 id="2-2-1-内置权限类"><a href="#2-2-1-内置权限类" class="headerlink" title="2.2.1 内置权限类"></a>2.2.1 内置权限类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> AllowAny,IsAuthenticated,IsAdminUser,IsAuthenticatedOrReadOnly</span><br><span class="line">- AllowAny 允许所有用户</span><br><span class="line">- IsAuthenticated 仅通过认证的用户</span><br><span class="line">- IsAdminUser 仅管理员用户</span><br><span class="line">- IsAuthenticatedOrReadOnly 已经登陆认证的用户可以对数据进行增删改操作，没有登陆认证的只能查看数据。</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-全局使用"><a href="#2-2-2-全局使用" class="headerlink" title="2.2.2 全局使用"></a>2.2.2 全局使用</h3><p>可以在配置文件中全局设置默认的权限管理类，如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;DEFAULT_PERMISSION_CLASSES&#x27;</span>: (</span><br><span class="line">        <span class="string">&#x27;rest_framework.permissions.IsAuthenticated&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果未指明，则采用如下默认配置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;DEFAULT_PERMISSION_CLASSES&#x27;</span>: (</span><br><span class="line">   <span class="string">&#x27;rest_framework.permissions.AllowAny&#x27;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-局部使用"><a href="#2-2-3-局部使用" class="headerlink" title="2.2.3 局部使用"></a>2.2.3 局部使用</h3><p>也可以在具体的视图中通过permission_classes属性来设置，如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> IsAuthenticated</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleView</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    permission_classes = (IsAuthenticated,)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h3 id="2-2-4-实际操作"><a href="#2-2-4-实际操作" class="headerlink" title="2.2.4 实际操作"></a>2.2.4 实际操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建超级用户，登陆到admin，创建普通用户（注意设置职员状态，也就是能登陆）</span></span><br><span class="line"><span class="comment"># 全局配置IsAuthenticated</span></span><br><span class="line"><span class="comment"># setting.py</span></span><br><span class="line"><span class="string">&#x27;DEFAULT_PERMISSION_CLASSES&#x27;</span>: (</span><br><span class="line">        <span class="string">&#x27;rest_framework.permissions.IsAuthenticated&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line"><span class="comment"># urls.py</span></span><br><span class="line"> path(<span class="string">&#x27;test/&#x27;</span>, views.TestView.as_view()),</span><br><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestView</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;msg&#x27;</span>:<span class="string">&#x27;个人中心&#x27;</span>&#125;)</span><br><span class="line"><span class="comment"># 登陆到admin后台后，直接访问可以，如果没登陆，不能访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##注意：如果全局配置了</span></span><br><span class="line">rest_framework.permissions.IsAdminUser</span><br><span class="line"><span class="comment"># 就只有管理员能访问，普通用户访问不了</span></span><br></pre></td></tr></table></figure>

<h1 id="三-限流Throttling"><a href="#三-限流Throttling" class="headerlink" title="三 限流Throttling"></a>三 限流Throttling</h1><p>可以对接口访问的频次进行限制，以减轻服务器压力。</p>
<p>一般用于付费购买次数,投票等场景使用.</p>
<h2 id="3-1-自定义频率类"><a href="#3-1-自定义频率类" class="headerlink" title="3.1 自定义频率类"></a>3.1 自定义频率类</h2><h3 id="3-1-1-编写频率类"><a href="#3-1-1-编写频率类" class="headerlink" title="3.1.1 编写频率类"></a>3.1.1 编写频率类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义的逻辑</span></span><br><span class="line"><span class="comment">#（1）取出访问者ip</span></span><br><span class="line"><span class="comment">#（2）判断当前ip不在访问字典里，添加进去，并且直接返回True,表示第一次访问，在字典里，继续往下走</span></span><br><span class="line"><span class="comment">#（3）循环判断当前ip的列表，有值，并且当前时间减去列表的最后一个时间大于60s，把这种数据pop掉，这样列表中只有60s以内的访问时间，</span></span><br><span class="line"><span class="comment">#（4）判断，当列表小于3，说明一分钟以内访问不足三次，把当前时间插入到列表第一个位置，返回True，顺利通过</span></span><br><span class="line"><span class="comment">#（5）当大于等于3，说明一分钟内访问超过三次，返回False验证失败</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThrottles</span>():</span></span><br><span class="line">    VISIT_RECORD = &#123;&#125;        <span class="comment"># 定义成类属性，self.VISIT_RECORD 所有对象用的都是一个</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.history=[]   <span class="comment"># 对象属性，每一个ip过来 就是一个对象</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allow_request</span>(<span class="params">self,request, view</span>):</span></span><br><span class="line">        <span class="comment">#（1）取出访问者ip</span></span><br><span class="line">        <span class="comment"># print(request.META)</span></span><br><span class="line">        ip=request.META.get(<span class="string">&#x27;REMOTE_ADDR&#x27;</span>)</span><br><span class="line">        <span class="keyword">import</span> time</span><br><span class="line">        ctime=time.time()</span><br><span class="line">        <span class="comment"># （2）判断当前ip不在访问字典里，添加进去，并且直接返回True,表示第一次访问</span></span><br><span class="line">        <span class="keyword">if</span> ip <span class="keyword">not</span> <span class="keyword">in</span> self.VISIT_RECORD:</span><br><span class="line">            self.VISIT_RECORD[ip]=[ctime,]</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        self.history=self.VISIT_RECORD.get(ip)</span><br><span class="line">        <span class="comment"># （3）循环判断当前ip的列表，有值，并且当前时间减去列表的最后一个时间大于60s，把这种数据pop掉，这样列表中只有60s以内的访问时间，</span></span><br><span class="line">        <span class="comment">#while self.history and ctime-self.history[-1]&gt;60:</span></span><br><span class="line">        <span class="comment">#    self.history.pop()</span></span><br><span class="line">        <span class="keyword">while</span> self.history:</span><br><span class="line">            <span class="keyword">if</span> ctime - self.history[<span class="number">-1</span>] &gt; <span class="number">60</span>:</span><br><span class="line">                self.history.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># （4）判断，当列表小于3，说明一分钟以内访问不足三次，把当前时间插入到列表第一个位置，返回True，顺利通过</span></span><br><span class="line">        <span class="comment"># （5）当大于等于3，说明一分钟内访问超过三次，返回False验证失败</span></span><br><span class="line">        <span class="keyword">if</span> len(self.history)&lt;<span class="number">3</span>:</span><br><span class="line">            self.history.insert(<span class="number">0</span>,ctime)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">import</span> time</span><br><span class="line">        ctime=time.time()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">60</span>-(ctime-self.history[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>

<h3 id="3-1-2-全局使用"><a href="#3-1-2-全局使用" class="headerlink" title="3.1.2 全局使用"></a>3.1.2 全局使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;DEFAULT_THROTTLE_CLASSES&#x27;</span>:[<span class="string">&#x27;app01.utils.MyThrottles&#x27;</span>,],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-3-局部使用"><a href="#3-1-3-局部使用" class="headerlink" title="3.1.3 局部使用"></a>3.1.3 局部使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在视图类里使用</span></span><br><span class="line">throttle_classes = [MyThrottles,]</span><br></pre></td></tr></table></figure>

<h2 id="3-2-内置频率类-常用"><a href="#3-2-内置频率类-常用" class="headerlink" title="3.2 内置频率类(常用)"></a>3.2 内置频率类(常用)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）继承SimpleRateThrottle</span><br><span class="line">（<span class="number">2</span>）重写get_cache_key 返回谁，就以谁做限制</span><br><span class="line">（<span class="number">3</span>）类中写scope，频率限制范围</span><br><span class="line">（<span class="number">4</span>）<span class="comment"># 在配置文件中配置</span></span><br><span class="line">    REST_FRAMEWORK = &#123;</span><br><span class="line">        <span class="comment"># 频率限制的配置信息</span></span><br><span class="line">        <span class="string">&#x27;DEFAULT_THROTTLE_RATES&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;ip_throttle&#x27;</span>: <span class="string">&#x27;3/m&#x27;</span>  <span class="comment"># key要跟类中的scop对应，1分钟只能访问3此</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">（<span class="number">5</span>）局部配置 throttle_classes = [MyThrottle,]</span><br><span class="line">    全局配置 <span class="string">&#x27;DEFAULT_THROTTLE_CLASSES&#x27;</span>: [<span class="string">&#x27;app01.auth.MyThrottle&#x27;</span>],</span><br></pre></td></tr></table></figure>



<h3 id="3-2-1-根据用户ip限制"><a href="#3-2-1-根据用户ip限制" class="headerlink" title="3.2.1 根据用户ip限制"></a>3.2.1 根据用户ip限制</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 限制用户的访问次数，根据ip，根据用户id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写个类，继承基类，重写get_cache_key, 返回什么，就以什么为key限制； 其实是个大字典&#123;&#x27;key&#x27;:几次, &#x27;key2&#x27;:几次&#125;</span></span><br><span class="line"><span class="comment"># scope 频率限制范围 定义: 类中定义字段+配置文件定义(必须写)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -----&gt; APIVIew 经过认证-权限--限流(调用对象的allow_request方法)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework.throttling <span class="keyword">import</span> BaseThrottle,SimpleRateThrottle</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThrottle</span>(<span class="params">SimpleRateThrottle</span>):</span></span><br><span class="line">    scope = <span class="string">&#x27;ip_throttle&#x27;</span>  <span class="comment"># 一定要写</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_cache_key</span>(<span class="params">self, request, view</span>):</span></span><br><span class="line">        <span class="comment"># 返回谁，就以谁做限制</span></span><br><span class="line">        <span class="comment"># 按ip限制</span></span><br><span class="line">        print(request.META)</span><br><span class="line">        <span class="keyword">return</span> request.META.get(<span class="string">&#x27;REMOTE_ADDR&#x27;</span>)</span><br><span class="line"><span class="comment"># 在视图类中配置</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookView</span>(<span class="params">ViewSetMixin,ListAPIView</span>):</span></span><br><span class="line">    throttle_classes = [MyThrottle,]</span><br><span class="line"><span class="comment"># 在配置文件中配置</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="comment"># 频率限制的配置信息</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_THROTTLE_RATES&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ip_throttle&#x27;</span>: <span class="string">&#x27;3/m&#x27;</span>  <span class="comment"># key要跟类中的scop对应，1分钟只能访问3此</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 局部使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookView</span>(<span class="params">ViewSetMixin,ListAPIView</span>):</span></span><br><span class="line">    throttle_classes = [MyThrottle,]</span><br><span class="line"><span class="comment"># 全局使用（在配置文件中）</span></span><br><span class="line"> <span class="comment"># 全局使用频率类</span></span><br><span class="line"><span class="string">&#x27;DEFAULT_THROTTLE_CLASSES&#x27;</span>: [<span class="string">&#x27;app01.auth.MyThrottle&#x27;</span>],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">#############################################</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#写一个类，继承自SimpleRateThrottle，（根据ip限制）</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.throttling <span class="keyword">import</span> SimpleRateThrottle</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VisitThrottle</span>(<span class="params">SimpleRateThrottle</span>):</span></span><br><span class="line">    scope = <span class="string">&#x27;luffy&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_cache_key</span>(<span class="params">self, request, view</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.get_ident(request)</span><br><span class="line"><span class="comment">#在setting里配置：（一分钟访问三次）</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;DEFAULT_THROTTLE_RATES&#x27;</span>:&#123;</span><br><span class="line">        <span class="string">&#x27;luffy&#x27;</span>:<span class="string">&#x27;3/m&#x27;</span>  <span class="comment"># key要跟类中的scop对应</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以全局使用，局部使用</span></span><br></pre></td></tr></table></figure>

<p>了解：错误信息中文显示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Course</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    authentication_classes = [TokenAuth, ]</span><br><span class="line">    permission_classes = [UserPermission, ]</span><br><span class="line">    throttle_classes = [MyThrottles,]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;post&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">throttled</span>(<span class="params">self, request, wait</span>):</span></span><br><span class="line">        <span class="keyword">from</span> rest_framework.exceptions <span class="keyword">import</span> Throttled</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MyThrottled</span>(<span class="params">Throttled</span>):</span></span><br><span class="line">            default_detail = <span class="string">&#x27;傻逼啊&#x27;</span></span><br><span class="line">            extra_detail_singular = <span class="string">&#x27;还有 &#123;wait&#125; second.&#x27;</span></span><br><span class="line">            extra_detail_plural = <span class="string">&#x27;出了 &#123;wait&#125; seconds.&#x27;</span></span><br><span class="line">        <span class="keyword">raise</span> MyThrottled(wait)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-限制匿名用户每分钟访问3次"><a href="#3-2-2-限制匿名用户每分钟访问3次" class="headerlink" title="3.2.2 限制匿名用户每分钟访问3次"></a>3.2.2 限制匿名用户每分钟访问3次</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;DEFAULT_THROTTLE_CLASSES&#x27;</span>: (</span><br><span class="line">        <span class="string">&#x27;rest_framework.throttling.AnonRateThrottle&#x27;</span>,</span><br><span class="line">    ),</span><br><span class="line">    <span class="string">&#x27;DEFAULT_THROTTLE_RATES&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;anon&#x27;</span>: <span class="string">&#x27;3/m&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 使用 `second`, `minute`, `hour` 或`day`来指明周期。</span></span><br><span class="line"><span class="comment"># 可以全局使用，局部使用</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-3-限制登陆用户每分钟访问10次"><a href="#3-2-3-限制登陆用户每分钟访问10次" class="headerlink" title="3.2.3 限制登陆用户每分钟访问10次"></a>3.2.3 限制登陆用户每分钟访问10次</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;DEFAULT_THROTTLE_CLASSES&#x27;</span>: (</span><br><span class="line">        <span class="string">&#x27;rest_framework.throttling.UserRateThrottle&#x27;</span></span><br><span class="line">    ),</span><br><span class="line">    <span class="string">&#x27;DEFAULT_THROTTLE_RATES&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;10/m&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 可以全局使用，局部使用</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-4-其他"><a href="#3-2-4-其他" class="headerlink" title="3.2.4 其他"></a>3.2.4 其他</h3><p>1） <strong>AnonRateThrottle</strong></p>
<p>限制所有匿名未认证用户，使用IP区分用户。</p>
<p>使用<code>DEFAULT_THROTTLE_RATES[&#39;anon&#39;]</code> 来设置频次</p>
<p>2）<strong>UserRateThrottle</strong></p>
<p>限制认证用户，使用User id 来区分。</p>
<p>使用<code>DEFAULT_THROTTLE_RATES[&#39;user&#39;]</code> 来设置频次</p>
<p>3）<strong>ScopedRateThrottle</strong></p>
<p>限制用户对于每个视图的访问频次，使用ip或user id。</p>
<p>例如：throttle_scope 属性指定限流范围(scope)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactListView</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    throttle_scope = <span class="string">&#x27;contacts&#x27;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactDetailView</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    throttle_scope = <span class="string">&#x27;contacts&#x27;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadView</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    throttle_scope = <span class="string">&#x27;uploads&#x27;</span></span><br><span class="line">    ...</span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;DEFAULT_THROTTLE_CLASSES&#x27;</span>: (</span><br><span class="line">        <span class="string">&#x27;rest_framework.throttling.ScopedRateThrottle&#x27;</span>,</span><br><span class="line">    ),</span><br><span class="line">    <span class="string">&#x27;DEFAULT_THROTTLE_RATES&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;contacts&#x27;</span>: <span class="string">&#x27;1000/day&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;uploads&#x27;</span>: <span class="string">&#x27;20/day&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-SimpleRateThrottle-源码分析"><a href="#3-3-SimpleRateThrottle-源码分析" class="headerlink" title="3.3 SimpleRateThrottle 源码分析"></a>3.3 SimpleRateThrottle 源码分析</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleRateThrottle</span>(<span class="params">BaseThrottle</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    A simple cache implementation, that only requires `.get_cache_key()`</span></span><br><span class="line"><span class="string">    to be overridden.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The rate (requests / seconds) is set by a `rate` attribute on the View</span></span><br><span class="line"><span class="string">    class.  The attribute is a string of the form &#x27;number_of_requests/period&#x27;.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Period should be one of: (&#x27;s&#x27;, &#x27;sec&#x27;, &#x27;m&#x27;, &#x27;min&#x27;, &#x27;h&#x27;, &#x27;hour&#x27;, &#x27;d&#x27;, &#x27;day&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Previous request information used for throttling is stored in the cache.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cache = default_cache</span><br><span class="line">    timer = time.time</span><br><span class="line">    cache_format = <span class="string">&#x27;throttle_%(scope)s_%(ident)s&#x27;</span></span><br><span class="line">    scope = <span class="literal">None</span></span><br><span class="line">    THROTTLE_RATES = api_settings.DEFAULT_THROTTLE_RATES</span><br><span class="line">    <span class="comment"># 从配置文件DEFAULT_THROTTLE_RATES中根据scope得到 频率 配置(次数/时间  3/min)</span></span><br><span class="line">    <span class="comment"># scope作为频率认证的类属性，写死</span></span><br><span class="line">    <span class="comment"># 将频率配置解析成 次数 和 时间 分别存到到 self.num_requests 和 self.duration</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> getattr(self, <span class="string">&#x27;rate&#x27;</span>, <span class="literal">None</span>): <span class="comment"># 去反射找rate, 如果没有执行下面的函数</span></span><br><span class="line">            self.rate = self.get_rate()  <span class="comment"># rate</span></span><br><span class="line">            <span class="comment">#3                   60</span></span><br><span class="line">        self.num_requests, self.duration = self.parse_rate(self.rate) <span class="comment"># num_requests : 3   duration: 60</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_cache_key</span>(<span class="params">self, request, view</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Should return a unique cache-key which can be used for throttling.</span></span><br><span class="line"><span class="string">        Must be overridden.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        May return `None` if the request should not be throttled.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&#x27;.get_cache_key() must be overridden&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_rate</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Determine the string representation of the allowed request rate.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> getattr(self, <span class="string">&#x27;scope&#x27;</span>, <span class="literal">None</span>):</span><br><span class="line">            msg = (<span class="string">&quot;You must set either `.scope` or `.rate` for &#x27;%s&#x27; throttle&quot;</span> %</span><br><span class="line">                   self.__class__.__name__)</span><br><span class="line">            <span class="keyword">raise</span> ImproperlyConfigured(msg)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self.THROTTLE_RATES[self.scope] <span class="comment"># THROTTLE_RATES配置信息，去配置字典里找值  3/m</span></span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            msg = <span class="string">&quot;No default throttle rate set for &#x27;%s&#x27; scope&quot;</span> % self.scope</span><br><span class="line">            <span class="keyword">raise</span> ImproperlyConfigured(msg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_rate</span>(<span class="params">self, rate</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Given the request rate string, return a two tuple of:</span></span><br><span class="line"><span class="string">        &lt;allowed number of requests&gt;, &lt;period of time in seconds&gt;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> rate <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">        num, period = rate.split(<span class="string">&#x27;/&#x27;</span>) <span class="comment"># rate: &#x27;3/min&#x27;</span></span><br><span class="line">        num_requests = int(num)</span><br><span class="line">        duration = &#123;<span class="string">&#x27;s&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;m&#x27;</span>: <span class="number">60</span>, <span class="string">&#x27;h&#x27;</span>: <span class="number">3600</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">86400</span>&#125;[period[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">return</span> (num_requests, duration) <span class="comment"># 3 , 60</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过get_cache_key的返回值，操作缓存self.history 列表</span></span><br><span class="line">    <span class="comment"># self.history 列表 长度就是访问次数，存放的就是某次访问的时间</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allow_request</span>(<span class="params">self, request, view</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Implement the check to see if the request should be throttled.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        On success calls `throttle_success`.</span></span><br><span class="line"><span class="string">        On failure calls `throttle_failure`.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.rate <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        self.key = self.get_cache_key(request, view)  <span class="comment"># 返回了 &#x27;throttle_user_1&#x27; 为key</span></span><br><span class="line">        <span class="keyword">if</span> self.key <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># django 缓存</span></span><br><span class="line">        <span class="comment"># 1) 导包 from django.core.cache import cache</span></span><br><span class="line">        <span class="comment"># 2) 添加缓存 cache.set(key, value, exp)</span></span><br><span class="line">        <span class="comment"># 3) 获取缓存 cache.get(self.key, [])</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初次访问缓存为空，self.history = [], 是存放时间的列表</span></span><br><span class="line">        self.history = self.cache.get(self.key, [])</span><br><span class="line">        <span class="comment"># 获取当前时间 存放到self.now  什么时候调用，什么时候存</span></span><br><span class="line">        self.now = self.timer()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Drop any requests from the history which have now passed the</span></span><br><span class="line">        <span class="comment"># throttle duration</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当前访问与第一次访问时间间隔如果大于60s，第一次记录清除，不再算作一次计数</span></span><br><span class="line">        <span class="keyword">while</span> self.history <span class="keyword">and</span> self.history[<span class="number">-1</span>] &lt;= self.now - self.duration:</span><br><span class="line">            self.history.pop()</span><br><span class="line">        <span class="comment"># history长度与限制次数3进行比较</span></span><br><span class="line">        <span class="comment"># history 长度第一次访问0， 第二次访问1， 第三次访问2， 第四次访问3失败</span></span><br><span class="line">        <span class="keyword">if</span> len(self.history) &gt;= self.num_requests:</span><br><span class="line">            <span class="keyword">return</span> self.throttle_failure()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># history长度未达到3，代表可以访问</span></span><br><span class="line">        <span class="comment"># 将当前时间插入到history插入到列表开头，将history列表作为数据存到缓存中，key是throttle_user_1，过期时间60s</span></span><br><span class="line">        <span class="keyword">return</span> self.throttle_success()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">throttle_success</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Inserts the current request&#x27;s timestamp along with the key</span></span><br><span class="line"><span class="string">        into the cache.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.history.insert(<span class="number">0</span>, self.now)</span><br><span class="line">        self.cache.set(self.key, self.history, self.duration)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">throttle_failure</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Called when a request to the API has failed due to throttling.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 计算下次访问需要等待时间</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns the recommended next request time in seconds.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.history:</span><br><span class="line">            remaining_duration = self.duration - (self.now - self.history[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            remaining_duration = self.duration</span><br><span class="line"></span><br><span class="line">        available_requests = self.num_requests - len(self.history) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> available_requests &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> remaining_duration / float(available_requests)</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>全局配置中设置访问频率</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;DEFAULT_THROTTLE_RATES&#x27;</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;anon&#x27;</span>: <span class="string">&#x27;3/minute&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;10/minute&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">from</span> rest_framework.authentication <span class="keyword">import</span> SessionAuthentication</span><br><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> IsAuthenticated</span><br><span class="line"><span class="keyword">from</span> rest_framework.generics <span class="keyword">import</span> RetrieveAPIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.throttling <span class="keyword">import</span> UserRateThrottle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentAPIView</span>(<span class="params">RetrieveAPIView</span>):</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentSerializer</span><br><span class="line">    authentication_classes = [SessionAuthentication]</span><br><span class="line">    permission_classes = [IsAuthenticated]</span><br><span class="line">    throttle_classes = (UserRateThrottle,)</span><br></pre></td></tr></table></figure>





<h3 id="上课实验代码"><a href="#上课实验代码" class="headerlink" title="上课实验代码"></a>上课实验代码</h3><h4 id="未登录用户限流（AnonRateThrottle）"><a href="#未登录用户限流（AnonRateThrottle）" class="headerlink" title="未登录用户限流（AnonRateThrottle）"></a>未登录用户限流（AnonRateThrottle）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># settings配置（未注释就代表全局限制未登录用户，注释掉就代表限制取消全局配置，进行局部配置）</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&quot;DEFAULT_AUTHENTICATION_CLASSES&quot;</span>: [<span class="string">&quot;app01.app_auth.MyAuthentication&quot;</span>],</span><br><span class="line">    <span class="string">&quot;DEFAULT_PERMISSION_CLASSES&quot;</span>: [<span class="string">&#x27;app01.app_auth.UserPermission&#x27;</span>,],</span><br><span class="line">    <span class="comment"># &#x27;DEFAULT_THROTTLE_CLASSES&#x27;: (</span></span><br><span class="line">    <span class="comment">#     &#x27;rest_framework.throttling.AnonRateThrottle&#x27;,</span></span><br><span class="line">    <span class="comment"># ),</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_THROTTLE_RATES&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;anon&#x27;</span>: <span class="string">&#x27;3/m&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制匿名用户</span></span><br><span class="line"></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;DEFAULT_THROTTLE_CLASSES&#x27;</span>: (</span><br><span class="line">        <span class="string">&#x27;rest_framework.throttling.AnonRateThrottle&#x27;</span>,</span><br><span class="line">    ),</span><br><span class="line">    <span class="string">&#x27;DEFAULT_THROTTLE_RATES&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;anon&#x27;</span>: <span class="string">&#x27;3/m&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 演示全局未登录用户的频率限制</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestView4</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    authentication_classes = []</span><br><span class="line">    permission_classes = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Response(<span class="string">&#x27;测试权限视图44444 未登录用户限流配置&#x27;</span>)</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework.throttling <span class="keyword">import</span> AnonRateThrottle</span><br><span class="line"><span class="comment">### 演示局部 未登录用户的 频率限制</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestView5</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    authentication_classes = []</span><br><span class="line">    permission_classes = []</span><br><span class="line">    throttle_classes = [AnonRateThrottle]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Response(<span class="string">&#x27;测试权限视图44444 未登录用户限流配置&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="登录用户限流（用原生的限流必须是用admin那套认证权限系统）"><a href="#登录用户限流（用原生的限流必须是用admin那套认证权限系统）" class="headerlink" title="登录用户限流（用原生的限流必须是用admin那套认证权限系统）"></a>登录用户限流（用原生的限流必须是用admin那套认证权限系统）</h4><p><code>如果用自己的权限认证，那就需要自己写限流组件</code>; 一般都是全局用，局部禁用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># settings </span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;DEFAULT_THROTTLE_CLASSES&#x27;</span>: (</span><br><span class="line">        <span class="string">&#x27;rest_framework.throttling.UserRateThrottle&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;rest_framework.throttling.AnonRateThrottle&#x27;</span>,</span><br><span class="line">    ),</span><br><span class="line">    <span class="string">&#x27;DEFAULT_THROTTLE_RATES&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;10/m&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;anon&#x27;</span>: <span class="string">&#x27;3/m&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">### 演示全局 登录用户的 访问10次，未登录访问5次</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestView6</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    authentication_classes = [SessionAuthentication]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Response(<span class="string">&#x27;测试权限视图5555 未登录用户限流配置&#x27;</span>)</span><br><span class="line">      </span><br><span class="line"><span class="comment">#### 局部配置</span></span><br><span class="line">    在视图类中配一个就行</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 禁用</span></span><br><span class="line">    在视图类中配[]</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>DRF</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>DRF-08-自动生成接口文档</title>
    <url>/posts/22390.html</url>
    <content><![CDATA[<p>自动生成接口文档</p>
<a id="more"></a>

<h1 id="一-自动生成接口文档"><a href="#一-自动生成接口文档" class="headerlink" title="一 自动生成接口文档"></a>一 自动生成接口文档</h1><p>REST framework可以自动帮助我们生成接口文档。</p>
<p>接口文档以网页的方式呈现。</p>
<p>自动接口文档能生成的是继承自<code>APIView</code>及其子类的视图。</p>
<h2 id="1-1-安装依赖"><a href="#1-1-安装依赖" class="headerlink" title="1.1. 安装依赖"></a>1.1. 安装依赖</h2><p>REST framewrok生成接口文档需要<code>coreapi</code>库的支持。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install coreapi</span><br></pre></td></tr></table></figure>

<h2 id="1-2-设置接口文档访问路径"><a href="#1-2-设置接口文档访问路径" class="headerlink" title="1.2. 设置接口文档访问路径"></a>1.2. 设置接口文档访问路径</h2><p>在总路由中添加接口文档路径。</p>
<p>文档路由对应的视图配置为<code>rest_framework.documentation.include_docs_urls</code>，</p>
<p>参数<code>title</code>为接口文档网站的标题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest_framework.documentation import include_docs_urls</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    ...</span><br><span class="line">    path(&#39;docs&#x2F;&#39;, include_docs_urls(title&#x3D;&#39;站点页面标题&#39;))</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="1-3-文档描述说明的定义位置"><a href="#1-3-文档描述说明的定义位置" class="headerlink" title="1.3. 文档描述说明的定义位置"></a>1.3. 文档描述说明的定义位置</h2><p>1） 单一方法的视图，可直接使用类视图的文档字符串，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BookListView(generics.ListAPIView):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    返回所有图书信息.</span><br><span class="line">    &quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>2）包含多个方法的视图，在类视图的文档字符串中，分开方法定义，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BookListCreateView(generics.ListCreateAPIView):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    get:</span><br><span class="line">    返回所有图书信息.</span><br><span class="line"></span><br><span class="line">    post:</span><br><span class="line">    新建图书.</span><br><span class="line">    &quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>3）对于视图集ViewSet，仍在类视图的文档字符串中封开定义，但是应使用action名称区分，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BookInfoViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin, GenericViewSet):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    list:</span><br><span class="line">    返回图书列表数据</span><br><span class="line"></span><br><span class="line">    retrieve:</span><br><span class="line">    返回图书详情数据</span><br><span class="line"></span><br><span class="line">    latest:</span><br><span class="line">    返回最新的图书数据</span><br><span class="line"></span><br><span class="line">    read:</span><br><span class="line">    修改图书的阅读量</span><br><span class="line">    &quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-访问接口文档网页"><a href="#1-4-访问接口文档网页" class="headerlink" title="1.4. 访问接口文档网页"></a>1.4. 访问接口文档网页</h2><p>浏览器访问 127.0.0.1:8000/docs/，即可看到自动生成的接口文档。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggghbdeu1pj31is0u013r.jpg" alt="æ¥å£ææ¡£ç½é¡µ"></p>
<p>如果遇到报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#AttributeError: &#39;AutoSchema&#39; object has no attribute &#39;get_link&#39;</span><br><span class="line">REST_FRAMEWORK &#x3D; &#123;</span><br><span class="line"> &#39;DEFAULT_SCHEMA_CLASS&#39;: &#39;rest_framework.schemas.coreapi.AutoSchema&#39;,</span><br><span class="line">    # 新版drf schema_class默认用的是rest_framework.schemas.openapi.AutoSchema</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="两点说明："><a href="#两点说明：" class="headerlink" title="两点说明："></a>两点说明：</h4><p>1） 视图集ViewSet中的retrieve名称，在接口文档网站中叫做read</p>
<p>2）参数的Description需要在模型类或序列化器类的字段中以help_text选项定义，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student(models.Model):</span><br><span class="line">    ...</span><br><span class="line">    age &#x3D; models.IntegerField(default&#x3D;0, verbose_name&#x3D;&#39;年龄&#39;, help_text&#x3D;&#39;年龄&#39;)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class StudentSerializer(serializers.ModelSerializer):</span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; Student</span><br><span class="line">        fields &#x3D; &quot;__all__&quot;</span><br><span class="line">        extra_kwargs &#x3D; &#123;</span><br><span class="line">            &#39;age&#39;: &#123;</span><br><span class="line">                &#39;required&#39;: True,</span><br><span class="line">                &#39;help_text&#39;: &#39;年龄&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DRF</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>DRF-04-视图组件</title>
    <url>/posts/3622.html</url>
    <content><![CDATA[<p>视图基类/ 视图扩展类/ GenericAPIView的视图子类</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.perform_create、destroy  好处可扩展，可以重写perform_create 然后扩展</span><br><span class="line">2.is_valid(validator&#x3D;) 直接抛异常，全局捕获 好处是不用写if else</span><br><span class="line">3.</span><br></pre></td></tr></table></figure>





<h1 id="一-视图"><a href="#一-视图" class="headerlink" title="一 视图"></a>一 视图</h1><p>Django REST framwork 提供的视图的主要作用：</p>
<ul>
<li>控制序列化器的执行（检验、保存、转换数据）</li>
<li>控制数据库查询的执行</li>
</ul>
<h2 id="1-1-视图继承关系"><a href="#1-1-视图继承关系" class="headerlink" title="1.1 视图继承关系"></a>1.1 视图继承关系</h2><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggipvctuxcj31wc0goq89.jpg" alt="image-20200707211311713"></p>
<p>视图的方法与属性：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggipulq6d5j30xu0u07mf.jpg" alt="通用视图的继承关系_含方法和属性"></p>
<h2 id="1-2-视图"><a href="#1-2-视图" class="headerlink" title="1.2 视图"></a>1.2 视图</h2><p>REST framework 提供了众多的通用视图基类与扩展类，以简化视图的编写。</p>
<h3 id="1-2-1-2个视图基类"><a href="#1-2-1-2个视图基类" class="headerlink" title="1.2.1 2个视图基类"></a>1.2.1 2个视图基类</h3><h4 id="1-2-1-1-APIView（继承了View）"><a href="#1-2-1-1-APIView（继承了View）" class="headerlink" title="1.2.1.1 APIView（继承了View）"></a>1.2.1.1 APIView（继承了View）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rest_framework.views.APIView</span><br></pre></td></tr></table></figure>

<p><code>APIView</code>是REST framework提供的所有视图的基类，继承自Django的<code>View</code>父类。</p>
<p><code>APIView</code>与<code>View</code>的不同之处在于：</p>
<ul>
<li>传入到视图方法中的是REST framework的<code>Request</code>对象，而不是Django的<code>HttpRequeset</code>对象；</li>
<li>视图方法可以返回REST framework的<code>Response</code>对象，视图会为响应数据设置（render）符合前端要求的格式；</li>
<li>任何<code>APIException</code>异常都会被捕获到，并且处理成合适的响应信息；</li>
<li>在进行dispatch()分发前，会对请求进行身份认证、权限检查、流量控制。</li>
</ul>
<p>支持定义的类属性</p>
<ul>
<li><strong>authentication_classes</strong> 列表或元祖，身份认证类</li>
<li><strong>permissoin_classes</strong> 列表或元祖，权限检查类</li>
<li><strong>throttle_classes</strong> 列表或元祖，流量控制类</li>
</ul>
<p>在<code>APIView</code>中仍以常规的类视图定义方法来实现get() 、post() 或者其他请求方式的方法。</p>
<p>举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"></span><br><span class="line"><span class="comment"># url(r&#x27;^students/$&#x27;, views.StudentsAPIView.as_view()),</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentsAPIView</span>(<span class="params">APIView</span>):</span></span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        data_list = Student.objects.all()</span><br><span class="line">        serializer = StudentModelSerializer(instance=data_list, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>

<h4 id="2-2-1-2-GenericAPIView-通用视图类-（继承了APIView）"><a href="#2-2-1-2-GenericAPIView-通用视图类-（继承了APIView）" class="headerlink" title="2.2.1.2 GenericAPIView[通用视图类]（继承了APIView）"></a>2.2.1.2 GenericAPIView[通用视图类]（继承了APIView）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rest_framework.generics.GenericAPIView</span><br></pre></td></tr></table></figure>

<p>继承自<code>APIVIew</code>，<strong>主要增加了操作序列化器和数据库查询的方法，作用是为下面Mixin扩展类的执行提供方法支持。通常在使用时，可搭配一个或多个Mixin扩展类。</strong></p>
<p>提供的关于序列化器使用的属性与方法</p>
<ul>
<li><p>属性：</p>
<ul>
<li><strong>serializer_class</strong> 指明视图使用的序列化器</li>
</ul>
</li>
<li><p>方法：</p>
<ul>
<li><p><strong>get_serializer_class(self)</strong></p>
<p>当出现一个视图类中调用多个序列化器时,那么可以通过条件判断在get_serializer_class方法中通过返回不同的序列化器类名就可以让视图方法执行不同的序列化器对象了。</p>
<p>返回序列化器类，默认返回<code>serializer_class</code>，可以重写，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_serializer_class</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">if</span> self.request.user.is_staff:</span><br><span class="line">        <span class="keyword">return</span> FullAccountSerializer</span><br><span class="line">    <span class="keyword">return</span> BasicAccountSerializer</span><br><span class="line"><span class="comment">## 示例2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegisterView</span>(<span class="params">GenericViewSet, CreateModelMixin, RetrieveModelMixin</span>):</span></span><br><span class="line">    queryset = models.User.objects.all()</span><br><span class="line">    <span class="comment"># serializer_class = ser.UserModelSerializer</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># get请求和post请求用的序列化类不一样，如何处理</span></span><br><span class="line">    <span class="comment"># 返回啥，get_serializer_class return 啥 用的序列化类就是啥</span></span><br><span class="line">    <span class="comment"># 注册用的序列化类是UserModelSerializer, 查询一个用的是序列化类 UserModelReadOnlySerializer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_class</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.action)</span><br><span class="line">        <span class="keyword">if</span> self.action == <span class="string">&#x27;create&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> ser.UserModelSerializer</span><br><span class="line">        <span class="keyword">elif</span> self.action == <span class="string">&#x27;retrieve&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> ser.UserModelReadOnlySerializer</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="get-serializer-self-args-kwargs"><a href="#get-serializer-self-args-kwargs" class="headerlink" title="get_serializer(self, *args, **kwargs)"></a>get_serializer(self, *args, **kwargs)</h5><p>返回序列化器对象，主要用来提供给Mixin扩展类使用，如果我们在视图中想要获取序列化器对象，也可以直接调用此方法。</p>
<p><strong>注意，该方法在提供序列化器对象的时候，会向序列化器对象的context属性补充三个数据：request、format、view，这三个数据对象可以在定义序列化器时使用。</strong></p>
<ul>
<li><strong>request</strong> 当前视图的请求对象</li>
<li><strong>view</strong> 当前请求的类视图对象</li>
<li>format 当前请求期望返回的数据格式</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>提供的关于数据库查询的属性与方法</p>
<ul>
<li><p>属性：</p>
<ul>
<li><strong>queryset</strong> 指明使用的数据查询集</li>
</ul>
</li>
<li><p>方法：</p>
<ul>
<li><p><strong>get_queryset(self)</strong></p>
<p>返回视图使用的查询集，主要用来提供给Mixin扩展类使用，是列表视图与详情视图获取数据的基础，默认返回<code>queryset</code>属性，可以重写，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span>(<span class="params">self</span>):</span></span><br><span class="line">    user = self.request.user</span><br><span class="line">    <span class="keyword">return</span> user.accounts.all()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>get_object(self)</strong></p>
<p>返回详情视图所需的模型类数据对象，主要用来提供给Mixin扩展类使用。</p>
<p>在试图中可以调用该方法获取详情信息的模型类对象。</p>
<p><strong>若详情访问的模型类对象不存在，会返回404。</strong></p>
<p>该方法会默认使用APIView提供的check_object_permissions方法检查当前对象是否有权限被访问。</p>
<p>举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># url(r&#x27;^books/(?P&lt;pk&gt;\d+)/$&#x27;, views.BookDetailView.as_view()),</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookDetailView</span>(<span class="params">GenericAPIView</span>):</span></span><br><span class="line">    queryset = BookInfo.objects.all()</span><br><span class="line">    serializer_class = BookInfoSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request, pk</span>):</span></span><br><span class="line">        book = self.get_object() <span class="comment"># get_object()方法根据pk参数查找queryset中的数据对象</span></span><br><span class="line">        serializer = self.get_serializer(book)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>其他可以设置的属性</p>
<ul>
<li><strong>pagination_class</strong> 指明分页控制类</li>
<li><strong>filter_backends</strong> 指明过滤控制后端</li>
</ul>
<p>为了方便学习上面的GenericAPIView通用视图类，我们新建一个子应用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py startapp gen</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.generics <span class="keyword">import</span> GenericAPIView</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> students.models <span class="keyword">import</span> Student</span><br><span class="line"><span class="keyword">from</span> .serializers <span class="keyword">import</span> StudentModelSerializer, StudentModel2Serializer</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentsGenericAPIView</span>(<span class="params">GenericAPIView</span>):</span></span><br><span class="line">    <span class="comment"># 本次视图类中要操作的数据[必填]</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    <span class="comment"># 本次视图类中要调用的默认序列化器[玄天]</span></span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取所有学生信息&quot;&quot;&quot;</span></span><br><span class="line">        serializer = self.get_serializer(instance=self.get_queryset(), many=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self,request</span>):</span></span><br><span class="line"></span><br><span class="line">        data = request.data</span><br><span class="line"></span><br><span class="line">        serializer = self.get_serializer(data=data)</span><br><span class="line"></span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        instance = serializer.save()</span><br><span class="line"></span><br><span class="line">        serializer = self.get_serializer(instance=instance)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentGenericAPIView</span>(<span class="params">GenericAPIView</span>):</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line"></span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_class</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;重写获取序列化器类的方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> StudentModel2Serializer</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> StudentModelSerializer</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在使用GenericAPIView视图获取或操作单个数据时,视图方法中的代表主键的参数最好是pk</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request,pk</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取一条数据&quot;&quot;&quot;</span></span><br><span class="line">        serializer = self.get_serializer(instance=self.get_object())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self,request,pk</span>):</span></span><br><span class="line"></span><br><span class="line">        data = request.data</span><br><span class="line"></span><br><span class="line">        serializer = self.get_serializer(instance=self.get_object(),data=data)</span><br><span class="line"></span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        serializer.save()</span><br><span class="line"></span><br><span class="line">        serializer = self.get_serializer(instance=self.get_object())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>

<p>序列化器类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> students.models <span class="keyword">import</span> Student</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentModelSerializer</span>(<span class="params">serializers.ModelSerializer</span>):</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model= Student</span><br><span class="line">        fields = <span class="string">&quot;__all__&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentModel2Serializer</span>(<span class="params">serializers.ModelSerializer</span>):</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model= Student</span><br><span class="line">        fields = (<span class="string">&quot;name&quot;</span>,<span class="string">&quot;class_null&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-5个视图扩展类（继承了object）"><a href="#1-2-2-5个视图扩展类（继承了object）" class="headerlink" title="1.2.2 5个视图扩展类（继承了object）"></a>1.2.2 5个视图扩展类（继承了object）</h3><p><strong>每个里面写了一个方法(ListModelMixin: list 方法)</strong></p>
<p>作用：</p>
<p>提供了几种后端视图（对数据资源进行增删改查）处理流程的实现，如果需要编写的视图属于这五种，则视图可以通过继承相应的扩展类来复用代码，减少自己编写的代码量。</p>
<p>这五个扩展类需要搭配GenericAPIView父类，因为五个扩展类的实现需要调用GenericAPIView提供的序列化器与数据库查询的方法。</p>
<h4 id="1）ListModelMixin"><a href="#1）ListModelMixin" class="headerlink" title="1）ListModelMixin"></a>1）ListModelMixin</h4><p>列表视图扩展类，提供<code>list(request, *args, **kwargs)</code>方法快速实现列表视图，返回200状态码。</p>
<p>该Mixin的list方法会对数据进行过滤和分页。</p>
<p>源代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListModelMixin</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    List a queryset.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 过滤</span></span><br><span class="line">        queryset = self.filter_queryset(self.get_queryset())</span><br><span class="line">        <span class="comment"># 分页</span></span><br><span class="line">        page = self.paginate_queryset(queryset)</span><br><span class="line">        <span class="keyword">if</span> page <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            serializer = self.get_serializer(page, many=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">return</span> self.get_paginated_response(serializer.data)</span><br><span class="line">        <span class="comment"># 序列化</span></span><br><span class="line">        serializer = self.get_serializer(queryset, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.mixins <span class="keyword">import</span> ListModelMixin</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookListView</span>(<span class="params">ListModelMixin, GenericAPIView</span>):</span></span><br><span class="line">    queryset = BookInfo.objects.all()</span><br><span class="line">    serializer_class = BookInfoSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.list(request)</span><br></pre></td></tr></table></figure>

<h4 id="2）CreateModelMixin"><a href="#2）CreateModelMixin" class="headerlink" title="2）CreateModelMixin"></a>2）CreateModelMixin</h4><p>创建视图扩展类，提供<code>create(request, *args, **kwargs)</code>方法快速实现创建资源的视图，成功返回201状态码。</p>
<p>如果序列化器对前端发送的数据验证失败，返回400错误。</p>
<p>源代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateModelMixin</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Create a model instance.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 获取序列化器</span></span><br><span class="line">        serializer = self.get_serializer(data=request.data)</span><br><span class="line">        <span class="comment"># 验证</span></span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 保存</span></span><br><span class="line">        self.perform_create(serializer)</span><br><span class="line">        headers = self.get_success_headers(serializer.data)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perform_create</span>(<span class="params">self, serializer</span>):</span></span><br><span class="line">        serializer.save()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_success_headers</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&#x27;Location&#x27;</span>: str(data[api_settings.URL_FIELD_NAME])&#125;</span><br><span class="line">        <span class="keyword">except</span> (TypeError, KeyError):</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3）RetrieveModelMixin"><a href="#3）RetrieveModelMixin" class="headerlink" title="3）RetrieveModelMixin"></a>3）RetrieveModelMixin</h4><p>详情视图扩展类，提供<code>retrieve(request, *args, **kwargs)</code>方法，可以快速实现返回一个存在的数据对象。</p>
<p>如果存在，返回200， 否则返回404。</p>
<p>源代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RetrieveModelMixin</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Retrieve a model instance.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">retrieve</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 获取对象，会检查对象的权限</span></span><br><span class="line">        instance = self.get_object()</span><br><span class="line">        <span class="comment"># 序列化</span></span><br><span class="line">        serializer = self.get_serializer(instance)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookDetailView</span>(<span class="params">RetrieveModelMixin, GenericAPIView</span>):</span></span><br><span class="line">    queryset = BookInfo.objects.all()</span><br><span class="line">    serializer_class = BookInfoSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request, pk</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.retrieve(request)</span><br></pre></td></tr></table></figure>

<h4 id="4）UpdateModelMixin"><a href="#4）UpdateModelMixin" class="headerlink" title="4）UpdateModelMixin"></a>4）UpdateModelMixin</h4><p>更新视图扩展类，提供<code>update(request, *args, **kwargs)</code>方法，可以快速实现更新一个存在的数据对象。</p>
<p>同时也提供<code>partial_update(request, *args, **kwargs)</code>方法，可以实现局部更新。</p>
<p>成功返回200，序列化器校验数据失败时，返回400错误。</p>
<p>源代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpdateModelMixin</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Update a model instance.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        partial = kwargs.pop(<span class="string">&#x27;partial&#x27;</span>, <span class="literal">False</span>)</span><br><span class="line">        instance = self.get_object()</span><br><span class="line">        serializer = self.get_serializer(instance, data=request.data, partial=partial)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        self.perform_update(serializer)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> getattr(instance, <span class="string">&#x27;_prefetched_objects_cache&#x27;</span>, <span class="literal">None</span>):</span><br><span class="line">            <span class="comment"># If &#x27;prefetch_related&#x27; has been applied to a queryset, we need to</span></span><br><span class="line">            <span class="comment"># forcibly invalidate the prefetch cache on the instance.</span></span><br><span class="line">            instance._prefetched_objects_cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perform_update</span>(<span class="params">self, serializer</span>):</span></span><br><span class="line">        serializer.save()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partial_update</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        kwargs[<span class="string">&#x27;partial&#x27;</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self.update(request, *args, **kwargs)</span><br></pre></td></tr></table></figure>

<h4 id="5）DestroyModelMixin"><a href="#5）DestroyModelMixin" class="headerlink" title="5）DestroyModelMixin"></a>5）DestroyModelMixin</h4><p>删除视图扩展类，提供<code>destroy(request, *args, **kwargs)</code>方法，可以快速实现删除一个存在的数据对象。</p>
<p>成功返回204，不存在返回404。</p>
<p>源代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DestroyModelMixin</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Destroy a model instance.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">destroy</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        instance = self.get_object()</span><br><span class="line">        self.perform_destroy(instance)</span><br><span class="line">        <span class="keyword">return</span> Response(status=status.HTTP_204_NO_CONTENT)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perform_destroy</span>(<span class="params">self, instance</span>):</span></span><br><span class="line">        instance.delete()</span><br></pre></td></tr></table></figure>

<p>使用GenericAPIView和视图扩展类，实现api接口，代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;GenericAPIView结合视图扩展类实现api接口&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.mixins <span class="keyword">import</span> ListModelMixin,CreateModelMixin</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Students2GenericAPIView</span>(<span class="params">GenericAPIView,ListModelMixin,CreateModelMixin</span>):</span></span><br><span class="line">    <span class="comment"># 本次视图类中要操作的数据[必填]</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    <span class="comment"># 本次视图类中要调用的默认序列化器[玄天]</span></span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取多个学生信息&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.list(request)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;添加学生信息&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.create(request)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework.mixins <span class="keyword">import</span> RetrieveModelMixin,UpdateModelMixin,DestroyModelMixin</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student2GenericAPIView</span>(<span class="params">GenericAPIView,RetrieveModelMixin,UpdateModelMixin,DestroyModelMixin</span>):</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line"></span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在使用GenericAPIView视图获取或操作单个数据时,视图方法中的代表主键的参数最好是pk</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request,pk</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取一条数据&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.retrieve(request,pk)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self,request,pk</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;更新一条数据&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.update(request,pk)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self,request,pk</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除一条数据&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.destroy(request,pk)</span><br></pre></td></tr></table></figure>

<h3 id="1-2-3-GenericAPIView的视图子类-继承了GenericAPIView-1或2或3个视图扩展类"><a href="#1-2-3-GenericAPIView的视图子类-继承了GenericAPIView-1或2或3个视图扩展类" class="headerlink" title="1.2.3 GenericAPIView的视图子类(继承了GenericAPIView+1或2或3个视图扩展类)"></a>1.2.3 GenericAPIView的视图子类(继承了GenericAPIView+1或2或3个视图扩展类)</h3><h4 id="1）CreateAPIView"><a href="#1）CreateAPIView" class="headerlink" title="1）CreateAPIView"></a>1）CreateAPIView</h4><p>提供 post 方法</p>
<p>继承自： GenericAPIView、CreateModelMixin</p>
<h4 id="2）ListAPIView"><a href="#2）ListAPIView" class="headerlink" title="2）ListAPIView"></a>2）ListAPIView</h4><p>提供 get 方法</p>
<p>继承自：GenericAPIView、ListModelMixin</p>
<h4 id="3）RetrieveAPIView"><a href="#3）RetrieveAPIView" class="headerlink" title="3）RetrieveAPIView"></a>3）RetrieveAPIView</h4><p>提供 get 方法</p>
<p>继承自: GenericAPIView、RetrieveModelMixin</p>
<h4 id="4）DestoryAPIView"><a href="#4）DestoryAPIView" class="headerlink" title="4）DestoryAPIView"></a>4）DestoryAPIView</h4><p>提供 delete 方法</p>
<p>继承自：GenericAPIView、DestoryModelMixin</p>
<h4 id="5）UpdateAPIView"><a href="#5）UpdateAPIView" class="headerlink" title="5）UpdateAPIView"></a>5）UpdateAPIView</h4><p>提供 put 和 patch 方法</p>
<p>继承自：GenericAPIView、UpdateModelMixin</p>
<h4 id="6）RetrieveUpdateAPIView"><a href="#6）RetrieveUpdateAPIView" class="headerlink" title="6）RetrieveUpdateAPIView"></a>6）RetrieveUpdateAPIView</h4><p>提供 get、put、patch方法</p>
<p>继承自： GenericAPIView、RetrieveModelMixin、UpdateModelMixin</p>
<h4 id="7）RetrieveUpdateDestoryAPIView"><a href="#7）RetrieveUpdateDestoryAPIView" class="headerlink" title="7）RetrieveUpdateDestoryAPIView"></a>7）RetrieveUpdateDestoryAPIView</h4><p>提供 get、put、patch、delete方法</p>
<p>继承自：GenericAPIView、RetrieveModelMixin、UpdateModelMixin、DestoryModelMixin</p>
<h2 id="1-3-视图集ViewSet"><a href="#1-3-视图集ViewSet" class="headerlink" title="1.3 视图集ViewSet"></a>1.3 视图集ViewSet</h2><p>使用视图集ViewSet，可以将一系列逻辑相关的动作放到一个类中：</p>
<ul>
<li>list() 提供一组数据</li>
<li>retrieve() 提供单个数据</li>
<li>create() 创建数据</li>
<li>update() 保存数据</li>
<li>destory() 删除数据</li>
</ul>
<p>ViewSet视图集类不再实现get()、post()等方法，而是实现动作 <strong>action</strong> 如 list() 、create() 等。</p>
<p>视图集只在使用as_view()方法的时候，才会将<strong>action</strong>动作与具体请求方式对应上。如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoViewSet</span>(<span class="params">viewsets.ViewSet</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        books = BookInfo.objects.all()</span><br><span class="line">        serializer = BookInfoSerializer(books, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">retrieve</span>(<span class="params">self, request, pk=None</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            books = BookInfo.objects.get(id=pk)</span><br><span class="line">        <span class="keyword">except</span> BookInfo.DoesNotExist:</span><br><span class="line">            <span class="keyword">return</span> Response(status=status.HTTP_404_NOT_FOUND)</span><br><span class="line">        serializer = BookInfoSerializer(books)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>

<p>在设置路由时，我们可以如下操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r&#x27;^books/$&#x27;</span>, BookInfoViewSet.as_view(&#123;<span class="string">&#x27;get&#x27;</span>:<span class="string">&#x27;list&#x27;</span>&#125;),</span><br><span class="line">    url(<span class="string">r&#x27;^books/(?P&lt;pk&gt;\d+)/$&#x27;</span>, BookInfoViewSet.as_view(&#123;<span class="string">&#x27;get&#x27;</span>: <span class="string">&#x27;retrieve&#x27;</span>&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="1-3-1-常用视图集父类"><a href="#1-3-1-常用视图集父类" class="headerlink" title="1.3.1 常用视图集父类"></a>1.3.1 常用视图集父类</h3><h4 id="1）-ViewSet"><a href="#1）-ViewSet" class="headerlink" title="1） ViewSet"></a>1） ViewSet</h4><p>继承自<code>APIView</code>与<code>ViewSetMixin</code>，作用也与APIView基本类似，提供了身份认证、权限校验、流量管理等。</p>
<p><strong>ViewSet主要通过继承ViewSetMixin来实现在调用as_view()时传入字典（如{‘get’:’list’}）的映射处理工作。</strong></p>
<p>在ViewSet中，没有提供任何动作action方法，需要我们自己实现action方法。</p>
<h4 id="2）GenericViewSet"><a href="#2）GenericViewSet" class="headerlink" title="2）GenericViewSet"></a>2）GenericViewSet</h4><p>使用ViewSet通常并不方便，因为list、retrieve、create、update、destory等方法都需要自己编写，而这些方法与前面讲过的Mixin扩展类提供的方法同名，所以我们可以通过继承Mixin扩展类来复用这些方法而无需自己编写。但是Mixin扩展类依赖与<code>GenericAPIView</code>，所以还需要继承<code>GenericAPIView</code>。</p>
<p><strong>GenericViewSet</strong>就帮助我们完成了这样的继承工作，继承自<code>GenericAPIView</code>与<code>ViewSetMixin</code>，在实现了调用as_view()时传入字典（如<code>&#123;&#39;get&#39;:&#39;list&#39;&#125;</code>）的映射处理工作的同时，还提供了<code>GenericAPIView</code>提供的基础方法，可以直接搭配Mixin扩展类使用。</p>
<p>举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> GenericViewSet</span><br><span class="line"><span class="keyword">from</span> rest_framework.mixins <span class="keyword">import</span> ListModelMixin,CreateModelMixin,RetrieveModelMixin,UpdateModelMixin,DestroyModelMixin</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student4ViewSet</span>(<span class="params">GenericViewSet,ListModelMixin,CreateModelMixin,RetrieveModelMixin,UpdateModelMixin,DestroyModelMixin</span>):</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br></pre></td></tr></table></figure>

<p>url的定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&quot;students7/&quot;</span>, views.Student4ViewSet.as_view(&#123;<span class="string">&quot;get&quot;</span>: <span class="string">&quot;list&quot;</span>, <span class="string">&quot;post&quot;</span>: <span class="string">&quot;create&quot;</span>&#125;)),</span><br><span class="line">    re_path(<span class="string">&quot;students7/(?P&lt;pk&gt;\d+)/&quot;</span>, views.Student4ViewSet.as_view(&#123;<span class="string">&quot;get&quot;</span>: <span class="string">&quot;retrieve&quot;</span>,<span class="string">&quot;put&quot;</span>:<span class="string">&quot;update&quot;</span>,<span class="string">&quot;delete&quot;</span>:<span class="string">&quot;destroy&quot;</span>&#125;)),</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="3）ModelViewSet-继承了5个视图扩展类和GenericAPIView-自己写的一个ViewSetMixin"><a href="#3）ModelViewSet-继承了5个视图扩展类和GenericAPIView-自己写的一个ViewSetMixin" class="headerlink" title="3）ModelViewSet(继承了5个视图扩展类和GenericAPIView+自己写的一个ViewSetMixin)"></a>3）ModelViewSet(继承了5个视图扩展类和GenericAPIView+自己写的一个ViewSetMixin)</h4><p>只要继承ViewSetMixin的，路由协程{‘get’: ‘自己写的方法’}</p>
<p>继承自<code>GenericViewSet(ViewSetMixin, generics.GenericAPIView)</code>，同时包括了ListModelMixin、RetrieveModelMixin、CreateModelMixin、UpdateModelMixin、DestoryModelMixin。</p>
<h4 id="4）ReadOnlyModelViewSet"><a href="#4）ReadOnlyModelViewSet" class="headerlink" title="4）ReadOnlyModelViewSet"></a>4）ReadOnlyModelViewSet</h4><p>继承自<code>GenericViewSet(ViewSetMixin, generics.GenericAPIView)</code>，同时包括了ListModelMixin、RetrieveModelMixin。</p>
<h3 id="1-3-2-视图集中定义附加action动作"><a href="#1-3-2-视图集中定义附加action动作" class="headerlink" title="1.3.2 视图集中定义附加action动作"></a>1.3.2 视图集中定义附加action动作</h3><p>在视图集中，除了上述默认的方法动作外，还可以添加自定义动作。</p>
<p>举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ModelViewSet,ReadOnlyModelViewSet</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentModelViewSet</span>(<span class="params">ModelViewSet</span>):</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;学生登录功能&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&quot;message&quot;</span>:<span class="string">&quot;登录成功&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>url的定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&quot;students8/&quot;</span>, views.StudentModelViewSet.as_view(&#123;<span class="string">&quot;get&quot;</span>: <span class="string">&quot;list&quot;</span>, <span class="string">&quot;post&quot;</span>: <span class="string">&quot;create&quot;</span>&#125;)),</span><br><span class="line">    re_path(<span class="string">&quot;students8/(?P&lt;pk&gt;\d+)/&quot;</span>,</span><br><span class="line">            views.StudentModelViewSet.as_view(&#123;<span class="string">&quot;get&quot;</span>: <span class="string">&quot;retrieve&quot;</span>, <span class="string">&quot;put&quot;</span>: <span class="string">&quot;update&quot;</span>, <span class="string">&quot;delete&quot;</span>: <span class="string">&quot;destroy&quot;</span>&#125;)),</span><br><span class="line"></span><br><span class="line">    path(<span class="string">&quot;stu/login/&quot;</span>,views.StudentModelViewSet.as_view(&#123;<span class="string">&quot;get&quot;</span>:<span class="string">&quot;login&quot;</span>&#125;))</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="1-3-3-action属性"><a href="#1-3-3-action属性" class="headerlink" title="1.3.3 action属性"></a>1.3.3 action属性</h3><p>在视图集中，我们可以通过action对象属性来获取当前请求视图集时的action动作是哪个。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ModelViewSet</span><br><span class="line"><span class="keyword">from</span> students.models <span class="keyword">import</span> Student</span><br><span class="line"><span class="keyword">from</span> .serializers <span class="keyword">import</span> StudentModelSerializer</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentModelViewSet</span>(<span class="params">ModelViewSet</span>):</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_new_5</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取最近添加的5个学生信息&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 操作数据库</span></span><br><span class="line">        print(self.action) <span class="comment"># 获取本次请求的视图方法名</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">通过路由访问到当前方法中.可以看到本次的action就是请求的方法名</span><br></pre></td></tr></table></figure>

<h2 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#两个基类</span></span><br><span class="line">APIView</span><br><span class="line">GenericAPIView：有关数据库操作，queryset 和serializer_class</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#5个视图扩展类(rest_framework.mixins)</span></span><br><span class="line">CreateModelMixin：create方法创建一条</span><br><span class="line">DestroyModelMixin：destory方法删除一条</span><br><span class="line">ListModelMixin：list方法获取所有</span><br><span class="line">RetrieveModelMixin：retrieve获取一条</span><br><span class="line">UpdateModelMixin：update修改一条</span><br><span class="line"></span><br><span class="line"><span class="comment">#9个子类视图(rest_framework.generics)</span></span><br><span class="line">CreateAPIView:继承CreateModelMixin,GenericAPIView，有post方法，新增数据</span><br><span class="line">DestroyAPIView：继承DestroyModelMixin,GenericAPIView，有delete方法，删除数据</span><br><span class="line">ListAPIView：继承ListModelMixin,GenericAPIView,有get方法获取所有</span><br><span class="line">UpdateAPIView：继承UpdateModelMixin,GenericAPIView，有put和patch方法，修改数据</span><br><span class="line">RetrieveAPIView：继承RetrieveModelMixin,GenericAPIView，有get方法，获取一条</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ListCreateAPIView：继承ListModelMixin,CreateModelMixin,GenericAPIView，有get获取所有，post方法新增</span><br><span class="line">RetrieveDestroyAPIView：继承RetrieveModelMixin,DestroyModelMixin,GenericAPIView，有get方法获取一条，delete方法删除</span><br><span class="line">RetrieveUpdateAPIView：继承RetrieveModelMixin,UpdateModelMixin,GenericAPIView，有get获取一条，put，patch修改</span><br><span class="line">RetrieveUpdateDestroyAPIView：继承RetrieveModelMixin,UpdateModelMixin,DestroyModelMixin,GenericAPIView，有get获取一条，put，patch修改，delete删除</span><br><span class="line"></span><br><span class="line"><span class="comment">#视图集</span></span><br><span class="line">ViewSetMixin：重写了as_view </span><br><span class="line">ViewSet：     继承ViewSetMixin + APIView</span><br><span class="line"></span><br><span class="line">GenericViewSet：继承ViewSetMixin + generics.GenericAPIView</span><br><span class="line"></span><br><span class="line">ModelViewSet：继承mixins.CreateModelMixin,mixins.RetrieveModelMixin,mixins.UpdateModelMixin,mixins.DestroyModelMixin,mixins.ListModelMixin,GenericViewSet</span><br><span class="line"></span><br><span class="line">ReadOnlyModelViewSet：继承mixins.RetrieveModelMixin,mixins.ListModelMixin,GenericViewSet</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20210702175446193.png" alt="image-20210702175446193"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/DRF%E8%A7%86%E5%9B%BE%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.jpeg" alt="DRF视图类继承关系"></p>
<h2 id="1-5-代码"><a href="#1-5-代码" class="headerlink" title="1.5 代码"></a>1.5 代码</h2><p>models.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">5</span>, decimal_places=<span class="number">2</span>)</span><br><span class="line">    publish = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publish</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    email = models.CharField(max_length=<span class="number">32</span>)</span><br></pre></td></tr></table></figure>

<p>ser.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> app01.models <span class="keyword">import</span> Book</span><br><span class="line"><span class="keyword">from</span> app01.models <span class="keyword">import</span> Publish</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookSerializer</span>(<span class="params">serializers.ModelSerializer</span>):</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Book</span><br><span class="line">        fields = <span class="string">&#x27;__all__&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublishSerializer</span>(<span class="params">serializers.ModelSerializer</span>):</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Publish</span><br><span class="line">        fields = <span class="string">&#x27;__all__&#x27;</span></span><br></pre></td></tr></table></figure>

<p>Urls.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 基于APIView的视图</span></span><br><span class="line">    path(<span class="string">&#x27;books/&#x27;</span>, views.BookView.as_view()),</span><br><span class="line">    re_path(<span class="string">&#x27;books/(?P&lt;pk&gt;\d+)&#x27;</span>, views.BookDetailView.as_view()),</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用genericAPIView重写的</span></span><br><span class="line">    path(<span class="string">&#x27;books2/&#x27;</span>, views.Book2View.as_view()),</span><br><span class="line">    re_path(<span class="string">&#x27;books2/(?P&lt;pk&gt;\d+)&#x27;</span>, views.BookDetailView.as_view()),</span><br><span class="line">    path(<span class="string">&#x27;publish/&#x27;</span>, views.PublishView.as_view()),</span><br><span class="line">    re_path(<span class="string">&#x27;publish/(?P&lt;pk&gt;\d+)&#x27;</span>, views.PublishDetailView.as_view()),</span><br><span class="line">    <span class="comment"># 使用genericAPIView提供的5个视图</span></span><br><span class="line">    path(<span class="string">&#x27;books3/&#x27;</span>, views.Book3View.as_view()),</span><br><span class="line">    re_path(<span class="string">&#x27;books3/(?P&lt;pk&gt;\d+)&#x27;</span>, views.Book3DetailView.as_view()),</span><br><span class="line">      <span class="comment"># 基于GenericAPIView的视图子类接口写的</span></span><br><span class="line">    path(<span class="string">&#x27;books4/&#x27;</span>, views.Book4View.as_view()),</span><br><span class="line">    re_path(<span class="string">&#x27;books4/(?P&lt;pk&gt;\d+)&#x27;</span>, views.Book4DetailView.as_view()),</span><br><span class="line">      <span class="comment"># 基于ModelViewSet的视图子类接口写的</span></span><br><span class="line">    path(<span class="string">&#x27;books5/&#x27;</span>, views.Book5View.as_view(actions=&#123;<span class="string">&#x27;get&#x27;</span>:<span class="string">&#x27;list&#x27;</span>, <span class="string">&#x27;post&#x27;</span>:<span class="string">&#x27;create&#x27;</span>&#125;)),</span><br><span class="line">    re_path(<span class="string">&#x27;books5/(?P&lt;pk&gt;\d+)&#x27;</span>, views.Book5View.as_view(actions=&#123;<span class="string">&#x27;get&#x27;</span>:<span class="string">&#x27;retrieve&#x27;</span>, <span class="string">&#x27;put&#x27;</span>:<span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>:<span class="string">&#x27;destroy&#x27;</span>&#125;)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="1-5-1-基于APIView的视图写接口"><a href="#1-5-1-基于APIView的视图写接口" class="headerlink" title="1.5.1 基于APIView的视图写接口"></a>1.5.1 基于APIView的视图写接口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基于APIVIew写的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookView</span>(<span class="params">APIView</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="comment"># book_queryset = models.Book.objects.all()</span></span><br><span class="line">        book_queryset = models.Book.objects.all()</span><br><span class="line">        book_ser = BookSerializer(instance=book_queryset, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(book_ser.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        book_ser = BookSerializer(data=request.data)</span><br><span class="line">        <span class="keyword">if</span> book_ser.is_valid():</span><br><span class="line">            book_ser.save()</span><br><span class="line">            <span class="keyword">return</span> Response(book_ser.data, status=status.HTTP_201_CREATED)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;status&#x27;</span>: <span class="string">&#x27;101&#x27;</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;校验失败&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookDetailView</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    queryset = models.Book.objects.all()</span><br><span class="line">    serializer_class = BookSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request, pk</span>):</span></span><br><span class="line">        book_obj = models.Book.objects.filter(pk=pk).first()</span><br><span class="line">        book_ser = BookSerializer(instance=book_obj)</span><br><span class="line">        <span class="keyword">return</span> Response(book_ser.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, request, pk</span>):</span></span><br><span class="line">        book_obj = models.Book.objects.filter(pk=pk).first()</span><br><span class="line">        book_ser = BookSerializer(instance=book_obj, data=request.data)</span><br><span class="line">        <span class="keyword">if</span> book_ser.is_valid():</span><br><span class="line">            book_ser.save()</span><br><span class="line">            <span class="keyword">return</span> Response(data=book_ser.data, status=status.HTTP_200_OK)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;status&#x27;</span>: <span class="number">101</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;校验失败&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self, request, pk</span>):</span></span><br><span class="line">        self.get_object().delete()</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;status&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;删除成功&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="1-5-2-基于GenericView写的接口"><a href="#1-5-2-基于GenericView写的接口" class="headerlink" title="1.5.2 基于GenericView写的接口"></a>1.5.2 基于GenericView写的接口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublishView</span>(<span class="params">GenericAPIView</span>):</span></span><br><span class="line">    <span class="comment"># queryset要传queryset对象，查询了所有的图书</span></span><br><span class="line">    <span class="comment"># serializer_class使用哪个序列化类来序列化这些数据</span></span><br><span class="line">    queryset = models.Publish.objects.all()</span><br><span class="line">    serializer_class = PublishSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="comment"># book_queryset = models.Book.objects.all()</span></span><br><span class="line">        book_queryset = self.get_queryset()</span><br><span class="line">        book_ser = self.get_serializer(instance=book_queryset, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(book_ser.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        book_ser = self.get_serializer(data=request.data)</span><br><span class="line">        <span class="keyword">if</span> book_ser.is_valid():</span><br><span class="line">            book_ser.save()</span><br><span class="line">            <span class="keyword">return</span> Response(book_ser.data, status=status.HTTP_201_CREATED)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;status&#x27;</span>: <span class="string">&#x27;101&#x27;</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;校验失败&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublishDetailView</span>(<span class="params">GenericAPIView</span>):</span></span><br><span class="line">    queryset = models.Publish.objects.all()</span><br><span class="line">    serializer_class = PublishSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request, pk</span>):</span></span><br><span class="line">        <span class="comment"># book_obj = models.Book.objects.filter(pk=pk).first()</span></span><br><span class="line">        book_obj = self.get_object()</span><br><span class="line">        book_ser = self.get_serializer(instance=book_obj)</span><br><span class="line">        <span class="keyword">return</span> Response(book_ser.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, request, pk</span>):</span></span><br><span class="line">        <span class="comment"># book_obj = models.Book.objects.filter(pk=pk).first()</span></span><br><span class="line">        book_obj = self.get_object()</span><br><span class="line">        book_ser = self.get_serializer(instance=book_obj, data=request.data)</span><br><span class="line">        <span class="keyword">if</span> book_ser.is_valid():</span><br><span class="line">            book_ser.save()</span><br><span class="line">            <span class="keyword">return</span> Response(data=book_ser.data, status=status.HTTP_200_OK)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;status&#x27;</span>: <span class="number">101</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;校验失败&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self, request, pk</span>):</span></span><br><span class="line">        self.get_object().delete()</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;status&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;删除成功&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="1-5-3-基于GenericAPIView和5个视图扩展类写的接口"><a href="#1-5-3-基于GenericAPIView和5个视图扩展类写的接口" class="headerlink" title="1.5.3 基于GenericAPIView和5个视图扩展类写的接口"></a>1.5.3 基于GenericAPIView和5个视图扩展类写的接口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.generics <span class="keyword">import</span> GenericAPIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.mixins <span class="keyword">import</span> ListModelMixin, CreateModelMixin, UpdateModelMixin, RetrieveModelMixin, DestroyModelMixin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book3View</span>(<span class="params">ListModelMixin, CreateModelMixin, GenericAPIView</span>):</span></span><br><span class="line">    queryset = models.Book.objects.all()</span><br><span class="line">    serializer_class = BookSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.list(request)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.create(request)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book3DetailView</span>(<span class="params">RetrieveModelMixin, DestroyModelMixin, UpdateModelMixin, GenericAPIView</span>):</span></span><br><span class="line">    queryset = models.Book.objects.all()</span><br><span class="line">    serializer_class = BookSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request, pk</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.retrieve(request, pk)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, request, pk</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.update(request, pk)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self, request, pk</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.destroy(request, pk)</span><br><span class="line">      </span><br><span class="line"><span class="comment">##### （第二种写法） ########</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book3View</span>(<span class="params">ListModelMixin, CreateModelMixin, GenericAPIView</span>):</span></span><br><span class="line">    queryset = models.Book.objects.all()</span><br><span class="line">    serializer_class = BookSerializer</span><br><span class="line"></span><br><span class="line">    get = ListModelMixin.list</span><br><span class="line">    post = CreateModelMixin.create</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book3DetailView</span>(<span class="params">RetrieveModelMixin, DestroyModelMixin, UpdateModelMixin, GenericAPIView</span>):</span></span><br><span class="line">    queryset = models.Book.objects.all()</span><br><span class="line">    serializer_class = BookSerializer</span><br><span class="line"></span><br><span class="line">    get = RetrieveModelMixin.get</span><br><span class="line"></span><br><span class="line">    put = UpdateModelMixin.update</span><br><span class="line">    </span><br><span class="line">    patch = UpdateModelMixin.partial_update</span><br><span class="line"></span><br><span class="line">    delete = DestroyModelMixin.delete</span><br></pre></td></tr></table></figure>

<h3 id="1-5-4-基于Generics的视图子类9个"><a href="#1-5-4-基于Generics的视图子类9个" class="headerlink" title="1.5.4 基于Generics的视图子类9个"></a>1.5.4 基于Generics的视图子类9个</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基于GenericAPIView的视图子类接口写的</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.generics <span class="keyword">import</span> CreateAPIView, ListAPIView, UpdateAPIView, DestroyAPIView, RetrieveAPIView, ListCreateAPIView, RetrieveUpdateDestroyAPIView,RetrieveDestroyAPIView,RetrieveUpdateAPIView</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># class Book4View(ListAPIView, CreateAPIView):</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book4View</span>(<span class="params">ListCreateAPIView</span>):</span></span><br><span class="line">    queryset = models.Book.objects.all()</span><br><span class="line">    serializer_class = BookSerializer</span><br><span class="line"></span><br><span class="line"><span class="comment"># class Book4DetailView(UpdateAPIView, DestroyAPIView, RetrieveAPIView):</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book4DetailView</span>(<span class="params">RetrieveUpdateDestroyAPIView</span>):</span></span><br><span class="line">    queryset = models.Book.objects.all()</span><br><span class="line">    serializer_class = BookSerializer</span><br></pre></td></tr></table></figure>

<h3 id="1-5-5-基于ModelViewSet-编写5个接口"><a href="#1-5-5-基于ModelViewSet-编写5个接口" class="headerlink" title="1.5.5 基于ModelViewSet 编写5个接口"></a>1.5.5 基于ModelViewSet 编写5个接口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ModelViewSet</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book5View</span>(<span class="params">ModelViewSet</span>):</span></span><br><span class="line">    queryset = models.Book.objects.all()</span><br><span class="line">    serializer_class = BookSerializer</span><br></pre></td></tr></table></figure>

<h2 id="1-6-ViewSetMixin-源码分析"><a href="#1-6-ViewSetMixin-源码分析" class="headerlink" title="1.6 ViewSetMixin 源码分析"></a>1.6 ViewSetMixin 源码分析</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重写了as_view()</span></span><br><span class="line"><span class="comment"># 核心代码(所以路由中只要配置了对应关系，比如&#123;&#x27;get&#x27;:&#x27;list&#x27;&#125;, 当get请求来，就会执行list方法)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> method, action <span class="keyword">in</span> actions.items():</span><br><span class="line">    <span class="comment"># method: get</span></span><br><span class="line">    <span class="comment"># action: list</span></span><br><span class="line">    handler = getattr(self, action)</span><br><span class="line">    <span class="comment"># 执行完上一句 handler 就变成了list的内存地址</span></span><br><span class="line">    setattr(self, method, handler)</span><br><span class="line">    <span class="comment"># 执行完上一句，对象.get = list</span></span><br><span class="line">    <span class="comment"># 通过反射赋值给原来self中没有的get, 让self 有get方法</span></span><br><span class="line">    <span class="comment"># for循环执行完毕，对象.get:对list 对象.post:对象.create</span></span><br><span class="line">    <span class="comment"># 下一次循环 对象.get: 对recrieve</span></span><br></pre></td></tr></table></figure>

<h3 id="1-6-1-继承VIewSetMixin的视图类"><a href="#1-6-1-继承VIewSetMixin的视图类" class="headerlink" title="1.6.1 继承VIewSetMixin的视图类"></a>1.6.1 继承VIewSetMixin的视图类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># views.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于ViewSetMixin的视图类</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ViewSetMixin</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book6View</span>(<span class="params">ViewSetMixin, APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_all_books</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        book_queryset = models.Book.objects.all()</span><br><span class="line">        book_ser = BookSerializer(instance=book_queryset, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(book_ser.data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># urls.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于ViewSetMixin的视图类，路由可以改写成这样</span></span><br><span class="line">path(<span class="string">&#x27;books6/&#x27;</span>, views.Book6View.as_view(actions=&#123;<span class="string">&#x27;get&#x27;</span>:<span class="string">&#x27;get_all_books&#x27;</span>&#125;)),</span><br></pre></td></tr></table></figure>

<p>f</p>
]]></content>
      <categories>
        <category>DRF</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>DRF-10-Xadmin</title>
    <url>/posts/39972.html</url>
    <content><![CDATA[<p>Xadmin</p>
<a id="more"></a>

<h1 id="一-Xadmin的使用"><a href="#一-Xadmin的使用" class="headerlink" title="一 Xadmin的使用"></a>一 Xadmin的使用</h1><p>xadmin是Django的第三方扩展，可是使Django的admin站点使用更方便。</p>
<p>文档：<a href="https://xadmin.readthedocs.io/en/latest/index.html">https://xadmin.readthedocs.io/en/latest/index.html</a></p>
<h2 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h2><p>通过如下命令安装xadmin的最新版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install https:&#x2F;&#x2F;codeload.github.com&#x2F;sshwsfc&#x2F;xadmin&#x2F;zip&#x2F;django2</span><br></pre></td></tr></table></figure>

<p>在配置文件中注册如下应用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BASE_DIR &#x3D; os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line"># 把apps目录设置环境变量中的导包路径</span><br><span class="line">sys.path.append( os.path.join(BASE_DIR,&quot;luffy&#x2F;apps&quot;) )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSTALLED_APPS &#x3D; [</span><br><span class="line">    ...</span><br><span class="line">    &#39;xadmin&#39;,</span><br><span class="line">    &#39;crispy_forms&#39;,</span><br><span class="line">    &#39;reversion&#39;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 修改使用中文界面</span><br><span class="line">LANGUAGE_CODE &#x3D; &#39;zh-Hans&#39;</span><br><span class="line"></span><br><span class="line"># 修改时区</span><br><span class="line">TIME_ZONE &#x3D; &#39;Asia&#x2F;Shanghai&#39;</span><br></pre></td></tr></table></figure>

<p>xadmin有建立自己的数据库模型类，需要进行数据库迁移</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<p>在总路由中添加xadmin的路由信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import xadmin</span><br><span class="line">xadmin.autodiscover()</span><br><span class="line"></span><br><span class="line"># version模块自动注册需要版本控制的 Model</span><br><span class="line">from xadmin.plugins import xversion</span><br><span class="line">xversion.register_models()</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    path(r&#39;xadmin&#x2F;&#39;, xadmin.site.urls)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>创建超级用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure>

<h2 id="1-2-使用"><a href="#1-2-使用" class="headerlink" title="1.2 使用"></a>1.2 使用</h2><ul>
<li>xadmin不再使用Django的admin.py，而是需要编写代码在adminx.py文件中。</li>
<li>xadmin的站点管理类不用继承<code>admin.ModelAdmin</code>，而是直接继承<code>object</code>即可。</li>
</ul>
<p>例如：在子应用中创建adminx.py文件。</p>
<h3 id="1-2-1-站点的全局配置"><a href="#1-2-1-站点的全局配置" class="headerlink" title="1.2.1 站点的全局配置"></a>1.2.1 站点的全局配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import xadmin</span><br><span class="line">from xadmin import views</span><br><span class="line"></span><br><span class="line">class BaseSetting(object):</span><br><span class="line">    &quot;&quot;&quot;xadmin的基本配置&quot;&quot;&quot;</span><br><span class="line">    enable_themes &#x3D; True  # 开启主题切换功能</span><br><span class="line">    use_bootswatch &#x3D; True</span><br><span class="line"></span><br><span class="line">xadmin.site.register(views.BaseAdminView, BaseSetting)</span><br><span class="line"></span><br><span class="line">class GlobalSettings(object):</span><br><span class="line">    &quot;&quot;&quot;xadmin的全局配置&quot;&quot;&quot;</span><br><span class="line">    site_title &#x3D; &quot;路飞学城&quot;  # 设置站点标题</span><br><span class="line">    site_footer &#x3D; &quot;路飞学城有限公司&quot;  # 设置站点的页脚</span><br><span class="line">    menu_style &#x3D; &quot;accordion&quot;  # 设置菜单折叠</span><br><span class="line"></span><br><span class="line">xadmin.site.register(views.CommAdminView, GlobalSettings)</span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-站点Model管理"><a href="#1-2-2-站点Model管理" class="headerlink" title="1.2.2 站点Model管理"></a>1.2.2 站点Model管理</h3><p>xadmin可以使用的页面样式控制基本与Django原生的admin一直。</p>
<ul>
<li><p><strong>list_display</strong> 控制列表展示的字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list_display &#x3D; [&#39;id&#39;, &#39;btitle&#39;, &#39;bread&#39;, &#39;bcomment&#39;]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>search_fields</strong> 控制可以通过搜索框搜索的字段名称，xadmin使用的是模糊查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search_fields &#x3D; [&#39;id&#39;,&#39;btitle&#39;]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>list_filter</strong> 可以进行过滤操作的列，对于分类、性别、状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list_filter &#x3D; [&#39;is_delete&#39;]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ordering</strong> 默认排序的字段</p>
</li>
<li><p><strong>readonly_fields</strong> 在编辑页面的只读字段</p>
</li>
<li><p><strong>exclude</strong> 在编辑页面隐藏的字段</p>
</li>
<li><p><strong>list_editable</strong> 在列表页可以快速直接编辑的字段</p>
</li>
<li><p><strong>show_detail_fields</strong> 在列表页提供快速显示详情信息</p>
</li>
<li><p><strong>refresh_times</strong> 指定列表页的定时刷新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">refresh_times &#x3D; [5, 10,30,60]  # 设置允许后端管理人员按多长时间(秒)刷新页面</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>list_export</strong> 控制列表页导出数据的可选格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list_export &#x3D; (&#39;xls&#39;, &#39;xml&#39;, &#39;json&#39;)   list_export设置为None来禁用数据导出功能</span><br><span class="line">list_export_fields &#x3D; (&#39;id&#39;, &#39;btitle&#39;, &#39;bpub_date&#39;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>show_bookmarks</strong> 控制是否显示书签功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show_bookmarks &#x3D; True</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>data_charts</strong> 控制显示图表的样式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data_charts &#x3D; &#123;</span><br><span class="line">        &quot;order_amount&quot;: &#123;</span><br><span class="line">          &#39;title&#39;: &#39;图书发布日期表&#39;, </span><br><span class="line">          &quot;x-field&quot;: &quot;bpub_date&quot;, </span><br><span class="line">          &quot;y-field&quot;: (&#39;btitle&#39;,),</span><br><span class="line">          &quot;order&quot;: (&#39;id&#39;,)</span><br><span class="line">        &#125;,</span><br><span class="line">    #    支持生成多个不同的图表</span><br><span class="line">    #    &quot;order_amount&quot;: &#123;</span><br><span class="line">    #      &#39;title&#39;: &#39;图书发布日期表&#39;, </span><br><span class="line">    #      &quot;x-field&quot;: &quot;bpub_date&quot;, </span><br><span class="line">    #      &quot;y-field&quot;: (&#39;btitle&#39;,),</span><br><span class="line">    #      &quot;order&quot;: (&#39;id&#39;,)</span><br><span class="line">    #    &#125;,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>title 控制图标名称</li>
<li>x-field 控制x轴字段</li>
<li>y-field 控制y轴字段，可以是多个值</li>
<li>order 控制默认排序</li>
</ul>
</li>
<li><p><strong>model_icon</strong> 控制菜单的图标</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BookInfoAdmin(object):</span><br><span class="line">    model_icon &#x3D; &#39;fa fa-gift&#39;</span><br><span class="line"></span><br><span class="line">xadmin.site.register(models.BookInfo, BookInfodmin)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>DRF</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>DRF-11-Book系列多表群操作</title>
    <url>/posts/61140.html</url>
    <content><![CDATA[<p>多表群操作注意点  基础表设置和继承/on_delete 设置</p>
<a id="more"></a>

<h1 id="Book系列连表接口"><a href="#Book系列连表接口" class="headerlink" title="Book系列连表接口"></a>Book系列连表接口</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">优先选择GenericAPIView</span><br><span class="line"></span><br><span class="line">示例按照APIView写</span><br><span class="line"><span class="comment"># get多条的时候，many=True 就可以判断出， ListSerializer 可以序列化 类列表对象，多条数据是QuerySet[数据对象1, 数据对象2]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># post 判断是字典 还是列表  列表单条 -- 字典多条（many=True）  </span></span><br><span class="line"><span class="number">1.</span> post 提交，单个增加</span><br><span class="line">   book_ser.is_valid(raise_exception=<span class="literal">True</span>) 校验时，可以直接抛异常，然后全局捕获</span><br><span class="line">2. post 增  多个增加  需要设置many=True---&gt; ListSerializer对象</span><br><span class="line"><span class="comment"># .save 新增 --&gt; ListSerializer --&gt; create方法</span></span><br><span class="line">    self.child 就是BookModelSerializer对象</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">self, validated_data</span>):</span></span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">        self.child.create(attrs) <span class="keyword">for</span> attrs <span class="keyword">in</span> validated_data</span><br><span class="line">      ]</span><br><span class="line">update的时候需要自己写，因为并不清楚传输的数据格式是什么样子的。带不带id之类的。 新增可以是因为就需要你传输对应的字段，且不需要携带id。</span><br><span class="line"></span><br><span class="line">3. put 判断有没有pk  带pk--&gt; 单改   不带pk--&gt; 群改</span><br><span class="line">   多条: 后端规定数据格式为 列表套字典 [&#123;&#125;, &#123;&#125;]</span><br><span class="line"></span><br><span class="line">   不能再用BookModelSerializer ，它只能处理单条</span><br><span class="line">   需要再定义一个BookListSerializer，重写他的update方法</span><br><span class="line">    </span><br><span class="line">第一种方案:</span><br><span class="line">  改多个</span><br><span class="line">  前端传递数据格式[&#123;id:<span class="number">1</span>, name:xx, price:xx&#125;, &#123;id:<span class="number">2</span>, name:xx, price:xx&#125;]</span><br><span class="line">      需要把id拿出来找到数据对象,再传入修改的数据;然后:book_ser=BookModelSerializer(instance=book, data=request.data)</span><br><span class="line">                                                book_ser.is_valid() --&gt; book_ser.save</span><br><span class="line">  处理传入的数据 对象列表[book1, book2]  修改的数据列表 [&#123;name:xx, price:xx&#125;,&#123;name:xx, price:xx&#125;]</span><br><span class="line">  第一种方案，<span class="keyword">for</span>循环，多写几遍 ,一个个修改</span><br><span class="line"></span><br><span class="line">第二种方案:</span><br><span class="line">  本质也是<span class="keyword">for</span> 循环</span><br><span class="line">  <span class="comment"># 重写ListSerializer的update方法 更新的时候 让其关联我们自己的update方法</span></span><br><span class="line">  <span class="comment"># book_ser = BookModelSerializer(instance=对象列表, data=修改的数据列表, many=True)</span></span><br><span class="line">  <span class="comment"># book_ser.is_valid(raise_exception=True)</span></span><br><span class="line">  <span class="comment"># book_ser.save()   ---&gt; ListSerializer的update方法</span></span><br><span class="line">  </span><br><span class="line">需要再序列化类中Meta 里设置 list_serializer_class = BookListSerializer  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookListSerializer</span>(<span class="params">serializers.ListSerializer</span>):</span></span><br><span class="line">    <span class="comment"># def create(self, validated_data):</span></span><br><span class="line">    <span class="comment">#     print(validated_data)</span></span><br><span class="line">    <span class="comment">#     return super(BookListSerializer, self).create(validated_data)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, instance, validated_data</span>):</span></span><br><span class="line">        print(instance)</span><br><span class="line">        print(validated_data)</span><br><span class="line">        <span class="comment"># self.child: 是BookModelSerializer 对象</span></span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            self.child.update(instance[i], attrs) <span class="keyword">for</span> i, attrs <span class="keyword">in</span> enumerate(validated_data)</span><br><span class="line">        ]</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="number">4.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="views-py"><a href="#views-py" class="headerlink" title="views.py"></a>views.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ModelViewSet</span><br><span class="line"><span class="keyword">from</span> app01.models <span class="keyword">import</span> Book</span><br><span class="line"><span class="comment"># from app01.ser import BookSerializers</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> action</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.authentication <span class="keyword">import</span> SessionAuthentication, BasicAuthentication</span><br><span class="line"><span class="comment"># class TestView(APIView):</span></span><br><span class="line"><span class="comment">#     def get(self,request):</span></span><br><span class="line"><span class="comment">#         1/0</span></span><br><span class="line"><span class="comment">#         return Response(&#123;&#x27;msg&#x27;:&#x27;个人中心&#x27;&#125;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># class BookViewSet(ModelViewSet):</span></span><br><span class="line"><span class="comment">#     authentication_classes = [BasicAuthentication,]</span></span><br><span class="line"><span class="comment">#     queryset = Book.objects.all()</span></span><br><span class="line"><span class="comment">#     serializer_class = BookSerializers</span></span><br><span class="line">    <span class="comment"># @action(methods=[&#x27;get&#x27;], detail=False)</span></span><br><span class="line">    <span class="comment"># def login(self, request):</span></span><br><span class="line">    <span class="comment">#     Book.objects.update_or_create()</span></span><br><span class="line">    <span class="comment">#     return Response(&#123;&#x27;msg&#x27;:&#x27;登陆成功&#x27;&#125;)</span></span><br><span class="line">    <span class="comment"># @action(methods=[&#x27;put&#x27;], detail=True)</span></span><br><span class="line">    <span class="comment"># def get_new_5(self, request,pk):</span></span><br><span class="line">    <span class="comment">#     return Response(&#123;&#x27;msg&#x27;:&#x27;获取5条数据成功&#x27;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> AllowAny,IsAuthenticated,IsAdminUser,IsAuthenticatedOrReadOnly</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> app01.response <span class="keyword">import</span> APIResponse</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> ser <span class="keyword">as</span> serializers</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublishAPIView</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        pk = kwargs.get(<span class="string">&#x27;pk&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> pk:</span><br><span class="line">            publish_obj = models.Publish.objects.filter(pk=pk).first()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> publish_obj:</span><br><span class="line">                <span class="keyword">return</span> APIResponse(<span class="number">1</span>, <span class="string">&#x27;pk error&#x27;</span>, http_status=<span class="number">400</span>)</span><br><span class="line">            publish_data = serializers.PublishModelSerializer(publish_obj).data</span><br><span class="line">            <span class="keyword">return</span> APIResponse(results=publish_data)</span><br><span class="line"></span><br><span class="line">        publish_query = models.Publish.objects.all()</span><br><span class="line">        <span class="keyword">return</span> APIResponse(<span class="number">0</span>, <span class="string">&#x27;ok&#x27;</span>, data=serializers.PublishModelSerializer(publish_query, many=<span class="literal">True</span>).data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookAPIView</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="comment"># 单查、群查</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        pk = kwargs.get(<span class="string">&#x27;pk&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> pk:</span><br><span class="line">            book_obj = models.Book.objects.filter(pk=pk, is_delete=<span class="literal">False</span>).first()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> book_obj:</span><br><span class="line">                <span class="keyword">return</span> APIResponse(<span class="number">1</span>, <span class="string">&#x27;pk error&#x27;</span>, http_status=<span class="number">400</span>)</span><br><span class="line">            book_data = serializers.BookModelSerializer(book_obj).data</span><br><span class="line">            print(book_data)</span><br><span class="line">            <span class="keyword">return</span> APIResponse(data=book_data)</span><br><span class="line"></span><br><span class="line">        book_query = models.Book.objects.filter(is_delete=<span class="literal">False</span>).all()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> APIResponse(<span class="number">0</span>, <span class="string">&#x27;ok&#x27;</span>, data=serializers.BookModelSerializer(book_query, many=<span class="literal">True</span>).data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单删、群删</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        单删：前台数据为pk，接口为 /books/(pk)/</span></span><br><span class="line"><span class="string">        群删：前台数据为pks，接口为 /books/</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        pk = kwargs.get(<span class="string">&#x27;pk&#x27;</span>)</span><br><span class="line">        <span class="comment"># 将单删群删逻辑整合</span></span><br><span class="line">        <span class="keyword">if</span> pk:  <span class="comment"># /books/(pk)/的接口就不考虑群删，就固定为单删</span></span><br><span class="line">            pks = [pk]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pks = request.data.get(<span class="string">&#x27;pks&#x27;</span>)</span><br><span class="line">        <span class="comment"># 前台数据有误(主要是群删没有提供pks)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pks:</span><br><span class="line">            <span class="keyword">return</span> APIResponse(<span class="number">1</span>, <span class="string">&#x27;delete error&#x27;</span>, http_status=<span class="number">400</span>)</span><br><span class="line">        <span class="comment"># 只要有操作受影响行，就是删除成功，反之失败</span></span><br><span class="line">        rows = models.Book.objects.filter(is_delete=<span class="literal">False</span>, pk__in=pks).update(is_delete=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> rows:</span><br><span class="line">            <span class="keyword">return</span> APIResponse(<span class="number">0</span>, <span class="string">&#x27;delete ok&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> APIResponse(<span class="number">1</span>, <span class="string">&#x27;delete failed&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单增、群增</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        单增：前台提交字典，接口 /books/</span></span><br><span class="line"><span class="string">        群增：前台提交列表套字典，接口 /books/</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        request_data = request.data</span><br><span class="line">        <span class="keyword">if</span> isinstance(request_data, dict):  <span class="comment"># 单增</span></span><br><span class="line">            book_ser = serializers.BookModelSerializer(data=request_data)</span><br><span class="line">            <span class="keyword">if</span> book_ser.is_valid():</span><br><span class="line">                book_obj = book_ser.save()</span><br><span class="line">                <span class="keyword">return</span> APIResponse(data=serializers.BookModelSerializer(book_obj).data)</span><br><span class="line">            <span class="keyword">return</span> APIResponse(<span class="number">1</span>, msg=book_ser.errors)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(request_data, list) <span class="keyword">and</span> len(request_data) != <span class="number">0</span> :  <span class="comment"># 群增</span></span><br><span class="line">            book_ser = serializers.BookModelSerializer(data=request_data, many=<span class="literal">True</span>)</span><br><span class="line">            book_ser.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">            book_obj_list = book_ser.save()</span><br><span class="line">            <span class="keyword">return</span> APIResponse(data=serializers.BookModelSerializer(book_obj_list, many=<span class="literal">True</span>).data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> APIResponse(<span class="number">1</span>, <span class="string">&#x27;data error&#x27;</span>, http_status=<span class="number">400</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单整体改、群整体改</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        单整体改：前台提交字典，接口 /books/(pk)/</span></span><br><span class="line"><span class="string">        群整体改：前台提交列表套字典，接口 /books/，注每一个字典都可以通过pk</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        pk = kwargs.get(<span class="string">&#x27;pk&#x27;</span>)</span><br><span class="line">        request_data = request.data</span><br><span class="line">        <span class="keyword">if</span> pk: <span class="comment"># 单改</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                book_obj = models.Book.objects.get(pk=pk)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">return</span> APIResponse(<span class="number">1</span>, <span class="string">&#x27;pk error&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 修改和新增，都需要通过数据，数据依旧给data，修改与新增不同点，instance要被赋值为被修改对象</span></span><br><span class="line">            book_ser = serializers.BookModelSerializer(instance=book_obj, data=request_data)</span><br><span class="line">            book_ser.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">            book_obj = book_ser.save()</span><br><span class="line">            <span class="keyword">return</span> APIResponse(data=serializers.BookModelSerializer(book_obj).data)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 群改</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isinstance(request_data, list) <span class="keyword">or</span> len(request_data) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> APIResponse(<span class="number">1</span>, <span class="string">&#x27;data error&#x27;</span>, http_status=<span class="number">400</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># [&#123;pk:1,...&#125;, &#123;pk:3,...&#125;, &#123;pk:100,...&#125;] =&gt; [obj1, obj3, obj100] + [&#123;...&#125;, &#123;...&#125;, &#123;...&#125;]</span></span><br><span class="line">            <span class="comment"># 要考虑pk对应的对象是否被删，以及pk没有对应的对象</span></span><br><span class="line">            <span class="comment"># 假设pk3被删，pk100没有 =&gt; [obj1] + [&#123;...&#125;]</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 注：一定不要在循环体中对循环对象进行增删(影响对象长度)的操作</span></span><br><span class="line">            obj_list = []</span><br><span class="line">            data_list = []</span><br><span class="line">            <span class="keyword">for</span> dic <span class="keyword">in</span> request_data:</span><br><span class="line">                <span class="comment"># request_data可能是list，单内部不一定是dict</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    pk = dic.pop(<span class="string">&#x27;pk&#x27;</span>)</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        obj = models.Book.objects.get(pk=pk, is_delete=<span class="literal">False</span>)</span><br><span class="line">                        obj_list.append(obj)</span><br><span class="line">                        data_list.append(dic)</span><br><span class="line">                    <span class="keyword">except</span>:</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="keyword">return</span> APIResponse(<span class="number">1</span>, <span class="string">&#x27;data error&#x27;</span>, http_status=<span class="number">400</span>)</span><br><span class="line"></span><br><span class="line">            book_ser = serializers.BookModelSerializer(instance=obj_list, data=data_list, many=<span class="literal">True</span>)</span><br><span class="line">            book_ser.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">            book_obj_list = book_ser.save()</span><br><span class="line">            <span class="keyword">return</span> APIResponse(data=serializers.BookModelSerializer(book_obj_list, many=<span class="literal">True</span>).data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单局部改、群局部改</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">patch</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        单整体改：前台提交字典，接口 /books/(pk)/</span></span><br><span class="line"><span class="string">        群整体改：前台提交列表套字典，接口 /books/，注每一个字典都可以通过pk</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        pk = kwargs.get(<span class="string">&#x27;pk&#x27;</span>)</span><br><span class="line">        request_data = request.data</span><br><span class="line">        <span class="keyword">if</span> pk:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                book_obj = models.Book.objects.get(pk=pk)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">return</span> APIResponse(<span class="number">1</span>, <span class="string">&#x27;pk error&#x27;</span>)</span><br><span class="line">            <span class="comment"># 局部修改就是在整体修改基础上设置partial=True，将所有参与反序列化字段设置为required=False</span></span><br><span class="line">            book_ser = serializers.BookModelSerializer(instance=book_obj, data=request_data, partial=<span class="literal">True</span>)</span><br><span class="line">            book_ser.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">            book_obj = book_ser.save()</span><br><span class="line">            <span class="keyword">return</span> APIResponse(data=serializers.BookModelSerializer(book_obj).data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 群改</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isinstance(request_data, list) <span class="keyword">or</span> len(request_data) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> APIResponse(<span class="number">1</span>, <span class="string">&#x27;data error&#x27;</span>, http_status=<span class="number">400</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># [&#123;pk:1,...&#125;, &#123;pk:3,...&#125;, &#123;pk:100,...&#125;] =&gt; [obj1, obj3, obj100] + [&#123;...&#125;, &#123;...&#125;, &#123;...&#125;]</span></span><br><span class="line">            <span class="comment"># 要考虑pk对应的对象是否被删，以及pk没有对应的对象</span></span><br><span class="line">            <span class="comment"># 假设pk3被删，pk100没有 =&gt; [obj1] + [&#123;...&#125;]</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 注：一定不要在循环体中对循环对象进行增删(影响对象长度)的操作</span></span><br><span class="line">            obj_list = []</span><br><span class="line">            data_list = []</span><br><span class="line">            <span class="keyword">for</span> dic <span class="keyword">in</span> request_data:</span><br><span class="line">                <span class="comment"># request_data可能是list，单内部不一定是dict</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    pk = dic.pop(<span class="string">&#x27;pk&#x27;</span>)</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        obj = models.Book.objects.get(pk=pk, is_delete=<span class="literal">False</span>)</span><br><span class="line">                        obj_list.append(obj)</span><br><span class="line">                        data_list.append(dic)</span><br><span class="line">                    <span class="keyword">except</span>:</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="keyword">return</span> APIResponse(<span class="number">1</span>, <span class="string">&#x27;data error&#x27;</span>, http_status=<span class="number">400</span>)</span><br><span class="line"></span><br><span class="line">            book_ser = serializers.BookModelSerializer(instance=obj_list, data=data_list, many=<span class="literal">True</span>, partial=<span class="literal">True</span>)</span><br><span class="line">            book_ser.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">            book_obj_list = book_ser.save()</span><br><span class="line">            <span class="keyword">return</span> APIResponse(data=serializers.BookModelSerializer(book_obj_list, many=<span class="literal">True</span>).data)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthorAPIView</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request,*args,**kwargs</span>):</span></span><br><span class="line">        authors=models.Author.objects.all()</span><br><span class="line">        author_ser=serializers.AuthorModelSerializer(authors,many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> APIResponse(data=author_ser.data)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self,reuqest,*args,**kwargs</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self,request,*args,**kwargs</span>):</span></span><br><span class="line">        author_ser=serializers.AuthorModelSerializer(data=request.data)</span><br><span class="line">        author_ser.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        author_ser.save()</span><br><span class="line">        <span class="keyword">return</span> APIResponse()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self,request,*args,**kwargs</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="ser-py"><a href="#ser-py" class="headerlink" title="ser.py"></a>ser.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 如果序列化的是数据库的表，尽量用ModelSerializer</span><br><span class="line"><span class="number">2.</span> 自己序列化一些东西，用Serializer</span><br><span class="line"></span><br><span class="line">ModelSerializer</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> depth = <span class="number">1</span> 只显示一层</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>序列化字段，可以重写字段； 反序列化需要考虑是否有问题。</span><br><span class="line"></span><br><span class="line">  第二种方案: models 里面可以写方法包装成数据属性@property或者定义SerializerField; 定义扩展字段,然后直接source 字段调用，或者直接写到fields</span><br><span class="line">    fields = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;price&#x27;</span>, <span class="string">&#x27;publish_name&#x27;</span>, <span class="string">&#x27;author_list&#x27;</span>, <span class="string">&#x27;publish&#x27;</span>, <span class="string">&#x27;authors&#x27;</span>)</span><br><span class="line"><span class="number">5.</span> 扩展字段定义些属性如write_only read_only</span><br><span class="line">extra_kwargs = &#123;</span><br><span class="line">            <span class="string">&#x27;publish&#x27;</span>: &#123;<span class="string">&#x27;write_only&#x27;</span>: <span class="literal">True</span>&#125;,</span><br><span class="line">            <span class="string">&#x27;publish_name&#x27;</span>: &#123;<span class="string">&#x27;read_only&#x27;</span>: <span class="literal">True</span>&#125;,</span><br><span class="line">            <span class="string">&#x27;authors&#x27;</span>: &#123;<span class="string">&#x27;write_only&#x27;</span>: <span class="literal">True</span>&#125;,</span><br><span class="line">            <span class="string">&#x27;author_list&#x27;</span>: &#123;<span class="string">&#x27;read_only&#x27;</span>: <span class="literal">True</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">models里面定义方法</span><br><span class="line"><span class="meta">@property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">author_list</span>(<span class="params">self</span>):</span></span><br><span class="line">        temp_author_list = []</span><br><span class="line">        <span class="keyword">for</span> author <span class="keyword">in</span> self.authors.all():</span><br><span class="line">            temp_author_list.append(&#123;</span><br><span class="line">                <span class="string">&#x27;name&#x27;</span>: author.name,</span><br><span class="line">                <span class="string">&#x27;sex&#x27;</span>: author.get_sex_display(),</span><br><span class="line">                <span class="string">&#x27;mobile&#x27;</span>: author.detail.mobile</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">return</span> temp_author_list</span><br><span class="line">      </span><br><span class="line"><span class="number">6.</span> </span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookListSerializer</span>(<span class="params">serializers.ListSerializer</span>):</span></span><br><span class="line">    <span class="comment"># 1、create方法父级ListSerializer已经提供了</span></span><br><span class="line">    <span class="comment"># def create(self, validated_data):</span></span><br><span class="line">    <span class="comment">#     # 通过self.child来访问绑定的ModelSerializer</span></span><br><span class="line">    <span class="comment">#     print(self.child)</span></span><br><span class="line">    <span class="comment">#     raise Exception(&#x27;我不提供&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2、父级ListSerializer没有通过update方法的实现体，需要自己重写</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, instance, validated_data</span>):</span></span><br><span class="line">        <span class="comment"># print(instance)</span></span><br><span class="line">        <span class="comment"># print(validated_data)</span></span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            self.child.update(instance[i], attrs) <span class="keyword">for</span> i, attrs <span class="keyword">in</span> enumerate(validated_data)</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookModelSerializer</span>(<span class="params">serializers.ModelSerializer</span>):</span></span><br><span class="line">    <span class="comment"># 通过BookModelSerializer.Meta.list_serializer_class来访问绑定的ListSerializer</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        <span class="comment"># 关联ListSerializer完成群增群改</span></span><br><span class="line">        list_serializer_class = BookListSerializer</span><br><span class="line"></span><br><span class="line">        model = models.Book</span><br><span class="line">        <span class="comment"># fields = (&#x27;name&#x27;, &#x27;price&#x27;, &#x27;publish&#x27;, &#x27;authors&#x27;)</span></span><br><span class="line">        <span class="comment"># fields = (&#x27;name&#x27;, &#x27;price&#x27;, &#x27;publish_name&#x27;, &#x27;author_list&#x27;)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 了解</span></span><br><span class="line">        <span class="comment"># fields = &#x27;__all__&#x27;</span></span><br><span class="line">        <span class="comment"># exclude = (&#x27;id&#x27;, )</span></span><br><span class="line">        <span class="comment"># depth = 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 序列化与反序列化整合</span></span><br><span class="line">        fields = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;price&#x27;</span>, <span class="string">&#x27;publish_name&#x27;</span>, <span class="string">&#x27;author_list&#x27;</span>, <span class="string">&#x27;publish&#x27;</span>, <span class="string">&#x27;authors&#x27;</span>)</span><br><span class="line">        extra_kwargs = &#123;</span><br><span class="line">            <span class="string">&#x27;publish&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;write_only&#x27;</span>: <span class="literal">True</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&#x27;authors&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;write_only&#x27;</span>: <span class="literal">True</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前提：如果只有查需求的接口，自定义深度还可以用子序列化方式完成</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublishModelSerializer</span>(<span class="params">serializers.ModelSerializer</span>):</span></span><br><span class="line">    <span class="comment"># 子序列化都是提供给外键(正向方向)完成深度查询的，外键数据是唯一：many=False；不唯一：many=True</span></span><br><span class="line">    <span class="comment"># 注：只能参与序列化，且反序列化不能写(反序列化外键字段会抛异常)</span></span><br><span class="line">    books = BookModelSerializer(many=<span class="literal">True</span>)</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = models.Publish</span><br><span class="line">        fields = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;address&#x27;</span>, <span class="string">&#x27;books&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthorModelSerializer</span>(<span class="params">serializers.ModelSerializer</span>):</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model=models.Author</span><br><span class="line">        fields=(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;sex&#x27;</span>,<span class="string">&#x27;mobile&#x27;</span>,<span class="string">&#x27;mobile_in&#x27;</span>)</span><br><span class="line">        extra_kwargs=&#123;</span><br><span class="line">            <span class="string">&#x27;mobile&#x27;</span>:&#123;</span><br><span class="line">                <span class="string">&#x27;read_only&#x27;</span>: <span class="literal">True</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    mobile_in=serializers.CharField(write_only=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># def validate_mobile_in(self, data):</span></span><br><span class="line">    <span class="comment">#     print(data)</span></span><br><span class="line">    <span class="comment">#     return data</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">self, validated_data</span>):</span></span><br><span class="line">        print(validated_data)</span><br><span class="line">        mobile=validated_data.pop(<span class="string">&#x27;mobile_in&#x27;</span>)</span><br><span class="line">        author=models.Author.objects.create(**validated_data)</span><br><span class="line">        authordetail=models.AuthorDetail.objects.create(mobile=mobile,author=author)</span><br><span class="line">        <span class="keyword">return</span> author</span><br></pre></td></tr></table></figure>

<h2 id="models-py"><a href="#models-py" class="headerlink" title="models.py"></a>models.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 外键: OneToOne 本质就是Foreign + Unique，自己手写也可以</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 抽离基表 BaseModel, 其他表继承；不会创建，抽象表。</span><br><span class="line">abstract=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>外键设置 db_constraint=<span class="literal">False</span>；逻辑关联，实际没有外键联系</span><br><span class="line"><span class="comment"># 二、表断关联</span></span><br><span class="line"><span class="comment"># 1、表之间没有外键关联，但是有外键逻辑关联(有充当外键的字段)</span></span><br><span class="line"><span class="comment"># 2、断关联后不会影响数据库查询效率，但是会极大提高数据库增删改效率（不影响增删改查操作）</span></span><br><span class="line"><span class="comment"># 3、断关联一定要通过逻辑保证表之间数据的安全</span></span><br><span class="line"><span class="comment"># 4、断关联</span></span><br><span class="line"><span class="comment"># 5、级联关系</span></span><br><span class="line"><span class="comment">#       作者没了，详情也没：on_delete=models.CASCADE</span></span><br><span class="line"><span class="comment">#       出版社没了，书还是那个出版社出版：on_delete=models.DO_NOTHING</span></span><br><span class="line"><span class="comment">#       部门没了，员工没有部门(空不能)：null=True, on_delete=models.SET_NULL</span></span><br><span class="line"><span class="comment">#       部门没了，员工进入默认部门(默认值)：default=0, on_delete=models.SET_DEFAULT</span></span><br><span class="line"></span><br><span class="line">3. 多对多，什么时候用自动，什么时候用手动  ---&gt;  也需要设置db_constraint=False</span><br><span class="line">自动：只有表名_id字段，不扩展字段</span><br><span class="line">手动: 有扩展字段的时候，手动（through，through_fields）</span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一、基表</span></span><br><span class="line"><span class="comment"># Model类的内部配置Meta类要设置abstract=True，这样的Model类就是用来作为基表;配置bstract=True之后不在数据库中建表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多表：Book，Publish，Author，AuthorDetail</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseModel</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    is_delete = models.BooleanField(default=<span class="literal">False</span>)</span><br><span class="line">    create_time = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        <span class="comment"># 基表必须设置abstract，基表就是给普通Model类继承使用的，设置了abstract就不会完成数据库迁移完成建表</span></span><br><span class="line">        abstract = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">16</span>)</span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">5</span>, decimal_places=<span class="number">2</span>)</span><br><span class="line">    publish = models.ForeignKey(to=<span class="string">&#x27;Publish&#x27;</span>, related_name=<span class="string">&#x27;books&#x27;</span>, db_constraint=<span class="literal">False</span>, on_delete=models.DO_NOTHING)</span><br><span class="line">    <span class="comment"># 重点：多对多外键实际在关系表中，ORM默认关系表中两个外键都是级联</span></span><br><span class="line">    <span class="comment"># ManyToManyField字段不提供设置on_delete，如果想设置关系表级联，只能手动定义关系表</span></span><br><span class="line">    authors = models.ManyToManyField(to=<span class="string">&#x27;Author&#x27;</span>, related_name=<span class="string">&#x27;books&#x27;</span>, db_constraint=<span class="literal">False</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 自定义连表深度，不需要反序列化，因为自定义插拔属性不参与反序列化</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">publish_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.publish.name</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">author_list</span>(<span class="params">self</span>):</span></span><br><span class="line">        temp_author_list = []</span><br><span class="line">        <span class="keyword">for</span> author <span class="keyword">in</span> self.authors.all():</span><br><span class="line">            temp_author_list.append(&#123;</span><br><span class="line">                <span class="string">&#x27;name&#x27;</span>: author.name,</span><br><span class="line">                <span class="string">&#x27;sex&#x27;</span>: author.get_sex_display(),</span><br><span class="line">                <span class="string">&#x27;mobile&#x27;</span>: author.detail.mobile</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">return</span> temp_author_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publish</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">16</span>)</span><br><span class="line">    address = models.CharField(max_length=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">16</span>)</span><br><span class="line">    sex = models.IntegerField(choices=[(<span class="number">0</span>, <span class="string">&#x27;男&#x27;</span>),(<span class="number">1</span>, <span class="string">&#x27;女&#x27;</span>)], default=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthorDetail</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    mobile = models.CharField(max_length=<span class="number">11</span>)</span><br><span class="line">    <span class="comment"># 有作者可以没有详情，删除作者，详情一定会被级联删除</span></span><br><span class="line">    <span class="comment"># 外键字段为正向查询字段，related_name是反向查询字段</span></span><br><span class="line">    author = models.OneToOneField(to=<span class="string">&#x27;Author&#x27;</span>, related_name=<span class="string">&#x27;detail&#x27;</span>, db_constraint=<span class="literal">False</span>, on_delete=models.CASCADE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二、表断关联</span></span><br><span class="line"><span class="comment"># 1、表之间没有外键关联，但是有外键逻辑关联(有充当外键的字段)</span></span><br><span class="line"><span class="comment"># 2、断关联后不会影响数据库查询效率，但是会极大提高数据库增删改效率（不影响增删改查操作）</span></span><br><span class="line"><span class="comment"># 3、断关联一定要通过逻辑保证表之间数据的安全</span></span><br><span class="line"><span class="comment"># 4、断关联</span></span><br><span class="line"><span class="comment"># 5、级联关系</span></span><br><span class="line"><span class="comment">#       作者没了，详情也没：on_delete=models.CASCADE</span></span><br><span class="line"><span class="comment">#       出版社没了，书还是那个出版社出版：on_delete=models.DO_NOTHING</span></span><br><span class="line"><span class="comment">#       部门没了，员工没有部门(空不能)：null=True, on_delete=models.SET_NULL</span></span><br><span class="line"><span class="comment">#       部门没了，员工进入默认部门(默认值)：default=0, on_delete=models.SET_DEFAULT</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 三、ORM外键设计</span></span><br><span class="line"><span class="comment"># 1、一对多：外键放在多的一方</span></span><br><span class="line"><span class="comment"># 2、多对多：外键放在常用的一方</span></span><br><span class="line"><span class="comment"># 3、一对一：外键放在不常用的一方</span></span><br><span class="line"><span class="comment"># 4、外键字段为正向查询字段，related_name是反向查询字段</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># from django.contrib.auth.models import AbstractUser, User</span></span><br><span class="line"><span class="comment"># class MyUser(AbstractUser):</span></span><br><span class="line"><span class="comment">#     pass</span></span><br></pre></td></tr></table></figure>

<h2 id="setting-py"><a href="#setting-py" class="headerlink" title="setting.py"></a>setting.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LANGUAGE_CODE = <span class="string">&#x27;zh-hans&#x27;</span></span><br><span class="line"></span><br><span class="line">TIME_ZONE = <span class="string">&#x27;Asia/shanghai&#x27;</span></span><br><span class="line"></span><br><span class="line">USE_I18N = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">USE_L10N = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">USE_TZ = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="urls-py"><a href="#urls-py" class="headerlink" title="urls.py"></a>urls.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path(<span class="string">r&#x27;publishes/&#x27;</span>, views.PublishAPIView.as_view()),</span><br><span class="line">re_path(<span class="string">r&#x27;^publishes/(?P&lt;pk&gt;\d+)/$&#x27;</span>, views.PublishAPIView.as_view()),</span><br><span class="line"></span><br><span class="line">path(<span class="string">r&#x27;books/&#x27;</span>, views.BookAPIView.as_view()),</span><br><span class="line">re_path(<span class="string">r&#x27;^books/(?P&lt;pk&gt;\d+)/$&#x27;</span>, views.BookAPIView.as_view()),</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DRF</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>DRF-09-JWT</title>
    <url>/posts/64081.html</url>
    <content><![CDATA[<p>JWT</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 前提: </span><br><span class="line"> </span><br><span class="line">  md5                固定长度, 不可反解</span><br><span class="line">  base64 编码(字符串)  变长, 可反解</span><br><span class="line"></span><br><span class="line">jwt : 三部分组成: header + payload + 签名</span><br><span class="line">    header:  类型jwt +  加密的算法SHA256</span><br><span class="line">    payload: 荷载信息(用户相关信息)</span><br><span class="line">    签名: (header(base64后的) + payload(base64后的)) &#x3D;&#x3D;&gt; 组成字符串  通过header中的加密算法 + secret盐 加密 </span><br><span class="line">前两端 用 base64编码，签名由前两段编码 + 签名用某种加密方式(md5)加密</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">refresh_token 作用：校验token有效性，然后刷新token</span><br></pre></td></tr></table></figure>



<p>JWT 的使用方式<br>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p>
<p>前端存储数据三种方式: localstorage sessionstorage cookie</p>
<p>sessionstorage  关闭页面就没了</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">&#x27;hou&#x27;</span>, JSON.stringify(info));</span><br><span class="line">localStorage.setItem(<span class="string">&#x27;zheng&#x27;</span>, str);</span><br><span class="line"></span><br><span class="line">this.$cookies.remove(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">this.$cookies.remove(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">3.0</span> </span><br><span class="line">sessionStorage.setItem(<span class="string">&#x27;user&#x27;</span>, JSON.stringify(userEntity));</span><br><span class="line"></span><br><span class="line"><span class="number">3.1</span> 通过getItem()方法取值</span><br><span class="line">sessionStorage.getItem(&#x27;testKey&#x27;); // =&gt; 返回testKey对应的值</span><br><span class="line"></span><br><span class="line"><span class="number">3.2</span> 通过属性方式取值</span><br><span class="line">sessionStorage[&#x27;testKey&#x27;]; // =&gt; 这是一个测试的value值</span><br></pre></td></tr></table></figure>



<h1 id="一-JWT认证"><a href="#一-JWT认证" class="headerlink" title="一 JWT认证"></a>一 JWT认证</h1><p>在用户注册或登录后，我们想记录用户的登录状态，或者为用户创建身份认证的凭证。我们不再使用Session认证机制，而使用Json Web Token（本质就是token）认证机制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggprivsr69j31i50u0tao.jpg" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggpriyyay5j31i80u03zl.jpg" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggprj27cflj31fq0u0abx.jpg" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggprj5moolj31ob0u0q4w.jpg" alt="img"></p>
<h2 id="1-1-构成和工作原理"><a href="#1-1-构成和工作原理" class="headerlink" title="1.1 构成和工作原理"></a>1.1 构成和工作原理</h2><h3 id="JWT的构成"><a href="#JWT的构成" class="headerlink" title="JWT的构成"></a>JWT的构成</h3><p>JWT就是一段字符串，由三段信息构成的，将这三段信息文本用<code>.</code>链接一起就构成了Jwt字符串。就像这样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre></td></tr></table></figure>

<p>第一部分我们称它为头部（header),第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature).</p>
<h3 id="1-1-1-header"><a href="#1-1-1-header" class="headerlink" title="1.1.1 header"></a>1.1.1 header</h3><p>jwt的头部承载两部分信息：</p>
<ul>
<li>声明类型，这里是jwt</li>
<li>声明加密的算法 通常直接使用 HMAC SHA256</li>
</ul>
<p>完整的头部就像下面这样的JSON：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#39;typ&#39;: &#39;JWT&#39;,</span><br><span class="line">  &#39;alg&#39;: &#39;HS256&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</span><br></pre></td></tr></table></figure>

<h3 id="1-1-2-payload"><a href="#1-1-2-payload" class="headerlink" title="1.1.2 payload"></a>1.1.2 payload</h3><p>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</p>
<ul>
<li>标准中注册的声明</li>
<li>公共的声明</li>
<li>私有的声明</li>
</ul>
<p><strong>标准中注册的声明</strong> (建议但不强制使用) ：</p>
<ul>
<li><strong>iss</strong>: jwt签发者</li>
<li><strong>sub</strong>: jwt所面向的用户</li>
<li><strong>aud</strong>: 接收jwt的一方</li>
<li><strong>exp</strong>: jwt的过期时间，这个过期时间必须要大于签发时间</li>
<li><strong>nbf</strong>: 定义在什么时间之前，该jwt都是不可用的.</li>
<li><strong>iat</strong>: jwt的签发时间</li>
<li><strong>jti</strong>: jwt的唯一身份标识，主要用来作为一次性token,从而回避时序攻击。</li>
</ul>
<p><strong>公共的声明</strong> ： 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.</p>
<p><strong>私有的声明</strong> ： 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</p>
<p>定义一个payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将其进行base64加密，得到JWT的第二部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span><br></pre></td></tr></table></figure>

<h3 id="1-1-3-signature"><a href="#1-1-3-signature" class="headerlink" title="1.1.3 signature"></a>1.1.3 signature</h3><p>JWT的第三部分是一个签证信息，这个签证信息由三部分组成：</p>
<ul>
<li>header (base64后的)</li>
<li>payload (base64后的)</li>
<li>secret</li>
</ul>
<p>这个部分需要base64加密后的header和base64加密后的payload使用<code>.</code>连接组成的字符串，然后通过header中声明的加密方式进行加盐<code>secret</code>组合加密，然后就构成了jwt的第三部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; javascript</span><br><span class="line">var encodedString &#x3D; base64UrlEncode(header) + &#39;.&#39; + base64UrlEncode(payload);</span><br><span class="line"></span><br><span class="line">var signature &#x3D; HMACSHA256(encodedString, &#39;secret&#39;); &#x2F;&#x2F; TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre></td></tr></table></figure>

<p>将这三部分用<code>.</code>连接成一个完整的字符串,构成了最终的jwt:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre></td></tr></table></figure>

<p><strong>注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。</strong></p>
<p><strong>关于签发和核验JWT，我们可以使用Django REST framework JWT扩展来完成。</strong></p>
<p>文档网站：<a href="http://getblimp.github.io/django-rest-framework-jwt/">http://getblimp.github.io/django-rest-framework-jwt/</a></p>
<h2 id="1-2-本质原理"><a href="#1-2-本质原理" class="headerlink" title="1.2 本质原理"></a>1.2 本质原理</h2><h2 id="jwt认证算法：签发与校验"><a href="#jwt认证算法：签发与校验" class="headerlink" title="jwt认证算法：签发与校验"></a>jwt认证算法：签发与校验</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">1）jwt分三段式：头.体.签名 （head.payload.sign）</span><br><span class="line">2）头和体是可逆加密，让服务器可以反解出user对象；签名是不可逆加密，保证整个token的安全性的</span><br><span class="line">3）头体签名三部分，都是采用json格式的字符串，进行加密，可逆加密一般采用base64算法，不可逆加密一般采用hash(md5)算法</span><br><span class="line">4）头中的内容是基本信息：公司信息、项目组信息、token采用的加密方式信息</span><br><span class="line">&#123;</span><br><span class="line">    &quot;company&quot;: &quot;公司信息&quot;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">5）体中的内容是关键信息：用户主键、用户名、签发时客户端信息(设备号、地址)、过期时间</span><br><span class="line">&#123;</span><br><span class="line">    &quot;user_id&quot;: 1,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">6）签名中的内容时安全信息：头的加密结果 + 体的加密结果 + 服务器不对外公开的安全码 进行md5加密</span><br><span class="line">&#123;</span><br><span class="line">    &quot;head&quot;: &quot;头的加密字符串&quot;,</span><br><span class="line">    &quot;payload&quot;: &quot;体的加密字符串&quot;,</span><br><span class="line">    &quot;secret_key&quot;: &quot;安全码&quot;</span><br><span class="line">&#125;</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h5 id="签发：根据登录请求提交来的-账号-密码-设备信息-签发-token"><a href="#签发：根据登录请求提交来的-账号-密码-设备信息-签发-token" class="headerlink" title="签发：根据登录请求提交来的 账号 + 密码 + 设备信息 签发 token"></a>签发：根据登录请求提交来的 账号 + 密码 + 设备信息 签发 token</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">1）用基本信息存储json字典，采用base64算法加密得到 头字符串</span><br><span class="line">2）用关键信息存储json字典，采用base64算法加密得到 体字符串</span><br><span class="line">3）用头、体加密字符串再加安全码信息存储json字典，采用hash md5算法加密得到 签名字符串</span><br><span class="line"></span><br><span class="line">账号密码就能根据User表得到user对象，形成的三段字符串用 . 拼接成token返回给前台</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h5 id="校验：根据客户端带token的请求-反解出-user-对象"><a href="#校验：根据客户端带token的请求-反解出-user-对象" class="headerlink" title="校验：根据客户端带token的请求 反解出 user 对象"></a>校验：根据客户端带token的请求 反解出 user 对象</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">1）将token按 . 拆分为三段字符串，第一段 头加密字符串 一般不需要做任何处理</span><br><span class="line">2）第二段 体加密字符串，要反解出用户主键，通过主键从User表中就能得到登录用户，过期时间和设备信息都是安全信息，确保token没过期，且时同一设备来的</span><br><span class="line">3）再用 第一段 + 第二段 + 服务器安全码 不可逆md5加密，与第三段 签名字符串 进行碰撞校验，通过后才能代表第二段校验得到的user对象就是合法的登录用户</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="drf项目的jwt认证开发流程（重点）"><a href="#drf项目的jwt认证开发流程（重点）" class="headerlink" title="drf项目的jwt认证开发流程（重点）"></a>drf项目的jwt认证开发流程（重点）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">1）用账号密码访问登录接口，登录接口逻辑中调用 签发token 算法，得到token，返回给客户端，客户端自己存到cookies中</span><br><span class="line"></span><br><span class="line">2）校验token的算法应该写在认证类中(在认证类中调用)，全局配置给认证组件，所有视图类请求，都会进行认证校验，所以请求带了token，就会反解出user对象，在视图类中用request.user就能访问登录的用户</span><br><span class="line"></span><br><span class="line">注：登录接口需要做 认证 + 权限 两个局部禁用</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-1-补充base64编码解码"><a href="#1-2-1-补充base64编码解码" class="headerlink" title="1.2.1 补充base64编码解码"></a>1.2.1 补充base64编码解码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import base64</span><br><span class="line">import json</span><br><span class="line">dic_info&#x3D;&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;lqz&quot;,</span><br><span class="line">  &quot;admin&quot;: True</span><br><span class="line">&#125;</span><br><span class="line">byte_info&#x3D;json.dumps(dic_info).encode(&#39;utf-8&#39;)</span><br><span class="line"># base64编码</span><br><span class="line">base64_str&#x3D;base64.b64encode(byte_info)</span><br><span class="line">print(base64_str)</span><br><span class="line"># base64解码</span><br><span class="line">base64_str&#x3D;&#39;eyJzdWIiOiAiMTIzNDU2Nzg5MCIsICJuYW1lIjogImxxeiIsICJhZG1pbiI6IHRydWV9&#39;</span><br><span class="line">str_url &#x3D; base64.b64decode(base64_str).decode(&quot;utf-8&quot;)</span><br><span class="line">print(str_url)</span><br></pre></td></tr></table></figure>

<h2 id="二-drf-jwt安装和简单使用"><a href="#二-drf-jwt安装和简单使用" class="headerlink" title="二 drf-jwt安装和简单使用"></a>二 drf-jwt安装和简单使用</h2><h5 id="2-1-官网"><a href="#2-1-官网" class="headerlink" title="2.1 官网"></a>2.1 官网</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">djangorestframework-jwt：https:&#x2F;&#x2F;jpadilla.github.io&#x2F;django-rest-framework-jwt&#x2F;</span><br><span class="line">djangorestframework-simplejwt：https:&#x2F;&#x2F;django-rest-framework-simplejwt.readthedocs.io&#x2F;en&#x2F;latest&#x2F;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install djangorestframework-jwt -----&gt; 内部适用的auth_user 表</span><br><span class="line">新的  djangorestframework-simplejwt</span><br><span class="line">https:&#x2F;&#x2F;django-rest-framework-simplejwt.readthedocs.io&#x2F;en&#x2F;latest&#x2F;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-使用："><a href="#2-3-使用：" class="headerlink" title="2.3 使用："></a>2.3 使用：</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 创建超级用户</span></span><br><span class="line">python3 manage.py createsuperuser</span><br><span class="line"><span class="comment"># 2 配置路由urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> rest_framework_jwt.views <span class="keyword">import</span> obtain_jwt_token</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;login/&#x27;</span>, obtain_jwt_token),</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 3 postman测试</span></span><br><span class="line">向后端接口发送post请求，携带用户名密码，即可看到生成的token</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 setting.py中配置认证使用jwt提供的jsonwebtoken</span></span><br><span class="line"><span class="comment"># 5 postman发送访问请求（必须带jwt空格）</span></span><br></pre></td></tr></table></figure>

<h2 id="三-实战之使用Django-auth的User表自动签发"><a href="#三-实战之使用Django-auth的User表自动签发" class="headerlink" title="三 实战之使用Django auth的User表自动签发"></a>三 实战之使用Django auth的User表自动签发</h2><h3 id="用django自带的用户体系，签发和认证如下（如果想用内置的认证类，需要配合内置权限类去使用）"><a href="#用django自带的用户体系，签发和认证如下（如果想用内置的认证类，需要配合内置权限类去使用）" class="headerlink" title="用django自带的用户体系，签发和认证如下（如果想用内置的认证类，需要配合内置权限类去使用）"></a>用django自带的用户体系，签发和认证如下（如果想用内置的认证类，需要配合内置权限类去使用）</h3><h3 id="0-1-签发"><a href="#0-1-签发" class="headerlink" title="0.1 签发"></a>0.1 签发</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">JSONWebTokenAPIView 是基类</span><br><span class="line">ObtainJSONWebToken, VerifyJSONWebToken, RefreshJSONWebToken  都继承了 ----&gt; JSONWebTokenAPIView</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置方式</span></span><br><span class="line"><span class="comment">## 局部：视图类</span></span><br><span class="line">authentication_classes = [JSONWebTokenAuthentication,]</span><br><span class="line"><span class="comment">## 全局</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># url  (登录和签发功能写好了)</span></span><br><span class="line"><span class="comment"># 签发，只需要再路由中加入,向这个地址发送post请求，携带用户名密码，就可以签发token</span></span><br><span class="line"><span class="comment"># 内部使用的是，auth 的user表</span></span><br><span class="line">path(<span class="string">&#x27;login/&#x27;</span>, obtain_jwt_token),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只需要再前端向 /login/地址，发送post请求，携带用户名密码，就可以签发token</span></span><br><span class="line">http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>/login/</span><br><span class="line">&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;lqz&quot;</span>,<span class="string">&quot;password&quot;</span>:<span class="string">&quot;lqz12345&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求方式</span></span><br><span class="line">请求头header  Authorization  JWT ”token“</span><br></pre></td></tr></table></figure>

<h3 id="0-2-认证"><a href="#0-2-认证" class="headerlink" title="0.2 认证"></a>0.2 认证</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在视图类中配置，认证类和权限类 搭配使用，才生效</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework_jwt.authentication <span class="keyword">import</span> JSONWebTokenAuthentication</span><br><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> IsAuthenticated</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookView</span>(<span class="params">ViewSetMixin,ListAPIView</span>):</span></span><br><span class="line">    authentication_classes = [JSONWebTokenAuthentication,] <span class="comment"># 认证类重写authenticate返回两个值,一个是user,一个是jwt_value</span></span><br><span class="line">    permission_classes = [IsAuthenticated,]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须搭配使用的原因是: 如果没传token, 那默认的JSONWebTokenAuthentication就不认证; 需要用IsAuthenticated再校验</span></span><br><span class="line">传了token</span><br><span class="line">    </span><br><span class="line"><span class="comment">### 前端访问，需要在请求头中加入，如果不携带，或者篡改了，就认证不通过</span></span><br><span class="line">Authorization：jwt eyJ0eXAiOiJKV1QiLChbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoyLCJ1c2VybmFtZSI6InJvb3QiLCJleHAiOjE2MjU3Mjk3MDAsImVtYWlsIjoiM0BxcS5jb20ifQ.V6X_4wdBvrrRSPOuUf8z5gENB1kJyGimxiLBEjbiQGY</span><br></pre></td></tr></table></figure>

<h3 id="0-3-配置setting-py"><a href="#0-3-配置setting-py" class="headerlink" title="0.3 配置setting.py"></a>0.3 配置setting.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">JWT_AUTH = &#123;</span><br><span class="line">    <span class="comment"># 过期时间1天</span></span><br><span class="line">    <span class="string">&#x27;JWT_EXPIRATION_DELTA&#x27;</span>: datetime.timedelta(days=<span class="number">1</span>),</span><br><span class="line">    <span class="comment"># 自定义认证结果：见下方序列化user和自定义response</span></span><br><span class="line">      <span class="comment"># 如果不自定义，返回的格式是固定的，只有token字段</span></span><br><span class="line">    <span class="string">&#x27;JWT_RESPONSE_PAYLOAD_HANDLER&#x27;</span>: <span class="string">&#x27;users.utils.jwt_response_payload_handler&#x27;</span>,  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="0-4-JWT使用auth表签发token，自定制格式（3星）"><a href="#0-4-JWT使用auth表签发token，自定制格式（3星）" class="headerlink" title="0.4 JWT使用auth表签发token，自定制格式（3星）"></a>0.4 JWT使用auth表签发token，自定制格式（3星）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只需要写一个函数，在配置文件中配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jwt_response_payload_handler</span>(<span class="params">token, user=None, request=None</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;code&#x27;</span>:<span class="number">100</span>,</span><br><span class="line">        <span class="string">&#x27;msg&#x27;</span>:<span class="string">&#x27;登录成功&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;username&#x27;</span>:user.username,</span><br><span class="line">        <span class="string">&#x27;token&#x27;</span>: token,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 配置文件</span></span><br><span class="line">JWT_AUTH =&#123;</span><br><span class="line">    <span class="comment"># token的过期时间</span></span><br><span class="line">    <span class="string">&#x27;JWT_EXPIRATION_DELTA&#x27;</span>: datetime.timedelta(days=<span class="number">7</span>),</span><br><span class="line">    <span class="comment"># 自定义认证结果：见下方序列化user和自定义response</span></span><br><span class="line">    <span class="comment"># 如果不自定义，返回的格式是固定的，只有token字段</span></span><br><span class="line">    <span class="string">&#x27;JWT_RESPONSE_PAYLOAD_HANDLER&#x27;</span>: <span class="string">&#x27;app01.utils.jwt_response_payload_handler&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="0-5-djangorestframework-jwt模块obtain-jwt-token源码分析（2星）"><a href="#0-5-djangorestframework-jwt模块obtain-jwt-token源码分析（2星）" class="headerlink" title="0.5 djangorestframework-jwt模块obtain_jwt_token源码分析（2星）"></a>0.5 djangorestframework-jwt模块obtain_jwt_token源码分析（2星）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ObtainJSONWebToken.as_view()---&gt;ObtainJSONWebToken----&gt;post方法  (登录提交)</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        serializer = self.get_serializer(data=request.data)</span><br><span class="line">        <span class="keyword">if</span> serializer.is_valid():  <span class="comment"># 验证用户登录和签发token，都在序列化类的validate方法中完成的</span></span><br><span class="line">            user = serializer.object.get(<span class="string">&#x27;user&#x27;</span>) <span class="keyword">or</span> request.user</span><br><span class="line">            token = serializer.object.get(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">            response_data = jwt_response_payload_handler(token, user, request)</span><br><span class="line">            response = Response(response_data)</span><br><span class="line">            <span class="comment"># 返回了咱们自定指的格式 </span></span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">               &#123;</span></span><br><span class="line"><span class="string">                &#x27;code&#x27;:100,</span></span><br><span class="line"><span class="string">                &#x27;msg&#x27;:&#x27;登录成功&#x27;,</span></span><br><span class="line"><span class="string">                &#x27;username&#x27;:user.username,</span></span><br><span class="line"><span class="string">                &#x27;token&#x27;: token,</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">            &#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> response</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">validate</span>(<span class="params">self, attrs</span>):</span></span><br><span class="line">        credentials = &#123;</span><br><span class="line">            self.username_field: attrs.get(self.username_field),</span><br><span class="line">            <span class="string">&#x27;password&#x27;</span>: attrs.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> all(credentials.values()):</span><br><span class="line">            <span class="comment"># 根据用户名密码去auth的user表校验，是否存在</span></span><br><span class="line">            user = authenticate(**credentials)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> user:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> user.is_active:</span><br><span class="line">                    msg = _(<span class="string">&#x27;User account is disabled.&#x27;</span>)</span><br><span class="line">                    <span class="keyword">raise</span> serializers.ValidationError(msg)</span><br><span class="line">                        <span class="comment"># 生成payload</span></span><br><span class="line">                payload = jwt_payload_handler(user)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="string">&#x27;token&#x27;</span>: jwt_encode_handler(payload), <span class="comment"># 通过payload生成token</span></span><br><span class="line">                    <span class="string">&#x27;user&#x27;</span>: user</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">               <span class="comment"># 不在抛异常，前端就看到信息了</span></span><br><span class="line">                <span class="keyword">raise</span> serializers.ValidationError(msg)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(msg)</span><br></pre></td></tr></table></figure>





<h3 id="3-1-配置setting-py"><a href="#3-1-配置setting-py" class="headerlink" title="3.1 配置setting.py"></a>3.1 配置setting.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">JWT_AUTH = &#123;</span><br><span class="line">    <span class="comment"># 过期时间1天</span></span><br><span class="line">    <span class="string">&#x27;JWT_EXPIRATION_DELTA&#x27;</span>: datetime.timedelta(days=<span class="number">1</span>),</span><br><span class="line">    <span class="comment"># 自定义认证结果：见下方序列化user和自定义response</span></span><br><span class="line">      <span class="comment"># 如果不自定义，返回的格式是固定的，只有token字段</span></span><br><span class="line">    <span class="string">&#x27;JWT_RESPONSE_PAYLOAD_HANDLER&#x27;</span>: <span class="string">&#x27;users.utils.jwt_response_payload_handler&#x27;</span>,  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-编写序列化类ser-py"><a href="#3-2-编写序列化类ser-py" class="headerlink" title="3.2 编写序列化类ser.py"></a>3.2 编写序列化类ser.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> users <span class="keyword">import</span> models</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserModelSerializers</span>(<span class="params">serializers.ModelSerializer</span>):</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = models.UserInfo</span><br><span class="line">        fields = [<span class="string">&#x27;username&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h5 id="3-3-自定义认证返回结果（setting中配置的）"><a href="#3-3-自定义认证返回结果（setting中配置的）" class="headerlink" title="3.3 自定义认证返回结果（setting中配置的）"></a>3.3 自定义认证返回结果（setting中配置的）</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#utils.py</span></span><br><span class="line"><span class="keyword">from</span> users.ser <span class="keyword">import</span> UserModelSerializers</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jwt_response_payload_handler</span>(<span class="params">token, user=None, request=None</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;status&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;ok&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;data&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;token&#x27;</span>: token,</span><br><span class="line">            <span class="string">&#x27;user&#x27;</span>: UserModelSerializers(user).data</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-基于drf-jwt的全局认证："><a href="#3-4-基于drf-jwt的全局认证：" class="headerlink" title="3.4 基于drf-jwt的全局认证："></a>3.4 基于drf-jwt的全局认证：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#app_auth.py(自己创建)</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.exceptions <span class="keyword">import</span> AuthenticationFailed</span><br><span class="line"><span class="keyword">from</span> rest_framework_jwt.authentication <span class="keyword">import</span> jwt_decode_handler</span><br><span class="line"><span class="keyword">from</span> rest_framework_jwt.authentication <span class="keyword">import</span> get_authorization_header,jwt_get_username_from_payload</span><br><span class="line"><span class="keyword">from</span> rest_framework_jwt.authentication <span class="keyword">import</span> BaseJSONWebTokenAuthentication</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONWebTokenAuthentication</span>(<span class="params">BaseJSONWebTokenAuthentication</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        jwt_value = get_authorization_header(request)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> jwt_value:</span><br><span class="line">            <span class="keyword">raise</span> AuthenticationFailed(<span class="string">&#x27;Authorization 字段是必须的&#x27;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            payload = jwt_decode_handler(jwt_value)</span><br><span class="line">        <span class="keyword">except</span> jwt.ExpiredSignature:</span><br><span class="line">            <span class="keyword">raise</span> AuthenticationFailed(<span class="string">&#x27;签名过期&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> jwt.InvalidTokenError:</span><br><span class="line">            <span class="keyword">raise</span> AuthenticationFailed(<span class="string">&#x27;非法用户&#x27;</span>)</span><br><span class="line">        user = self.authenticate_credentials(payload)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> user, jwt_value</span><br></pre></td></tr></table></figure>

<h3 id="3-5-全局使用"><a href="#3-5-全局使用" class="headerlink" title="3.5 全局使用"></a>3.5 全局使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># setting.py</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="comment"># 认证模块</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;</span>: (</span><br><span class="line">        <span class="string">&#x27;users.app_auth.JSONWebTokenAuthentication&#x27;</span>,</span><br><span class="line">    ),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-局部启用禁用"><a href="#3-6-局部启用禁用" class="headerlink" title="3.6 局部启用禁用"></a>3.6 局部启用禁用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 局部禁用</span></span><br><span class="line">authentication_classes = []</span><br><span class="line"><span class="comment"># 局部启用</span></span><br><span class="line"><span class="keyword">from</span> user.authentications <span class="keyword">import</span> JSONWebTokenAuthentication</span><br><span class="line">authentication_classes = [JSONWebTokenAuthentication]</span><br><span class="line"><span class="comment"># 实际代码如下view.py</span></span><br><span class="line"><span class="comment"># 自定义Response</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonResponse</span>(<span class="params">Response</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,status,msg,data=<span class="string">&#x27;&#x27;</span>,*args,**kwargs</span>):</span></span><br><span class="line">        dic=&#123;<span class="string">&#x27;status&#x27;</span>:status,<span class="string">&#x27;msg&#x27;</span>:msg,<span class="string">&#x27;data&#x27;</span>:data&#125;</span><br><span class="line">        super().__init__(data=dic,*args,**kwargs)</span><br><span class="line"><span class="comment"># 测试订单接口</span></span><br><span class="line"><span class="keyword">from</span> users.app_auth <span class="keyword">import</span> JSONWebTokenAuthentication</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderView</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="comment"># authentication_classes = [JSONWebTokenAuthentication]</span></span><br><span class="line">    authentication_classes = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> CommonResponse(<span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;成功&#x27;</span>,&#123;<span class="string">&#x27;数据&#x27;</span>:<span class="string">&#x27;测试&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-7-多方式登录："><a href="#3-7-多方式登录：" class="headerlink" title="3.7 多方式登录："></a>3.7 多方式登录：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## views.py</span></span><br><span class="line"><span class="comment"># 重点：自定义login，完成多方式登录</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ViewSet</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginViewSet</span>(<span class="params">ViewSet</span>):</span></span><br><span class="line">    <span class="comment"># 需要和mixins结合使用，继承GenericViewSet，不需要则继承ViewSet</span></span><br><span class="line">    <span class="comment"># 为什么继承视图集，不去继承工具视图或视图基类，因为视图集可以自定义路由映射：</span></span><br><span class="line">    <span class="comment">#       可以做到get映射get，get映射list，还可以做到自定义（灵活）</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        serializer = serializers.LoginSerializer(data=request.data, context=&#123;<span class="string">&#x27;request&#x27;</span>: request&#125;)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        token = serializer.context.get(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&quot;token&quot;</span>: token&#125;)</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="comment">## ser.py</span></span><br><span class="line"><span class="comment"># 重点：自定义login，完成多方式登录</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginSerializer</span>(<span class="params">serializers.ModelSerializer</span>):</span></span><br><span class="line">    <span class="comment"># 登录请求，走的是post方法，默认post方法完成的是create入库校验，所以唯一约束的字段，会进行数据库唯一校验，导致逻辑相悖</span></span><br><span class="line">    <span class="comment"># 需要覆盖系统字段，自定义校验规则，就可以避免完成多余的不必要校验，如唯一字段校验</span></span><br><span class="line">    username = serializers.CharField()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = models.User</span><br><span class="line">        <span class="comment"># 结合前台登录布局：采用账号密码登录，或手机密码登录，布局一致，所以不管账号还是手机号，都用username字段提交的</span></span><br><span class="line">        fields = (<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span>(<span class="params">self, attrs</span>):</span></span><br><span class="line">        <span class="comment"># 在全局钩子中，才能提供提供的所需数据，整体校验得到user</span></span><br><span class="line">        <span class="comment"># 再就可以调用签发token算法，将user信息转换为token</span></span><br><span class="line">        <span class="comment"># 将token存放到context属性中，传给外键视图类使用</span></span><br><span class="line">        user = self._get_user(attrs)</span><br><span class="line">        payload = jwt_payload_handler(user)</span><br><span class="line">        token = jwt_encode_handler(payload)</span><br><span class="line">        self.context[<span class="string">&#x27;token&#x27;</span>] = token</span><br><span class="line">        <span class="keyword">return</span> attrs</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 多方式登录</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_user</span>(<span class="params">self, attrs</span>):</span></span><br><span class="line">        username = attrs.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        password = attrs.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        <span class="keyword">import</span> re</span><br><span class="line">        <span class="keyword">if</span> re.match(<span class="string">r&#x27;^1[3-9][0-9]&#123;9&#125;$&#x27;</span>, username):</span><br><span class="line">            <span class="comment"># 手机登录</span></span><br><span class="line">            user = models.User.objects.filter(mobile=username, is_active=<span class="literal">True</span>).first()</span><br><span class="line">        <span class="keyword">elif</span> re.match(<span class="string">r&#x27;^.+@.+$&#x27;</span>, username):</span><br><span class="line">            <span class="comment"># 邮箱登录</span></span><br><span class="line">            user = models.User.objects.filter(email=username, is_active=<span class="literal">True</span>).first()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 账号登录</span></span><br><span class="line">            user = models.User.objects.filter(username=username, is_active=<span class="literal">True</span>).first()</span><br><span class="line">        <span class="keyword">if</span> user <span class="keyword">and</span> user.check_password(password):</span><br><span class="line">            <span class="keyword">return</span> user</span><br><span class="line"></span><br><span class="line">        <span class="keyword">raise</span> ValidationError(&#123;<span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;user error&#x27;</span>&#125;)</span><br><span class="line"><span class="comment"># utils.py</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.backends <span class="keyword">import</span> ModelBackend</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JWTModelBackend</span>(<span class="params">ModelBackend</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate</span>(<span class="params">self, request, username=None, password=None, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> re.match(<span class="string">r&#x27;^1[3-9]\d&#123;9&#125;$&#x27;</span>, username):</span><br><span class="line">                user = User.objects.get(mobile=username)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                user = User.objects.get(username=username)</span><br><span class="line">        <span class="keyword">except</span> User.DoesNotExist:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> user.check_password(password) <span class="keyword">and</span> self.user_can_authenticate(user):</span><br><span class="line">            <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure>

<h3 id="3-8-配置多方式登录"><a href="#3-8-配置多方式登录" class="headerlink" title="3.8 配置多方式登录"></a>3.8 配置多方式登录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">settings.py</span><br><span class="line">AUTHENTICATION_BACKENDS &#x3D; [&#39;user.utils.JWTModelBackend&#39;]</span><br></pre></td></tr></table></figure>

<h2 id="四-实战之自定义User表，手动签发"><a href="#四-实战之自定义User表，手动签发" class="headerlink" title="四 实战之自定义User表，手动签发"></a>四 实战之自定义User表，手动签发</h2><h3 id="4-1-手动签发JWT："><a href="#4-1-手动签发JWT：" class="headerlink" title="4.1 手动签发JWT："></a>4.1 手动签发JWT：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以拥有原生登录基于Model类user对象签发JWT</span></span><br><span class="line"><span class="keyword">from</span> rest_framework_jwt.settings <span class="keyword">import</span> api_settings</span><br><span class="line">jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER</span><br><span class="line">jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER</span><br><span class="line"></span><br><span class="line">payload = jwt_payload_handler(user)</span><br><span class="line">token = jwt_encode_handler(payload)</span><br></pre></td></tr></table></figure>

<h3 id="4-2-编写登陆视图类"><a href="#4-2-编写登陆视图类" class="headerlink" title="4.2 编写登陆视图类"></a>4.2 编写登陆视图类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># views.py</span><br><span class="line">from rest_framework_jwt.settings import api_settings</span><br><span class="line">jwt_payload_handler &#x3D; api_settings.JWT_PAYLOAD_HANDLER</span><br><span class="line">jwt_encode_handler &#x3D; api_settings.JWT_ENCODE_HANDLER</span><br><span class="line">from users.models import User</span><br><span class="line">class LoginView(APIView):</span><br><span class="line">    authentication_classes &#x3D; []</span><br><span class="line">    def post(self,request):</span><br><span class="line">        username&#x3D;request.data.get(&#39;username&#39;)</span><br><span class="line">        password&#x3D;request.data.get(&#39;password&#39;)</span><br><span class="line">        user&#x3D;User.objects.filter(username&#x3D;username,password&#x3D;password).first()</span><br><span class="line">        if user: # 能查到，登陆成功，手动签发</span><br><span class="line">            payload &#x3D; jwt_payload_handler(user)</span><br><span class="line">            token &#x3D; jwt_encode_handler(payload)</span><br><span class="line">            return CommonResponse(&#39;100&#39;,&#39;登陆成功&#39;,data&#x3D;&#123;&#39;token&#39;:token&#125;)</span><br><span class="line">        else:</span><br><span class="line">            return CommonResponse(&#39;101&#39;, &#39;登陆失败&#39;)</span><br></pre></td></tr></table></figure>

<h3 id="4-3-编写认证组件"><a href="#4-3-编写认证组件" class="headerlink" title="4.3 编写认证组件"></a>4.3 编写认证组件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># app_auth.py</span><br><span class="line">from users.models import User</span><br><span class="line">class MyJSONWebTokenAuthentication(BaseAuthentication):</span><br><span class="line">    def authenticate(self, request):</span><br><span class="line">        jwt_value &#x3D; get_authorization_header(request)</span><br><span class="line"></span><br><span class="line">        if not jwt_value:</span><br><span class="line">            raise AuthenticationFailed(&#39;Authorization 字段是必须的&#39;)</span><br><span class="line">        try:</span><br><span class="line">            payload &#x3D; jwt_decode_handler(jwt_value)</span><br><span class="line">        except jwt.ExpiredSignature:</span><br><span class="line">            raise AuthenticationFailed(&#39;签名过期&#39;)</span><br><span class="line">        except jwt.InvalidTokenError:</span><br><span class="line">            raise AuthenticationFailed(&#39;非法用户&#39;)</span><br><span class="line">        username &#x3D; jwt_get_username_from_payload(payload)</span><br><span class="line">        print(username)</span><br><span class="line">        user &#x3D; User.objects.filter(username&#x3D;username).first()</span><br><span class="line">        print(user)</span><br><span class="line"></span><br><span class="line">        return user, jwt_value</span><br></pre></td></tr></table></figure>

<h3 id="4-4-登陆获取token"><a href="#4-4-登陆获取token" class="headerlink" title="4.4 登陆获取token"></a>4.4 登陆获取token</h3><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggjrfa03aaj312z0u0afg.jpg" alt="image-20200708185227693"></p>
<h3 id="4-5-编写测试接口"><a href="#4-5-编写测试接口" class="headerlink" title="4.5 编写测试接口"></a>4.5 编写测试接口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from users.app_auth import JSONWebTokenAuthentication,MyJSONWebTokenAuthentication</span><br><span class="line">class OrderView(APIView):</span><br><span class="line">    # authentication_classes &#x3D; [JSONWebTokenAuthentication]</span><br><span class="line">    authentication_classes &#x3D; [MyJSONWebTokenAuthentication]</span><br><span class="line">    def get(self,request):</span><br><span class="line">        print(request.user)</span><br><span class="line">        return CommonResponse(&#39;100&#39;, &#39;成功&#39;,&#123;&#39;数据&#39;:&#39;测试&#39;&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="4-6-测试"><a href="#4-6-测试" class="headerlink" title="4.6 测试"></a>4.6 测试</h3><p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/007S8ZIlgy1ggjrg9ots0j31d60rcjv6.jpg" alt="image-20200708185327976"></p>
<h2 id="0-1-两种方式自定制基于jwt的认证类"><a href="#0-1-两种方式自定制基于jwt的认证类" class="headerlink" title="0.1 : 两种方式自定制基于jwt的认证类"></a>0.1 : 两种方式自定制基于jwt的认证类</h2><p>三种方案得到user对象</p>
<p>1.继承BaseJSONWebTokenAuthentication; self.authenticate_credentials</p>
<p>2.直接把BaseJSONWebTokenAuthentication，authenticate_credentials方法拿出来，放到自己类中</p>
<p>3.自己查数据库</p>
<h4 id="1-基于BaseAuthentication自定制jwt认证类"><a href="#1-基于BaseAuthentication自定制jwt认证类" class="headerlink" title="1.基于BaseAuthentication自定制jwt认证类"></a>1.基于BaseAuthentication自定制jwt认证类</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基于BaseAuthentication自定制基jwt的认证类</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.authentication <span class="keyword">import</span> BaseAuthentication</span><br><span class="line"><span class="keyword">from</span> rest_framework_jwt.authentication <span class="keyword">import</span> jwt_decode_handler</span><br><span class="line"><span class="keyword">from</span> rest_framework_jwt.utils <span class="keyword">import</span> jwt_decode_handler <span class="comment"># 和上面是一个</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.exceptions <span class="keyword">import</span> AuthenticationFailed</span><br><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyJwtAuthentication</span>(<span class="params">BaseAuthentication</span>):</span> <span class="comment">#try后面的异常不会被DRF异常捕获, 需要处理后交给AuthenticationFailed</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        jwt_value = request.META.get(<span class="string">&#x27;HTTP_AUTHORIZATION&#x27;</span>)   <span class="comment">#</span></span><br><span class="line">        <span class="comment"># jwt_value = request.GET.get(&#x27;token&#x27;)</span></span><br><span class="line">        <span class="keyword">if</span> jwt_value:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># jwt提供了通过三段token, 取出payload的方法, 并且有校验功能</span></span><br><span class="line">                payload = jwt_decode_handler(jwt_value)</span><br><span class="line">            <span class="keyword">except</span> jwt.ExpiredSignature:</span><br><span class="line">                <span class="keyword">raise</span> AuthenticationFailed(<span class="string">&#x27;签名过期&#x27;</span>)</span><br><span class="line">            <span class="keyword">except</span> jwt.InvalidTokenError:</span><br><span class="line">                <span class="keyword">raise</span> AuthenticationFailed(<span class="string">&#x27;用户非法&#x27;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="comment"># 所有异常都会走这里</span></span><br><span class="line">                <span class="keyword">raise</span> AuthenticationFailed(str(e))</span><br><span class="line">            <span class="comment"># payload就是用户信息的字典</span></span><br><span class="line">            print(payload)</span><br><span class="line">            <span class="comment"># 需要得到user对象,</span></span><br><span class="line">            <span class="comment"># 第一种, 去数据库查</span></span><br><span class="line">            user = models.User.objects.get(pk=payload.get(<span class="string">&#x27;user_id&#x27;</span>))</span><br><span class="line">            <span class="comment"># 第二种不查库, 快，但是信息不完整; 可以是优化点</span></span><br><span class="line">            user = models.User(id=payload.get(<span class="string">&#x27;user_id&#x27;</span>), username=payload.get(<span class="string">&#x27;username&#x27;</span>))</span><br><span class="line">            <span class="keyword">return</span> user, jwt_value</span><br><span class="line">        <span class="comment"># 没有值, 直接抛异常</span></span><br><span class="line">        <span class="keyword">raise</span> AuthenticationFailed(<span class="string">&#x27;您没有携带认证信息&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-基于BaseJSONWebTokenAuthentication自定制jwt的认证类"><a href="#2-基于BaseJSONWebTokenAuthentication自定制jwt的认证类" class="headerlink" title="2.基于BaseJSONWebTokenAuthentication自定制jwt的认证类"></a>2.基于BaseJSONWebTokenAuthentication自定制jwt的认证类</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 核心就是取user对象的时候，有现成的方法(实际上还是去数据库查了);self.authenticate_credentials(payload)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyJwtAuthentication</span>(<span class="params">BaseJSONWebTokenAuthentication</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        jwt_value = request.META.get(<span class="string">&#x27;HTTP_AUTHORIZATION&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> jwt_value:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># jwt提供了通过三段token, 取出payload的方法, 并且有校验功能</span></span><br><span class="line">                payload = jwt_decode_handler(jwt_value)</span><br><span class="line">            <span class="keyword">except</span> jwt.ExpiredSignature:</span><br><span class="line">                <span class="keyword">raise</span> AuthenticationFailed(<span class="string">&#x27;签名过期&#x27;</span>)</span><br><span class="line">            <span class="keyword">except</span> jwt.InvalidTokenError:</span><br><span class="line">                <span class="keyword">raise</span> AuthenticationFailed(<span class="string">&#x27;用户非法&#x27;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="comment"># 所有异常都会走这里</span></span><br><span class="line">                <span class="keyword">raise</span> AuthenticationFailed(str(e))</span><br><span class="line">            <span class="comment"># payload就是用户信息的字典</span></span><br><span class="line">            print(payload)</span><br><span class="line">            <span class="comment"># 需要得到user对象,</span></span><br><span class="line">            user = self.authenticate_credentials(payload)</span><br><span class="line">            <span class="keyword">return</span> user, jwt_value</span><br><span class="line">        <span class="comment"># 没有值, 直接抛异常</span></span><br><span class="line">        <span class="keyword">raise</span> AuthenticationFailed(<span class="string">&#x27;您没有携带认证信息&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="0-2-基于自定义User表-签发token"><a href="#0-2-基于自定义User表-签发token" class="headerlink" title="0.2 基于自定义User表, 签发token"></a>0.2 基于自定义User表, 签发token</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 路由</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.routers <span class="keyword">import</span> DefaultRouter,SimpleRouter</span><br><span class="line">router=SimpleRouter()</span><br><span class="line">router.register(<span class="string">&#x27;books&#x27;</span>,views.BookView)</span><br><span class="line">router.register(<span class="string">&#x27;user&#x27;</span>,views.UserInfoView,basename=<span class="string">&#x27;user&#x27;</span>)</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, include(router.urls)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 视图</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ViewSet</span><br><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> action</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> rest_framework_jwt.settings <span class="keyword">import</span> api_settings</span><br><span class="line">jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER</span><br><span class="line">jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfoView</span>(<span class="params">ViewSet</span>):</span></span><br><span class="line"><span class="meta">    @action(methods=[&#x27;POST&#x27;],detail=False)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        username=request.data.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        password=request.data.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        res=&#123;<span class="string">&#x27;code&#x27;</span>:<span class="string">&#x27;100&#x27;</span>,<span class="string">&#x27;msg&#x27;</span>:<span class="string">&#x27;登录成功&#x27;</span>&#125;</span><br><span class="line">        user=User.objects.filter(username=username,password=password).first()</span><br><span class="line">        <span class="keyword">if</span> user:</span><br><span class="line">            <span class="comment"># 登录成功,生成token，提供了（去找）</span></span><br><span class="line">            payload = jwt_payload_handler(user)</span><br><span class="line">            token=jwt_encode_handler(payload)</span><br><span class="line">            res[<span class="string">&#x27;token&#x27;</span>]=token</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res[<span class="string">&#x27;code&#x27;</span>]=<span class="number">101</span></span><br><span class="line">            res[<span class="string">&#x27;msg&#x27;</span>]=<span class="string">&#x27;用户名或密码错误&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> Response(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 认证类</span></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> User</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JWTMyUserAuthentication</span>(<span class="params">BaseAuthentication</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        token=request.META.get(<span class="string">&#x27;HTTP_AUTHORIZATION&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> token:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                payload = jwt_decode_handler(token)</span><br><span class="line">                print(payload)</span><br><span class="line">            <span class="keyword">except</span> jwt.ExpiredSignature:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">raise</span> AuthenticationFailed(<span class="string">&#x27;token过期&#x27;</span>)</span><br><span class="line">            <span class="keyword">except</span> jwt.DecodeError:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">raise</span> AuthenticationFailed(<span class="string">&#x27;token认证失败&#x27;</span>)</span><br><span class="line">            <span class="keyword">except</span> jwt.InvalidTokenError:</span><br><span class="line">                <span class="keyword">raise</span> AuthenticationFailed(<span class="string">&#x27;token不合法&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">           <span class="keyword">raise</span> AuthenticationFailed(<span class="string">&#x27;token没有携带&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        user=User.objects.get(pk=payload.get(<span class="string">&#x27;user_id&#x27;</span>))</span><br><span class="line">        <span class="comment"># user=User(id=payload.get(&#x27;user_id&#x27;),username=payload.get(&#x27;username&#x27;))</span></span><br><span class="line">        <span class="comment"># 优化，减少数据库压力（）</span></span><br><span class="line">        <span class="comment"># user=&#123;&#x27;id&#x27;:payload.get(&#x27;user_id&#x27;),&#x27;username&#x27;:payload.get(&#x27;username&#x27;)&#125;</span></span><br><span class="line">        <span class="keyword">return</span> (user, token)</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"><span class="comment"># 接口</span></span><br><span class="line"><span class="keyword">from</span> .auth <span class="keyword">import</span> JWTMyUserAuthentication</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookView</span>(<span class="params">ViewSetMixin,ListAPIView,CreateAPIView</span>):</span></span><br><span class="line">    queryset = Books.objects.all()</span><br><span class="line">    serializer_class = BookSerializer</span><br><span class="line">    authentication_classes = [JWTMyUserAuthentication,]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        print(request.user[<span class="string">&#x27;id&#x27;</span>])</span><br><span class="line">        <span class="keyword">return</span> super().list(request, *args, **kwargs)</span><br></pre></td></tr></table></figure>



<h2 id="0-3-签发token-多方式登录-就是把登录写到了ser"><a href="#0-3-签发token-多方式登录-就是把登录写到了ser" class="headerlink" title="0.3 签发token(多方式登录)  就是把登录写到了ser"></a>0.3 签发token(多方式登录)  就是把登录写到了ser</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 使用用户名，邮箱，手机号+密码都能登录成功</span><br><span class="line"><span class="number">2</span> 可以使用auth 的user表，也可以自定义用户表</span><br><span class="line"><span class="number">3</span> 扩写auth的user表，要么不用，要用一定要在项目开始就使用（没有迁移之前）</span><br><span class="line"><span class="number">4</span> 如果已经迁移了（正常是不能再使用了），如果还想用，解决方案：</span><br><span class="line">    -删库</span><br><span class="line">    -删除迁移记录（app的迁移记录，auth app的迁移记录（源码中），admin app的迁移记录（源码中））</span><br><span class="line"></span><br><span class="line"><span class="comment"># ser.py</span></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> rest_framework.exceptions <span class="keyword">import</span> ValidationError</span><br><span class="line"><span class="keyword">from</span> rest_framework_jwt.settings <span class="keyword">import</span> api_settings</span><br><span class="line">jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER</span><br><span class="line">jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSerializer</span>(<span class="params">serializers.ModelSerializer</span>):</span></span><br><span class="line">    username=serializers.CharField()  <span class="comment"># 重新覆盖username字段,数据中它是unique, post,认为你是保存数据,自己没有校验过</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model=User</span><br><span class="line">        fields=[<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;password&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span>(<span class="params">self, attrs</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># username:可能是手机号，可能是邮箱，可能是用户名</span></span><br><span class="line">        user=self._get_user(attrs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 签发token</span></span><br><span class="line">        token=self._get_token(user)</span><br><span class="line"></span><br><span class="line">        self.context[<span class="string">&#x27;token&#x27;</span>]=token</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> attrs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_user</span>(<span class="params">self,attrs</span>):</span></span><br><span class="line">        username = attrs.get(<span class="string">&#x27;username&#x27;</span>)<span class="comment"># username:可能是手机号，可能是邮箱，可能是用户名</span></span><br><span class="line">        password = attrs.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        <span class="comment"># 使用正则去匹配，手机号，邮箱或者其他</span></span><br><span class="line">        <span class="keyword">if</span> re.match(<span class="string">r&#x27;^1[3-9][0-9]&#123;9&#125;$&#x27;</span>, username):</span><br><span class="line">            user=User.objects.filter(phone=username).first()</span><br><span class="line">        <span class="keyword">elif</span> re.match(<span class="string">r&#x27;^.+@.+$&#x27;</span>, username):</span><br><span class="line">            user = User.objects.filter(email=username).first()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            user = User.objects.filter(username=username).first()</span><br><span class="line">        <span class="keyword">if</span> user:</span><br><span class="line">            <span class="keyword">if</span> user.check_password(password):</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> user</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValidationError(<span class="string">&#x27;密码错误&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValidationError(<span class="string">&#x27;用户不存在&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_token</span>(<span class="params">self,user</span>):</span></span><br><span class="line">        payload = jwt_payload_handler(user)</span><br><span class="line">        token=jwt_encode_handler(payload)</span><br><span class="line">        <span class="keyword">return</span> token</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment"># views.py视图类</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ViewSet</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> api <span class="keyword">import</span> ser</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginView</span>(<span class="params">ViewSet</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 需要序列化类，实例化对象</span></span><br><span class="line">        login_ser = ser.LoginModelSerializer(data=request.data,context=&#123;<span class="string">&#x27;request&#x27;</span>:request&#125;)</span><br><span class="line">        <span class="comment"># 调用序列化累is_valid</span></span><br><span class="line">        login_ser.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        token = login_ser.context.get(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">        username = login_ser.context.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        <span class="comment"># return token</span></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;status&#x27;</span>:<span class="number">100</span>, <span class="string">&#x27;msg&#x27;</span>:<span class="string">&#x27;登录成功&#x27;</span>, <span class="string">&#x27;token&#x27;</span>: token, <span class="string">&#x27;username&#x27;</span>: username&#125;)</span><br><span class="line">      </span><br></pre></td></tr></table></figure>



<p>优化: 只要配置认证类都会去查DB, 返回用户对象  —-&gt; 改成用户对象 </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p><strong>1.使用Django auth的User表自动签发</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 视图views:</span></span><br><span class="line">认证类 --&gt; 局部限制  </span><br><span class="line"><span class="comment">### 必须搭配使用: 如果没传token, 那默认的JSONWebTokenAuthentication就不认证; 需要用IsAuthenticated再校验</span></span><br><span class="line">  authentication_classes = [JSONWebTokenAuthentication,]</span><br><span class="line">  permission_classes = [IsAuthenticated,]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 路由:</span></span><br><span class="line">  path(<span class="string">&#x27;login/&#x27;</span>, obtain_jwt_token)</span><br><span class="line"></span><br><span class="line">自定制返回: 重写返回函数方法+</span><br><span class="line"><span class="comment"># 函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jwt_response_payload_handler</span>(<span class="params">token, user=None, request=None</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;code&#x27;</span>:<span class="number">100</span>,</span><br><span class="line">        <span class="string">&#x27;msg&#x27;</span>:<span class="string">&#x27;登录成功&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;username&#x27;</span>:user.username,</span><br><span class="line">        <span class="string">&#x27;token&#x27;</span>: token,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 配置文件</span></span><br><span class="line">JWT_AUTH =&#123;</span><br><span class="line">    <span class="comment"># token的过期时间</span></span><br><span class="line">    <span class="string">&#x27;JWT_EXPIRATION_DELTA&#x27;</span>: datetime.timedelta(days=<span class="number">7</span>),</span><br><span class="line">    <span class="comment"># 自定义认证结果：见下方序列化user和自定义response</span></span><br><span class="line">    <span class="comment"># 如果不自定义，返回的格式是固定的，只有token字段</span></span><br><span class="line">    <span class="string">&#x27;JWT_RESPONSE_PAYLOAD_HANDLER&#x27;</span>: <span class="string">&#x27;app01.utils.jwt_response_payload_handler&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.两种方式自定制基于jwt的认证类</strong></p>
<p><strong>认证类返回两个值 user 和 jwt_value</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.基于BaseAuthentication自定制jwt认证类</span></span><br><span class="line">拿到user对象有四种方式: </span><br><span class="line"><span class="number">1.</span> (<span class="number">1</span>)查库 (<span class="number">2</span>) 实例化对象(payload中拿信息) 快，但是不完整 </span><br><span class="line"><span class="number">2.</span>继承BaseJSONWebTokenAuthentication; self.authenticate_credentials</span><br><span class="line"><span class="number">3.</span>直接把BaseJSONWebTokenAuthentication，authenticate_credentials方法拿出来，放到自己类中</span><br><span class="line"><span class="keyword">from</span> rest_framework.authentication <span class="keyword">import</span> BaseAuthentication</span><br><span class="line"><span class="keyword">from</span> rest_framework_jwt.authentication <span class="keyword">import</span> jwt_decode_handler</span><br><span class="line"><span class="keyword">from</span> rest_framework_jwt.utils <span class="keyword">import</span> jwt_decode_handler <span class="comment"># 和上面是一个</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.exceptions <span class="keyword">import</span> AuthenticationFailed</span><br><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyJwtAuthentication</span>(<span class="params">BaseAuthentication</span>):</span> <span class="comment">#try后面的异常不会被DRF异常捕获, 需要处理后交给AuthenticationFailed</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        jwt_value = request.META.get(<span class="string">&#x27;HTTP_AUTHORIZATION&#x27;</span>)   <span class="comment">#</span></span><br><span class="line">        <span class="comment"># jwt_value = request.GET.get(&#x27;token&#x27;)</span></span><br><span class="line">        <span class="keyword">if</span> jwt_value:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># jwt提供了通过三段token, 取出payload的方法, 并且有校验功能</span></span><br><span class="line">                payload = jwt_decode_handler(jwt_value)</span><br><span class="line">            <span class="keyword">except</span> jwt.ExpiredSignature:</span><br><span class="line">                <span class="keyword">raise</span> AuthenticationFailed(<span class="string">&#x27;签名过期&#x27;</span>)</span><br><span class="line">            <span class="keyword">except</span> jwt.InvalidTokenError:</span><br><span class="line">                <span class="keyword">raise</span> AuthenticationFailed(<span class="string">&#x27;用户非法&#x27;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="comment"># 所有异常都会走这里</span></span><br><span class="line">                <span class="keyword">raise</span> AuthenticationFailed(str(e))</span><br><span class="line">            <span class="comment"># payload就是用户信息的字典</span></span><br><span class="line">            print(payload)</span><br><span class="line">            <span class="comment"># 需要得到user对象,</span></span><br><span class="line">            <span class="comment"># 第一种, 去数据库查</span></span><br><span class="line">            user = models.User.objects.get(pk=payload.get(<span class="string">&#x27;user_id&#x27;</span>))</span><br><span class="line">            <span class="comment"># 第二种不查库, 快，但是信息不完整; 可以是优化点</span></span><br><span class="line">            user = models.User(id=payload.get(<span class="string">&#x27;user_id&#x27;</span>), username=payload.get(<span class="string">&#x27;username&#x27;</span>))</span><br><span class="line">            <span class="keyword">return</span> user, jwt_value</span><br><span class="line">        <span class="comment"># 没有值, 直接抛异常</span></span><br><span class="line">        <span class="keyword">raise</span> AuthenticationFailed(<span class="string">&#x27;您没有携带认证信息&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>2.基于BaseJSONWebTokenAuthentication自定制jwt的认证类</strong></p>
<p>核心就是取user对象的时候，有现成的方法(实际上还是去数据库查了);self.authenticate_credentials(payload)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyJwtAuthentication</span>(<span class="params">BaseJSONWebTokenAuthentication</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        jwt_value = request.META.get(<span class="string">&#x27;HTTP_AUTHORIZATION&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> jwt_value:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># jwt提供了通过三段token, 取出payload的方法, 并且有校验功能</span></span><br><span class="line">                payload = jwt_decode_handler(jwt_value)</span><br><span class="line">            <span class="keyword">except</span> jwt.ExpiredSignature:</span><br><span class="line">                <span class="keyword">raise</span> AuthenticationFailed(<span class="string">&#x27;签名过期&#x27;</span>)</span><br><span class="line">            <span class="keyword">except</span> jwt.InvalidTokenError:</span><br><span class="line">                <span class="keyword">raise</span> AuthenticationFailed(<span class="string">&#x27;用户非法&#x27;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="comment"># 所有异常都会走这里</span></span><br><span class="line">                <span class="keyword">raise</span> AuthenticationFailed(str(e))</span><br><span class="line">            <span class="comment"># payload就是用户信息的字典</span></span><br><span class="line">            print(payload)</span><br><span class="line">            <span class="comment"># 需要得到user对象,</span></span><br><span class="line">            user = self.authenticate_credentials(payload)</span><br><span class="line">            <span class="keyword">return</span> user, jwt_value</span><br><span class="line">        <span class="comment"># 没有值, 直接抛异常</span></span><br><span class="line">        <span class="keyword">raise</span> AuthenticationFailed(<span class="string">&#x27;您没有携带认证信息&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>3.基于自定义User表, 签发token</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>拿到输入的用户名密码之后，查user对象</span><br><span class="line"><span class="number">2.</span>通过user对象调用对应方法得到 payload = jwt_payload_handler(user)</span><br><span class="line"><span class="number">3.</span>通过payload拿到token      token=jwt_encode_handler(payload)</span><br></pre></td></tr></table></figure>

<p>**4.**手动签发token,并支持多方式登录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>拿到输入的用户名密码之后，调用序列化器验证</span><br><span class="line">2.序列化器中写全局钩子检验用户名---&gt; 正则匹配---&gt;查询到user对象，然后check_password校验密码(这些可以统一写到_get_user方法)</span><br><span class="line">3.获取token ---&gt; _get_token ---&gt; 通过user获取payload, 通过payload拿到token</span><br><span class="line"><span class="number">4.</span>通过context上下文 和 views视图联动，self.context[<span class="string">&#x27;token&#x27;</span>] = token   记得最后validate返回attrs</span><br><span class="line"><span class="number">5.</span>视图层拿到token login_ser = login_ser.context.get(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSerializer</span>(<span class="params">serializers.ModelSerializer</span>):</span></span><br><span class="line">    username=serializers.CharField()  <span class="comment"># 重新覆盖username字段,数据中它是unique, post,认为你是保存数据,自己没有校验过</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model=User</span><br><span class="line">        fields=[<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;password&#x27;</span>]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>DRF</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>DRF-12-RBAC</title>
    <url>/posts/17010.html</url>
    <content><![CDATA[<p>RBAC</p>
<a id="more"></a>

<h1 id="RBAC-基于角色的访问控制"><a href="#RBAC-基于角色的访问控制" class="headerlink" title="RBAC-基于角色的访问控制"></a>RBAC-基于角色的访问控制</h1><h2 id="一-什么是RBAC"><a href="#一-什么是RBAC" class="headerlink" title="一 什么是RBAC"></a>一 什么是RBAC</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RBAC  是基于角色的访问控制（Role-Based Access Control ）在 RBAC  中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。这样管理都是层级相互依赖的，权限赋予给角色，而把角色又赋予用户，这样的权限设计很清楚，管理起来很方便。</span><br></pre></td></tr></table></figure>

<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># RBAC - Role-Based Access Control</span><br><span class="line"># Django的 Auth组件 采用的认证规则就是RBAC</span><br><span class="line"></span><br><span class="line"># 1）像专门做人员权限管理的系统（CRM系统）都是公司内部使用，所以数据量都在10w一下，一般效率要求也不是很高</span><br><span class="line"># 2）用户量极大的常规项目，会分两种用户：前台用户(三大认证) 和 后台用户(BRAC来管理)</span><br><span class="line"># 结论：没有特殊要求的Django项目可以直接采用Auth组件的权限六表，不需要自定义六个表，也不需要断开表关系，单可能需要自定义User表</span><br></pre></td></tr></table></figure>

<h3 id="前后台权限控制"><a href="#前后台权限控制" class="headerlink" title="前后台权限控制"></a>前后台权限控制</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1）后台用户对各表操作，是后台项目完成的，我们可以直接借助admin后台项目（Django自带的）</span><br><span class="line"># 2）后期也可以用xadmin框架来做后台用户权限管理</span><br><span class="line"></span><br><span class="line"># 3）前台用户的权限管理如何处理</span><br><span class="line">#   定义了一堆数据接口的视图类，不同的登录用户是否能访问这些视图类，能就代表有权限，不能就代表无权限</span><br><span class="line">#   前台用户权限用drf框架的 三大认证</span><br></pre></td></tr></table></figure>

<h2 id="二-Django的内置RBAC-六表"><a href="#二-Django的内置RBAC-六表" class="headerlink" title="二 Django的内置RBAC(六表)"></a>二 Django的内置RBAC(六表)</h2><h3 id="权限三表"><a href="#权限三表" class="headerlink" title="权限三表"></a>权限三表</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggqmxia622j317j08gmy2.jpg" alt="权限三表"></p>
<h3 id="权限六表"><a href="#权限六表" class="headerlink" title="权限六表"></a>权限六表</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggqmxvp38zj319t0jlgnb.jpg" alt="权限六表"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user表    permission表    group表</span><br><span class="line">user_groups表  是  user  和  group  中间表</span><br><span class="line">group_permissions表 是  group 和 permission中间表</span><br><span class="line">user_user_permission 是 user 和 permission中间表  （用户扩展权限）</span><br></pre></td></tr></table></figure>





<h2 id="三-实操"><a href="#三-实操" class="headerlink" title="三 实操"></a>三 实操</h2><h3 id="models-py"><a href="#models-py" class="headerlink" title="models.py"></a>models.py</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">from django.contrib.auth.models import AbstractUser</span><br><span class="line">class User(AbstractUser):</span><br><span class="line">    mobile &#x3D; models.CharField(max_length&#x3D;11, unique&#x3D;True)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.username</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Book(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;64)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Car(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;64)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br></pre></td></tr></table></figure>

<h3 id="admin-py"><a href="#admin-py" class="headerlink" title="admin.py"></a>admin.py</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from . import models</span><br><span class="line"></span><br><span class="line">from django.contrib.auth.admin import UserAdmin as DjangoUserAdmin</span><br><span class="line"></span><br><span class="line"># 自定义User表后，admin界面管理User类</span><br><span class="line">class UserAdmin(DjangoUserAdmin):</span><br><span class="line">    # 添加用户课操作字段</span><br><span class="line">    add_fieldsets &#x3D; (</span><br><span class="line">        (None, &#123;</span><br><span class="line">            &#39;classes&#39;: (&#39;wide&#39;,),</span><br><span class="line">            &#39;fields&#39;: (&#39;username&#39;, &#39;password1&#39;, &#39;password2&#39;, &#39;is_staff&#39;, &#39;mobile&#39;, &#39;groups&#39;, &#39;user_permissions&#39;),</span><br><span class="line">        &#125;),</span><br><span class="line">    )</span><br><span class="line">    # 展示用户呈现的字段</span><br><span class="line">    list_display &#x3D; (&#39;username&#39;, &#39;mobile&#39;, &#39;is_staff&#39;, &#39;is_active&#39;, &#39;is_superuser&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">admin.site.register(models.User, UserAdmin)</span><br><span class="line">admin.site.register(models.Book)</span><br><span class="line">admin.site.register(models.Car)</span><br></pre></td></tr></table></figure>

<p>这样就可以登陆到admin后台进行操作了</p>
<h2 id="四-创建自定义的用户模型类"><a href="#四-创建自定义的用户模型类" class="headerlink" title="四 创建自定义的用户模型类"></a>四 创建自定义的用户模型类</h2><ul>
<li>为什么继承Django的用户，扩展自己的用户表<ul>
<li>字段满足需求</li>
<li>提供了很多常用的方法和管理器方法<ul>
<li>方法：set_password 设置密码 加密， 检查密码check_password</li>
<li>管理器方法：create user ；create superuser</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Django认证系统中提供的用户模型类及方法很方便，我们可以使用这个模型类，但是字段有些无法满足项目需求，如本项目中需要保存用户的手机号，需要给模型类添加额外的字段。</p>
<p>Django提供了<code>django.contrib.auth.models.AbstractUser</code>用户抽象模型类允许我们继承，扩展字段来使用Django认证系统的用户模型类。</p>
<p><strong>我们可以在apps中创建Django应用users，并在配置文件中注册users应用。</strong></p>
<p>在创建好的应用models.py中定义用户的用户模型类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> AbstractUser</span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"><span class="keyword">from</span> host.utils.models <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">AbstractUser</span>):</span></span><br><span class="line"></span><br><span class="line">    mobile = models.CharField(max_length=<span class="number">15</span>,verbose_name=<span class="string">&#x27;手机号码&#x27;</span>)</span><br><span class="line">    avatar = models.ImageField(upload_to=<span class="string">&#x27;avatar&#x27;</span>, verbose_name=<span class="string">&#x27;用户头像&#x27;</span>, null=<span class="literal">True</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># roles = models.ManyToManyField(&#x27;Role&#x27;)</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">&#x27;hippo_user&#x27;</span></span><br><span class="line">        verbose_name = <span class="string">&#x27;用户信息&#x27;</span></span><br><span class="line">        verbose_name_plural = verbose_name</span><br><span class="line"></span><br><span class="line">// 下面的<span class="number">3</span>个表现不用创建，留着以后使用</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Menu</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    一级菜单表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">12</span>)</span><br><span class="line">    weight = models.IntegerField(default=<span class="number">0</span>)</span><br><span class="line">    icon = models.CharField(max_length=<span class="number">16</span>, null=<span class="literal">True</span>, blank=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.title</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">&#x27;hippo_menu&#x27;</span></span><br><span class="line">        verbose_name = <span class="string">&#x27;一级菜单表&#x27;</span></span><br><span class="line">        verbose_name_plural = verbose_name</span><br><span class="line">        unique_together = (<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;weight&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Permission</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    url = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    title = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    menus = models.ForeignKey(<span class="string">&#x27;Menu&#x27;</span>,on_delete=models.CASCADE , null=<span class="literal">True</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    parent = models.ForeignKey(<span class="string">&#x27;self&#x27;</span>,on_delete=models.CASCADE ,  null=<span class="literal">True</span>, blank=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    url_name = models.CharField(max_length=<span class="number">32</span>, unique=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.title</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">&#x27;hippo_permission&#x27;</span></span><br><span class="line">        verbose_name = <span class="string">&#x27;权限表&#x27;</span></span><br><span class="line">        verbose_name_plural = verbose_name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">12</span>)</span><br><span class="line">    permissions = models.ManyToManyField(to=<span class="string">&#x27;Permission&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">&#x27;hippo_role&#x27;</span></span><br><span class="line">        verbose_name = <span class="string">&#x27;角色表&#x27;</span></span><br><span class="line">        verbose_name_plural = verbose_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们自定义的用户模型类还不能直接被Django的认证系统所识别，需要在配置文件中告知Django认证系统使用我们自定义的模型类。</p>
<p>在配置文件中进行设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注册自定义用户模型，格式：“应用名.模型类名”</span></span><br><span class="line">AUTH_USER_MODEL = <span class="string">&#x27;users.User&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>AUTH_USER_MODEL</code> 参数的设置以<code>点.</code>来分隔，表示<code>应用名.模型类名</code>。</p>
<p><strong>注意：Django建议我们对于AUTH_USER_MODEL参数的设置一定要在第一次数据库迁移之前就设置好，否则后续使用可能出现未知错误。</strong></p>
<p>执行数据库迁移</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<p>如果在第一次数据迁移以后，才设置AUTH_USER_MODEL自定义用户模型，则会报错。解决方案如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0.</span> 先把现有的数据库导出备份，然后清掉数据库中所有的数据表。</span><br><span class="line"><span class="number">1.</span> 把开发者创建的所有子应用下面的migrations目录下除了__init__.py以外的所有迁移文件，只要涉及到用户的，一律删除,并将django-migrations表中的数据全部删除。</span><br><span class="line"><span class="number">2.</span> 把django.contrib.admin.migrations目录下除了__init__.py以外的所有迁移文件，全部删除。</span><br><span class="line"><span class="number">3.</span> 把django.contrib.auth.migrations目录下除了__init__.py以外的所有迁移文件，全部删除。</span><br><span class="line"><span class="number">4.</span> 把reversion.migrations目录下除了__init__.py以外的所有迁移文件，全部删除。这个不在django目录里面，在site-packages里面，是xadmin安装的时候带的，它会记录用户信息，也需要删除</span><br><span class="line"><span class="number">5.</span> 把xadmin.migrations目录下除了__init__.py以外的所有迁移文件，全部删除。</span><br><span class="line"><span class="number">6.</span> 删除我们当前数据库中的所有表</span><br><span class="line"><span class="number">7.</span> 接下来，执行数据迁移(makemigrations和migrate)，回顾第<span class="number">0</span>步中的数据，将数据导入就可以了，以后如果要修改用户相关数据，不需要重复本次操作，直接数据迁移即可。</span><br></pre></td></tr></table></figure>

<h4 id="Django用户模型类"><a href="#Django用户模型类" class="headerlink" title="Django用户模型类"></a>Django用户模型类</h4><p>Django认证系统中提供了用户模型类User保存用户的数据，默认的User包含以下常见的基本字段：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>username</code></td>
<td>必选。150个字符以内。 用户名可能包含字母数字，<code>_</code>，<code>@</code>，<code>+</code> <code>.</code> 和<code>-</code>个字符。</td>
</tr>
<tr>
<td><code>first_name</code></td>
<td>可选（<code>blank=True</code>）。 少于等于30个字符。</td>
</tr>
<tr>
<td><code>last_name</code></td>
<td>可选（<code>blank=True</code>）。 少于等于30个字符。</td>
</tr>
<tr>
<td><code>email</code></td>
<td>可选（<code>blank=True</code>）。 邮箱地址。</td>
</tr>
<tr>
<td><code>password</code></td>
<td>必选。 密码的哈希加密串。 （Django 不保存原始密码）。 原始密码可以无限长而且可以包含任意字符。</td>
</tr>
<tr>
<td><code>groups</code></td>
<td>与<code>Group</code> 之间的多对多关系。</td>
</tr>
<tr>
<td><code>user_permissions</code></td>
<td>与<code>Permission</code> 之间的多对多关系。</td>
</tr>
<tr>
<td><code>is_staff</code></td>
<td>布尔值。 设置用户是否可以访问Admin 站点。</td>
</tr>
<tr>
<td><code>is_active</code></td>
<td>布尔值。 指示用户的账号是否激活。 它不是用来控制用户是否能够登录，而是描述一种帐号的使用状态。</td>
</tr>
<tr>
<td><code>is_superuser</code></td>
<td>是否是超级用户。超级用户具有所有权限。</td>
</tr>
<tr>
<td><code>last_login</code></td>
<td>用户最后一次登录的时间。</td>
</tr>
<tr>
<td><code>date_joined</code></td>
<td>账户创建的时间。 当账号创建时，默认设置为当前的date/time。</td>
</tr>
</tbody></table>
<p>上面缺少一些字段，所以后面我们会对它进行改造，比如说它里面没有手机号字段，后面我们需要加上。</p>
<h5 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h5><ul>
<li><p><code>set_password</code>(<em>raw_password</em>)</p>
<p>设置用户的密码为给定的原始字符串，并负责密码的。 不会保存<code>User</code> 对象。当<code>None</code>为<code>raw_password</code> 时，密码将设置为一个不可用的密码。</p>
</li>
<li><p><code>check_password</code>(<em>raw_password</em>)</p>
<p>如果给定的raw_password是用户的真实密码，则返回True，可以在校验用户密码时使用。</p>
</li>
</ul>
<h5 id="管理器方法："><a href="#管理器方法：" class="headerlink" title="管理器方法："></a>管理器方法：</h5><p>管理器方法即可以通过<code>User.objects.</code> 进行调用的方法。</p>
<ul>
<li><p><code>create_user</code>(<em>username</em>, <em>email=None</em>, <em>password=None</em>, *<em>\</em>extra_fields*)</p>
<p>创建、保存并返回一个<code>User</code>对象。</p>
</li>
<li><p><code>create_superuser</code>(<em>username</em>, <em>email</em>, <em>password</em>, *<em>\</em>extra_fields*)</p>
<p>与<code>create_user()</code> 相同，但是设置<code>is_staff</code> 和<code>is_superuser</code> 为<code>True</code>。</p>
</li>
</ul>
<hr>
<p>对象级别权限控制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Django-guardian</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>DRF</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>DRF-13-跨域请求</title>
    <url>/posts/26748.html</url>
    <content><![CDATA[<p>跨域</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">同源策略: 浏览器的安全策略。不允许不同域(ip+端口+协议)   </span><br><span class="line">  APP不存在跨域，前后端分离存在跨域</span><br><span class="line">同源策略: 请求的url地址，必须与浏览器上的url地址处于同域上, 也就是域名,端口,协议相同。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">跨域资源共享，CORS,本质就是在响应头部加入允许,允许某些域,允许某些头</span><br><span class="line">本质允许不同的域来我的服务器拿数据: </span><br><span class="line">  <span class="number">1.</span> 后端解决: 响应头上加允许(CORS: 跨域资源共享)  (<span class="number">1</span>)可以在中间件写 (<span class="number">2</span>)也可以用django-cors-headers模块</span><br><span class="line">  <span class="number">2.</span> 前端解决: 前端自己代理（假装自己是访问者，直接访问后端接口）</span><br><span class="line">  <span class="number">3.</span> Nginx上解决</span><br><span class="line">(<span class="number">1</span>)相同域名的项目，就用Nginx代理，不用配置跨域（原因是你访问前端页面是<span class="number">80</span>，访问后端接口也是<span class="number">80</span>代理的后端，浏览器认为是同源）</span><br><span class="line">访问<span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span>/api路径转发到<span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span>:<span class="number">8080</span>/api</span><br><span class="line">(<span class="number">2</span>) 不同域名的项目</span><br><span class="line">location / &#123;  </span><br><span class="line">    add_header Access-Control-Allow-Origin *;</span><br><span class="line">    add_header Access-Control-Allow-Methods <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">    add_header Access-Control-Allow-Headers <span class="string">&#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($request_method = <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">204</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">###前端解决，一般不用</span></span><br><span class="line"><span class="comment"># 原理: </span></span><br><span class="line">在本地运行 npm run dev 等命令时实际上是用 node 运行了一个服务器，因此 proxyTable 实际上是将请求发给自己的服务器，再由服务器转发给后台服务器，做了一层代理。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> vue.config.js中module.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        target: <span class="string">&#x27;http://127.0.0.1:8000&#x27;</span>,</span><br><span class="line">        changeOrigin: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 使用axios发送请求</span><br><span class="line">      mounted() &#123;</span><br><span class="line">            axios.get(&#x27;api/index/&#x27;).then(res =&gt; &#123;</span><br><span class="line">                console.log(res.data)</span><br><span class="line">                this.data_list = res.data.data.films</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># csrf: 跨站请求伪造(唯一字符串)   cors: 跨域资源共享   xss: 跨站脚本攻击</span></span><br><span class="line"><span class="comment">## 解决方式    </span></span><br><span class="line">csrf解决方式: csrf --&gt; django对提交数据的请求会要求携带一个随机字符串。</span><br><span class="line"></span><br><span class="line">xss解决方式: 后端在渲染的时候模板语言 将标签替换成特殊字符例如 &lt; 替换为 &amp;lt。</span><br><span class="line">    前端不转义: </span><br><span class="line">      value=<span class="string">&quot;&lt;a href=&quot;</span><span class="string">&quot;&gt;点击&lt;/a&gt;&quot;</span></span><br><span class="line">      &#123;&#123; value|safe&#125;&#125;</span><br><span class="line">      &lt;p&gt;&#123;&#123; label &#125;&#125;&lt;/p&gt;  &lt;!--为了安全系统会把标签变成字符串--&gt;</span><br><span class="line">      &lt;p&gt;&#123;&#123; label|safe &#125;&#125;&lt;/p&gt;    &lt;!--加上safe，确定你的数据是安全的才能被当成是标签--&gt;</span><br><span class="line">    后端不转义:</span><br><span class="line">      mark_safe 通过html特殊字符的替换</span><br></pre></td></tr></table></figure>

<p>可以直接写在中间件:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMiddle</span>(<span class="params">MiddlewareMixin</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span>(<span class="params">self, request, response</span>):</span></span><br><span class="line">        response[<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>] = <span class="string">&#x27;*&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> request.method == <span class="string">&#x27;OPTIONS&#x27;</span>:</span><br><span class="line">            <span class="comment"># 可以加</span></span><br><span class="line">            response[<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>] = <span class="string">&quot;Content-Type&quot;</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<p>处理方式:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 三方模块</span></span><br><span class="line">    - django-cors-headers  注册app-配置中间件-settings配置</span><br><span class="line"><span class="comment"># 2. 自己处理, 就在中间件中允许域和头</span></span><br></pre></td></tr></table></figure>

<p>跨域:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">跨域: 简单请求和非简单请求, 非简单请求发送两次，一次OPTIONS预检请求</span><br><span class="line"><span class="comment"># 只要同时满足以下两大条件，就属于简单请求。</span></span><br><span class="line">(<span class="number">1</span>)请求方法是以下三种方法之一：</span><br><span class="line">HEAD</span><br><span class="line">GET</span><br><span class="line">POST</span><br><span class="line">（<span class="number">2</span>）HTTP的头信息不超出以下几种字段：</span><br><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Content-Language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</span><br><span class="line"></span><br><span class="line"><span class="comment"># 凡是不同时满足上面两个条件，就属于非简单请求。</span></span><br><span class="line"><span class="comment"># 览器对这两种请求的处理，是不一样的。</span></span><br></pre></td></tr></table></figure>



<h1 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h1><h2 id="一-同源策略"><a href="#一-同源策略" class="headerlink" title="一 同源策略"></a>一 同源策略</h2><p>同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现</p>
<p>请求的url地址,必须与浏览器上的url地址处于同域上,也就是域名,端口,协议相同.</p>
<p>比如:我在本地上的域名是127.0.0.1:8000,请求另外一个域名：127.0.0.1:8001一段数据</p>
<p>浏览器上就会报错，个就是同源策略的保护,如果浏览器对javascript没有同源策略的保护,那么一些重要的机密网站将会很危险</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">已拦截跨源请求：同源策略禁止读取位于 http:&#x2F;&#x2F;127.0.0.1:8001&#x2F;SendAjax&#x2F; 的远程资源。（原因：CORS 头缺少 &#39;Access-Control-Allow-Origin&#39;）。</span><br></pre></td></tr></table></figure>

<p>但是注意，项目2中的访问已经发生了，说明是浏览器对非同源请求返回的结果做了拦截</p>
<h2 id="二-CORS（跨域资源共享）简介"><a href="#二-CORS（跨域资源共享）简介" class="headerlink" title="二 CORS（跨域资源共享）简介"></a>二 CORS（跨域资源共享）简介</h2><p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<h2 id="三-CORS基本流程"><a href="#三-CORS基本流程" class="headerlink" title="三 CORS基本流程"></a>三 CORS基本流程</h2><p>浏览器将CORS请求分成两类：<strong>简单请求（simple request）</strong>和<strong>非简单请求（not-so-simple request</strong>）。<br>浏览器发出CORS<strong>简单请求</strong>，<strong>只需要在头信息之中增加一个Origin字</strong>段。<br>浏览器发出CORS<strong>非简单请求</strong>，<strong>会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</strong></p>
<h2 id="四-CORS两种请求详解"><a href="#四-CORS两种请求详解" class="headerlink" title="四 CORS两种请求详解"></a>四 CORS两种请求详解</h2><p>只要同时满足以下两大条件，就属于简单请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1) 请求方法是以下三种方法之一：</span><br><span class="line">HEAD</span><br><span class="line">GET</span><br><span class="line">POST</span><br><span class="line">（2）HTTP的头信息不超出以下几种字段：</span><br><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Content-Language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-Type：只限于三个值application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain</span><br></pre></td></tr></table></figure>

<p>凡是不同时满足上面两个条件，就属于非简单请求。</p>
<p>浏览器对这两种请求的处理，是不一样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 简单请求和非简单请求的区别？</span><br><span class="line"></span><br><span class="line">   简单请求：一次请求</span><br><span class="line">   非简单请求：两次请求，在发送数据之前会先发一次请求用于做“预检”，只有“预检”通过后才再发送一次请求用于数据传输。</span><br><span class="line">* 关于“预检”</span><br><span class="line"></span><br><span class="line">- 请求方式：OPTIONS</span><br><span class="line">- “预检”其实做检查，检查如果通过则允许传输数据，检查不通过则不再发送真正想要发送的消息</span><br><span class="line">- 如何“预检”</span><br><span class="line">     &#x3D;&gt; 如果复杂请求是PUT等请求，则服务端需要设置允许某请求，否则“预检”不通过</span><br><span class="line">        Access-Control-Request-Method</span><br><span class="line">     &#x3D;&gt; 如果复杂请求设置了请求头，则服务端需要设置允许某请求头，否则“预检”不通过</span><br><span class="line">        Access-Control-Request-Headers</span><br></pre></td></tr></table></figure>

<p><strong>支持跨域，简单请求</strong></p>
<p>服务器设置响应头：Access-Control-Allow-Origin = ‘域名’ 或 ‘*’</p>
<p><strong>支持跨域，复杂请求</strong></p>
<p>由于复杂请求时，首先会发送“预检”请求，如果“预检”成功，则发送真实数据。</p>
<ul>
<li>“预检”请求时，允许请求方式则需服务器设置响应头：Access-Control-Request-Method</li>
<li>“预检”请求时，允许请求头则需服务器设置响应头：Access-Control-Request-Headers</li>
</ul>
<h2 id="五-Django项目中支持CORS"><a href="#五-Django项目中支持CORS" class="headerlink" title="五 Django项目中支持CORS"></a>五 Django项目中支持CORS</h2><p>在返回的结果中加入允许信息（简单请求）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def test(request):</span><br><span class="line">    import json</span><br><span class="line">    obj&#x3D;HttpResponse(json.dumps(&#123;&#39;name&#39;:&#39;lqz&#39;&#125;))</span><br><span class="line">    # obj[&#39;Access-Control-Allow-Origin&#39;]&#x3D;&#39;*&#39;</span><br><span class="line">    obj[&#39;Access-Control-Allow-Origin&#39;]&#x3D;&#39;http:&#x2F;&#x2F;127.0.0.1:8004&#39;</span><br><span class="line">    return obj</span><br></pre></td></tr></table></figure>

<p>放到中间件处理复杂和简单请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.utils.deprecation import MiddlewareMixin</span><br><span class="line">class CorsMiddleWare(MiddlewareMixin):</span><br><span class="line">    def process_response(self,request,response):</span><br><span class="line">        if request.method&#x3D;&#x3D;&quot;OPTIONS&quot;:</span><br><span class="line">            #可以加*</span><br><span class="line">            response[&quot;Access-Control-Allow-Headers&quot;]&#x3D;&quot;Content-Type&quot;</span><br><span class="line">        response[&quot;Access-Control-Allow-Origin&quot;] &#x3D; &quot;http:&#x2F;&#x2F;localhost:8080&quot;</span><br><span class="line">        return response</span><br></pre></td></tr></table></figure>

<h2 id="六-django-使用django-cors-headers-解决跨域问题"><a href="#六-django-使用django-cors-headers-解决跨域问题" class="headerlink" title="六 django 使用django-cors-headers 解决跨域问题"></a>六 django 使用django-cors-headers 解决跨域问题</h2><h3 id="1、使用pip安装"><a href="#1、使用pip安装" class="headerlink" title="1、使用pip安装"></a>1、使用pip安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install django-cors-headers</span><br><span class="line"></span><br><span class="line">官网地址：https:&#x2F;&#x2F;github.com&#x2F;adamchainz&#x2F;django-cors-headers</span><br></pre></td></tr></table></figure>

<h3 id="2、添加到setting的app中"><a href="#2、添加到setting的app中" class="headerlink" title="2、添加到setting的app中"></a>2、添加到setting的app中</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS &#x3D; (</span><br><span class="line">    ...</span><br><span class="line">    &#39;corsheaders&#39;,</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="3、添加中间件"><a href="#3、添加中间件" class="headerlink" title="3、添加中间件"></a>3、添加中间件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MIDDLEWARE &#x3D; [  # Or MIDDLEWARE_CLASSES on Django &lt; 1.10</span><br><span class="line">    ...</span><br><span class="line">    &#39;corsheaders.middleware.CorsMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.common.CommonMiddleware&#39;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="4、setting下面添加下面的配置"><a href="#4、setting下面添加下面的配置" class="headerlink" title="4、setting下面添加下面的配置"></a>4、setting下面添加下面的配置</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CORS_ALLOW_ALL_ORIGINS = <span class="literal">True</span></span><br><span class="line"><span class="comment"># CORS_ORIGIN_WHITELIST = (</span></span><br><span class="line">    <span class="string">&#x27;http://127.0.0.1:9528&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;http://localhost:9528&#x27;</span>,</span><br><span class="line">)</span><br><span class="line">CORS_ALLOW_CREDENTIALS = <span class="literal">False</span> <span class="comment">#  是否允许ajax跨域请求时携带cookie，False表示不用，我们后面也用不到cookie，所以关掉它就可以了，以防有人通过cookie来搞我们的网站 </span></span><br><span class="line">CORS_ORIGIN_ALLOW_ALL = <span class="literal">True</span></span><br><span class="line"><span class="comment"># 允许的请求方法</span></span><br><span class="line">CORS_ALLOW_METHODS = (</span><br><span class="line">    <span class="string">&#x27;DELETE&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;OPTIONS&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;PATCH&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;PUT&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;VIEW&#x27;</span>,</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 允许的请求头</span></span><br><span class="line">CORS_ALLOW_HEADERS = (</span><br><span class="line">    <span class="string">&#x27;XMLHttpRequest&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;X_FILENAME&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;accept-encoding&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;authorization&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;content-type&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;dnt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;origin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;user-agent&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;x-csrftoken&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;x-requested-with&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Pragma&#x27;</span>,</span><br><span class="line">  <span class="comment"># 额外允许的头</span></span><br><span class="line">  <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DRF</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>DRF-07-过滤分页异常处理</title>
    <url>/posts/35751.html</url>
    <content><![CDATA[<p>过滤/分页/异常处理</p>
<a id="more"></a>

<h1 id="一-过滤Filtering"><a href="#一-过滤Filtering" class="headerlink" title="一 过滤Filtering"></a>一 过滤Filtering</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">三种方式：</span><br><span class="line">(<span class="number">1</span>)内置过滤类SearchFilter  使用前提：最顶层的类至少是GenericAPIView</span><br><span class="line">视图类中添加 search_fields=[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;publish&#x27;</span>] 属性</span><br><span class="line"><span class="comment"># 查询使用</span></span><br><span class="line">http://127.0.0.1:8000/books/?search=达   # 出版社中或名字中有 达 就能查询出来</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)扩展插件django-filter </span><br><span class="line">视图类中添加 filter_fields 属性</span><br><span class="line"><span class="comment"># 127.0.0.1:8000/four/students/?sex=1</span></span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)方式一: 自定义过滤类BaseFilterBackend</span><br><span class="line">   <span class="number">1</span> 继承BaseFilterBackend</span><br><span class="line">   <span class="number">2</span> 重写filter_queryset，在内部实现过滤逻辑，返回queryset对象</span><br><span class="line">   <span class="number">3</span> 在视图类配置  filter_backends = [DjangoFilterBackend,SearchByName]</span><br><span class="line">     放置顺序问题: 尽量越往后结果集越小</span><br><span class="line">     [DjangoFilterBackend,SearchByName] </span><br><span class="line">    </span><br><span class="line">(<span class="number">4</span>) 方式二: 自定义过滤类  继承 filterSet</span><br><span class="line">      使用时不需要写filter_fileds字段了</span><br><span class="line">    <span class="comment"># 直接自定义过滤类即可 DjangoFilterBackend 和  filter_class  要配合使用</span></span><br><span class="line">    filter_backends = [SearchFilter, OrderingFilter, DjangoFilterBackend]</span><br><span class="line">    filter_class = CourseFilterSet</span><br></pre></td></tr></table></figure>



<h2 id="1-内置过滤类使用（在视图类中配置，最顶层的类至少是GenericAPIView）"><a href="#1-内置过滤类使用（在视图类中配置，最顶层的类至少是GenericAPIView）" class="headerlink" title="1. 内置过滤类使用（在视图类中配置，最顶层的类至少是GenericAPIView）"></a>1. 内置过滤类使用（在视图类中配置，最顶层的类至少是GenericAPIView）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">###### 使用前提：最顶层的类至少是GenericAPIView</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 内置过滤类使用，在视图类中配置</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.filters <span class="keyword">import</span> SearchFilter</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookView</span>(<span class="params">ViewSetMixin,ListAPIView</span>):</span></span><br><span class="line">    <span class="comment"># 在视图类中配置，最顶层的类至少是GenericAPIView</span></span><br><span class="line">    filter_backends = [SearchFilter,]</span><br><span class="line">    <span class="comment"># 过滤条件，按名字过滤</span></span><br><span class="line">    search_fields=[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;publish&#x27;</span>]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 查询使用</span></span><br><span class="line">http://127.0.0.1:8000/books/?search=达   # 出版社中或名字中有 达 就能查询出来</span><br><span class="line"></span><br><span class="line">filter_backends = [SearchFilter,]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">######### 如果继承APIView</span></span><br><span class="line">就orm自己写</span><br></pre></td></tr></table></figure>



<h2 id="2-扩展过滤组件django-filter"><a href="#2-扩展过滤组件django-filter" class="headerlink" title="2. 扩展过滤组件django-filter"></a>2. 扩展过滤组件django-filter</h2><p>对于列表数据可能需要根据字段进行过滤，我们可以通过添加django-fitlter扩展来增强支持。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install django-filter</span><br></pre></td></tr></table></figure>

<p>在配置文件中增加过滤后端的设置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;django_filters&#x27;</span>,  <span class="comment"># 需要注册应用，</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">### 全局配置</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;DEFAULT_FILTER_BACKENDS&#x27;</span>: (<span class="string">&#x27;django_filters.rest_framework.DjangoFilterBackend&#x27;</span>,)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 局部配置</span></span><br><span class="line">filter_backends = [DjangoFilterBackend,]</span><br></pre></td></tr></table></figure>

<p>在视图中添加filter_fields属性，指定可以过滤的字段  需要继承<strong>ListAPIView</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentListView</span>(<span class="params">ListAPIView</span>):</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentSerializer</span><br><span class="line">    filter_fields = (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>)   配置可以按照哪个字段来过滤</span><br><span class="line">    <span class="comment">### 局部配置</span></span><br><span class="line">        filter_backends = [DjangoFilterBackend,]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 127.0.0.1:8000/four/students/?sex=1</span></span><br></pre></td></tr></table></figure>



<h2 id="3-自定义过滤器-方式1-继承BaseFilterBackend"><a href="#3-自定义过滤器-方式1-继承BaseFilterBackend" class="headerlink" title="3. 自定义过滤器-方式1(继承BaseFilterBackend)"></a>3. 自定义过滤器-方式1(继承BaseFilterBackend)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>) 继承BaseFilterBackend（通过看内置的过滤类SearchFilter写的）</span><br><span class="line">(<span class="number">2</span>) 重写filter_queryset，在内部实现过滤逻辑，返回queryset对象</span><br><span class="line">(<span class="number">3</span>) 在视图类配置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework.filters <span class="keyword">import</span> BaseFilterBackend</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模糊过滤</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SearchByName</span>(<span class="params">BaseFilterBackend</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">filter_queryset</span>(<span class="params">self, request, queryset, view</span>):</span></span><br><span class="line">        name = request.GET.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        queryset = queryset.filter(name__startswith=name)</span><br><span class="line">        <span class="keyword">return</span> queryset</span><br><span class="line">使用方式---</span><br><span class="line"><span class="comment">### filter_backends = [SearchByName]</span></span><br><span class="line">      </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 区间过滤</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SearchByPrice</span>(<span class="params">BaseFilterBackend</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">filter_queryset</span>(<span class="params">self, request, queryset, view</span>):</span></span><br><span class="line">        price_gt = request.GET.get(<span class="string">&#x27;price_gt&#x27;</span>)</span><br><span class="line">        price_lt = request.GET.get(<span class="string">&#x27;price_lt&#x27;</span>)</span><br><span class="line">        queryset = queryset.filter(price__gt=price_gt, price__lt=price_lt)</span><br><span class="line">        <span class="keyword">return</span> queryset</span><br></pre></td></tr></table></figure>

<h2 id="4-自定义过滤器-方式2-扩写django-filter的filterset实现"><a href="#4-自定义过滤器-方式2-扩写django-filter的filterset实现" class="headerlink" title="4. 自定义过滤器-方式2(扩写django-filter的filterset实现)"></a>4. 自定义过滤器-方式2(扩写django-filter的filterset实现)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># django-filter插件 过滤类</span></span><br><span class="line"><span class="keyword">from</span> django_filters.filterset <span class="keyword">import</span> FilterSet </span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django_filters <span class="keyword">import</span> filters</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CourseFilterSet</span>(<span class="params">FilterSet</span>):</span></span><br><span class="line">    <span class="comment"># 区间过滤：field_name关联的Model字段；lookup_expr设置规则；gt是大于，gte是大于等于；</span></span><br><span class="line">    min_price = filters.NumberFilter(field_name=<span class="string">&#x27;price&#x27;</span>, lookup_expr=<span class="string">&#x27;gte&#x27;</span>)</span><br><span class="line">    max_price = filters.NumberFilter(field_name=<span class="string">&#x27;price&#x27;</span>, lookup_expr=<span class="string">&#x27;lte&#x27;</span>)</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = models.Course</span><br><span class="line">        <span class="comment"># 如果过滤条件仅仅就是Model已有的字段，方式一更好</span></span><br><span class="line">        <span class="comment"># 但是方式二可以自定义过滤字段(重写字段)</span></span><br><span class="line">        fields = [<span class="string">&#x27;course_category&#x27;</span>, <span class="string">&#x27;min_price&#x27;</span>, <span class="string">&#x27;max_price&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment">#####-----&gt;使用&lt;------#####</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DjangoFilterBackend 和  filter_class  要配合使用</span></span><br><span class="line">        % filter_class才能调用到，DjangoFilterBackend里面的filter_queryset</span><br><span class="line"><span class="comment"># 过滤组件：实际开发，有多个过滤条件时，要把优先级高的放在前面</span></span><br><span class="line">    filter_backends = [SearchFilter, OrderingFilter, DjangoFilterBackend]</span><br><span class="line"><span class="comment"># 过滤类：分类过滤、区间过滤 </span></span><br><span class="line">    filter_class = CourseFilterSet</span><br></pre></td></tr></table></figure>

<h4 id="模糊过滤"><a href="#模糊过滤" class="headerlink" title="模糊过滤"></a>模糊过滤</h4><p>官方文档：<a href="https://q1mi.github.io/Django-REST-framework-documentation/api-guide/filtering_zh/">https://q1mi.github.io/Django-REST-framework-documentation/api-guide/filtering_zh/</a></p>
<p><a href="https://django-filter.readthedocs.io/en/latest/guide/rest_framework.html">https://django-filter.readthedocs.io/en/latest/guide/rest_framework.html</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2.</span>字段模糊过滤</span><br><span class="line"></span><br><span class="line">前面三步跟精确匹配完全一致</span><br><span class="line"></span><br><span class="line">第四步,创建一个角色过滤器:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RolesFilter</span>(<span class="params">FilterSet</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;角色过滤器&quot;&quot;&quot;</span></span><br><span class="line">    name = django_filters.CharFilter(field_name=<span class="string">&#x27;name&#x27;</span>, lookup_expr=<span class="string">&quot;icontains&quot;</span>)  <span class="comment"># icontains 包含,忽略大小写</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Role  <span class="comment"># 关联的模型</span></span><br><span class="line">        fields = [<span class="string">&#x27;name&#x27;</span>]  <span class="comment"># 过滤的字段</span></span><br><span class="line">第五步,类视图引入类属性:</span><br><span class="line"></span><br><span class="line">filterset_class = RolesFilter  <span class="comment"># 自定义角色过滤器</span></span><br><span class="line"></span><br><span class="line">第六步,开始使用:http://10.0.2.29:8000/role_manage/roles/?name=媒体,注意:能实现模糊过滤</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="二-排序"><a href="#二-排序" class="headerlink" title="二 排序"></a>二 排序</h1><p>对于列表数据，REST framework提供了<strong>OrderingFilter</strong>过滤器来帮助我们快速指明数据按照指定字段进行排序。</p>
<p>使用方法：</p>
<p>1.在类视图中设置<strong>filter_backends</strong>，使用<code>rest_framework.filters.OrderingFilter</code>过滤器2</p>
<p>2.REST framework会在请求的查询字符串参数中检查是否包含了ordering参数，如果包含了ordering参数，则按照ordering参数指明的排序字段对数据集进行排序。</p>
<p>3.前端可以传递的ordering参数的可选字段值需要在ordering_fields中指明。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentListView</span>(<span class="params">ListAPIView</span>):</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line">    filter_backends = [OrderingFilter]</span><br><span class="line">    ordering_fields = (<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 127.0.0.1:8000/books/?ordering=-age</span></span><br><span class="line"><span class="comment"># -id 表示针对id字段进行倒序排序</span></span><br><span class="line"><span class="comment"># id  表示针对id字段进行升序排序</span></span><br></pre></td></tr></table></figure>

<p>如果需要在过滤以后再次进行排序，则需要两者结合!</p>
<p><font color=red>注意配置字段覆盖的问题</font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.generics <span class="keyword">import</span> ListAPIView</span><br><span class="line"><span class="keyword">from</span> students.models <span class="keyword">import</span> Student</span><br><span class="line"><span class="keyword">from</span> .serializers <span class="keyword">import</span> StudentModelSerializer</span><br><span class="line"><span class="keyword">from</span> django_filters.rest_framework <span class="keyword">import</span> DjangoFilterBackend</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student3ListView</span>(<span class="params">ListAPIView</span>):</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line">    filter_fields = (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>)</span><br><span class="line">    <span class="comment"># 因为局部配置会覆盖全局配置,所以需要重新把过滤组件核心类再次声明,</span></span><br><span class="line">    <span class="comment"># 否则过滤功能会失效</span></span><br><span class="line">    filter_backends = [OrderingFilter,DjangoFilterBackend]</span><br><span class="line">    ordering_fields = (<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;age&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="三-分页Pagination"><a href="#三-分页Pagination" class="headerlink" title="三 分页Pagination"></a>三 分页Pagination</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用的最多的就是 PageNumberPagination</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 重点</span></span><br><span class="line">REST framework提供了分页的支持。继承**ListAPIView类使用**只需要视图中配置pagenation_class即可,因为GenericAPIVIew中有对应的方法。</span><br><span class="line"></span><br><span class="line">要不然比如继承APIView的话, 需要实例化创建分页对象,调用对象方法，传入要分页的数据，book_list,返回分页号的数据, 对分页进行序列化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request,*args,**kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 获取所有数据</span></span><br><span class="line">        ret=models.Book.objects.all()</span><br><span class="line">        <span class="comment"># 创建分页对象</span></span><br><span class="line">        page=PageNumberPagination()</span><br><span class="line">         <span class="comment">#调用对象方法，传入要分页的数据，book_list,返回分页号的数据</span></span><br><span class="line">        page_list=page.paginate_queryset(ret,request,view=self)</span><br><span class="line">        <span class="comment"># 对分页进行序列化</span></span><br><span class="line">        ser=BookSerializer1(instance=page_list,many=<span class="literal">True</span>)</span><br><span class="line">        res=&#123;<span class="string">&#x27;pre&#x27;</span>:pagination.get_previous_link(),<span class="string">&#x27;next&#x27;</span>:pagination.get_next_link(),<span class="string">&#x27;count&#x27;</span>:pagination.page.paginator.count,<span class="string">&#x27;data&#x27;</span>:ser.data&#125;</span><br><span class="line">        <span class="keyword">return</span> Response(res)</span><br><span class="line">        <span class="comment"># 另一种返回方式</span></span><br><span class="line">        <span class="keyword">return</span> pagination.get_paginated_response(ser.data)</span><br></pre></td></tr></table></figure>

<p><strong>查询所有</strong>，才有分页功能，在网站上的下一页功能，app的下滑加载更多</p>
<p>我们可以在配置文件中设置全局的分页方式，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;DEFAULT_PAGINATION_CLASS&#x27;</span>:  <span class="string">&#x27;rest_framework.pagination.PageNumberPagination&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;PAGE_SIZE&#x27;</span>: <span class="number">100</span>  <span class="comment"># 每页数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可通过自定义Pagination类，来为视图添加不同分页行为。在视图中通过<code>pagination_clas</code>属性来指明。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeResultsSetPagination</span>(<span class="params">PageNumberPagination</span>):</span></span><br><span class="line">    page_size = <span class="number">1000</span></span><br><span class="line">    page_size_query_param = <span class="string">&#x27;page_size&#x27;</span></span><br><span class="line">    max_page_size = <span class="number">10000</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookDetailView</span>(<span class="params">RetrieveAPIView</span>):</span></span><br><span class="line">    queryset = BookInfo.objects.all()</span><br><span class="line">    serializer_class = BookInfoSerializer</span><br><span class="line">    pagination_class = LargeResultsSetPagination</span><br></pre></td></tr></table></figure>

<p><strong>注意：如果在视图内关闭分页功能，只需在视图内设置</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pagination_class = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="可选分页器"><a href="#可选分页器" class="headerlink" title="可选分页器"></a>可选分页器</h2><p>1） <strong>PageNumberPagination</strong>（99页，到下一页；先检索前99页，加载几条，显示100页）</p>
<p>前端访问网址形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET  http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;students&#x2F;?page&#x3D;4</span><br></pre></td></tr></table></figure>

<p>可以在子类中定义的属性：</p>
<ul>
<li>page_size = api_settings.PAGE_SIZE   # 每页显示条数</li>
<li>page_query_param = ‘page’                 # 查询时用的参数<a href="http://127.0.0.1:8000/books/?page=2">http://127.0.0.1:8000/books/?page=2</a></li>
<li>page_size_query_param = ‘size’           # <a href="http://127.0.0.1:8000/books/?page=1&amp;size=4">http://127.0.0.1:8000/books/?page=1&amp;size=4</a>  更改返回条数，第一页返回四条</li>
<li>max_page_size = 10                             # 一页最多显示10条 </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># APIView</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.pagination <span class="keyword">import</span> PageNumberPagination</span><br><span class="line"><span class="comment"># 一 基本使用：url=url=http://127.0.0.1:8000/pager/?page=2&amp;size=3，size无效</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Pager</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request,*args,**kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 获取所有数据</span></span><br><span class="line">        ret=models.Book.objects.all()</span><br><span class="line">        <span class="comment"># 创建分页对象</span></span><br><span class="line">        page=PageNumberPagination()</span><br><span class="line">         <span class="comment">#调用对象方法，传入要分页的数据，book_list,返回分页号的数据</span></span><br><span class="line">        page_list=page.paginate_queryset(ret,request,view=self)</span><br><span class="line">        <span class="comment"># 对分页进行序列化</span></span><br><span class="line">        ser=BookSerializer1(instance=page_list,many=<span class="literal">True</span>)</span><br><span class="line">        res=&#123;<span class="string">&#x27;pre&#x27;</span>:pagination.get_previous_link(),<span class="string">&#x27;next&#x27;</span>:pagination.get_next_link(),<span class="string">&#x27;count&#x27;</span>:pagination.page.paginator.count,<span class="string">&#x27;data&#x27;</span>:ser.data&#125;</span><br><span class="line">        <span class="keyword">return</span> Response(res)</span><br><span class="line">        <span class="comment"># 另一种返回方式</span></span><br><span class="line">        <span class="keyword">return</span> pagination.get_paginated_response(ser.data)</span><br><span class="line">      </span><br><span class="line"><span class="comment"># 二 自定制 url=http://127.0.0.1:8000/pager/?page=2&amp;size=3</span></span><br><span class="line"><span class="comment"># size=30，无效，最多5条</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mypage</span>(<span class="params">PageNumberPagination</span>):</span></span><br><span class="line">    page_size = <span class="number">2</span></span><br><span class="line">    page_query_param = <span class="string">&#x27;page&#x27;</span></span><br><span class="line">    <span class="comment"># 定制传参</span></span><br><span class="line">    page_size_query_param = <span class="string">&#x27;size&#x27;</span></span><br><span class="line">    <span class="comment"># 最大一页的数据</span></span><br><span class="line">    max_page_size = <span class="number">5</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Pager</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request,*args,**kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 获取所有数据</span></span><br><span class="line">        ret=models.Book.objects.all()</span><br><span class="line">        <span class="comment"># 创建分页对象</span></span><br><span class="line">        page=Mypage()</span><br><span class="line">        <span class="comment"># 在数据库中获取分页的数据</span></span><br><span class="line">        page_list=page.paginate_queryset(ret,request,view=self)</span><br><span class="line">        <span class="comment"># 对分页进行序列化</span></span><br><span class="line">        ser=BookSerializer1(instance=page_list,many=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># return Response(ser.data)</span></span><br><span class="line">        <span class="comment"># 这个也是返回Response对象，但是比基本的多了上一页，下一页，和总数据条数（了解即可）</span></span><br><span class="line">        <span class="keyword">return</span> page.get_paginated_response(ser.data)</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"><span class="comment">#ListAPIView</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明分页的配置类</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.pagination <span class="keyword">import</span> PageNumberPagination</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardPageNumberPagination</span>(<span class="params">PageNumberPagination</span>):</span></span><br><span class="line">    <span class="comment"># 默认每一页显示的数据量</span></span><br><span class="line">    page_size = <span class="number">2</span></span><br><span class="line">    <span class="comment"># 允许客户端通过get参数来控制每一页的数据量</span></span><br><span class="line">    page_size_query_param = <span class="string">&quot;size&quot;</span></span><br><span class="line">    max_page_size = <span class="number">10</span></span><br><span class="line">    <span class="comment"># 自定义页码的参数名</span></span><br><span class="line">    page_query_param = <span class="string">&quot;p&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentAPIView</span>(<span class="params">ListAPIView</span>):</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line">    pagination_class = StandardPageNumberPagination</span><br><span class="line"></span><br><span class="line"><span class="comment"># 127.0.0.1/four/students/?p=1&amp;size=5</span></span><br></pre></td></tr></table></figure>

<p>2）<strong>LimitOffsetPagination</strong>（99页，到下一页；先检索前99页，加载几条，显示100页）</p>
<p>前端访问网址形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET http:&#x2F;&#x2F;127.0.0.1&#x2F;four&#x2F;students&#x2F;?limit&#x3D;100&amp;offset&#x3D;400</span><br></pre></td></tr></table></figure>

<p>可以在子类中定义的属性：</p>
<ul>
<li>default_limit = api_settings.PAGE_SIZE   # 显示多少条</li>
<li>limit_query_param = ‘limit’                       # limit的参数</li>
<li>offset_query_param = ‘offset’                  # offset偏移的查询参数</li>
<li>max_limit 最大limit限制，默认None        # 最大显示条数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># APIView</span></span><br><span class="line"><span class="comment"># http://127.0.0.1:8000/pager/?offset=4&amp;limit=3</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.pagination <span class="keyword">import</span> LimitOffsetPagination</span><br><span class="line"><span class="comment"># 也可以自定制，同简单分页</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Pager</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request,*args,**kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 获取所有数据</span></span><br><span class="line">        ret=models.Book.objects.all()</span><br><span class="line">        <span class="comment"># 创建分页对象</span></span><br><span class="line">        page=LimitOffsetPagination()</span><br><span class="line">        <span class="comment"># 在数据库中获取分页的数据</span></span><br><span class="line">        page_list=page.paginate_queryset(ret,request,view=self)</span><br><span class="line">        <span class="comment"># 对分页进行序列化</span></span><br><span class="line">        ser=BookSerializer1(instance=page_list,many=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># return page.get_paginated_response(ser.data)</span></span><br><span class="line">        <span class="keyword">return</span> Response(ser.data)</span><br><span class="line"><span class="comment">#ListAPIView</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.pagination <span class="keyword">import</span> LimitOffsetPagination</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardLimitOffsetPagination</span>(<span class="params">LimitOffsetPagination</span>):</span></span><br><span class="line">    <span class="comment"># 默认每一页查询的数据量,类似上面的page_size</span></span><br><span class="line">    default_limit = <span class="number">2</span></span><br><span class="line">    limit_query_param = <span class="string">&quot;size&quot;</span></span><br><span class="line">    offset_query_param = <span class="string">&quot;start&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentAPIView</span>(<span class="params">ListAPIView</span>):</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line">    <span class="comment"># 调用页码分页类</span></span><br><span class="line">    <span class="comment"># pagination_class = StandardPageNumberPagination</span></span><br><span class="line">    <span class="comment"># 调用查询偏移分页类</span></span><br><span class="line">    pagination_class = StandardLimitOffsetPagination</span><br></pre></td></tr></table></figure>

<p>3）<strong>CursorPagination</strong>（下一页上一页速度是一样的，数据量越大越快）</p>
<p>前端访问网址形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET http:&#x2F;&#x2F;127.0.0.1&#x2F;four&#x2F;students&#x2F;?cursor&#x3D;cD0xNQ%3D%3D</span><br></pre></td></tr></table></figure>

<p>可以在子类中定义的属性：</p>
<ul>
<li>cursor_query_param = ‘cursor’                         # 默认查询字段，不需要修改</li>
<li>page_size=api_settings.PAGE_SIZE                 # 每页显示多少条</li>
<li>ordering = ‘id’                                                    # 排序，按id排序</li>
<li>page_size_query_param = ‘size’                       # 通过这个参数决定每页显示多少条  </li>
<li>max_page_size=5                                              # 每页最大显示多少条</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#APIView</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.pagination <span class="keyword">import</span> CursorPagination</span><br><span class="line"><span class="comment"># 看源码，是通过sql查询，大于id和小于id</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Pager</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request,*args,**kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 获取所有数据</span></span><br><span class="line">        ret=models.Book.objects.all()</span><br><span class="line">        <span class="comment"># 创建分页对象</span></span><br><span class="line">        page=CursorPagination()</span><br><span class="line">        page.ordering=<span class="string">&#x27;nid&#x27;</span></span><br><span class="line">        <span class="comment"># 在数据库中获取分页的数据</span></span><br><span class="line">        page_list=page.paginate_queryset(ret,request,view=self)</span><br><span class="line">        <span class="comment"># 对分页进行序列化</span></span><br><span class="line">        ser=BookSerializer1(instance=page_list,many=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 可以避免页码被猜到</span></span><br><span class="line">        <span class="keyword">return</span> page.get_paginated_response(ser.data)</span><br><span class="line"><span class="comment"># ListAPIView</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCursorPagination</span>(<span class="params">CursorPagination</span>):</span></span><br><span class="line">    page_size=<span class="number">2</span></span><br><span class="line">    ordering=<span class="string">&#x27;-id&#x27;</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.generics <span class="keyword">import</span> ListAPIView</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthorListView</span>(<span class="params">ListAPIView</span>):</span></span><br><span class="line">    serializer_class = serializers.AuthorModelSerializer</span><br><span class="line">    queryset = models.Author.objects.filter(is_delete=<span class="literal">False</span>)</span><br><span class="line">    pagination_class =MyCursorPagination</span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.pagination <span class="keyword">import</span> PageNumberPagination,LimitOffsetPagination,CursorPagination</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPageNumberPagination</span>(<span class="params">PageNumberPagination</span>):</span></span><br><span class="line">    page_size = <span class="number">2</span></span><br><span class="line">    page_query_param = <span class="string">&#x27;page&#x27;</span></span><br><span class="line">    <span class="comment"># 定制传参</span></span><br><span class="line">    page_size_query_param = <span class="string">&#x27;size&#x27;</span></span><br><span class="line">    <span class="comment"># 最大一页的数据</span></span><br><span class="line">    max_page_size = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLimitOffsetPagination</span>(<span class="params">LimitOffsetPagination</span>):</span></span><br><span class="line">    default_limit = <span class="number">2</span></span><br><span class="line">    <span class="comment"># 最大一页的数据</span></span><br><span class="line">    max_limit = <span class="number">5</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCursorPagination</span>(<span class="params">CursorPagination</span>):</span></span><br><span class="line">    page_size=<span class="number">2</span></span><br><span class="line">    ordering=<span class="string">&#x27;-id&#x27;</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.generics <span class="keyword">import</span> ListAPIView</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthorListView</span>(<span class="params">ListAPIView</span>):</span></span><br><span class="line">    serializer_class = serializers.AuthorModelSerializer</span><br><span class="line">    queryset = models.Author.objects.filter(is_delete=<span class="literal">False</span>)</span><br><span class="line">    pagination_class =MyCursorPagination</span><br></pre></td></tr></table></figure>

<h1 id="四-异常处理-Exceptions"><a href="#四-异常处理-Exceptions" class="headerlink" title="四 异常处理 Exceptions"></a>四 异常处理 Exceptions</h1><p>默认异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## restframework的settings配置里面</span></span><br><span class="line"><span class="comment"># Exception handling</span></span><br><span class="line"><span class="string">&#x27;EXCEPTION_HANDLER&#x27;</span>: <span class="string">&#x27;rest_framework.views.exception_handler&#x27;</span>,</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 源码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exception_handler</span>(<span class="params">exc, context</span>):</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(exc, Http404):</span><br><span class="line">        exc = exceptions.NotFound()</span><br><span class="line">    <span class="keyword">elif</span> isinstance(exc, PermissionDenied):</span><br><span class="line">        exc = exceptions.PermissionDenied()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> isinstance(exc, exceptions.APIException):</span><br><span class="line">        headers = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> getattr(exc, <span class="string">&#x27;auth_header&#x27;</span>, <span class="literal">None</span>):</span><br><span class="line">            headers[<span class="string">&#x27;WWW-Authenticate&#x27;</span>] = exc.auth_header</span><br><span class="line">        <span class="keyword">if</span> getattr(exc, <span class="string">&#x27;wait&#x27;</span>, <span class="literal">None</span>):</span><br><span class="line">            headers[<span class="string">&#x27;Retry-After&#x27;</span>] = <span class="string">&#x27;%d&#x27;</span> % exc.wait</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> isinstance(exc.detail, (list, dict)):</span><br><span class="line">            data = exc.detail</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data = &#123;<span class="string">&#x27;detail&#x27;</span>: exc.detail&#125;</span><br><span class="line"></span><br><span class="line">        set_rollback()</span><br><span class="line">        <span class="keyword">return</span> Response(data, status=exc.status_code, headers=headers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 有一些没处理，所以return  None,要处理这些</span></span><br></pre></td></tr></table></figure>

<p>REST framework提供了异常处理，我们可以自定义异常处理函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统一接口返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义异常方法: 替换掉全局</span></span><br><span class="line"><span class="comment"># 写一个方法</span></span><br><span class="line"><span class="comment"># 自定义异常处理的方法</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> exception_handler</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_exception_handler</span>(<span class="params">exc, context</span>):</span></span><br><span class="line">    <span class="comment"># 记录日志</span></span><br><span class="line"></span><br><span class="line">    response = exception_handler(exc, context)</span><br><span class="line">    <span class="comment"># 两种情况，一个是None,drf没处理。</span></span><br><span class="line">    <span class="comment"># 一个是Response对象,django处理了，但是处理的不符合要求</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> response:  <span class="comment"># drf未处理的异常</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(exc, ZeroDivisionError):</span><br><span class="line">            <span class="keyword">return</span> Response(data=&#123;<span class="string">&#x27;status&#x27;</span>: <span class="number">777</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;除以0的错误&#x27;</span> + str(exc)&#125;, status=status.HTTP_400_BAD_REQUEST)</span><br><span class="line">         <span class="comment">#未知错误</span></span><br><span class="line">        <span class="keyword">return</span> Response(data=&#123;<span class="string">&#x27;status&#x27;</span>: <span class="number">999</span>, <span class="string">&#x27;msg&#x27;</span>: str(exc)&#125;, status=status.HTTP_400_BAD_REQUEST)</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># drf处理的异常</span></span><br><span class="line">        <span class="keyword">return</span> Response(data=&#123;<span class="string">&#x27;status&#x27;</span>: <span class="number">888</span>, <span class="string">&#x27;msg&#x27;</span>: response.data.get(<span class="string">&#x27;detail&#x27;</span>)&#125;, status=status.HTTP_400_BAD_REQUEST)</span><br><span class="line">        <span class="comment"># return APIResponse(code=0, msg=&#x27;drf-error&#x27;, result=&#123;str(exc)&#125;,status=status.HTTP_400_BAD_REQUEST)</span></span><br></pre></td></tr></table></figure>



<h2 id="4-1-使用方式"><a href="#4-1-使用方式" class="headerlink" title="4.1 使用方式"></a>4.1 使用方式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> exception_handler</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">custom_exception_handler</span>(<span class="params">exc, context</span>):</span></span><br><span class="line">    <span class="comment"># 先调用REST framework默认的异常处理方法获得标准错误响应对象</span></span><br><span class="line">    response = exception_handler(exc, context)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在此处补充自定义的异常处理</span></span><br><span class="line">    <span class="keyword">if</span> response <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        response.data[<span class="string">&#x27;status_code&#x27;</span>] = response.status_code</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<p>在配置文件中声明自定义的异常处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK &#x3D; &#123;</span><br><span class="line">    &#39;EXCEPTION_HANDLER&#39;: &#39;my_project.my_app.utils.custom_exception_handler&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果未声明，会采用默认的方式，如下</p>
<p>rest_frame/settings.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK &#x3D; &#123;</span><br><span class="line">    &#39;EXCEPTION_HANDLER&#39;: &#39;rest_framework.views.exception_handler&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-案例"><a href="#4-2-案例" class="headerlink" title="4.2 案例"></a>4.2 案例</h2><p>补充上处理关于数据库的异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> exception_handler</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> exception_handler <span class="keyword">as</span> drf_exception_handler</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> DatabaseError</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exception_handler</span>(<span class="params">exc, context</span>):</span></span><br><span class="line">    response = drf_exception_handler(exc, context)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> response <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        view = context[<span class="string">&#x27;view&#x27;</span>]</span><br><span class="line">        print(<span class="string">&#x27;[%s]: %s&#x27;</span> % (view, exc))</span><br><span class="line">        <span class="keyword">if</span> isinstance(exc, DatabaseError):</span><br><span class="line">            response = Response(&#123;<span class="string">&#x27;detail&#x27;</span>: <span class="string">&#x27;服务器内部错误&#x27;</span>&#125;, status=status.HTTP_507_INSUFFICIENT_STORAGE)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            response = Response(&#123;<span class="string">&#x27;detail&#x27;</span>: <span class="string">&#x27;未知错误&#x27;</span>&#125;, status=status.HTTP_500_INTERNAL_SERVER_ERROR)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 在setting.py中配置</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;EXCEPTION_HANDLER&#x27;</span>: <span class="string">&#x27;app01.ser.exception_handler&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-REST-framework定义的异常"><a href="#4-3-REST-framework定义的异常" class="headerlink" title="4.3 REST framework定义的异常"></a>4.3 REST framework定义的异常</h2><ul>
<li>APIException 所有异常的父类</li>
<li>ParseError 解析错误</li>
<li>AuthenticationFailed 认证失败</li>
<li>NotAuthenticated 尚未认证</li>
<li>PermissionDenied 权限决绝</li>
<li>NotFound 未找到</li>
<li>MethodNotAllowed 请求方式不支持</li>
<li>NotAcceptable 要获取的数据格式不支持</li>
<li>Throttled 超过限流次数</li>
<li>ValidationError 校验失败</li>
</ul>
<p>也就是说，很多的没有在上面列出来的异常，就需要我们在自定义异常中自己处理了。</p>
<p><strong>上面列出的异常，drf已经处理，如果想要变成我们自己想要的格式，需要在最后单独处理</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统一接口返回, 记录日志</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局配置</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;EXCEPTION_HANDLER&#x27;</span>: <span class="string">&#x27;my_project.my_app.utils.custom_exception_handler&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">###########只有全局配置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">################改版后的配置（不仅要捕获异常, 最主要的还是想要加日志）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">common_exception_handler</span>(<span class="params">exc, context</span>):</span></span><br><span class="line">    <span class="comment"># context[&#x27;view&#x27;] 是对应View的对象, 错误日志想拿到类名</span></span><br><span class="line">    response = exception_handler(exc, context)</span><br><span class="line">    logger.error(<span class="string">&#x27;ip为%s的用户，访问%s视图类出错,错误信息是%s&#x27;</span> % (</span><br><span class="line">        context.get(<span class="string">&#x27;request&#x27;</span>).META.get(<span class="string">&#x27;REMOTE_ADDR&#x27;</span>), str(context.get(<span class="string">&#x27;view&#x27;</span>)), str(exc)))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> response:  <span class="comment"># drf 自己处理不了, 丢给django处理的, 我们自己处理</span></span><br><span class="line">        <span class="comment"># 好多逻辑, 更具体的捕获异常</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(exc, KeyError):</span><br><span class="line">            <span class="keyword">return</span> APIResponse(code=<span class="number">888</span>, msg=<span class="string">&#x27;key error&#x27;</span>, result=&#123;str(exc)&#125;)</span><br><span class="line">        <span class="keyword">return</span> APIResponse(code=<span class="number">777</span>, msg=<span class="string">&#x27;error&#x27;</span>, result=<span class="string">&#x27;服务器异常, 请联系系统管路员&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> APIResponse(code=<span class="number">999</span>, msg=response.data.get(<span class="string">&#x27;detail&#x27;</span>, <span class="string">&#x27;服务器异常，请联系系统管理员&#x27;</span>))</span><br><span class="line">        <span class="comment"># return APIResponse(code=999, msg=&#x27;drf-error&#x27;, result=&#123;response.data&#125;)</span></span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"><span class="comment"># ValidationError 想要被捕获 前提是 不再视图中返回HttpResponse对象, 直接在校验is_valid的时候，is_valid(raise_exception=True), 相当于走全局异常返回HttpResponse对象。</span></span><br><span class="line"></span><br><span class="line">http://www.iamnancy.top/djangorestframework/Exceptions/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主动抛异常写 raise APIException([&#x27;detail&#x27;: 手机号没有传]), 这样全局捕获就可以捕获到&#123;response.data.get(&#x27;detail&#x27;)&#125;</span></span><br></pre></td></tr></table></figure>

<p>exc和context</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">exc: 是个异常对象; str(exc) 就是返回错误信息, 返回的时候就打印了__str__</span></span><br><span class="line"><span class="string">context: 哪个视图的那个函数出了问题</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/image-20210710213156641.png" alt="image-20210710213156641"></p>
<h2 id="4-4-另外一种方式自定义异常"><a href="#4-4-另外一种方式自定义异常" class="headerlink" title="4.4 另外一种方式自定义异常"></a>4.4 另外一种方式自定义异常</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">全局异常我需要自定义，对异常进行拦截</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> Http404</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> exceptions</span><br><span class="line"><span class="keyword">from</span> django.core.exceptions <span class="keyword">import</span> PermissionDenied</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> set_rollback</span><br><span class="line"><span class="keyword">from</span> rest_framework.exceptions <span class="keyword">import</span> APIException</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagBaseException</span>(<span class="params">APIException</span>):</span></span><br><span class="line">    code = <span class="number">10000</span> <span class="comment"># 0表示正常，非0表示异常</span></span><br><span class="line">    message = <span class="string">&quot;未知异常&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_message</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&#x27;code&#x27;</span>:cls.code, <span class="string">&#x27;message&#x27;</span>:cls.message&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvalidUsernameOrPassword</span>(<span class="params">MagBaseException</span>):</span></span><br><span class="line">    code = <span class="number">1</span></span><br><span class="line">    message = <span class="string">&#x27;用户名或密码错误，请重新登录&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvalidToken</span>(<span class="params">MagBaseException</span>):</span></span><br><span class="line">    code = <span class="number">2</span></span><br><span class="line">    message = <span class="string">&#x27;登录无效，请重新登录&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 内部异常转换成某种自定义异常，不暴露细节</span></span><br><span class="line">exc_map = &#123;</span><br><span class="line">    <span class="string">&#x27;InvalidToken&#x27;</span> : InvalidToken,</span><br><span class="line">    <span class="string">&#x27;AuthenticationFailed&#x27;</span>: InvalidUsernameOrPassword,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">global_exception_handler</span>(<span class="params">exc, context</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    要对DRF的异常处理做一些改造；</span></span><br><span class="line"><span class="string">    全局异常处理</span></span><br><span class="line"><span class="string">    照抄rest_framework.views.exception_handler，略作修改</span></span><br><span class="line"><span class="string">    不管什么异常这里统一处理。根据不同类型显示不同的</span></span><br><span class="line"><span class="string">    为了前端解析方便，这里响应的状态码采用默认的200</span></span><br><span class="line"><span class="string">    异常对应处理后返回对应的错误码和错误描述</span></span><br><span class="line"><span class="string">    异常找不到对应就返回缺省</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(exc, Http404):</span><br><span class="line">        exc = exceptions.NotFound()</span><br><span class="line">    <span class="keyword">elif</span> isinstance(exc, PermissionDenied):</span><br><span class="line">        exc = exceptions.PermissionDenied()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;@#&#x27;</span> * <span class="number">30</span>)</span><br><span class="line">    print(type(exc), str(exc))</span><br><span class="line">    <span class="comment"># 写日志 打印出来是方便判断异常种类是什么</span></span><br><span class="line">    print(<span class="string">&#x27;@#&#x27;</span> * <span class="number">30</span>)</span><br><span class="line">    <span class="comment"># 源码：判断是否是APIException；即使不是，</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(exc, exceptions.APIException):</span><br><span class="line">        headers = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> getattr(exc, <span class="string">&#x27;auth_header&#x27;</span>, <span class="literal">None</span>):</span><br><span class="line">            headers[<span class="string">&#x27;WWW-Authenticate&#x27;</span>] = exc.auth_header</span><br><span class="line">        <span class="keyword">if</span> getattr(exc, <span class="string">&#x27;wait&#x27;</span>, <span class="literal">None</span>):</span><br><span class="line">            headers[<span class="string">&#x27;Retry-After&#x27;</span>] = <span class="string">&#x27;%d&#x27;</span> % exc.wait</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> isinstance(exc.detail, (list, dict)):</span><br><span class="line">            data = exc.detail</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data = &#123;<span class="string">&#x27;detail&#x27;</span>: exc.detail&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        set_rollback()</span><br><span class="line">    <span class="comment"># 不是APIException的话，做个替换，换成APIException；所以错误都做了拦截</span></span><br><span class="line">    err_msg = exc_map.get(exc.__class__.__name__, MagBaseException).get_message()</span><br><span class="line">    <span class="keyword">return</span> Response(err_msg, status=<span class="number">200</span>)</span><br><span class="line">    <span class="comment"># return Response(data, status=exc.status_code, headers=headers)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># return None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>DRF</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>DRF-14-Django整合Swagger</title>
    <url>/posts/59908.html</url>
    <content><![CDATA[<p>Django整合Swagger</p>
<a id="more"></a>

<p>我们不使用django-rest-<a href="https://so.csdn.net/so/search?q=swagger">swagger</a>，这个作者已经弃用多年，我们使用drf-yasg2</p>
<p>官方文档上推荐使用drf-yasg，但是它不能兼容最新的DRF，所以我们使用drf-yasg2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install drf-yasg2</span><br></pre></td></tr></table></figure>

<p>更新项目文件里的 settings.py 来加载 <code>drf_yasg2</code> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Application definition</span></span><br><span class="line"> </span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.contenttypes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;rest_framework&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;drf_yasg2&#x27;</span>, <span class="comment"># &lt;---- 这里</span></span><br><span class="line">    <span class="string">&#x27;django_filters&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;tweets&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>更新项目里的 urls.py 文件来加载 the schema_view</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># drf_yasg2 从这里开始</span></span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> permissions</span><br><span class="line"><span class="keyword">from</span> drf_yasg2.views <span class="keyword">import</span> get_schema_view</span><br><span class="line"><span class="keyword">from</span> drf_yasg2 <span class="keyword">import</span> openapi</span><br><span class="line">schema_view = get_schema_view(</span><br><span class="line">    openapi.Info(</span><br><span class="line">        title=<span class="string">&quot;Tweet API&quot;</span>,</span><br><span class="line">        default_version=<span class="string">&#x27;v1&#x27;</span>,</span><br><span class="line">        description=<span class="string">&quot;Welcome to the world of Tweet&quot;</span>,</span><br><span class="line">        terms_of_service=<span class="string">&quot;https://www.tweet.org&quot;</span>,</span><br><span class="line">        contact=openapi.Contact(email=<span class="string">&quot;demo@tweet.org&quot;</span>),</span><br><span class="line">        license=openapi.License(name=<span class="string">&quot;Awesome IP&quot;</span>),</span><br><span class="line">    ),</span><br><span class="line">    public=<span class="literal">True</span>,</span><br><span class="line">    permission_classes=(permissions.AllowAny,),</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 这里结束</span></span><br><span class="line"> </span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r&#x27;^doc(?P&lt;format&gt;\.json|\.yaml)$&#x27;</span>,schema_view.without_ui(cache_timeout=<span class="number">0</span>), name=<span class="string">&#x27;schema-json&#x27;</span>),  <span class="comment">#&lt;-- 这里</span></span><br><span class="line">    path(<span class="string">&#x27;doc/&#x27;</span>, schema_view.with_ui(<span class="string">&#x27;swagger&#x27;</span>, cache_timeout=<span class="number">0</span>), name=<span class="string">&#x27;schema-swagger-ui&#x27;</span>),  <span class="comment">#&lt;-- 这里</span></span><br><span class="line">    path(<span class="string">&#x27;redoc/&#x27;</span>, schema_view.with_ui(<span class="string">&#x27;redoc&#x27;</span>, cache_timeout=<span class="number">0</span>), name=<span class="string">&#x27;schema-redoc&#x27;</span>),  <span class="comment">#&lt;-- 这里</span></span><br><span class="line">    path(<span class="string">r&#x27;polls/&#x27;</span>, include(<span class="string">&#x27;polls.urls&#x27;</span>)),</span><br><span class="line">    path(<span class="string">r&#x27;tweet/&#x27;</span>, include(<span class="string">&#x27;tweets.urls&#x27;</span>)),</span><br><span class="line">    path(<span class="string">r&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">r&#x27;api-auth/&#x27;</span>, include((<span class="string">&#x27;rest_framework.urls&#x27;</span>, <span class="string">&#x27;rest_framework&#x27;</span>), namespace=<span class="string">&quot;api-auth&quot;</span>))</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DRF</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>DevOps实践</title>
    <url>/posts/44846.html</url>
    <content><![CDATA[<p>DevOps实践</p>
<a id="more"></a>

<h2 id="1-版本控制之将所有内容纳入版本控制系统"><a href="#1-版本控制之将所有内容纳入版本控制系统" class="headerlink" title="1.版本控制之将所有内容纳入版本控制系统"></a>1.版本控制之将所有内容纳入版本控制系统</h2><p>制品管理可能是管道最重要的特征。在最基本的层面上，管道从源代码创建二进制/包制品，并将它们部署到适当的基础设施，为正在部署的应用程序提供动力。<br>关于资产和源代码要遵循的最重要的规则如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/640.png" alt="图片"></p>
<p>构成应用程序的所有文件都应使用源代码控制进行管理。<br>不幸的是，尽管这条规则看起来很基本，但仍有很多组织未能遵守它。传统上，开发人员仅将版本控制系统用于应用程序的源代码，而忽略了其他支持文件，例如安装脚本、配置文件或测试数据。</p>
<p>参与应用程序生命周期的所有内容都应检查到源代码控制中。这包括但不限于：<br>源代码<br>构建脚本<br>管道定义文件<br>配置文件<br>测试和测试数据<br>数据库模式<br>数据库更新脚本<br>基础设施定义脚本<br>清理/安装/清除脚本<br>其他相关文件</p>
<p>最终目标是任何人都可以检查与应用程序相关的所有内容，并可以在本地或任何其他替代环境中重新创建它。<br>我们看到的一个常见反模式是使用特殊脚本进行部署，该脚本仅在特定机器或特定团队成员的工作站上可用，甚至是 wiki 页面中的附件，等等。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/640-20210629085408200.png" alt="图片"></p>
<p>版本控制还意味着所有这些资源都经过审核并拥有所有更改的详细历史记录。如果您想查看应用程序在 6 个月前的样子，您可以轻松地使用版本控制系统的工具来获取该信息。</p>
<p>请注意，即使所有这些资源都应该进行版本控制，但它们不必位于同一个存储库中。无论您使用多个存储库还是单个存储库，这是一个需要仔细考虑的决定，并且没有明确的答案。然而，重要的部分是确保一切确实是版本控制的。</p>
<p>尽管 GitOps 是使用 Git 操作进行推广和部署的新兴实践，但您不应该仅因为使用GitOps 而来遵循此最佳实践。无论您遵循何种实际软件范例，拥有项目资产的历史和审计信息始终是一件好事。</p>
<h2 id="2-制品管理之为所有环境使用同一个制品"><a href="#2-制品管理之为所有环境使用同一个制品" class="headerlink" title="2.制品管理之为所有环境使用同一个制品"></a>2.制品管理之为所有环境使用同一个制品</h2><p>制品可能是一个包、一个二进制文件或者一个docker镜像。</p>
<p>CI/CD 管道的主要功能之一是<strong>验证新功能是否能够部署到生产中</strong>。这是逐渐发生的，因为管道中的每一步本质上都是对该功能执行额外检查。</p>
<p>但是，要使此范例起作用，您需要确保在管道中测试的内容（制品）要与部署的内容（制品）相同。在实践中，这意味着<strong>一个特性/版本应该打包一次，并以相同的方式持续部署到所有的环境中</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/640-20210629090058104.png" alt="图片"></p>
<p><strong>不幸的是，许多组织陷入了开发/测试/生产环境使用不同制品的常见陷阱，因为他们还没有掌握用于配置的通用基础架构。这意味着他们部署的版本与管道期间测试的版本略有不同。当涉及到部署失败时，配置差异和最后一刻的更改是最大的罪魁祸首，每个环境使用不同的包会加剧这个问题。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/640-20210629090111207.png" alt="图片"></p>
<p>与为每个环境创建多个版本不同，公认的做法是<strong>拥有一个仅更改不同环境之间配置的制品</strong>。随着容器的出现以及以 Docker 镜像的形式创建应用程序的自给自足的能力，没有理由不遵循这种做法。</p>
<p>关于配置，有两种方法：</p>
<ol>
<li><p>二进制制品/容器将所有配置嵌入其中，并根据运行环境更改活动的配置（易于启动，但不是很灵活。我们不推荐这种方法）</p>
</li>
<li><p><strong>容器根本没有配置。它使用诸如键/值数据库、文件系统卷、服务发现机制等机制在运行时按需获取所需的配置（推荐方法）</strong></p>
</li>
</ol>
<p>结果是保证在生产中部署的确切二进制文件/包也是在管道中测试过的二进制文件/包。</p>
<h2 id="3-每个功能使用短期分支"><a href="#3-每个功能使用短期分支" class="headerlink" title="3.每个功能使用短期分支"></a>3.每个功能使用短期分支</h2><p>健全的管道有几个质量阈配置（例如单元测试或安全扫描），用于测试功能的质量及其对生产部署的适用性。在高速开发环境（和庞大的开发团队）中，并非所有功能都可以立即投入生产。某些功能甚至可能在其初始部署版本中相互冲突。</p>
<p>为了允许在功能之间进行细粒度的质量控制，管道应该有权否决单个功能，并且只能选择其中的一个子集进行生产部署。获得这种保证的最简单方法是遵循每个分支的特征方法，其中短期特征（即可以适合单个开发冲刺的）对应于各个源代码控制分支。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/640-20210629090449073.png" alt="图片"></p>
<p>这使得管道设计非常简单，因为一切都围绕着单个功能。针对代码分支运行测试套件仅测试新功能。分支机构的安全扫描揭示了新功能的问题。</p>
<p>然后，项目利益相关者能够部署和回滚单个功能，或者阻止完整的分支甚至被合并到主干代码中。</p>
<p>不幸的是，仍有一些公司拥有长期存在的功能分支，它们在一个批次中收集多个不相关的功能。这不仅使合并变得痛苦，而且在发现单个功能有问题时也会成为问题（因为很难单独恢复它）。</p>
<p>短期分支的演变是遵循<strong>基于主干的开发</strong>和功能切换。这可能是你想要的结果，但前提是你首先掌握了短期分支。</p>
<h2 id="4-应该在管道内传递Artifact而不是Git提交"><a href="#4-应该在管道内传递Artifact而不是Git提交" class="headerlink" title="4.应该在管道内传递Artifact而不是Git提交"></a>4.应该在管道内传递Artifact而不是Git提交</h2><p>上一个实践的一个推论（应该在所有环境中部署相同的制品/包）是一个部署制品<strong>应该只构建一次</strong>的实际案例。</p>
<p>围绕容器（以及过去的 VM 镜像）的整个概念是具有<strong>不可变的</strong>制品。应用程序只构建一次，并带有即将发布的最新功能。</p>
<p>一旦构建了该制品，它应该作为一个不变的实体从每个管道步骤移动到下一个步骤。容器是实现这种不变性的完美工具，因为它们允许您只创建一次镜像（在管道开始时），并在每个连续的管道步骤中将其推向生产。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/640-20210629090530805.png" alt="图片"></p>
<p>不幸的是，这里看到的常见反模式是<strong>公司推广提交而不是容器镜像</strong>。源代码提交在管道阶段进行，并且通过一次又一次地检查源代码来重建每个步骤。</p>
<p>这是一个不好的做法，主要有两个原因。首先，它使管道变得非常缓慢，因为打包和编译软件是一个非常漫长的过程，并且在每一步都重复它是浪费时间和资源。</p>
<p>其次，它打破了之前的规则。在每个管道步骤重新编译代码提交会打开窗口，导致产生与以前不同的制品。您无法保证在生产中部署的内容与在管道中测试的内容相同。</p>
<h2 id="5-采用命令或脚本实现构建过程自动化"><a href="#5-采用命令或脚本实现构建过程自动化" class="headerlink" title="5.采用命令或脚本实现构建过程自动化"></a>5.采用命令或脚本实现构建过程自动化</h2><p>CI/CD 管道都是关于自动化的。自动化一些本来就很容易运行的东西是很容易的。</p>
<p><strong>理想情况下，一个项目的构建应该是由一个简单的命令或者脚本自动化完成</strong>。该构建命令通常包含获取源代码、运行一些基本测试和打包最终二进制制品/容器的构建系统或脚本（例如：bash、PowerShell）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/640-20210629090618972.png" alt="图片"></p>
<p>如果需要更高级的检查（例如负载测试）那属于额外的步骤，可以不做强制要求。然而，基本构建（产生可部署的制品）应该只涉及一个命令或脚本来完成。新开发人员一般都应该能够查看最新的源代码，通过执行此单个命令或脚本可以立即获得可部署的制品。</p>
<p>这个方法也同样适用于部署步骤（部署应该也使用单个命令或脚本自动化进行），然后如果需要在持续集成系统中创建任何管道时，可以简单地在管道部分插入这个步骤。</p>
<p>不幸的是，仍然有一些公司需要通过许多手动步骤来运行和完成基本构建。<strong>下载一些与构建相关的文件、配置属性以及其他构建所需依赖的步骤，都应该在同一个脚本中自动化的完成</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/640-20210629090636284.png" alt="图片"></p>
<p>如果您的开发团队中的新员工，需要超过 15分钟才能完成基本构建（在他们的工作站中检查代码之后），那么很有可能是由于遇到这个问题导致的。</p>
<p>一个构建良好的 CI/CD 管道其实只是在本地工作站上重复执行已经可以实现的功能。在迁移到 CI/CD 平台之前，应该保证基本的构建和部署过程已经进行了有效的调整。</p>
<h2 id="6-基本构建应在5到10分钟内完成"><a href="#6-基本构建应在5到10分钟内完成" class="headerlink" title="6.基本构建应在5到10分钟内完成"></a>6.基本构建应在5到10分钟内完成</h2><p>快速构建对于开发人员和运维/系统管理员来说都是一个很大的优势。</p>
<p>发现提交的代码出现质量编译等问题时更快的获取反馈，开发人员会很高兴。因为这样可以使修复您刚刚提交的代码中的错误变得非常容易，因为它在您的脑海中还留有深刻的印象。如果必须等待一个小时或者更长的时间才能让开发人员检测到失败的构建，这是一种非常令人沮丧的体验。</p>
<p>构建在 CI 平台和本地环境中都应该很快完成。在任何给定的时间点，多个功能都试图进入代码主干。如果构建它们需要大量时间，CI 服务器很容易不堪重负。</p>
<p>运营商也从快速构建中获得了巨大的好处。在生产中推送补丁程序或回滚到以前的版本总是一种压力很大的体验。这种体验越短越好。需要 30 分钟的回滚比需要 3 分钟的回滚更难处理。</p>
<p>总之，基本构建应该非常快。最好少于五分钟。如果超过 10 分钟，您的团队应调查原因并尽量缩短该时间。现代构建系统有很好的缓存机制。</p>
<ul>
<li><p>应从内部代理存储库而不是 Internet 获取库依赖项</p>
</li>
<li><p>除非另有需要，否则避免使用代码生成器</p>
</li>
<li><p>拆分您的单元（快速）和集成测试（慢）并且只对基本构建使用单元测试</p>
</li>
<li><p>微调您的容器镜像以充分利用 Docker 层缓存</p>
</li>
</ul>
<p>如果您正在转向微服务，获得更快的构建也是您应该探索的原因之一。</p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker01-背景</title>
    <url>/posts/11870.html</url>
    <content><![CDATA[<p>Docker背景-前世今生</p>
<a id="more"></a>



<h2 id="dotCloud"><a href="#dotCloud" class="headerlink" title="dotCloud"></a>dotCloud</h2><p>宣布将公司名称改为“Docker”</p>
<p>Docker 项目从发布之初就全面发力，从技术、社区、商业、市场全方位争取到的开发者群体，实际上是为此后吸引整个生态到自家“PaaS”上的一个铺垫。只不过这时，“PaaS”的定义已经全然不是 Cloud Foundry 描述的那个样子，而是变成了一套以 Docker 容器为技术核心，以 Docker 镜像为打包标准的、全新的“容器化”思路。</p>
<ul>
<li>Docker 镜像通过技术手段解决了 PaaS 的根本性问题；</li>
<li>Docker 容器同开发者之间有着与生俱来的密切关系；</li>
<li>PaaS 概念已经深入人心的完美契机。</li>
</ul>
<h3 id="Docker版本信息"><a href="#Docker版本信息" class="headerlink" title="Docker版本信息"></a>Docker版本信息</h3><ul>
<li>Moby项目<ul>
<li>docker-ce（17.03 17年3月份）社区版，缺点新版本出来，旧版本只维护一个月。</li>
<li>docker-ee 17.03 官方会维护1年，18年3月份</li>
</ul>
</li>
</ul>
<h3 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h3><p>Docker 镜像解决的，恰恰就是打包这个根本性的问题。 所谓 Docker 镜像，其实就是一个压缩包。但是这个压缩包里的内容，比 PaaS 的应用可执行文件 + 启停脚本的组合就要丰富多了。实际上，大多数 Docker 镜像是直接由一个完整操作系统的所有文件和目录构成的，所以这个压缩包里的内容跟你本地开发和测试环境用的操作系统是完全一样的。</p>
<h4 id="精髓所在"><a href="#精髓所在" class="headerlink" title="精髓所在"></a>精髓所在</h4><p>镜像：假设你的应用在本地运行时，能看见的环境是 CentOS 7.2 操作系统的所有文件和目录，那么只要用 CentOS 7.2 的 ISO 做一个压缩包，再把你的应用可执行文件也压缩进去，那么无论在哪里解压这个压缩包，都可以得到与你本地测试时一样的环境。当然，你的应用也在里面！</p>
<blockquote>
<p>镜像精髓：本地环境和云端环境的高度一致</p>
<p>镜像其实只打包了文件系统，不包括操作系统内核。在容器技术基础里我们会详细解释。</p>
</blockquote>
<p>​        所以，Docker 项目给 PaaS 世界带来的“降维打击”，其实是提供了一种非常便利的打包机制。这种机制直接打包了应用运行所需要的整个操作系统，从而保证了本地环境和云端环境的高度一致，避免了用户通过“试错”来匹配两种不同运行环境之间差异的痛苦过程。</p>
<h3 id="时间节点"><a href="#时间节点" class="headerlink" title="时间节点"></a>时间节点</h3><ul>
<li>2014 年 “Docker 原生”容器集群管理项目 Swarm发布</li>
<li>2014年，CoreOS 公司以强烈的措辞宣布与 Docker 公司停止合作，并直接推出了自己研制的 Rocket（后来叫 rkt）容器</li>
<li>2014年，正式宣告了Kubernetes 项目的诞生。而这个项目，不仅挽救了当时的 CoreOS 和 RedHat，还如同当年 Docker 项目的横空出世一样，再一次改变了整个容器市场的格局。</li>
<li>2017 年开始，Docker 公司先是将 Docker 项目的容器运行时部分 Containerd 捐赠给 CNCF 社区，标志着 Docker 项目已经全面升级成为一个 PaaS 平台；</li>
</ul>
<h2 id="CNCF"><a href="#CNCF" class="headerlink" title="CNCF"></a>CNCF</h2><blockquote>
<p>Google、RedHat 建立 CNCF 来围剿 Docker 抢占云计算市场</p>
</blockquote>
<p>CNCF 社区就需要至少确保两件事情：</p>
<ol>
<li>Kubernetes 项目必须能够在容器编排领域取得足够大的竞争优势；<ul>
<li>1.容器运行时 </li>
<li>2.镜像标准 </li>
<li>3.编排标准</li>
</ul>
</li>
<li>CNCF 社区必须以 Kubernetes 项目为核心，覆盖足够多的场景。<ul>
<li>在已经囊括了容器监控事实标准的 Prometheus 项目之后，CNCF 社区迅速在成员项目中添加了 Fluentd、OpenTracing、CNI 等一系列容器生态的知名工具和项目。</li>
<li>目前热度极高的微服务治理项目 Istio；</li>
<li>被广泛采用的有状态应用部署框架 Operator；</li>
<li>还有像 Rook 这样的开源创业项目，它通过 Kubernetes 的可扩展接口，把 Ceph 这样的重量级产品封装成了简单易用的容器存储插件。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        2013~2014 年，以 Cloud Foundry 为代表的 PaaS 项目，逐渐完成了教育用户和开拓市场的艰巨任务，也正是在这个将概念逐渐落地的过程中，应用“打包”困难这个问题，成了整个后端技术圈子的一块心病。Docker 项目的出现，则为这个根本性的问题提供了一个近乎完美的解决方案。这正是 Docker 项目刚刚开源不久，就能够带领一家原本默默无闻的 PaaS 创业公司脱颖而出，然后迅速占领了所有云计算领域头条的技术原因。而在成为了基础设施领域近十年难得一见的技术明星之后，dotCloud 公司则在 2013 年底大胆改名为 Docker 公司。不过，这个在当时就颇具争议的改名举动，也成为了日后容器技术圈风云变幻的一个关键伏笔。</p>
<ul>
<li>容器技术的兴起源于 PaaS 技术的普及；</li>
<li>Docker 公司发布的 Docker 项目具有里程碑式的意义；</li>
<li>Docker 项目通过“容器镜像”，解决了应用打包这个根本性难题。</li>
<li>容器本身没有价值，有价值的是“容器编排”。（编排主要就是容器之间的关系。对象之间的关系远重要于对象本身）</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker02-进程隔离与限制</title>
    <url>/posts/13216.html</url>
    <content><![CDATA[<p>容器基础，概念入门</p>
<a id="more"></a>

<p>容器：容器是一个 创建时指定了namespace的进程,并且启动参数里设置了cpu,内存的限制,使用的文件系统目录也被提前设置了,挂载到了其他的目录(这个就是镜像) 2.所以容器没有像虚拟机一样虚拟出内核等,容器使用的是宿主机的内核</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>容器只是运行在宿主机上的一个特殊进程。</p>
<p>​        除了我们刚刚用到的 PID Namespace，Linux 操作系统还提供了 Mount、UTS、IPC、Network 和 User 这些 Namespace，用来对各种不同的进程上下文进行“障眼法”操作。比如，Mount Namespace，用于让被隔离进程只看到当前 Namespace 里的挂载点信息；Network Namespace，用于让被隔离进程看到当前 Namespace 里的网络设备和配置。</p>
<ul>
<li><strong>PID(进程隔离)</strong></li>
<li><strong>UTS(独立的hostname、domain name)</strong></li>
<li><strong>network(网络隔离)</strong></li>
<li><strong>user(独立的用户、用户组)</strong></li>
<li><strong>mount(挂载点隔离)</strong></li>
<li><strong>IPC(进程间通信隔离)</strong></li>
</ul>
<p>查看docker容器的namespace</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">查看docker容器的namespace： </span><br><span class="line">1. docker ps拿到containerID </span><br><span class="line">2. 有三种常用方式查看docker在宿主机的PID：</span><br><span class="line">   1) 直接查看文件cat /sys/fs/cgroup/memory/docker/&lt;container ID&gt;/cgroup.procs </span><br><span class="line">   2）docker container top &lt;containerID&gt; </span><br><span class="line">   3） docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> &lt;containerID&gt; </span><br><span class="line">3. 拿到进程ID后，执行ll /proc/&lt;PID&gt;/ns/ 可查看docker启用的具体Namespace参数 docker启用的六个Namespace：</span><br></pre></td></tr></table></figure>



<blockquote>
<p>namespace 和 cgroup 是内核特性，容器本质上就是一个加了限定参数的进程， 容器其实是一种特殊的进程而已。</p>
<p>单进程意思不是只能运行一个进程，而是只有一个进程是可控的。控制指的是它们的回收和生命周期管理。</p>
</blockquote>
<h2 id="边界手段（进程间隔离与限制）"><a href="#边界手段（进程间隔离与限制）" class="headerlink" title="边界手段（进程间隔离与限制）"></a>边界手段（进程间隔离与限制）</h2><h4 id="Cgroups资源限制"><a href="#Cgroups资源限制" class="headerlink" title="Cgroups资源限制"></a>Cgroups资源限制</h4><h4 id="Namespace隔离资源"><a href="#Namespace隔离资源" class="headerlink" title="Namespace隔离资源"></a>Namespace隔离资源</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用虚拟化技术作为应用沙盒，就必须要由 Hypervisor 来负责创建虚拟机，这个虚拟机是真实存在的，并且它里面必须运行一个完整的 Guest OS 才能执行用户的应用进程。这就不可避免地带来了额外的资源消耗和占用。</span><br><span class="line">根据实验，一个运行着 CentOS 的 KVM 虚拟机启动后，在不做优化的情况下，虚拟机自己就需要占用 100~200 MB 内存。此外，用户应用运行在虚拟机里面，它对宿主机操作系统的调用就不可避免地要经过虚拟化软件的拦截和处理，这本身又是一层性能损耗，尤其对计算资源、网络和磁盘 I&#x2F;O 的损耗非常大。</span><br><span class="line">而相比之下，容器化后的用户应用，却依然还是一个宿主机上的普通进程，这就意味着这些因为虚拟化而带来的性能损耗都是不存在的；而另一方面，使用 Namespace 作为隔离手段的容器并不需要单独的 Guest OS，这就使得容器额外的资源占用几乎可以忽略不计。</span><br></pre></td></tr></table></figure>



<ol>
<li><p><strong>Namespace 技术实际上修改了应用进程看待整个计算机“视图”，即它的“视线”被操作系统做了限制，只能“看到”某些指定的内容。</strong>但对于宿主机来说，这些被“隔离”了的进程跟其他进程并没有太大区别。</p>
<ul>
<li>Namespace是一种资源逻辑隔离机制，在架构设计时经常用到。<ul>
<li>Docker本身并没有对应用进程进行隔离，也没有创建所谓的“容器”，而是通过宿主机的操作系统通过namespace对应用进程进行隔离，通过cgroups对被隔离的应用进程限制相关资源属性</li>
<li>容器，其实就是操作系统在启动进程时通过<strong>设置一些参数</strong>实现了隔离不相关资源后的一个特殊进程。而 Namespace 的使用方式也非常有意思：它其实只是 Linux 创建新进程的一个可选参数</li>
</ul>
</li>
<li>不足：隔离得不彻底。(共享内核导致隔离不彻底)<ul>
<li>首先，既然容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内核。<ul>
<li>尽管你可以在容器里通过 Mount Namespace 单独挂载其他不同版本的操作系统文件，比如 CentOS 或者 Ubuntu，但这并不能改变共享宿主机内核的事实。这意味着，如果你要在 Windows 宿主机上运行 Linux 容器，或者在低版本的 Linux 宿主机上运行高版本的 Linux 容器，都是行不通的。</li>
</ul>
</li>
<li>其次，在 Linux 内核中，有很多资源和对象是不能被 Namespace 化的，最典型的例子就是：时间。<ul>
<li>挂载 localtime 时要设置 ReadOnly</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Linux Cgroups 就是 Linux 内核中用来为进程设置资源限制的一个重要功能</strong></p>
<blockquote>
<p>Linux Cgroups 的全称是 Linux Control Group。它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。</p>
</blockquote>
<ul>
<li><p>Cgrounp通过配置文件限制进程可占用资源，通过查看 /sys/fs/cgroup目录，可以查看所支持的配置(``mount -t cgroup`)</p>
</li>
<li><pre><code class="bash">$ docker run -it --cpu-period=100000 --cpu-quota=20000 ubuntu /bin/bash

# 查看
$ cat /sys/fs/cgroup/cpu/docker/5d5c9f67d/cpu.cfs_period_us 
100000
$ cat /sys/fs/cgroup/cpu/docker/5d5c9f67d/cpu.cfs_quota_us 
20000
&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   - 不足：Cgroups 对资源的限制能力也有很多不完善的地方，被提及最多的自然是 **&amp;#x2F;proc** 文件系统的问题。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     - Linux 下的 &amp;#x2F;proc 目录存储的是记录当前内核运行状态的一系列特殊文件，用户可以通过访问这些文件，查看系统以及当前正在运行的进程的信息，比如 CPU 使用情况、内存占用率等，这些文件也是 top 指令查看系统信息的主要数据来源。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     - **问题**：但是，你如果在容器里执行 top 指令，就会发现，它显示的信息居然是宿主机的 CPU 和内存数据，而不是当前容器的数据。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     - **原因**：&amp;#x2F;proc 文件系统并不知道用户通过 Cgroups 给这个容器做了什么样的资源限制，即：&amp;#x2F;proc 文件系统不了解 Cgroups 限制的存在。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     - **解决**：**lxcfs 可解决此问题**(top 是从 &amp;#x2F;prof&amp;#x2F;stats 目录下获取数据，所以道理上来讲，容器不挂载宿主机的该目录就可以了。lxcfs就是来实现这个功能的，做法是把宿主机的 &amp;#x2F;var&amp;#x2F;lib&amp;#x2F;lxcfs&amp;#x2F;proc&amp;#x2F;memoinfo 文件挂载到Docker容器的&amp;#x2F;proc&amp;#x2F;meminfo位置后。容器中进程读取相应文件内容时，LXCFS的FUSE实现会从容器对应的Cgroup中读取正确的内存限制。从而使得应用获得正确的资源约束设定。kubernetes环境下，也能用，以ds 方式运行 lxcfs ，自动给容器注入争取的 proc 信息。)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 容器间进程关系&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;![image-20220403201214296](https:&amp;#x2F;&amp;#x2F;cdn.jsdelivr.net&amp;#x2F;gh&amp;#x2F;Waylonwhynot&amp;#x2F;whatyouneed_blog_pic@main&amp;#x2F;pic&amp;#x2F;image-20220403201214296.png)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## 总结&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 一个正在运行的 Docker 容器，其实就是一个启用了多个 Linux Namespace 的应用进程，而这个进程能够使用的资源量，则受 Cgroups 配置的限制。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;容器是一个“单进程”模型。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;
由于一个容器的本质就是一个进程，用户的应用进程实际上就是容器里 PID=1 的进程，也是其他后续创建的所有进程的父进程。这就意味着，在一个容器中，你没办法同时运行两个不同的应用，除非你能事先找到一个公共的 PID=1 的程序来充当两个不同应用的父进程，这也是为什么很多人都会用 systemd 或者 supervisord 这样的软件来代替应用本身作为容器的启动进程。
但是，在后面分享容器设计模式时，我还会推荐其他更好的解决办法。这是因为容器本身的设计，就是希望容器和应用能够同生命周期，这个概念对后续的容器编排非常重要。否则，一旦出现类似于“容器是正常运行的，但是里面的应用早已经挂了”的情况，编排系统处理起来就非常麻烦了。
&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 问题1：一个容器本质上只是一个进程，那么不能同时启动两个应用？这个能解释一下吗？ 如果我打包一个docker镜像 里面安装了redis和tomcat 那就不能跑在容器里了？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;
能。但至少一个进程会无法管理。
由于一个容器的本质就是一个进程，用户的应用进程实际上就是容器里 PID=1 的进程，也是其他后续创建的所有进程的父进程。这就意味着，在一个容器中，你没办法同时运行两个不同的应用，除非你能事先找到一个公共的 PID=1 的程序来充当两个不同应用的父进程，这也是为什么很多人都会用 systemd 或者 supervisord ,比如用systemd当公共父进程;这样的软件来代替应用本身作为容器的启动进程。
</code></pre>
</li>
</ul>
</li>
</ol>
<p>这里的应用指的是容器里的apache redis mysql这类的应用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 问题2：docker的实现原理也仅仅是调用了底层的namespace和cgroup吗？</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>准确的说，是调用containerd + runc。runc干你说的这些事儿</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 问题3：这意味着，如果你要在 Windows 宿主机上运行 Linux 容器，或者在低版本的 Linux 宿主机上运行高版本的 Linux 容器，都是行不通的。”这段话有些不解，我的macbook pro可以运行最新版本的linux的docker，感觉是不是跟您这句话有冲突？</span><br><span class="line"></span><br><span class="line">![image-20220312160351099](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Waylonwhynot&#x2F;whatyouneed_blog_pic@main&#x2F;pic&#x2F;image-20220312160351099.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="http://www.floydhilton.com/docker/2017/03/31/Docker-ContainerHost-vs-ContainerOS-Linux-Windows.html">http://www.floydhilton.com/docker/2017/03/31/Docker-ContainerHost-vs-ContainerOS-Linux-Windows.html</a></p>
<p>mac docker其实是个虚拟机<br>windows：Docker Machine 也会在 Windows 上创建一个 Linux 虚拟机，用于运行 Docker 引擎。也就是说，这个环境也只支持 Linux 的应用程序格式的，并不支持 Windows 应用程序的运行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 问题4：对于&#x2F;etc&#x2F;hosts这个文件而言，同一个pod中不同container修改权限时是修改的宿主机的文件权限，而修改hosts文件内容时，修改的是各自的文件么？</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不是……hosts跟volume是一样的，所有容器共同mount了同一份。但是这个文件的内容，是kubelet维护的，在每个容器创建的时候，kubelet会重写它里面的内容。这就是为啥我说不让你手动改hosts……</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 问题5：为什么我原先一直在用的某个 JVM 参数，在容器里就不好使了？</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;bash</span><br><span class="line">**解决**：**lxcfs 可解决此问题**(top 是从 &#x2F;prof&#x2F;stats 目录下获取数据，所以道理上来讲，容器不挂载宿主机的该目录就可以了。lxcfs就是来实现这个功能的，做法是把宿主机的 &#x2F;var&#x2F;lib&#x2F;lxcfs&#x2F;proc&#x2F;memoinfo 文件挂载到Docker容器的&#x2F;proc&#x2F;meminfo位置后。容器中进程读取相应文件内容时，LXCFS的FUSE实现会从容器对应的Cgroup中读取正确的内存限制。从而使得应用获得正确的资源约束设定。kubernetes环境下，也能用，以ds 方式运行 lxcfs ，自动给容器注入争取的 proc 信息。)</span><br><span class="line">即 lxcfs 方案。通过 lxcfs，你可以把宿主机的 &#x2F;var&#x2F;lib&#x2F;lxcfs&#x2F;proc 文件系统挂载到 Docker 容器的 &#x2F;proc 目录下。使得容器中进程读取相应文件内容时，实际上会从容器对应的 Cgroups 中读取正确的资源限制。 从而得到正确的 top 命令的返回值。</span><br><span class="line"></span><br><span class="line">   案例：（1）较为典型的Java的应用程序，若未使用-Xmx选项指定JVM的堆内存可用总量，则会默认设置为主机内存可用总量的一个空间比例（例如30%），这会导致容器中的应用程序申请内存资源时很快达到上限，而转为OOM状态。另外，即便使用了-Xmx选项设置其堆内存上限，但该设置对非堆内存的可用空间不产生任何限制作用，仍然存在达到容器内存资源上限的可能性。</span><br><span class="line">   （2）另外一个典型是Pod中运行Nginx容器时，其配置参数worker_process的值设置为auto，则会创建于与可见CPU核心数量相同的worker进程数，若容器的CPU可用资源量远小于节点所需资源量时，这种设置较大的访问负荷下会产生严重的资源竞争，并且会带来更多的内存资源消耗。</span><br><span class="line">   解决办法：使用Downward API 将limits定义的资源量暴露给容器</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>常用限制配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-m,--memory #限制物理内存</span><br><span class="line">-c --cpus: #限制CPU</span><br><span class="line">nginx pod：</span><br><span class="line">    1c&#x2F;2G 2c&#x2F;2g #生产资源</span><br><span class="line">    0.5&#x2F;512M #测试资源</span><br><span class="line">java：</span><br><span class="line">    微服务：</span><br><span class="line">        1C&#x2F;2G 1C&#x2F;2G </span><br><span class="line">    elasticsearch:</span><br><span class="line">        4C&#x2F;12G</span><br><span class="line">    kafka:</span><br><span class="line">        2C&#x2F;6G</span><br><span class="line">    jenkins:</span><br><span class="line">        2C&#x2F;4G </span><br><span class="line">    tomcat:</span><br><span class="line">        1C&#x2F;2G,1C&#x2F;4G</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker03-理解容器镜像</title>
    <url>/posts/49499.html</url>
    <content><![CDATA[<p>容器镜像,容器指令</p>
<a id="more"></a>

<p>Namespace、CGroup区别 <a href="https://www.jianshu.com/p/ab423c3db59d">https://www.jianshu.com/p/ab423c3db59d</a> </p>
<p>容器 = cgroup + namespace + rootfs + 容器引擎 </p>
<p><strong>Cgroup</strong>： 资源控制 </p>
<p><strong>Namespace</strong>： 访问隔离 </p>
<p><strong>rootfs</strong>：文件系统隔离。镜像本身就是一个根文件系统(包含操作系统的文件、配置和目录，不包括操作系统内核；linux容器，共享操作系统内核。)</p>
<p><strong>容器引擎</strong>：生命周期控制</p>
<h2 id="容器里的进程看到的文件系统又是什么样子的？"><a href="#容器里的进程看到的文件系统又是什么样子的？" class="headerlink" title="容器里的进程看到的文件系统又是什么样子的？"></a>容器里的进程看到的文件系统又是什么样子的？</h2><p>​       可能你立刻就能想到，这一定是一个关于 Mount Namespace 的问题：容器里的应用进程，理应看到一份完全独立的文件系统。这样，它就可以在自己的容器目录（比如 /tmp）下进行操作，而完全不会受宿主机以及其他容器的影响。</p>
<p>​       <strong>Mount Namespace 修改的，是容器进程对文件系统“挂载点”的认知。</strong>但是，这也就意味着，只有在“挂载”这个操作发生之后，进程的视图才会被改变。而在此之前，新创建的容器会直接继承宿主机的各个挂载点。（mount namespace是修改文件系统的挂载点，只有挂载操作之后容器才能修改挂载点，修改之前都是直接继承宿主机的挂载点。）</p>
<ul>
<li>Mount Namespace 解决 容器中 看到全新的 目录结构（我们可以在容器进程启动之前重新挂载它的整个根目录“/”。而由于 Mount Namespace 的存在，这个挂载对宿主机不可见，所以容器进程就可以在里面随便折腾了。）</li>
<li>在 Linux 操作系统里，有一个名为 chroot 的命令可以帮助你在 shell 中方便地完成这个工作。顾名思义，它的作用就是帮你“change root file system”，即改变进程的根目录到你指定的位置。</li>
</ul>
<p>​       实际上，<strong>Mount Namespace</strong> 正是基于对 <strong>chroot</strong> 的不断改良才被发明出来的，它也是 Linux 操作系统里的第一个 Namespace。</p>
<pre><code>   &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;三板斧：开启Mount Namespace，执行mount挂载volume（指定的目录），chroot改变进程的根目录。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;</code></pre>
<h2 id="RootFS-根文件系统"><a href="#RootFS-根文件系统" class="headerlink" title="RootFS(根文件系统)"></a>RootFS(根文件系统)</h2><p>​       为了能够让容器的这个根目录看起来更“真实”，我们一般会在这个容器的根目录下挂载一个完整操作系统的文件系统，比如 Ubuntu16.04 的 ISO。这样，在容器启动之后，我们在容器里通过执行 “ls /“ 查看根目录下的内容，就是 Ubuntu 16.04 的所有目录和文件。（<strong>容器间各自拷贝一份系统配置和库文件，但共享系统内核</strong>）</p>
<p>​        <strong>而这个挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）。</strong></p>
<blockquote>
<p>对 Docker 项目来说，它最核心的原理实际上就是为待创建的用户进程：</p>
</blockquote>
<ol>
<li>启用 Linux Namespace 配置；</li>
<li>设置指定的 Cgroups 参数；</li>
<li>切换进程的根目录（Change Root）。</li>
</ol>
<h2 id="缺陷与特性"><a href="#缺陷与特性" class="headerlink" title="缺陷与特性"></a>缺陷与特性</h2><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>rootfs 只包括了操作系统的“躯壳”，并没有包括操作系统的“灵魂”。</p>
<p><strong>同一台机器上的所有容器，都共享宿主机操作系统的内核。</strong></p>
<p>这就意味着，如果你的应用程序需要配置内核参数、加载额外的内核模块，以及跟内核进行直接的交互，你就需要注意了：这些操作和依赖的对象，<strong>都是宿主机操作系统的内核</strong>，它对于该机器上的所有容器来说是一个“全局变量”，牵一发而动全身。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>正是由于 rootfs 的存在，容器才有了一个被反复宣传至今的重要特性：<strong>一致性</strong>。</p>
<h2 id="镜像分层-layer"><a href="#镜像分层-layer" class="headerlink" title="镜像分层*(layer)*"></a>镜像分层*(layer)*</h2><blockquote>
<p>docker构建镜像是分层构建的，引入联合文件系统(UnionFS)</p>
</blockquote>
<p>Ubuntu 16.04 和 Docker CE 18.05，这对组合默认使用的是 AuFS 这个联合文件系统的实现.</p>
<p><code>新docker+centos 在/var/lib/docker/overlay2/&lt;layer_id&gt;/diff 目录下 layer_id 可以docker image inspect ubuntu:latest 查到</code></p>
<p>新的docker是使用overlay2文件系统，在/var/lib/docker/overlay2/ID/merged和/var/lib/docker/overlay2/l目录下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/8a7b5cfabaab2d877a1d4566961edd5f.png" alt="img"></p>
<h3 id="第一部分，只读层"><a href="#第一部分，只读层" class="headerlink" title="第一部分，只读层"></a>第一部分，只读层</h3><p>它是这个容器的 rootfs 最下面的五层，对应的正是 ubuntu:latest 镜像的五层。可以看到，它们的挂载方式都是只读的（ro+wh，即 readonly+whiteout，至于什么是 whiteout，我下面马上会讲到）。这时，我们可以分别查看一下这些层的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ ls &#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;diff&#x2F;72b0744e06247c7d0...</span><br><span class="line">etc sbin usr var</span><br><span class="line">$ ls &#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;diff&#x2F;32e8e20064858c0f2...</span><br><span class="line">run</span><br><span class="line">$ ls &#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;diff&#x2F;a524a729adadedb900...</span><br><span class="line">bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span><br></pre></td></tr></table></figure>

<p>可以看到，这些层，都以增量的方式分别包含了 Ubuntu 操作系统的一部分。</p>
<h3 id="第二部分，可读写层"><a href="#第二部分，可读写层" class="headerlink" title="第二部分，可读写层"></a>第二部分，可读写层</h3><p>​       它是这个容器的 rootfs 最上面的一层（6e3be5d2ecccae7cc），它的挂载方式为：rw，即 read write。在没有写入文件之前，这个目录是空的。而一旦在容器里做了写操作，你修改产生的内容就会以增量的方式出现在这个层中。</p>
<p>​        可是，你有没有想到这样一个问题：如果我现在要做的，是删除只读层里的一个文件呢？为了实现这样的删除操作，AuFS 会在可读写层创建一个 whiteout 文件，把只读层里的文件“遮挡”起来。比如，你要删除只读层里一个名叫 foo 的文件，那么这个删除操作实际上是在可读写层创建了一个名叫.wh.foo 的文件。这样，当这两个层被联合挂载之后，foo 文件就会被.wh.foo 文件“遮挡”起来，“消失”了。这个功能，就是“ro+wh”的挂载方式，即只读 +whiteout 的含义。我喜欢把 whiteout 形象地翻译为：“白障”。</p>
<p>​       所以，最上面这个可读写层的作用，就是专门用来存放你修改 rootfs 后产生的增量，无论是增、删、改，都发生在这里。而当我们使用完了这个被修改过的容器之后，还可以使用 docker commit 和 push 指令，保存这个被修改过的可读写层，并上传到 Docker Hub 上，供其他人使用；而与此同时，原先的只读层里的内容则不会有任何变化。这，就是增量 rootfs 的好处。</p>
<p><strong>删除只读层的文件原理</strong>：实际上是在可读写层创建一个名为.wh.xxx的文件。这样，当这两个层被联合挂载之后，该文件就会被.wh.xxx遮挡起来，消失了。这个功能就是“ro+wh”的挂载方式，即只读+whiteout的含义。</p>
<h3 id="第三部分，Init-层"><a href="#第三部分，Init-层" class="headerlink" title="第三部分，Init 层"></a>第三部分，Init 层</h3><p>它是一个以“-init”结尾的层，夹在只读层和读写层之间。Init 层是 Docker 项目单独生成的一个内部层，专门用来存放 /etc/hosts、/etc/resolv.conf 等信息。</p>
<p>需要这样一层的原因是，这些文件本来属于只读的 Ubuntu 镜像的一部分，但是用户往往需要在启动容器时写入一些指定的值比如 hostname，所以就需要在可读写层对它们进行修改。</p>
<p>可是，这些修改往往只对当前的容器有效，我们并不希望执行 docker commit 时，把这些信息连同可读写层一起提交掉。</p>
<p>所以，Docker 做法是，在修改了这些文件之后，以一个单独的层挂载了出来。而用户执行 <strong>docker commit 只会提交可读写层</strong>，所以是不包含这些内容的。</p>
<p>最终，这 7 个层都被联合挂载到 /var/lib/docker/aufs/mnt 目录下，表现为一个完整的 Ubuntu 操作系统供容器使用。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol>
<li>Linux 容器文件系统的实现方式。而这种机制，正是我们经常提到的容器镜像，也叫作：rootfs。它只是一个操作系统的所有文件和目录，并不包含内核，最多也就几百兆。而相比之下，传统虚拟机的镜像大多是一个磁盘的“快照”，磁盘有多大，镜像就至少有多大。</li>
<li>通过结合使用 Mount Namespace 和 rootfs，容器就能够为进程构建出一个完善的文件系统隔离环境。当然，这个功能的实现还必须感谢 chroot 和 pivot_root 这两个系统调用切换进程根目录的能力。</li>
<li>而在 rootfs 的基础上，Docker 公司创新性地提出了使用<strong>多个增量 rootfs 联合挂载一个完整 rootfs 的方案</strong>，这就是容器镜像中“层”的概念。</li>
</ol>
<h3 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h3><ol>
<li><p>既然容器的 rootfs（比如，Ubuntu 镜像），是以只读方式挂载的，那么又如何在容器里修改 Ubuntu 镜像的内容呢？（提示：Copy-on-Write）</p>
<pre><code> 1. 上面的读写层通常也称为容器层，下面的只读层称为镜像层，所有的增删查改操作都只会作用在容器层，相同的文件上层会覆盖掉下层。知道这一点，就不难理解镜像文件的修改，比如修改一个文件的时候，首先会从上到下查找有没有这个文件，找到，就复制到容器层中，修改，修改的结果就会作用到下层的文件，这种方式也被称为copy-on-write。
修改一个镜像里的文件的时候，联合文件系统首先会从上到下在各个层中查找有没有目标文件。如果找到，就把这个文件复制到可读写层进行修改。这个修改的结果会屏蔽掉下层的文件，这种方式就被称为 copy-on-write。</code></pre>
</li>
</ol>
<ol start="2">
<li><p>除了 AuFS，你知道 Docker 项目还支持哪些 UnionFS 实现吗？你能说出不同宿主机环境下推荐使用哪种实现吗?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aufs, device mapper, btrfs, overlayfs, vfs, zfs。aufs是ubuntu 常用的，device mapper 是 centos，btrfs 是 SUSE，overlayfs ubuntu 和 centos 都会使用，现在最新的 docker 版本中默认两个系统都是使用的 overlayfs，vfs 和 zfs 常用在 solaris 系统。</span><br></pre></td></tr></table></figure>
</li>
<li><p>容器镜像依赖宿主机内核。那么如果镜像是基于Linux的系统制作而成（线上运行环境就是Linux），那么如果在Windows系统上它是不能运行这个镜像了，对吗？甚至目标机器如果内核跟镜像制作不同（比如centos5和centos7）如果是，请问该怎么理解容器跨平台部署一说？</p>
<pre><code> 如果你的应用依赖内核版本，那果断跨不了平台，除非再创建对应的虚拟机出来做宿主。说跨平台其实是因为大多数应用没有内核依赖。windows系统会给容器外面套一个vm，所以也能运行linux容器。</code></pre>
</li>
<li><p>你在查看 Docker 容器的 Namespace 时，是否注意到有一个叫 cgroup 的 Namespace？它是 Linux 4.6 之后新增加的一个 Namespace，你知道它的作用吗？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Linux 内核从 4.6 开始，支持了一个新的 Namespace 叫作：Cgroup Namespace。 我们知道，正常情况下，在一个容器里查看 &#x2F;proc&#x2F;$PID&#x2F;cgroup，是会看到整个宿主机的 cgroup 信息的。而有了 Cgroup Namespace 后，每个容器里的进程都会有自己 Cgroup Namespace，从而获得一个属于自己的 Cgroups 文件目录视图。也就是说，Cgroups 文件系统也可以被 Namespace 隔离起来了。</span><br></pre></td></tr></table></figure>





</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/a37bd402bba80807bcc0eeaf78320243.jpg" alt="img"></p>
<hr>
<h1 id="1、Docker容器信息"><a href="#1、Docker容器信息" class="headerlink" title="1、Docker容器信息"></a>1、Docker容器信息</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#查看docker容器版本</span></span></span><br><span class="line">docker version</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#查看docker容器信息</span></span></span><br><span class="line">docker info</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#查看docker容器帮助</span></span></span><br><span class="line">docker --help</span><br></pre></td></tr></table></figure>

<h1 id="2、镜像操作"><a href="#2、镜像操作" class="headerlink" title="2、镜像操作"></a>2、镜像操作</h1><p>提示：对于镜像的操作可使用镜像名、镜像长ID和短ID。</p>
<h2 id="2-1、镜像查看"><a href="#2-1、镜像查看" class="headerlink" title="2.1、镜像查看"></a>2.1、镜像查看</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#列出本地images</span></span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#含中间映像层</span></span></span><br><span class="line">docker images -a</span><br></pre></td></tr></table></figure>

<p><a href="https://img2018.cnblogs.com/blog/1659331/201905/1659331-20190521104721523-485290950.png"><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1659331-20190521104721523-485290950.png" alt="img"></a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#只显示镜像ID</span></span></span><br><span class="line">docker images -q</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#含中间映像层</span></span></span><br><span class="line">docker images -qa   </span><br></pre></td></tr></table></figure>

<p><a href="https://img2018.cnblogs.com/blog/1659331/201905/1659331-20190521104927909-600452122.png"><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1659331-20190521104927909-600452122.png" alt="img"></a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#显示镜像摘要信息(DIGEST列)</span></span></span><br><span class="line">docker images --digests</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#显示镜像完整信息</span></span></span><br><span class="line">docker images --no-trunc</span><br></pre></td></tr></table></figure>

<p><a href="https://img2018.cnblogs.com/blog/1659331/201905/1659331-20190521105114405-1780655005.png"><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1659331-20190521105114405-1780655005.png" alt="img"></a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#显示指定镜像的历史创建；参数：-H 镜像大小和日期，默认为true；--no-trunc  显示完整的提交记录；-q  仅列出提交记录ID</span></span></span><br><span class="line">docker history -H redis</span><br></pre></td></tr></table></figure>

<h2 id="2-2、镜像搜索"><a href="#2-2、镜像搜索" class="headerlink" title="2.2、镜像搜索"></a>2.2、镜像搜索</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#搜索仓库MySQL镜像</span></span></span><br><span class="line">docker search mysql</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># --filter=stars=600：只显示 starts&gt;=600 的镜像</span></span></span><br><span class="line">docker search --filter=stars=600 mysql</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># --no-trunc 显示镜像完整 DESCRIPTION 描述</span></span></span><br><span class="line">docker search --no-trunc mysql</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># --automated ：只列出 AUTOMATED=OK 的镜像</span></span></span><br><span class="line">docker search  --automated mysql</span><br></pre></td></tr></table></figure>

<p><a href="https://img2018.cnblogs.com/blog/1659331/201905/1659331-20190521110514156-691788920.png"><img src="https://img2018.cnblogs.com/blog/1659331/201905/1659331-20190521110514156-691788920.png" alt="img"></a></p>
<h2 id="2-3、镜像下载"><a href="#2-3、镜像下载" class="headerlink" title="2.3、镜像下载"></a>2.3、镜像下载</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#下载Redis官方最新镜像，相当于：docker pull redis:latest</span></span></span><br><span class="line">docker pull redis</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#下载仓库所有Redis镜像</span></span></span><br><span class="line">docker pull -a redis</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#下载私人仓库镜像</span></span></span><br><span class="line">docker pull bitnami/redis</span><br></pre></td></tr></table></figure>

<p><a href="https://img2018.cnblogs.com/blog/1659331/201905/1659331-20190521112716615-10141164.png"><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/1659331-20190521112716615-10141164.png" alt="img"></a></p>
<h2 id="2-4、镜像删除"><a href="#2-4、镜像删除" class="headerlink" title="2.4、镜像删除"></a>2.4、镜像删除</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#单个镜像删除，相当于：docker rmi redis:latest</span></span></span><br><span class="line">docker rmi redis</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#强制删除(针对基于镜像有运行的容器进程)</span></span></span><br><span class="line">docker rmi -f redis</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#多个镜像删除，不同镜像间以空格间隔</span></span></span><br><span class="line">docker rmi -f redis tomcat nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#删除本地全部镜像</span></span></span><br><span class="line">docker rmi -f $(docker images -q)</span><br></pre></td></tr></table></figure>

<h2 id="2-5、镜像构建"><a href="#2-5、镜像构建" class="headerlink" title="2.5、镜像构建"></a>2.5、镜像构建</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#（1）编写dockerfile</span></span></span><br><span class="line">cd /docker/dockerfile</span><br><span class="line">vim mycentos</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#（2）构建docker镜像</span></span></span><br><span class="line">docker build -f /docker/dockerfile/mycentos -t mycentos:1.1</span><br></pre></td></tr></table></figure>

<h1 id="3、容器操作"><a href="#3、容器操作" class="headerlink" title="3、容器操作"></a>3、容器操作</h1><p>提示：对于容器的操作可使用CONTAINER ID 或 NAMES。</p>
<h2 id="3-1、容器启动"><a href="#3-1、容器启动" class="headerlink" title="3.1、容器启动"></a>3.1、容器启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#新建并启动容器，参数：-i  以交互模式运行容器；-t  为容器重新分配一个伪输入终端；--name  为容器指定一个名称</span></span></span><br><span class="line">docker run -i -t --name mycentos</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#后台启动容器，参数：-d  已守护方式启动容器</span></span></span><br><span class="line">docker run -d mycentos</span><br></pre></td></tr></table></figure>

<p>注意：此时使用”docker ps -a”会发现容器已经退出。这是docker的机制：要使Docker容器后台运行，就必须有一个前台进程。解决方案：将你要运行的程序以前台进程的形式运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#启动一个或多个已经被停止的容器</span></span></span><br><span class="line">docker start redis</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#重启容器</span></span></span><br><span class="line">docker restart redis</span><br></pre></td></tr></table></figure>

<h2 id="3-2、指定端口映射"><a href="#3-2、指定端口映射" class="headerlink" title="3.2、指定端口映射"></a>3.2、指定端口映射</h2><p>方式0：随机端口 映射 容器端口</p>
<p><code>docker run -P -name nginx-test-port1 nginx</code></p>
<p>方式1：本地81映射容器80</p>
<p><code>docker run -p 81:80 -name nginx-test-port1 nginx</code></p>
<p>方式2：本地ip本地端口映射容器端口</p>
<p><code>docker run -p 192.168.10.205:81:80 -name nginx-test-port1 nginx</code></p>
<p>方式3：本地ip随机端口映射容器端口</p>
<p><code>docker run -p 192.168.10.205::80 -name nginx-test-port1 nginx</code></p>
<p>方式4：本地ip:本地端口 映射 容器端口/协议；默认tcp协议</p>
<p><code>docker run -p 192.168.10.205:83:80/udp -name nginx-test-port1 nginx</code></p>
<p>方式5：一次映射多个端口+协议</p>
<p><code>docker run -p 86:80/tcp -p 53:53/udp -name nginx-test-port1 nginx</code></p>
<h2 id="3-2、容器进程"><a href="#3-2、容器进程" class="headerlink" title="3.2、容器进程"></a>3.2、容器进程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#top支持 ps 命令参数，格式：docker top [OPTIONS] CONTAINER [ps OPTIONS]</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#列出redis容器中运行进程</span></span></span><br><span class="line">docker top redis</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#查看所有运行容器的进程信息</span></span></span><br><span class="line">for i in  `docker ps |grep Up|awk &#x27;&#123;print $1&#125;&#x27;`;do echo \ &amp;&amp;docker top $i; done</span><br></pre></td></tr></table></figure>

<h2 id="3-3、容器日志"><a href="#3-3、容器日志" class="headerlink" title="3.3、容器日志"></a>3.3、容器日志</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#查看redis容器日志，默认参数</span></span></span><br><span class="line">docker logs rabbitmq</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#查看redis容器日志，参数：-f  跟踪日志输出；-t   显示时间戳；--tail  仅列出最新N条容器日志；</span></span></span><br><span class="line">docker logs -f -t --tail=20 redis</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#查看容器redis从2019年05月21日后的最新10条日志。</span></span></span><br><span class="line">docker logs --since=&quot;2019-05-21&quot; --tail=10 redis</span><br></pre></td></tr></table></figure>

<h2 id="3-4、容器的进入与退出"><a href="#3-4、容器的进入与退出" class="headerlink" title="3.4、容器的进入与退出"></a>3.4、容器的进入与退出</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#使用run方式在创建时进入</span></span></span><br><span class="line">docker run -it centos /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#关闭容器并退出</span></span></span><br><span class="line">exit</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#仅退出容器，不关闭</span></span></span><br><span class="line">快捷键：Ctrl + P + Q</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#直接进入centos 容器启动命令的终端，不会启动新进程，多个attach连接共享容器屏幕，参数：--sig-proxy=false  确保CTRL-D或CTRL-C不会关闭容器</span></span></span><br><span class="line">docker attach --sig-proxy=false centos </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#在 centos 容器中打开新的交互模式终端，可以启动新进程，参数：-i  即使没有附加也保持STDIN 打开；-t  分配一个伪终端</span></span></span><br><span class="line">docker exec -i -t  centos /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#以交互模式在容器中执行命令，结果返回到当前终端屏幕</span></span></span><br><span class="line">docker exec -i -t centos ls -l /tmp</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#以分离模式在容器中执行命令，程序后台运行，结果不会反馈到当前终端</span></span></span><br><span class="line">docker exec -d centos  touch cache.txt </span><br></pre></td></tr></table></figure>

<h2 id="3-5、查看容器"><a href="#3-5、查看容器" class="headerlink" title="3.5、查看容器"></a>3.5、查看容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#查看正在运行的容器</span></span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#查看正在运行的容器的ID</span></span></span><br><span class="line">docker ps -q</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#查看正在运行+历史运行过的容器</span></span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#显示运行容器总文件大小</span></span></span><br><span class="line">docker ps -s</span><br></pre></td></tr></table></figure>

<p><a href="https://img2018.cnblogs.com/blog/1659331/201905/1659331-20190521132255698-500560462.png"><img src="https://img2018.cnblogs.com/blog/1659331/201905/1659331-20190521132255698-500560462.png" alt="img"></a><br><a href="https://img2018.cnblogs.com/blog/1659331/201905/1659331-20190521133039811-1994116017.png"><img src="https://img2018.cnblogs.com/blog/1659331/201905/1659331-20190521133039811-1994116017.png" alt="img"></a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#显示最近创建容器</span></span></span><br><span class="line">docker ps -l</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#显示最近创建的3个容器</span></span></span><br><span class="line">docker ps -n 3</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#不截断输出</span></span></span><br><span class="line">docker ps --no-trunc </span><br></pre></td></tr></table></figure>

<p><a href="https://img2018.cnblogs.com/blog/1659331/201905/1659331-20190521132741451-294716433.png"><img src="https://img2018.cnblogs.com/blog/1659331/201905/1659331-20190521132741451-294716433.png" alt="img"></a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#获取镜像redis的元信息</span></span></span><br><span class="line">docker inspect redis</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#获取正在运行的容器redis的 IP</span></span></span><br><span class="line">docker inspect --format=&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; redis</span><br></pre></td></tr></table></figure>

<h2 id="3-6、容器的停止与删除"><a href="#3-6、容器的停止与删除" class="headerlink" title="3.6、容器的停止与删除"></a>3.6、容器的停止与删除</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#停止一个运行中的容器</span></span></span><br><span class="line">docker stop redis</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#杀掉一个运行中的容器</span></span></span><br><span class="line">docker kill redis</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#删除一个已停止的容器</span></span></span><br><span class="line">docker rm redis</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#删除一个运行中的容器</span></span></span><br><span class="line">docker rm -f redis</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#删除多个容器</span></span></span><br><span class="line">docker rm -f $(docker ps -a -q)</span><br><span class="line">docker ps -a -q | xargs docker rm</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># -l 移除容器间的网络连接，连接名为 db</span></span></span><br><span class="line">docker rm -l db </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># -v 删除容器，并删除容器挂载的数据卷</span></span></span><br><span class="line">docker rm -v redis</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 批量关闭正在运行的容器</span></span></span><br><span class="line">docker stop $(docker ps -a -q)</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 批量强制关闭正在运行的容器</span></span></span><br><span class="line">docker kill $(docker ps -a -q)</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 批量删除已经退出的容器</span></span></span><br><span class="line">docker rm -f `docker ps -aq -f status=exited`</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 批量删除所有容器</span></span></span><br><span class="line">docker rm -f $(docker ps -q -q)</span><br></pre></td></tr></table></figure>

<h2 id="3-7、生成镜像"><a href="#3-7、生成镜像" class="headerlink" title="3.7、生成镜像"></a>3.7、生成镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#基于当前redis容器创建一个新的镜像；参数：-a 提交的镜像作者；-c 使用Dockerfile指令来创建镜像；-m :提交时的说明文字；-p :在commit时，将容器暂停</span></span></span><br><span class="line">docker commit -a=&quot;DeepInThought&quot; -m=&quot;my redis&quot; [redis容器ID]  myredis:v1.1</span><br></pre></td></tr></table></figure>

<h2 id="3-8、容器与主机间的数据拷贝"><a href="#3-8、容器与主机间的数据拷贝" class="headerlink" title="3.8、容器与主机间的数据拷贝"></a>3.8、容器与主机间的数据拷贝</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#将rabbitmq容器中的文件copy至本地路径</span></span></span><br><span class="line">docker cp rabbitmq:/[container_path] [local_path]</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#将主机文件copy至rabbitmq容器</span></span></span><br><span class="line">docker cp [local_path] rabbitmq:/[container_path]/</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#将主机文件copy至rabbitmq容器，目录重命名为[container_path]（注意与非重命名copy的区别）</span></span></span><br><span class="line">docker cp [local_path] rabbitmq:/[container_path]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker04-重新认识Docker容器</title>
    <url>/posts/18219.html</url>
    <content><![CDATA[<p>重新认识Docker</p>
<a id="more"></a>

<h2 id="Docker-部署一个用-Python-编写的-Web-应用"><a href="#Docker-部署一个用-Python-编写的-Web-应用" class="headerlink" title="Docker 部署一个用 Python 编写的 Web 应用"></a>Docker 部署一个用 Python 编写的 Web 应用</h2><h4 id="app-py"><a href="#app-py" class="headerlink" title="app.py"></a>app.py</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    html = <span class="string">&quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;&quot;</span> \</span><br><span class="line">           <span class="string">&quot;&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;&quot;</span>           </span><br><span class="line">    <span class="keyword">return</span> html.format(name=os.getenv(<span class="string">&quot;NAME&quot;</span>, <span class="string">&quot;world&quot;</span>), hostname=socket.gethostname())</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure>

<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat requirements.txt</span><br><span class="line">Flask</span><br></pre></td></tr></table></figure>

<h4 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 使用官方提供的Python开发镜像作为基础镜像</span></span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将工作目录切换为/app</span></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前目录下的所有内容复制到/app下</span></span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用pip命令安装这个应用所需要的依赖</span></span><br><span class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许外界访问容器的80端口</span></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置容器进程为：python app.py，即：这个Python应用的启动命令</span></span><br><span class="line">CMD [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>FROM</strong>: 指定了“python:2.7-slim”这个官方维护的基础镜像，从而免去了安装 Python 等语言环境的操作</li>
<li><strong>WORKDIR</strong>: Dockerfile 后面的操作都以这一句指定的 /app 目录作为当前目录。</li>
<li><strong>CMD</strong>: Dockerfile 指定 python app.py 为这个容器的进程。这里，app.py 的实际路径是 /app/app.py。所以，``CMD [“python”, “app.py”] <code>等价于</code> “docker run image python app.py”<code> </code>。</li>
<li><strong>ENTRYPOINT</strong>: 它和 CMD 都是 Docker 容器进程启动所必需的参数，完整执行格式是：“ENTRYPOINT CMD”。在不指定 ENTRYPOINT 时，比如在我们这个例子里，实际上运行在容器里的完整进程是：/bin/sh -c “python app.py”，即 <strong>CMD 的内容就是 ENTRYPOINT 的参数</strong>。</li>
</ul>
<h4 id="制作这个镜像"><a href="#制作这个镜像" class="headerlink" title="制作这个镜像"></a>制作这个镜像</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build -t helloworld .</span><br></pre></td></tr></table></figure>

<p>需要<strong>注意</strong>的是，<strong>Dockerfile 中的每个原语执行后，都会生成一个对应的镜像层。</strong>即使原语本身并没有明显地修改文件的操作（比如，ENV 原语），它对应的层也会存在。只不过在外界看来，这个层是空的。</p>
<h4 id="使用这个镜像，通过-docker-run-命令启动容器："><a href="#使用这个镜像，通过-docker-run-命令启动容器：" class="headerlink" title="使用这个镜像，通过 docker run 命令启动容器："></a>使用这个镜像，通过 docker run 命令启动容器：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 4000:80 helloworld</span><br></pre></td></tr></table></figure>

<p>在这一句命令中，镜像名 helloworld 后面，我什么都不用写，因为在 Dockerfile 中已经指定了 CMD。否则，我就得把进程的启动命令加在后面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -p 4000:80 helloworld python app.py</span><br></pre></td></tr></table></figure>

<h4 id="容器启动之后，我可以使用-docker-ps-命令看到："><a href="#容器启动之后，我可以使用-docker-ps-命令看到：" class="headerlink" title="容器启动之后，我可以使用 docker ps 命令看到："></a>容器启动之后，我可以使用 docker ps 命令看到：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED</span><br><span class="line">4ddf4638572d helloworld <span class="string">&quot;python app.py&quot;</span> 10 seconds ago</span><br></pre></td></tr></table></figure>

<p>已经通过 -p 4000:80 告诉了 Docker，请把容器内的 80 端口映射在宿主机的 4000 端口上。</p>
<h4 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h4><p>docker tag 命令给容器镜像起一个完整的名字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker tag helloworld geektime/helloworld:v1</span><br><span class="line"><span class="comment"># 执行 docker push：</span></span><br><span class="line">docker push geektime/helloworld:v1</span><br></pre></td></tr></table></figure>

<p>geektime 是我在 Docker Hub 上的用户名，它的“学名”叫镜像仓库（Repository）；</p>
<p>“/”后面的 helloworld 是这个镜像的名字，</p>
<p>而“v1”则是我给这个镜像分配的版本号。</p>
<h4 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h4><p>还可以使用 docker commit 指令，把一个正在运行的容器，直接提交为一个镜像。一般来说，需要这么操作原因是：这个容器运行起来后，我又在里面做了一些操作，并且要把操作结果保存到镜像里。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -it 4ddf4638572d /bin/sh</span><br><span class="line"><span class="comment"># 在容器内部新建了一个文件</span></span><br><span class="line">root@4ddf4638572d:/app<span class="comment"># touch test.txt</span></span><br><span class="line">root@4ddf4638572d:/app<span class="comment"># exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将这个新建的文件提交到镜像中保存</span></span><br><span class="line">$ docker commit 4ddf4638572d geektime/helloworld:v2</span><br></pre></td></tr></table></figure>

<p>​          docker commit，实际上就是在容器运行起来后，把最上层的“可读写层”，加上原先容器镜像的只读层，打包组成了一个新的镜像。当然，下面这些只读层在宿主机上是共享的，不会占用额外的空间。</p>
<p>​         而由于使用了联合文件系统，你在容器里对镜像 rootfs 所做的任何修改，都会被操作系统先复制到这个可读写层，然后再修改。这就是所谓的：Copy-on-Write。</p>
<p>​         而正如前所说，Init 层的存在，就是为了避免你执行 docker commit 时，把 Docker 自己对 /etc/hosts 等文件做的修改，也一起提交掉。</p>
<h4 id="docker-exec-的实现原理"><a href="#docker-exec-的实现原理" class="headerlink" title="docker exec 的实现原理"></a>docker exec 的实现原理</h4><p>Linux Namespace 创建的隔离空间虽然看不见摸不着，但一个进程的 Namespace 信息在宿主机上是确确实实存在的，并且是以一个文件的方式存在</p>
<p>通过如下指令，你可以看到当前正在运行的 Docker 容器的进程号（PID）是 25686：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker inspect --format <span class="string">&#x27;&#123;&#123; .State.Pid &#125;&#125;&#x27;</span>  4ddf4638572d</span><br><span class="line">25686</span><br></pre></td></tr></table></figure>

<p>这时，你可以通过查看宿主机的 proc 文件，看到这个 25686 进程的所有 Namespace 对应的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ ls -l  /proc/25686/ns</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 Aug 13 14:05 cgroup -&gt; cgroup:[4026531835]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Aug 13 14:05 ipc -&gt; ipc:[4026532278]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Aug 13 14:05 mnt -&gt; mnt:[4026532276]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Aug 13 14:05 net -&gt; net:[4026532281]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Aug 13 14:05 pid -&gt; pid:[4026532279]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Aug 13 14:05 pid_for_children -&gt; pid:[4026532279]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Aug 13 14:05 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Aug 13 14:05 uts -&gt; uts:[4026532277]</span><br></pre></td></tr></table></figure>

<p>可以看到，一个进程的每种 Linux Namespace，都在它对应的 /proc/[进程号]/ns 下有一个对应的虚拟文件，并且链接到一个真实的 Namespace 文件上。</p>
<p>这也就意味着：一个进程，可以选择加入到某个进程已有的 Namespace 当中，从而达到“进入”这个进程所在容器的目的，这正是 docker exec 的实现原理。</p>
<p><strong>原理</strong>：docker exec的原理就是找到proc的namespace信息，并加入进程</p>
<h4 id="docker-–net参数"><a href="#docker-–net参数" class="headerlink" title="docker –net参数"></a>docker –net参数</h4><p>Docker 还专门提供了一个参数，可以让你启动一个容器并“加入”到另一个容器的 Network Namespace 里，这个参数就是 -net，比如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ docker run -it --net container:4ddf4638572d busybox ifconfig</span><br></pre></td></tr></table></figure>

<h4 id="Docker-Volume"><a href="#Docker-Volume" class="headerlink" title="Docker Volume"></a>Docker Volume</h4><p><strong>Volume 机制，允许你将宿主机上指定的目录或者文件，挂载到容器里面进行读取和修改操作。</strong></p>
<p>它支持两种 Volume 声明方式，可以把宿主机目录挂载进容器的 /test 目录当中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -v /<span class="built_in">test</span> ...</span><br><span class="line">$ docker run -v /home:/<span class="built_in">test</span> ...</span><br></pre></td></tr></table></figure>

<ul>
<li>第一种情况下，由于你并没有显示声明宿主机目录，那么 Docker 就会默认在宿主机上创建一个临时目录 /var/lib/docker/volumes/[VOLUME_ID]/_data，然后把它挂载到容器的 /test 目录上。</li>
<li>第二种情况下，Docker 就直接把宿主机的 /home 目录挂载到容器的 /test 目录上。</li>
</ul>
<p><strong>Volume原理</strong>：</p>
<ol>
<li><p>为了保证隔离性，所以挂载操作必须在mount namespace之后执行 </p>
</li>
<li><p>为了保证可以看到系统的文件，所以挂载操作需要在chroot之前。所以操作的大致顺序是 mount namespace mount挂载 chroot</p>
</li>
<li><p>更重要的是，由于执行这个挂载操作时，“容器进程”已经创建了，也就意味着此时 Mount Namespace 已经开启了。所以，这个挂载事件只在这个容器里可见。你在宿主机上，是看不见容器内部的这个挂载点的。这就保证了容器的隔离性不会被 Volume 打破。</p>
<blockquote>
<p>注意：这里提到的”容器进程”，是 Docker 创建的一个容器初始化进程 (dockerinit)，而不是应用进程 (ENTRYPOINT + CMD)。dockerinit 会负责完成根目录的准备、挂载设备和目录、配置 hostname 等一系列需要在容器内进行的初始化操作。最后，它通过 execv() 系统调用，让应用进程取代自己，成为容器里的 PID=1 的进程。</p>
</blockquote>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/95c957b3c2813bb70eb784b8d1daedc6.png" alt="img"></p>
<p><strong>Inode替换</strong></p>
<p>而这里要使用到的挂载技术，就是 Linux 的绑定挂载（bind mount）机制。它的主要作用就是，允许你将一个目录或者文件，而不是整个设备，挂载到一个指定的目录上。并且，这时你在该挂载点上进行的任何操作，只是发生在被挂载的目录或者文件上，而原挂载点的内容则会被隐藏起来且不受影响。其实，如果你了解 Linux 内核的话，就会明白，绑定挂载实际上是一个 inode 替换的过程。在 Linux 操作系统中，inode 可以理解为存放文件内容的“对象”，而 dentry，也叫目录项，就是访问这个 inode 所使用的“指针”。</p>
<h5 id="commit-会提交-挂载点的文件内容吗？"><a href="#commit-会提交-挂载点的文件内容吗？" class="headerlink" title="commit 会提交 挂载点的文件内容吗？"></a>commit 会提交 挂载点的文件内容吗？</h5><p>不会。容器的镜像操作，比如 docker commit，都是发生在宿主机空间的。而由于 Mount Namespace 的隔离作用，宿主机并不知道这个绑定挂载的存在。所以，在宿主机看来，容器中可读写层的 /test 目录（/var/lib/docker/aufs/mnt/[可读写层 ID]/test），始终是空的。</p>
<p>   不过，由于 Docker 一开始还是要创建 /test 这个目录作为挂载点，所以执行了 docker commit 之后，你会发现新产生的镜像里，会多出来一个空的 /test 目录。毕竟，新建目录操作，又不是挂载操作，Mount Namespace 对它可起不到“障眼法”的作用。</p>
<p><strong>示例</strong>：</p>
<p>首先，启动一个 helloworld 容器，给它声明一个 Volume，挂载在容器里的 /test 目录上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -v /<span class="built_in">test</span> helloworld</span><br><span class="line">cf53b766fa6f</span><br></pre></td></tr></table></figure>

<p>容器启动之后，我们来查看一下这个 Volume 的 ID:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               cb1c2f7221fa9b0971cc35f68aa1034824755ac44a034c0c0a1dd318838d3a6d</span><br></pre></td></tr></table></figure>

<p>然后，使用这个 ID，可以找到它在 Docker 工作目录下的 volumes 路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls /var/lib/docker/volumes/cb1c2f7221fa/_data/</span><br></pre></td></tr></table></figure>

<p>这个 _data 文件夹，就是这个容器的 Volume 在宿主机上对应的临时目录了。</p>
<p>接下来，我们在容器的 Volume 里，添加一个文件 text.txt：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it cf53b766fa6f /bin/sh</span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">test</span>/</span><br><span class="line">touch text.txt</span><br></pre></td></tr></table></figure>

<p>这时，我们再回到宿主机，就会发现 text.txt 已经出现在了宿主机上对应的临时目录里：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls /var/lib/docker/volumes/cb1c2f7221fa/_data/</span><br><span class="line">text.txt</span><br></pre></td></tr></table></figure>

<p>可是，如果你在宿主机上查看该容器的可读写层，虽然可以看到这个 /test 目录，但其内容是空的（关于如何找到这个 AuFS 文件系统的路径，请参考我上一次分享的内容）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls /var/lib/docker/aufs/mnt/6780d0778b8a/<span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>可以确认，容器 Volume 里的信息，并不会被 docker commit 提交掉；但这个挂载点目录 /test 本身，则会出现在新的镜像当中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/3116751445d182687ce496f2825117e5.jpg" alt="img"></p>
<ul>
<li>这个容器进程“python app.py”，运行在由 Linux Namespace 和 Cgroups 构成的隔离环境里；而它运行所需要的各种文件，比如 python，app.py，以及整个操作系统文件，则由多个联合挂载在一起的 rootfs 层提供。</li>
<li>这些 rootfs 层的最下层，是来自 Docker 镜像的只读层。</li>
<li>在只读层之上，是 Docker 自己添加的 Init 层，用来存放被临时修改过的 /etc/hosts 等文件。</li>
<li>而 rootfs 的最上层是一个可读写层，它以 Copy-on-Write 的方式存放任何对只读层的修改，容器声明的 Volume 的挂载点，也出现在这一层。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask</title>
    <url>/posts/40609.html</url>
    <content><![CDATA[<p>Flask</p>
<a id="more"></a>

<h2 id="1-Flask-核心"><a href="#1-Flask-核心" class="headerlink" title="1. Flask 核心"></a>1. Flask 核心</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># flask的路由是基于装饰器</span></span><br><span class="line"><span class="comment"># request对象是个全局对象，request.args---&gt;不同请求取出来是不同请求携带的数据</span></span><br><span class="line"><span class="comment"># 通过不同协程/线程来区分是哪个request</span></span><br><span class="line"><span class="meta">@app.route(&#x27;/&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    print(request)</span><br><span class="line">    print(request.method)  <span class="comment"># method</span></span><br><span class="line">    print(request.cookies) <span class="comment"># cookie</span></span><br><span class="line">    print(request.environ) <span class="comment"># meta</span></span><br><span class="line">    print(request.form)    <span class="comment"># POST</span></span><br><span class="line">    print(request.query_string) <span class="comment"># BODY</span></span><br><span class="line">    print(request.args)    <span class="comment"># GET</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;lqz&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/home/&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>():</span></span><br><span class="line">    print(request.method)</span><br><span class="line">    print(request.args)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;我是home&#x27;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(port=<span class="number">8000</span>) </span><br><span class="line">    <span class="comment"># flask请求来了会执行，执行app()---&gt; run_simple(host, port, self, **options)</span></span><br><span class="line">    <span class="comment"># 请求来了--&gt; Flask对象() --&gt; 触发类的__call__</span></span><br><span class="line">    <span class="comment"># app.__call__----&gt;self.wsgi_app(environ, start_response)</span></span><br><span class="line">    <span class="comment"># 请求来了以后，会执行Md对象的__call__</span></span><br><span class="line">    <span class="comment"># aaa(environ, start_response)---&gt;Md类的__call__()</span></span><br></pre></td></tr></table></figure>

<h2 id="2-session存在哪"><a href="#2-session存在哪" class="headerlink" title="2.session存在哪"></a>2.session存在哪</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> django 默认存在orm数据库中</span><br><span class="line">  request.session[<span class="string">&#x27;user_info&#x27;</span>] = <span class="string">&#x27;lqz&#x27;</span></span><br><span class="line">  生成一个随机字符串: dsadsdasd</span><br><span class="line">  往cookie 中写入 sessionid = asasdsad</span><br><span class="line">  请求来:</span><br><span class="line">     session_id = asasdsad 根据随机字符串去数据库查, 查到以后把数据取出来</span><br><span class="line">     赋值给request.SESSION</span><br><span class="line">     </span><br><span class="line"><span class="number">2.</span> flask中根本不涉及到数据库, 以cookie形式，放到了客户端</span><br><span class="line">   session[<span class="string">&#x27;user_info&#x27;</span>] = <span class="string">&#x27;lqz&#x27;</span></span><br><span class="line">   把session字典通过秘钥加密 --&gt; asdasdsda加密串</span><br><span class="line">   请求来:</span><br><span class="line">        sessionid = asdsadsadsad把后面的加密串解密赋值给session</span><br><span class="line">        session.gee(<span class="string">&#x27;name&#x27;</span>) 就能取到值</span><br><span class="line">   flask 的 加密算法是可逆的</span><br></pre></td></tr></table></figure>

<h2 id="session及源码分析"><a href="#session及源码分析" class="headerlink" title="session及源码分析"></a>session及源码分析</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 第一步必须配置秘钥</span><br><span class="line"><span class="number">2</span> 全局导入session对象</span><br><span class="line"><span class="number">3</span> 赋值：sesion[<span class="string">&#x27;key&#x27;</span>]=value</span><br><span class="line"><span class="number">4</span> 取值：session[<span class="string">&#x27;key&#x27;</span>]</span><br><span class="line"><span class="number">5</span> 数据加密以后，放到了cookie中----（token）</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 源码分析执行流程</span><br><span class="line"><span class="number">2</span> 请求来了在open_session中取出cookie，反解数据，包装成session---》视图函数中使用session</span><br><span class="line"><span class="number">3</span> 只要session修改了，请求走了---》save_session---》把session加密，放到cookie中，返回给前端</span><br><span class="line"><span class="number">4</span> 不同浏览器，cookie不同（你的淘宝，同一个浏览器只能登陆一个用户）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">    -增：session[<span class="string">&#x27;name&#x27;</span>]=lqz</span><br><span class="line">    -查:session.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    -删:session.pop(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment">## 源码分析SecureCookieSessionInterface</span></span><br><span class="line"><span class="comment">## open_session</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">val = request.cookies.get(app.session_cookie_name)</span></span><br><span class="line"><span class="string">data = s.loads(val, max_age=max_age)</span></span><br><span class="line"><span class="string">return self.session_class(data)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## save_session</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">val = self.get_signing_serializer(app).dumps(dict(session))</span></span><br><span class="line"><span class="string">response.set_cookie(</span></span><br><span class="line"><span class="string">    app.session_cookie_name,</span></span><br><span class="line"><span class="string">    val,</span></span><br><span class="line"><span class="string">    expires=expires,</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span><span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># set_cookie其他参数</span></span><br><span class="line"></span><br><span class="line">key, 键</span><br><span class="line">value=<span class="string">&#x27;&#x27;</span>, 值</span><br><span class="line">max_age=<span class="literal">None</span>, 超时时间 cookie需要延续的时间（以秒为单位）如果参数是\ <span class="literal">None</span>`` ，这个cookie会延续到浏览器关闭为止</span><br><span class="line">expires=<span class="literal">None</span>, 超时时间(IE requires expires, so set it <span class="keyword">if</span> hasn<span class="string">&#x27;t been already.)</span></span><br><span class="line"><span class="string">path=&#x27;</span>/<span class="string">&#x27;, Cookie生效的路径，/ 表示根路径，特殊的：根路径的cookie可以被任何url的页面访问，浏览器只会把cookie回传给带有该路径的页面，这样可以避免将cookie传给站点中的其他的应用。</span></span><br><span class="line"><span class="string">domain=None, Cookie生效的域名 你可用这个参数来构造一个跨站cookie。如， domain=&quot;.example.com&quot;所构造的cookie对下面这些站点都是可读的：www.example.com 、 www2.example.com 和an.other.sub.domain.example.com 。如果该参数设置为 None ，cookie只能由设置它的站点读取</span></span><br><span class="line"><span class="string">secure=False, 浏览器将通过HTTPS来回传cookie</span></span><br><span class="line"><span class="string">httponly=False 只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖）</span></span><br></pre></td></tr></table></figure>

<h2 id="3-闪现"><a href="#3-闪现" class="headerlink" title="3.闪现"></a>3.闪现</h2><p>(本质用的是session, 不同的人都能看到) 效果: 看到一次就没了</p>
<p>高级用发： 可以给消息设置个分类category，取的时候按分类去 取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,jsonify,flash,get_flashed_messages</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> render_template</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> redirect</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> make_response</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.debug=<span class="literal">True</span></span><br><span class="line">app.secret_key=<span class="string">&#x27;sdfsdfsadfasdf&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/user&#x27;, methods=[&#x27;GET&#x27;, &quot;POST&quot;])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>():</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">        print(a[<span class="number">9</span>])</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">        <span class="comment">## 放到某个位置</span></span><br><span class="line">        <span class="comment"># flash(str(e))</span></span><br><span class="line">        <span class="comment"># 高级使用</span></span><br><span class="line">        flash(<span class="string">&#x27;超时错误&#x27;</span>, category=<span class="string">&quot;x1&quot;</span>)</span><br><span class="line">        flash(<span class="string">&#x27;xx错误&#x27;</span>, category=<span class="string">&quot;x3&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># return redirect(&#x27;/error?errors=%s&#x27;%str(e))</span></span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/error&#x27;</span>)</span><br><span class="line">    response=make_response(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/error&#x27;, methods=[&#x27;GET&#x27;, &quot;POST&quot;])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error</span>():</span></span><br><span class="line">    <span class="comment">#从那个位置取出来</span></span><br><span class="line">    <span class="comment"># errors=get_flashed_messages()</span></span><br><span class="line"></span><br><span class="line">    errors=get_flashed_messages(category_filter=[<span class="string">&#x27;x1&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;error.html&#x27;</span>,errors=errors)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(port=<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="4-请求扩展"><a href="#4-请求扩展" class="headerlink" title="4 请求扩展"></a>4 请求扩展</h2><p>before-request</p>
<p>after-reuqest</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,jsonify,flash,get_flashed_messages</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,request</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> render_template</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> redirect</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> make_response</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.debug=<span class="literal">False</span></span><br><span class="line">app.secret_key=<span class="string">&#x27;sdfsdfsadfasdf&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># @app.before_request   #类比django中间件中的process_request,写多个执行顺序是从上往下</span></span><br><span class="line"><span class="comment"># def before():</span></span><br><span class="line"><span class="comment">#     print(&#x27;我来了&#x27;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     request.xx=&#x27;xxxxxx&#x27;</span></span><br><span class="line"><span class="comment">#     # return &#x27;回去吧&#x27;  #四件套之一</span></span><br><span class="line"><span class="comment">#     return  None  # 继续进入下一个before_request</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @app.before_request   #类比django中间件中的process_request</span></span><br><span class="line"><span class="comment"># def before2():</span></span><br><span class="line"><span class="comment">#     print(&#x27;我来了22&#x27;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     return  None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @app.after_request   # 从下往上</span></span><br><span class="line"><span class="comment"># def after(response):</span></span><br><span class="line"><span class="comment">#     print(&#x27;我走了&#x27;)</span></span><br><span class="line"><span class="comment">#     print(response)</span></span><br><span class="line"><span class="comment">#     response.headers[&#x27;xxxx&#x27;]=&#x27;xxx&#x27;</span></span><br><span class="line"><span class="comment">#     return  response  #要return response</span></span><br><span class="line"><span class="comment"># @app.after_request</span></span><br><span class="line"><span class="comment"># def after2(response):</span></span><br><span class="line"><span class="comment">#     print(&#x27;我走了222&#x27;)</span></span><br><span class="line"><span class="comment">#     return  response  #要return response</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># @app.before_first_request  # 只会执行一次，程序启动以后，第一个访问的会触发，以后再也不会了</span></span><br><span class="line"><span class="comment"># def first():</span></span><br><span class="line"><span class="comment">#     # 程序初始化的一些操作</span></span><br><span class="line"><span class="comment">#     print(&#x27;我的第一次&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># @app.teardown_request</span></span><br><span class="line"><span class="comment"># def ter(e):</span></span><br><span class="line"><span class="comment">#     # 日志记录，不管当次请求是否出异常，都会执行，出了异常，e就是异常对象，debug=False模式下</span></span><br><span class="line"><span class="comment">#     print(e)</span></span><br><span class="line"><span class="comment">#     print(&#x27;我执行了&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @app.errorhandler(404)   #只要是404错误，都会走它</span></span><br><span class="line"><span class="comment"># def error_404(arg):</span></span><br><span class="line"><span class="comment">#     return &quot;404错误了&quot;</span></span><br><span class="line"><span class="comment">#     # return render_template(&#x27;404.html&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @app.errorhandler(500)   #只要是500错误，都会走它，debug模式要关掉</span></span><br><span class="line"><span class="comment"># def error_500(arg):</span></span><br><span class="line"><span class="comment">#     return &quot;出问题了&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.template_global()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sb</span>(<span class="params">a1, a2</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a1 + a2</span><br><span class="line"><span class="comment">#&#123;&#123;sb(1,2)&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.template_filter()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">db</span>(<span class="params">a1, a2, a3</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a1 + a2 + a3</span><br><span class="line"><span class="comment">#&#123;&#123; 1|db(2,3)&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/user&#x27;, methods=[&#x27;GET&#x27;, &quot;POST&quot;])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>():</span></span><br><span class="line">    <span class="comment"># print(request.xx)</span></span><br><span class="line">    <span class="comment"># response=make_response(&#x27;hello&#x27;)</span></span><br><span class="line">    <span class="comment"># return response</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;login.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(port=<span class="number">8080</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="5-蓝图"><a href="#5-蓝图" class="headerlink" title="5 蓝图"></a>5 蓝图</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对程序进行目录结构划分</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用步骤</span></span><br><span class="line">    -实例化得到一个蓝图对象(可以指定直接的静态文件和模板路径)</span><br><span class="line">    -在app中注册蓝图（可以指定前缀）</span><br><span class="line">    -以后再写路由装饰器，使用蓝图对象的.route</span><br></pre></td></tr></table></figure>



<h2 id="6-flask-项目演示"><a href="#6-flask-项目演示" class="headerlink" title="6 flask 项目演示"></a>6 flask 项目演示</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 创建一个库movie</span></span><br><span class="line"><span class="comment"># 2 手动把表同步进去</span></span><br><span class="line">    -modes.py,解开注释，右键执行</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 3 安装项目依赖</span></span><br><span class="line">    -flask-sqlalchemy</span><br><span class="line">    -flask_script</span><br><span class="line">    -flask_redis</span><br><span class="line">    -flask_wtf</span><br><span class="line"><span class="comment"># 4 命令行中运行</span></span><br><span class="line">python3 manage.py runserver </span><br><span class="line"><span class="comment"># 5 后台管理中rbac控制</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># https://gitee.com/openspug/spug/tree/1.x/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Go-01-第一个Go程序</title>
    <url>/posts/55381.html</url>
    <content><![CDATA[<p>第一个Go程序</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置国内代理</span><br><span class="line">go env -w GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn,direct</span><br></pre></td></tr></table></figure>





<h2 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h2><p>Go 语言是由谷歌的开发工程师(罗伯特·格瑞史莫、罗勃·派克、肯·汤普逊等)于 2007 年 开始设计，利用 20%的自由时间开发的实验项目，并于 2009 年以 BSD-style 授权（完全开 源）首次公开发布，于 2012 年正式发布</p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul>
<li>简单的部署方式<ul>
<li>可直接编译成机械码</li>
<li>不依赖其他库</li>
<li>直接运行即可部署</li>
</ul>
</li>
<li>静态类型语言<ul>
<li>编译的时候可以检测出隐藏的大多数问题</li>
<li>强类型方便阅读与重构</li>
</ul>
</li>
<li>语言层面的并发<ul>
<li>天生的基于支持</li>
<li>充分利用多核</li>
</ul>
</li>
<li>工程化比较优秀<ul>
<li>GoDoc 可以直接从代码和注释生成漂亮的文档</li>
<li>GoFmt 统一的代码格式</li>
<li>GoLint 代码语法提示</li>
<li>测试框架内置</li>
</ul>
</li>
<li>强大的标准库<ul>
<li>Runtime系统调度机制</li>
<li>高效的GC垃圾回收</li>
<li>丰富的标准库</li>
</ul>
</li>
<li>简单易学<ul>
<li>25个关键字</li>
<li>C语言简洁基因，内嵌C语言语法支持</li>
<li>面向对象特征(继承, 多态，封装)</li>
<li>跨平台</li>
</ul>
</li>
</ul>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><ul>
<li>包管理, 大部分都在 github上<ul>
<li>作者修改项目名称</li>
<li>作者删库跑路</li>
<li>vendor 到 mod 迁移麻烦，很多遗留依赖问题</li>
</ul>
</li>
<li>无泛型， 2.0 有计划加上 (传言)<ul>
<li>interface{}可以解决该问题, 但是不易于代码阅读</li>
</ul>
</li>
<li>没有Exception，使用Error来处理异常<ul>
<li>error处理不太优雅, 很多重复代码</li>
</ul>
</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>Go 语言主要用于服务端开发，其定位是开发大型软件，常用于：</p>
<ul>
<li>服务器编程：日志处理、数据打包、虚拟机处理、文件系统、分布式系统、数据库代理等</li>
<li>网络编程：Web 应用、API 应用、下载应用</li>
<li>内存数据库</li>
<li>云平台</li>
<li>机器学习</li>
<li>区块链</li>
<li>……</li>
</ul>
<p>使用 Go 开发的项目列表：<a href="https://github.com/golang/go/wiki/Projects">https://github.com/golang/go/wiki/Projects</a></p>
<ul>
<li>Go</li>
<li>docker</li>
<li>kubernetes</li>
<li>lantern</li>
<li>etcd</li>
<li>Prometheus</li>
<li>Influxdb</li>
<li>Consul</li>
<li>nsq</li>
<li>nats</li>
<li>beego</li>
</ul>
<h2 id="学习Golang的一些方法"><a href="#学习Golang的一些方法" class="headerlink" title="学习Golang的一些方法"></a>学习Golang的一些方法</h2><ul>
<li>官网: <a href="https://golang.google.cn/doc/">https://golang.google.cn/doc/</a></li>
<li>不错的gitbook入门:<ul>
<li><a href="https://yar999.gitbook.io/gopl-zh/">Go语言圣经</a></li>
<li><a href="https://astaxie.gitbooks.io/build-web-application-with-golang/content/zh/">Go Web 编程</a></li>
<li>不错的微信公众号: 现在还在更新的就只有GoCN了</li>
</ul>
</li>
<li>阅读一些优秀的项目的源码<ul>
<li><a href="https://github.com/kubernetes/kubernetes">kubernetes</a></li>
<li><a href="https://github.com/nats-io/nats-server">nats</a></li>
<li><a href="https://github.com/influxdata/telegraf">telegraf</a></li>
<li><a href="https://github.com/elastic/beats">beats</a></li>
<li><a href="https://github.com/etcd-io/etcd/tree/main/raft">etcd raft</a></li>
</ul>
</li>
</ul>
<h1 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h1><ol>
<li>下载。到 <a href="https://studygolang.com/dl">https://studygolang.com/dl</a> 上下载最新的Go稳定版本。</li>
<li>安装。对于Windows和macOS用户，直接双击即可安装，留意一下安装路径。对于Linux用户，直接解压安装包即可，比如你打算把go安装到/usr/local目录下，则使用命令<br>tar zxvf goxxx.tar.gz –C /usr/local。这样go标准库及相关的可执行文件就安装到了/usr/local/go目录下，在后续的步骤中会把/usr/local/go赋给GOROOT环境变量。  </li>
<li>准确GOPATH。在任意目录下创建一个空目录，将来用于存放go语言第三方库文件。比如你打算使用/data/go_path这个目录，则在Linux下使用命令mkdir -p /data/go_path。在GOPATH目录建3个子目录：src、bin、pkg。  </li>
<li>配置环境变量。把第2步和第3步生成的目录分别赋给GOROOT和GOPATH环境变量，对于Linux和Mac用户在~/.bashrc文件中追加以下几行</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Go 配置</span></span><br><span class="line"><span class="built_in">export</span> GOROOT=/usr/<span class="built_in">local</span>/go</span><br><span class="line"><span class="built_in">export</span> GOPATH=/Users/waylonyan/GoPath</span><br><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.cn,direct</span><br><span class="line"><span class="comment"># 还可以设置不走proxy的私有仓库或组, 多个用逗号相隔(可选)</span></span><br><span class="line"><span class="comment"># export GOPRIVATE=git.mycompany.com,github.com/my/private</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOROOT</span>/bin:<span class="variable">$GOPATH</span>/bin</span><br></pre></td></tr></table></figure>

<p>PATH环境变量下的可执行文件在任意目录下都可以直接访问。  </p>
<h1 id="第一个Go程序"><a href="#第一个Go程序" class="headerlink" title="第一个Go程序"></a>第一个Go程序</h1><p>编写一个hello world程序, 并可以运行它</p>
<h2 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h2><p>go语言有2种工程结构:</p>
<ul>
<li>GOPATH工程结构</li>
<li>GO MODULE工程结构</li>
</ul>
<p>我们这里先讲解GOPATH工程结构, 等后面引入包的概念后再开始使用GO MODULE工程结构, 而Go1.16默认使用的GO MODULE工程结构, 因此我们需要修改下设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go env -w GO111MODULE&#x3D;auto</span><br></pre></td></tr></table></figure>

<p>工作目录是一个工程开发的相对参考目录, GOPATH工程结构中的工作目录就是GOPATH变量指向的目录 我们可以通过GOPATH这个变量查看当前设置的工作目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go env GOPATH &#x2F;&#x2F; 通过go env 可以查看go语言设置相关的所有变量</span><br><span class="line">E:\Golang       &#x2F;&#x2F; 这是我的工作目录</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/gopath_workspace.png" alt="img"></p>
<p>以上 $GOPATH 目录，通常存放第三方依赖库，约定有三个子目录：</p>
<ul>
<li>src 存放源代码（比如：.go .c .h .s等）</li>
<li>pkg 编译后生成的静态库（比如：.a）, 多个静态库文件通过连接器连接 最终构成我们要得目标文件</li>
<li>bin 编译后生成的可执行文件（为了方便，可以把此目录加入到 PATH变量中，如果有多个gopath，那么使用PATH变量中，如果有多个gopath，那么使用{GOPATH//://bin:}/bin添加所有的bin目录）</li>
</ul>
<p>如果你的这3个目录不存在请提前创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir bin pkg src</span><br><span class="line"></span><br><span class="line">- pkg&#x2F;mod    go get 下载的第三方依赖</span><br><span class="line">- go install 生成的可执行文件存储在$GOPATH&#x2F;bin 下</span><br><span class="line">- 依赖包查找顺序：</span><br><span class="line">  1. 工作目录</span><br><span class="line">  2. $GOPATH&#x2F;pkg&#x2F;mod</span><br><span class="line">  3. $GOROOT&#x2F;src</span><br></pre></td></tr></table></figure>

<h2 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h2><p>使用vscode打开你的工作目录</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/vscode_open_workspace.png" alt="img"></p>
<p>我们在src下编写我们的第一个Go程序: hello.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;hello world, this is my first golang program!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解读:</p>
<ul>
<li>package: Go源文件开头必须使用 package 声明代码所属包，包是 Go 代码分发的最基本单位。若程序需要运行包名必须为 main。</li>
<li>import: 用于导入程序依赖的所有的包。此程序依赖于 fmt 包。</li>
<li>func: 用于定义函数。main 函数是程序的入口,若程序需要运行必须声明 main 函数,main 函数无参数也无返回值</li>
<li>fmt.Println 调用 fmt.Println 函数将参数信息打印到控制台</li>
</ul>
<p>main()函数是Go程序的唯一入口，且main()函数必须位于package main中。fmt是Go标准库中的一个package，该package下有一个Println()函数用于输出字符串。Go语言会依次从以下3个目录里查找依赖包：</p>
<ol>
<li>当前工作目录</li>
<li>$GOPATH/pkg/mod</li>
<li>$GOROOT/src</li>
</ol>
<h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><h3 id="快速运行"><a href="#快速运行" class="headerlink" title="快速运行"></a>快速运行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go run src&#x2F;day1&#x2F;hello.go </span><br><span class="line">hello world, this is my first golang program!</span><br></pre></td></tr></table></figure>

<p>go run：用于直接运行程序, 编译和运行一个Go的main包</p>
<h3 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go build -o day1&#x2F;hello.exe day1&#x2F;hello.go   &#x2F;&#x2F; 编译hello.go, 输出二进制目标文件hello.exe</span><br><span class="line">.&#x2F;day1&#x2F;hello.exe     &#x2F;&#x2F; 运行编译好的hello.exe</span><br><span class="line">hello world, this is my first golang program!</span><br></pre></td></tr></table></figure>

<p>go build: 用于编译&amp;链接程序或包</p>
<p>常用参数说明：</p>
<ul>
<li>-x: 打印编译过程执行的命令，并完成编译或运行</li>
<li>-n: 只打印编译过程执行命令</li>
<li>-work：打印编译过程的临时目录</li>
<li>-o: 指定编译结果文件</li>
</ul>
<h2 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h2><h3 id="go-env"><a href="#go-env" class="headerlink" title="go env"></a>go env</h3><p>我们可以通过go env 打印当前Go运行的所有环境变量配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go env</span><br><span class="line">set GO111MODULE&#x3D;auto</span><br><span class="line">set GOARCH&#x3D;amd64</span><br><span class="line">set GOBIN&#x3D;</span><br><span class="line">set GOCACHE&#x3D;C:\Users\yumaojun\AppData\Local\go-build    </span><br><span class="line">set GOENV&#x3D;C:\Users\yumaojun\AppData\Roaming\go\env      </span><br><span class="line">set GOEXE&#x3D;.exe</span><br><span class="line">set GOFLAGS&#x3D;</span><br><span class="line">set GOHOSTARCH&#x3D;amd64</span><br><span class="line">set GOHOSTOS&#x3D;windows</span><br><span class="line">set GOINSECURE&#x3D;</span><br><span class="line">set GOMODCACHE&#x3D;E:\Golang\pkg\mod</span><br><span class="line">set GONOPROXY&#x3D;</span><br><span class="line">set GONOSUMDB&#x3D;</span><br><span class="line">set GOOS&#x3D;windows</span><br><span class="line">set GOPATH&#x3D;E:\Golang</span><br><span class="line">set GOPRIVATE&#x3D;</span><br><span class="line">set GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn</span><br><span class="line">set GOROOT&#x3D;C:\Program Files\Go</span><br><span class="line">set GOSUMDB&#x3D;sum.golang.org</span><br><span class="line">set GOTMPDIR&#x3D;</span><br><span class="line">set GOTOOLDIR&#x3D;C:\Program Files\Go\pkg\tool\windows_amd64</span><br><span class="line">set GOVCS&#x3D;</span><br><span class="line">set GOVERSION&#x3D;go1.16.4</span><br><span class="line">set GCCGO&#x3D;gccgo</span><br><span class="line">set AR&#x3D;ar</span><br><span class="line">set CC&#x3D;gcc</span><br><span class="line">set CXX&#x3D;g++</span><br><span class="line">set CGO_ENABLED&#x3D;1</span><br><span class="line">set GOMOD&#x3D;</span><br><span class="line">set CGO_CFLAGS&#x3D;-g -O2</span><br><span class="line">set CGO_CPPFLAGS&#x3D;</span><br><span class="line">set CGO_CXXFLAGS&#x3D;-g -O2</span><br><span class="line">set CGO_FFLAGS&#x3D;-g -O2</span><br><span class="line">set CGO_LDFLAGS&#x3D;-g -O2</span><br><span class="line">set PKG_CONFIG&#x3D;pkg-config</span><br><span class="line">set GOGCCFLAGS&#x3D;-m64 -mthreads -fmessage-length&#x3D;0 -fdebug-prefix-map&#x3D;C:\Users\yumaojun\AppData\Local\Temp\go-build483455790&#x3D;&#x2F;tmp&#x2F;go-build -gno-record-gcc-switches</span><br></pre></td></tr></table></figure>

<p>读取环境变量的值： go env <ENV_NAME></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go env GO111MODULE</span><br></pre></td></tr></table></figure>

<p>设置环境变量的值: go env -w <ENV_NAME>=<ENV_VALUE></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go env -w GO111MODULE&#x3D;auto</span><br></pre></td></tr></table></figure>

<h3 id="go-tool"><a href="#go-tool" class="headerlink" title="go tool"></a>go tool</h3><p>go tool 是一组工具集, 支持很多子命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go tool</span><br><span class="line">addr2line</span><br><span class="line">api</span><br><span class="line">asm</span><br><span class="line">buildid</span><br><span class="line">cgo</span><br><span class="line">compile   &#x2F;&#x2F; 编译源代码, 生成静态库或者目标文件</span><br><span class="line">cover</span><br><span class="line">dist</span><br><span class="line">doc</span><br><span class="line">fix</span><br><span class="line">go_bootstrap</span><br><span class="line">link     &#x2F;&#x2F; 链接目标文件和目标文件依赖的静态库 生成最终的可执行二进制文件</span><br><span class="line">nm</span><br><span class="line">objdump</span><br><span class="line">pack</span><br><span class="line">pprof</span><br><span class="line">test2json</span><br><span class="line">trace   </span><br><span class="line">vet</span><br></pre></td></tr></table></figure>

<p>我们使用go tool 提供的 compile 和 link 来手动编译一个程序, 这有助于你更好的理解编译的过程</p>
<ol>
<li>首先我们需要写一个这样一个样例程序</li>
</ol>
<p><img src="https://gitee.com/infraboard/go-course/raw/master/image/go_compile_demo.png" alt="compile_demo"></p>
<p>我们在day1下面创建一个compile目录, 用于存放我们这次演示的项目代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir day1&#x2F;compile</span><br></pre></td></tr></table></figure>

<p>然后我们先编写pkg包: day1/compile/pkg/demo.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Demo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;This is demo for go install&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们需要编写我们的mian包(程序入口): day1/compile/main.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;day1/compile/pkg&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        pkg.Demo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>编译并安装我们的pkg包</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go env -w GO111MODULE&#x3D;auto &#x2F;&#x2F; 为了让go install 命令能正常生成静态库到pkg目录下, 我们首先需要关闭go mod</span><br><span class="line">go install day1&#x2F;compile&#x2F;pkg  &#x2F;&#x2F; 使用go install 安装依赖包, 安装过后静态库会放置到 GOPATH下的pkg&#x2F;&lt;platform&gt;下</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编译main.go</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;day1&#x2F;compile  &#x2F;&#x2F; 切换到compile目录下 进行编译与链接</span><br><span class="line">go tool compile -I &#x2F;e&#x2F;Golang&#x2F;pkg&#x2F;windows_amd64 main.go &#x2F;&#x2F; 编译原文件, 指定静态库搜索目录</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>链接main.o</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go tool link -o main.exe -L &#x2F;e&#x2F;Golang&#x2F;pkg&#x2F;windows_amd64&#x2F;  main.o &#x2F;&#x2F; 将目标文件和静态库链接成一个二进制可执行文件</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>运行我们连接生成的二进制可执行文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;main.exe</span><br></pre></td></tr></table></figure>

<h3 id="go-get-与-go-install"><a href="#go-get-与-go-install" class="headerlink" title="go get 与 go install"></a>go get 与 go install</h3><p>go get 用于拉去外部依赖的包或者工具, 如果是Mod项目, 并将依赖添加至 go.mod中</p>
<p>go get 相当于执行了如下命令:</p>
<ol>
<li>git clone <PKG_PATH></li>
<li>cd /<PKG_PATH> &amp;&amp; go install</li>
</ol>
<p>关键参数: -d： 只拉去源码, 不执行 go install &lt;在未来的版本中 该选项默认开启&gt;</p>
<p>外部依赖的包的源码会放置到GOPATH的src下面, 而可执行文件将会编译安装到GOPATH的bin下面</p>
<p>我们之前在安装vscode go的扩展工具时安装了gopls</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get -v golang.org&#x2F;x&#x2F;tools&#x2F;gopls </span><br></pre></td></tr></table></figure>

<p>如下是gopls的源码存放位置 <img src="https://gitee.com/infraboard/go-course/raw/master/image/vscode_ext_src_dir.png" alt="img"></p>
<p>如下下gopls的二进制文件存放位置 <img src="https://gitee.com/infraboard/go-course/raw/master/image/vscode_ext_exe_dir.png" alt="img"></p>
<p>go install 用于编译和安装二进制文件</p>
<ol>
<li>如果有main包, 将直接build, 将build好的二进制文件放到GOPATH的bin目录下</li>
<li>如果不是main包, 将编译静态库, 放到GOPATH/pkg/目录下面</li>
</ol>
<h3 id="go-clean"><a href="#go-clean" class="headerlink" title="go clean"></a>go clean</h3><p>这个命令是用来移除当前源码包和关联源码包里面编译生成的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls &#x2F;e&#x2F;Golang&#x2F;pkg&#x2F;windows_amd64&#x2F;demo</span><br><span class="line">go clean -i -n</span><br></pre></td></tr></table></figure>

<h3 id="go-fmt"><a href="#go-fmt" class="headerlink" title="go fmt"></a>go fmt</h3><p>代码格式化</p>
<h3 id="go-vet"><a href="#go-vet" class="headerlink" title="go vet"></a>go vet</h3><p>语法静态检查</p>
<p>go help: 查看帮助文档。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go help build</span><br></pre></td></tr></table></figure>

<p>go build: 对源代码和依赖的文件进行打包，生成可执行文件。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go build -o my_first_go_exe entrance_class/demo.go</span><br></pre></td></tr></table></figure>

<p>go install: 编译并安装包或依赖，安装到$GOPATH/bin下。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go install entrance_class/demo.go</span><br></pre></td></tr></table></figure>

<p>go get: 把依赖库添加到当前module中，如果本机之前从未下载过则先下载。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go get github.com/tinylib/msgp </span><br></pre></td></tr></table></figure>

<p>以上命令会在$GOPATH/pkg/mod目录下会生成github.com/tinylib/msgp目录。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go install github.com/tinylib/msgp@latest </span><br></pre></td></tr></table></figure>

<p>以上命令会在$GOPATH/bin下生成msgp可执行文件。<br>go mod init module_name<br>初始化一个Go项目。<br>go mod tidy通过扫描当前项目中的所有代码来添加未被记录的依赖至go.mod文件或从go.mod文件中删除不再被使用的依赖。<br>go run: 编译并运行程序。<br>go test: 执行测试代码。<br>go tool: 执行go自带的工具。go tool pprof对cpu、内存和协程进行监控；go tool trace跟踪协程的执行过程。<br>go vet: 检查代码中的静态错误。<br>go fmt: 对代码文件进行格式化，如果用了IDE这个命令就不需要了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go fmt entrance_class/demo.go</span><br></pre></td></tr></table></figure>

<p>go doc: 查看go标准库或第三方库的帮助文档。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go doc fmt</span><br><span class="line">go doc gonum.org/v1/gonum/stat</span><br></pre></td></tr></table></figure>

<p>go version: 查看go版本号。<br>go env: 查看go环境信息。  </p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker05-DockerFile</title>
    <url>/posts/1819.html</url>
    <content><![CDATA[<p>DockerFile</p>
<a id="more"></a>

<h2 id="Dockerfile-概念"><a href="#Dockerfile-概念" class="headerlink" title="Dockerfile 概念"></a>Dockerfile 概念</h2><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。有了 Dockerfile，当我们需要定制自己额外的需求时，只需在 Dockerfile 上添加或者修改指令，重新生成 image 即可，省去了敲命令的麻烦。</p>
<h2 id="Dockerfile-文件格式"><a href="#Dockerfile-文件格式" class="headerlink" title="Dockerfile 文件格式"></a>Dockerfile 文件格式</h2><p>Dockerfile文件格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##  Dockerfile文件格式</span><br><span class="line"></span><br><span class="line"># This dockerfile uses the ubuntu image</span><br><span class="line"># VERSION 2 - EDITION 1</span><br><span class="line"># Author: docker_user</span><br><span class="line"># Command format: Instruction [arguments &#x2F; command] ..</span><br><span class="line"> </span><br><span class="line"># 1、第一行必须指定 基础镜像信息</span><br><span class="line">FROM ubuntu</span><br><span class="line"> </span><br><span class="line"># 2、维护者信息</span><br><span class="line">MAINTAINER docker_user docker_user@email.com</span><br><span class="line"> </span><br><span class="line"># 3、镜像操作指令</span><br><span class="line">RUN echo &quot;deb http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; raring main universe&quot; &gt;&gt; &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y nginx</span><br><span class="line">RUN echo &quot;\ndaemon off;&quot; &gt;&gt; &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line"> </span><br><span class="line"># 4、容器启动执行指令</span><br><span class="line">CMD &#x2F;usr&#x2F;sbin&#x2F;nginx</span><br></pre></td></tr></table></figure>

<p>Dockerfile 分为四部分：<strong>基础镜像信息、维护者信息、镜像操作指令、容器启动执行指令</strong>。一开始必须要指明所基于的镜像名称，接下来一般会说明维护者信息；后面则是镜像操作指令，例如 RUN 指令。每执行一条RUN 指令，镜像添加新的一层，并提交；最后是 CMD 指令，来指明运行容器时的操作命令。</p>
<h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>docker build 命令会根据 Dockerfile 文件及上下文构建新 Docker 镜像。构建上下文是指 Dockerfile 所在的本地路径或一个URL（Git仓库地址）。构建上下文环境会被递归处理，所以构建所指定的路径还包括了子目录，而URL还包括了其中指定的子模块。</p>
<p>将当前目录做为构建上下文时，可以像下面这样使用docker build命令构建镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build .</span><br><span class="line">Sending build context to Docker daemon  6.51 MB</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>说明：构建会在 Docker 后台守护进程（daemon）中执行，而不是<code>CLI</code>中。构建前，构建进程会将全部内容（递归）发送到守护进程。大多情况下，应该将一个空目录作为构建上下文环境，并将 Dockerfile 文件放在该目录下。</p>
<p>在构建上下文中使用的 Dockerfile 文件，是一个构建指令文件。为了提高构建性能，可以通过<code>.dockerignore</code>文件排除上下文目录下不需要的文件和目录。</p>
<p>在 Docker 构建镜像的第一步，docker CLI 会先在上下文目录中寻找<code>.dockerignore</code>文件，根据<code>.dockerignore</code> 文件排除上下文目录中的部分文件和目录，然后把剩下的文件和目录传递给 Docker 服务。</p>
<p>Dockerfile 一般位于构建上下文的根目录下，也可以通过<code>-f</code>指定该文件的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -f &#x2F;path&#x2F;to&#x2F;a&#x2F;Dockerfile .</span><br></pre></td></tr></table></figure>

<p>构建时，还可以通过<code>-t</code>参数指定构建成镜像的仓库、标签。</p>
<h2 id="镜像标签"><a href="#镜像标签" class="headerlink" title="镜像标签"></a>镜像标签</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t nginx&#x2F;v3 .</span><br></pre></td></tr></table></figure>

<p>如果存在多个仓库下，或使用多个镜像标签，就可以使用多个<code>-t</code>参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t nginx&#x2F;v3:1.0.2 -t nginx&#x2F;v3:latest .</span><br></pre></td></tr></table></figure>

<p>在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t nginx&#x2F;v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Error response from daemon: Unknown instruction: RUNCMD</span><br></pre></td></tr></table></figure>

<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>Docker 守护进程会一条一条的执行 Dockerfile 中的指令，而且会在每一步提交并生成一个新镜像，最后会输出最终镜像的ID。生成完成后，Docker 守护进程会自动清理你发送的上下文。 Dockerfile文件中的每条指令会被独立执行，并会创建一个新镜像，RUN cd /tmp等命令不会对下条指令产生影响。 Docker 会重用已生成的中间镜像，以加速docker build的构建速度。以下是一个使用了缓存镜像的执行过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker build -t svendowideit&#x2F;ambassador .</span><br><span class="line">Sending build context to Docker daemon 15.36 kB</span><br><span class="line">Step 1&#x2F;4 : FROM alpine:3.2</span><br><span class="line"> ---&gt; 31f630c65071</span><br><span class="line">Step 2&#x2F;4 : MAINTAINER SvenDowideit@home.org.au</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 2a1c91448f5f</span><br><span class="line">Step 3&#x2F;4 : RUN apk update &amp;&amp;      apk add socat &amp;&amp;        rm -r &#x2F;var&#x2F;cache&#x2F;</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 21ed6e7fbb73</span><br><span class="line">Step 4&#x2F;4 : CMD env | grep _TCP&#x3D; | (sed &#39;s&#x2F;.*_PORT_\([0-9]*\)_TCP&#x3D;tcp:\&#x2F;\&#x2F;\(.*\):\(.*\)&#x2F;socat -t 100000000 TCP4-LISTEN:\1,fork,reuseaddr TCP4:\2:\3 \&amp;&#x2F;&#39; &amp;&amp; echo wait) | sh</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 7ea8aef582cc</span><br><span class="line">Successfully built 7ea8aef582cc</span><br></pre></td></tr></table></figure>

<p>构建缓存仅会使用本地父生成链上的镜像，如果不想使用本地缓存的镜像，也可以通过<code>--cache-from</code>指定缓存。指定后将不再使用本地生成的镜像链，而是从镜像仓库中下载。</p>
<h2 id="寻找缓存的逻辑"><a href="#寻找缓存的逻辑" class="headerlink" title="寻找缓存的逻辑"></a>寻找缓存的逻辑</h2><p>Docker 寻找缓存的逻辑其实就是树型结构根据 Dockerfile 指令遍历子节点的过程。下图可以说明这个逻辑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     FROM base_image:version           Dockerfile:</span><br><span class="line">           +----------+                FROM base_image:version</span><br><span class="line">           |base image|                RUN cmd1  --&gt; use cache because we found base image</span><br><span class="line">           +-----X----+                RUN cmd11 --&gt; use cache because we found cmd1</span><br><span class="line">                &#x2F; \</span><br><span class="line">               &#x2F;   \</span><br><span class="line">       RUN cmd1     RUN cmd2           Dockerfile:</span><br><span class="line">       +------+     +------+           FROM base_image:version</span><br><span class="line">       |image1|     |image2|           RUN cmd2  --&gt; use cache because we found base image</span><br><span class="line">       +---X--+     +------+           RUN cmd21 --&gt; not use cache because there&#39;s no child node</span><br><span class="line">          &#x2F; \                                        running cmd21, so we build a new image here</span><br><span class="line">         &#x2F;   \</span><br><span class="line">RUN cmd11     RUN cmd12</span><br><span class="line">+-------+     +-------+</span><br><span class="line">|image11|     |image12|</span><br><span class="line">+-------+     +-------+</span><br></pre></td></tr></table></figure>

<p>大部分指令可以根据上述逻辑去寻找缓存，除了 ADD 和 COPY 。这两个指令会复制文件内容到镜像内，除了指令相同以外，Docker 还会检查每个文件内容校验(不包括最后修改时间和最后访问时间)，如果校验不一致，则不会使用缓存。</p>
<p>除了这两个命令，Docker 并不会去检查容器内的文件内容，比如 <code>RUN apt-get -y update</code>，每次执行时文件可能都不一样，但是 Docker 认为命令一致，会继续使用缓存。这样一来，以后构建时都不会再重新运行<code>apt-get -y update</code>。</p>
<p>如果 Docker 没有找到当前指令的缓存，则会构建一个新的镜像，并且之后的所有指令都不会再去寻找缓存。</p>
<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>接下来用一个简单的示例来感受一下 Dockerfile 是如何用来构建镜像启动容器。我们以定制 nginx 镜像为例，在一个空白目录中，建立一个文本文件，并命名为 Dockerfile：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir mynginx</span><br><span class="line">cd mynginx</span><br><span class="line">vi Dockerfile</span><br></pre></td></tr></table></figure>

<p>构建一个 Dockerfile 文件内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br><span class="line">vi Dockerfile</span><br></pre></td></tr></table></figure>

<p>这个 Dockerfile 很简单，一共就两行涉及到了两条指令：FROM 和 RUN，FROM 表示获取指定基础镜像，RUN 执行命令，在执行的过程中重写了 nginx 的默认页面信息，将信息替换为：Hello, Docker!。</p>
<p>在 Dockerfile 文件所在目录执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t nginx:v1 .</span><br></pre></td></tr></table></figure>

<p>命令最后有一个. 表示当前目录</p>
<p>构建完成之后，使用 <code>docker images</code> 命令查看所有镜像，如果存在 REPOSITORY 为 nginx 和 TAG 是 v1 的信息，就表示构建成功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line">REPOSITORY                      TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx                           v1                  8c92471de2cc        6 minutes ago       108.6 MB</span><br></pre></td></tr></table></figure>

<p>接下来使用 docker run 命令来启动容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run  --name docker_nginx_v1   -d -p 80:80 nginx:v1</span><br></pre></td></tr></table></figure>

<p>这条命令会用 nginx 镜像启动一个容器，命名为<code>docker_nginx_v1</code>，并且映射了 80 端口，这样我们可以用浏览器去访问这个 nginx 服务器：<code>http://192.168.0.54/</code>，页面返回信息：</p>
<p><img src="http://favorites.ren/assets/images/2018/docker/1.png" alt="img"></p>
<p>这样一个简单使用 Dockerfile 构建镜像，运行容器的示例就完成了！</p>
<h2 id="修改容器内容"><a href="#修改容器内容" class="headerlink" title="修改容器内容"></a>修改容器内容</h2><p>容器启动后，需要对容器内的文件进行进一步的完善，可以使用<code>docker exec -it xx bash</code>命令再次进行修改，以上面的示例为基础，修改 nginx 启动页面内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it docker_nginx_v1   bash</span><br><span class="line">root@3729b97e8226:&#x2F;# echo &#39;&lt;h1&gt;Hello, Docker neo!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br><span class="line">root@3729b97e8226:&#x2F;# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>以交互式终端方式进入 docker_nginx_v1 容器，并执行了 bash 命令，也就是获得一个可操作的 Shell。然后，我们用<code>&lt;h1&gt;Hello, Docker neo!&lt;/h1&gt;</code>覆盖了 <code>/usr/share/nginx/html/index.html</code> 的内容。</p>
<p>再次刷新浏览器，会发现内容被改变。</p>
<p><img src="http://favorites.ren/assets/images/2018/docker/2.png" alt="img"></p>
<p>修改了容器的文件，也就是改动了容器的存储层，可以通过 docker diff 命令看到具体的改动。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker diff docker_nginx_v1 </span><br><span class="line">... </span><br></pre></td></tr></table></figure>

<h2 id="Dockerfile-指令详解"><a href="#Dockerfile-指令详解" class="headerlink" title="Dockerfile 指令详解"></a>Dockerfile 指令详解</h2><h3 id="1-FROM-指定基础镜像"><a href="#1-FROM-指定基础镜像" class="headerlink" title="1 FROM 指定基础镜像"></a>1 FROM 指定基础镜像</h3><p>FROM 指令用于指定其后构建新镜像所使用的基础镜像。FROM 指令必是 Dockerfile 文件中的首条命令，启动构建流程后，Docker 将会基于该镜像构建新镜像，FROM 后的命令也会基于这个基础镜像。</p>
<p>FROM语法格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM &lt;image&gt;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM &lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM &lt;image&gt;:&lt;digest&gt;</span><br></pre></td></tr></table></figure>

<p>通过 FROM 指定的镜像，可以是任何有效的基础镜像。FROM 有以下限制：</p>
<ul>
<li>FROM 必须 是 Dockerfile 中第一条非注释命令</li>
<li>在一个 Dockerfile 文件中创建多个镜像时，FROM 可以多次出现。只需在每个新命令 FROM 之前，记录提交上次的镜像 ID。</li>
<li>tag 或 digest 是可选的，如果不使用这两个值时，会使用 latest 版本的基础镜像</li>
</ul>
<h3 id="2-RUN-执行命令"><a href="#2-RUN-执行命令" class="headerlink" title="2 RUN 执行命令"></a>2 RUN 执行命令</h3><p>在镜像的构建过程中执行特定的命令，并生成一个中间镜像。格式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#shell格式</span><br><span class="line">RUN &lt;command&gt;</span><br><span class="line">#exec格式</span><br><span class="line">RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</span><br></pre></td></tr></table></figure>

<ul>
<li>RUN 命令将在当前 image 中执行任意合法命令并提交执行结果。命令执行提交后，就会自动执行 Dockerfile 中的下一个指令。</li>
<li>层级 RUN 指令和生成提交是符合 Docker 核心理念的做法。它允许像版本控制那样，在任意一个点，对 image 镜像进行定制化构建。</li>
<li>RUN 指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定 <code>--no-cache</code> 参数，如：<code>docker build --no-cache</code>。</li>
</ul>
<h3 id="3-COPY-复制文件"><a href="#3-COPY-复制文件" class="headerlink" title="3 COPY 复制文件"></a>3 COPY 复制文件</h3><p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY &lt;源路径&gt;... &lt;目标路径&gt;</span><br><span class="line">COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</span><br></pre></td></tr></table></figure>

<p>和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的<code>&lt;目标路径&gt;</code>位置。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY package.json &#x2F;usr&#x2F;src&#x2F;app&#x2F;</span><br></pre></td></tr></table></figure>

<p><code>&lt;源路径&gt;</code>可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY hom* &#x2F;mydir&#x2F;</span><br><span class="line">COPY hom?.txt &#x2F;mydir&#x2F;</span><br></pre></td></tr></table></figure>

<p><code>&lt;目标路径&gt;</code>可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p>
<h3 id="4-ADD-更高级的复制文件"><a href="#4-ADD-更高级的复制文件" class="headerlink" title="4 ADD 更高级的复制文件"></a>4 ADD 更高级的复制文件</h3><p>ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。比如<code>&lt;源路径&gt;</code>可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到<code>&lt;目标路径&gt;</code>去。</p>
<p>在构建镜像时，复制上下文中的文件到镜像内，格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADD &lt;源路径&gt;... &lt;目标路径&gt;</span><br><span class="line">ADD [&quot;&lt;源路径&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong><br>如果 docker 发现文件内容被改变，则接下来的指令都不会再使用缓存。关于复制文件时需要处理的/，基本跟正常的 copy 一致</p>
<h3 id="5-ENV-设置环境变量"><a href="#5-ENV-设置环境变量" class="headerlink" title="5 ENV 设置环境变量"></a>5 ENV 设置环境变量</h3><p>格式有两种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key1&gt;&#x3D;&lt;value1&gt; &lt;key2&gt;&#x3D;&lt;value2&gt;...</span><br></pre></td></tr></table></figure>

<p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV VERSION&#x3D;1.0 DEBUG&#x3D;on \</span><br><span class="line">    NAME&#x3D;&quot;Happy Feet&quot;</span><br></pre></td></tr></table></figure>

<p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p>
<h3 id="6-EXPOSE"><a href="#6-EXPOSE" class="headerlink" title="6 EXPOSE"></a>6 EXPOSE</h3><p>为构建的镜像设置监听端口，使容器在运行时监听。格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPOSE &lt;port&gt; [&lt;port&gt;...]</span><br></pre></td></tr></table></figure>

<p>EXPOSE 指令并不会让容器监听 host 的端口，如果需要，需要在 docker run 时使用 <code>-p</code>、<code>-P</code> 参数来发布容器端口到 host 的某个端口上。</p>
<h3 id="7-VOLUME-定义匿名卷"><a href="#7-VOLUME-定义匿名卷" class="headerlink" title="7 VOLUME 定义匿名卷"></a>7 VOLUME 定义匿名卷</h3><p>VOLUME用于创建挂载点，即向基于所构建镜像创始的容器添加卷：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VOLUME [&quot;&#x2F;data&quot;]</span><br></pre></td></tr></table></figure>

<p>一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：</p>
<ul>
<li>卷可以容器间共享和重用</li>
<li>容器并不一定要和其它容器共享卷</li>
<li>修改卷后会立即生效</li>
<li>对卷的修改不会对镜像产生影响</li>
<li>卷会一直存在，直到没有任何容器在使用它</li>
</ul>
<p>VOLUME 让我们可以将源代码、数据或其它内容添加到镜像中，而又不并提交到镜像中，并使我们可以多个容器间共享这些内容。</p>
<h3 id="8-WORKDIR-指定工作目录"><a href="#8-WORKDIR-指定工作目录" class="headerlink" title="8 WORKDIR 指定工作目录"></a>8 WORKDIR 指定工作目录</h3><p>WORKDIR用于在容器内设置一个工作目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WORKDIR &#x2F;path&#x2F;to&#x2F;workdir</span><br></pre></td></tr></table></figure>

<p>通过WORKDIR设置工作目录后，Dockerfile 中其后的命令 RUN、CMD、ENTRYPOINT、ADD、COPY 等命令都会在该目录下执行。 如，使用WORKDIR设置工作目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WORKDIR &#x2F;a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure>

<p>在以上示例中，pwd 最终将会在 <code>/a/b/c</code> 目录中执行。在使用 docker run 运行容器时，可以通过<code>-w</code>参数覆盖构建时所设置的工作目录。</p>
<h3 id="9-USER-指定当前用户"><a href="#9-USER-指定当前用户" class="headerlink" title="9 USER 指定当前用户"></a>9 USER 指定当前用户</h3><p>USER 用于指定运行镜像所使用的用户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USER daemon</span><br></pre></td></tr></table></figure>

<p>使用USER指定用户时，可以使用用户名、UID 或 GID，或是两者的组合。以下都是合法的指定试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USER user</span><br><span class="line">USER user:group</span><br><span class="line">USER uid</span><br><span class="line">USER uid:gid</span><br><span class="line">USER user:gid</span><br><span class="line">USER uid:group</span><br></pre></td></tr></table></figure>

<p>使用USER指定用户后，Dockerfile 中其后的命令 RUN、CMD、ENTRYPOINT 都将使用该用户。镜像构建完成后，通过 docker run 运行容器时，可以通过 <code>-u</code> 参数来覆盖所指定的用户。</p>
<h3 id="10-CMD"><a href="#10-CMD" class="headerlink" title="10 CMD"></a>10 CMD</h3><p>CMD用于指定在容器启动时所要执行的命令。CMD 有以下三种格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line">CMD [&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line">CMD command param1 param2</span><br></pre></td></tr></table></figure>

<p>省略可执行文件的 exec 格式，这种写法使 CMD 中的参数当做 ENTRYPOINT 的默认参数，此时 ENTRYPOINT 也应该是 exec 格式，具体与 ENTRYPOINT 的组合使用，参考 ENTRYPOINT。</p>
<p><strong>注意</strong><br>与 RUN 指令的区别：RUN 在构建的时候执行，并生成一个新的镜像，CMD 在容器运行的时候执行，在构建时不进行任何操作。</p>
<h4 id="常用CMD方式"><a href="#常用CMD方式" class="headerlink" title="常用CMD方式"></a>常用CMD方式</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 命令</span></span><br><span class="line">  tail -f /etc/hosts</span><br><span class="line"><span class="comment"># 2.服务守护进程</span></span><br><span class="line">  nginx -g <span class="string">&quot;daemon off;&quot;</span></span><br><span class="line">  catalina.sh run</span><br><span class="line"><span class="comment"># 3.脚本</span></span><br><span class="line">  命令1：catalina.sh start</span><br><span class="line">  命令2：<span class="built_in">echo</span> ”1.2.3.4 api.test.com &gt;&gt; /etc/hosts“</span><br><span class="line">  命令3：tail -f /etc/hosts</span><br></pre></td></tr></table></figure>





<h3 id="11-ENTRYPOINT"><a href="#11-ENTRYPOINT" class="headerlink" title="11 ENTRYPOINT"></a>11 ENTRYPOINT</h3><p>ENTRYPOINT 用于给容器配置一个可执行程序。也就是说，每次使用镜像创建容器时，通过 ENTRYPOINT 指定的程序都会被设置为默认程序。ENTRYPOINT 有以下两种形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</span><br><span class="line">ENTRYPOINT command param1 param2</span><br></pre></td></tr></table></figure>

<p>ENTRYPOINT 与 CMD 非常类似，不同的是通过<code>docker run</code>执行的命令不会覆盖 ENTRYPOINT，而<code>docker run</code>命令中指定的任何参数，都会被当做参数再次传递给 ENTRYPOINT。Dockerfile 中只允许有一个 ENTRYPOINT 命令，多指定时会覆盖前面的设置，而只执行最后的 ENTRYPOINT 指令。</p>
<p><code>docker run</code>运行容器时指定的参数都会被传递给 ENTRYPOINT ，且会覆盖 CMD 命令指定的参数。如，执行<code>docker run &lt;image&gt; -d</code>时，-d 参数将被传递给入口点。</p>
<p>也可以通过<code>docker run --entrypoint</code>重写 ENTRYPOINT 入口点。如：可以像下面这样指定一个容器执行程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENTRYPOINT [&quot;&#x2F;usr&#x2F;bin&#x2F;nginx&quot;]</span><br></pre></td></tr></table></figure>

<p>完整构建代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Version: 0.0.3</span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line">MAINTAINER 何民三 &quot;cn.liuht@gmail.com&quot;</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y nginx</span><br><span class="line">RUN echo &#39;Hello World, 我是个容器&#39; \ </span><br><span class="line">   &gt; &#x2F;var&#x2F;www&#x2F;html&#x2F;index.html</span><br><span class="line">ENTRYPOINT [&quot;&#x2F;usr&#x2F;sbin&#x2F;nginx&quot;]</span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure>

<p>使用docker build构建镜像，并将镜像指定为 itbilu/test：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t&#x3D;&quot;itbilu&#x2F;test&quot; .</span><br></pre></td></tr></table></figure>

<p>构建完成后，使用itbilu/test启动一个容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -i -t  itbilu&#x2F;test -g &quot;daemon off;&quot;</span><br></pre></td></tr></table></figure>

<p>在运行容器时，我们使用了 <code>-g &quot;daemon off;&quot;</code>，这个参数将会被传递给 ENTRYPOINT，最终在容器中执行的命令为 <code>/usr/sbin/nginx -g &quot;daemon off;&quot;</code>。</p>
<h4 id="如果同时存在ENTRYPOINT和CMD"><a href="#如果同时存在ENTRYPOINT和CMD" class="headerlink" title="如果同时存在ENTRYPOINT和CMD"></a>如果同时存在ENTRYPOINT和CMD</h4><blockquote>
<p>CMD 会当成参数传给ENTRYPOINT</p>
</blockquote>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7.9</span>.<span class="number">2009</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">&quot;WaylonYan&quot;</span></span></span><br><span class="line"><span class="keyword">ENV</span> HOST=<span class="number">172.31</span>.<span class="number">6.100</span></span><br><span class="line"><span class="keyword">ENV</span> PASSWORD=<span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> <span class="keyword">USER</span>=<span class="string">&quot;Waylon&quot;</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /opt</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> docker-entrypoint.sh /root/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> nginx.conf /apps/nginx/conf/nginx.conf</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /data/nginx/html</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> static.tar /data/nginx/html</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">443</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;/apps/nginx/sbin/nginx&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;-g&quot;</span>,<span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>Docker-entrypoint.sh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">/apps/nginx/sbin/nginx <span class="variable">$1</span> <span class="variable">$2</span></span><br></pre></td></tr></table></figure>



<h3 id="12-LABEL"><a href="#12-LABEL" class="headerlink" title="12 LABEL"></a>12 LABEL</h3><p>LABEL用于为镜像添加元数据，元数以键值对的形式指定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LABEL &lt;key&gt;&#x3D;&lt;value&gt; &lt;key&gt;&#x3D;&lt;value&gt; &lt;key&gt;&#x3D;&lt;value&gt; ...</span><br></pre></td></tr></table></figure>

<p>使用LABEL指定元数据时，一条LABEL指定可以指定一或多条元数据，指定多条元数据时不同元数据之间通过空格分隔。推荐将所有的元数据通过一条LABEL指令指定，以免生成过多的中间镜像。 如，通过LABEL指定一些元数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LABEL version&#x3D;&quot;1.0&quot; description&#x3D;&quot;这是一个Web服务器&quot; by&#x3D;&quot;IT笔录&quot;</span><br></pre></td></tr></table></figure>

<p>指定后可以通过docker inspect查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect itbilu&#x2F;test</span><br><span class="line">&quot;Labels&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;1.0&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;这是一个Web服务器&quot;,</span><br><span class="line">    &quot;by&quot;: &quot;IT笔录&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="13-ARG"><a href="#13-ARG" class="headerlink" title="13 ARG"></a>13 ARG</h3><p>ARG用于指定传递给构建运行时的变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ARG &lt;name&gt;[&#x3D;&lt;default value&gt;]</span><br></pre></td></tr></table></figure>

<p>如，通过ARG指定两个变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ARG site</span><br><span class="line">ARG build_user&#x3D;IT笔录</span><br></pre></td></tr></table></figure>

<p>以上我们指定了 site 和 build_user 两个变量，其中 build_user 指定了默认值。在使用 docker build 构建镜像时，可以通过 <code>--build-arg &lt;varname&gt;=&lt;value&gt;</code> 参数来指定或重设置这些变量的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build --build-arg site&#x3D;itiblu.com -t itbilu&#x2F;test .</span><br></pre></td></tr></table></figure>

<p>这样我们构建了 itbilu/test 镜像，其中site会被设置为 itbilu.com，由于没有指定 build_user，其值将是默认值 IT 笔录。</p>
<h3 id="14-ONBUILD"><a href="#14-ONBUILD" class="headerlink" title="14 ONBUILD"></a>14 ONBUILD</h3><p>ONBUILD用于设置镜像触发器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ONBUILD [INSTRUCTION]</span><br></pre></td></tr></table></figure>

<p>当所构建的镜像被用做其它镜像的基础镜像，该镜像中的触发器将会被钥触发。 如，当镜像被使用时，可能需要做一些处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[...]</span><br><span class="line">ONBUILD ADD . &#x2F;app&#x2F;src</span><br><span class="line">ONBUILD RUN &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python-build --dir &#x2F;app&#x2F;src</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<h3 id="15-STOPSIGNAL"><a href="#15-STOPSIGNAL" class="headerlink" title="15 STOPSIGNAL"></a>15 STOPSIGNAL</h3><p>STOPSIGNAL用于设置停止容器所要发送的系统调用信号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STOPSIGNAL signal</span><br></pre></td></tr></table></figure>

<p>所使用的信号必须是内核系统调用表中的合法的值，如：SIGKILL。</p>
<h3 id="16-SHELL"><a href="#16-SHELL" class="headerlink" title="16 SHELL"></a>16 SHELL</h3><p>SHELL用于设置执行命令（shell式）所使用的的默认 shell 类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHELL [&quot;executable&quot;, &quot;parameters&quot;]</span><br></pre></td></tr></table></figure>

<p>SHELL在Windows环境下比较有用，Windows 下通常会有 cmd 和 powershell 两种 shell，可能还会有 sh。这时就可以通过 SHELL 来指定所使用的 shell 类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM microsoft&#x2F;windowsservercore</span><br><span class="line"></span><br><span class="line"># Executed as cmd &#x2F;S &#x2F;C echo default</span><br><span class="line">RUN echo default</span><br><span class="line"></span><br><span class="line"># Executed as cmd &#x2F;S &#x2F;C powershell -command Write-Host default</span><br><span class="line">RUN powershell -command Write-Host default</span><br><span class="line"></span><br><span class="line"># Executed as powershell -command Write-Host hello</span><br><span class="line">SHELL [&quot;powershell&quot;, &quot;-command&quot;]</span><br><span class="line">RUN Write-Host hello</span><br><span class="line"></span><br><span class="line"># Executed as cmd &#x2F;S &#x2F;C echo hello</span><br><span class="line">SHELL [&quot;cmd&quot;, &quot;&#x2F;S&quot;&quot;, &quot;&#x2F;C&quot;]</span><br><span class="line">RUN echo hello</span><br></pre></td></tr></table></figure>

<h2 id="Dockerfile-使用经验"><a href="#Dockerfile-使用经验" class="headerlink" title="Dockerfile 使用经验"></a>Dockerfile 使用经验</h2><h3 id="Dockerfile-示例"><a href="#Dockerfile-示例" class="headerlink" title="Dockerfile 示例"></a>Dockerfile 示例</h3><p><strong>构建Nginx运行环境</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 指定基础镜像</span><br><span class="line">FROM sameersbn&#x2F;ubuntu:14.04.20161014</span><br><span class="line"></span><br><span class="line"># 维护者信息</span><br><span class="line">MAINTAINER sameer@damagehead.com</span><br><span class="line"></span><br><span class="line"># 设置环境</span><br><span class="line">ENV RTMP_VERSION&#x3D;1.1.10 \</span><br><span class="line">    NPS_VERSION&#x3D;1.11.33.4 \</span><br><span class="line">    LIBAV_VERSION&#x3D;11.8 \</span><br><span class="line">    NGINX_VERSION&#x3D;1.10.1 \</span><br><span class="line">    NGINX_USER&#x3D;www-data \</span><br><span class="line">    NGINX_SITECONF_DIR&#x3D;&#x2F;etc&#x2F;nginx&#x2F;sites-enabled \</span><br><span class="line">    NGINX_LOG_DIR&#x3D;&#x2F;var&#x2F;log&#x2F;nginx \</span><br><span class="line">    NGINX_TEMP_DIR&#x3D;&#x2F;var&#x2F;lib&#x2F;nginx \</span><br><span class="line">    NGINX_SETUP_DIR&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx</span><br><span class="line"></span><br><span class="line"># 设置构建时变量，镜像建立完成后就失效</span><br><span class="line">ARG BUILD_LIBAV&#x3D;false</span><br><span class="line">ARG WITH_DEBUG&#x3D;false</span><br><span class="line">ARG WITH_PAGESPEED&#x3D;true</span><br><span class="line">ARG WITH_RTMP&#x3D;true</span><br><span class="line"></span><br><span class="line"># 复制本地文件到容器目录中</span><br><span class="line">COPY setup&#x2F; $&#123;NGINX_SETUP_DIR&#125;&#x2F;</span><br><span class="line">RUN bash $&#123;NGINX_SETUP_DIR&#125;&#x2F;install.sh</span><br><span class="line"></span><br><span class="line"># 复制本地配置文件到容器目录中</span><br><span class="line">COPY nginx.conf &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">COPY entrypoint.sh &#x2F;sbin&#x2F;entrypoint.sh</span><br><span class="line"></span><br><span class="line"># 运行指令</span><br><span class="line">RUN chmod 755 &#x2F;sbin&#x2F;entrypoint.sh</span><br><span class="line"></span><br><span class="line"># 允许指定的端口</span><br><span class="line">EXPOSE 80&#x2F;tcp 443&#x2F;tcp 1935&#x2F;tcp</span><br><span class="line"></span><br><span class="line"># 指定网站目录挂载点</span><br><span class="line">VOLUME [&quot;$&#123;NGINX_SITECONF_DIR&#125;&quot;]</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;&#x2F;sbin&#x2F;entrypoint.sh&quot;]</span><br><span class="line">CMD [&quot;&#x2F;usr&#x2F;sbin&#x2F;nginx&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>构建tomcat 环境</strong></p>
<p>Dockerfile文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定基于的基础镜像</span></span><br><span class="line">FROM ubuntu:13.10  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line">MAINTAINER zhangjiayang <span class="string">&quot;zhangjiayang@sczq.com.cn&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 镜像的指令操作</span></span><br><span class="line"><span class="comment"># 获取APT更新的资源列表</span></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&quot;deb http://archive.ubuntu.com/ubuntu precise main universe&quot;</span>&gt; /etc/apt/sources.list</span><br><span class="line"><span class="comment"># 更新软件</span></span><br><span class="line">RUN apt-get update  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Install curl  </span></span><br><span class="line">RUN apt-get -y install curl  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Install JDK 7  </span></span><br><span class="line">RUN <span class="built_in">cd</span> /tmp &amp;&amp;  curl -L <span class="string">&#x27;http://download.oracle.com/otn-pub/java/jdk/7u65-b17/jdk-7u65-linux-x64.tar.gz&#x27;</span> -H <span class="string">&#x27;Cookie: oraclelicense=accept-securebackup-cookie; gpw_e24=Dockerfile&#x27;</span> | tar -xz  </span><br><span class="line">RUN mkdir -p /usr/lib/jvm  </span><br><span class="line">RUN mv /tmp/jdk1.7.0_65/ /usr/lib/jvm/java-7-oracle/  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Set Oracle JDK 7 as default Java  </span></span><br><span class="line">RUN update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-7-oracle/bin/java 300     </span><br><span class="line">RUN update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java-7-oracle/bin/javac 300     </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置系统环境</span></span><br><span class="line">ENV JAVA_HOME /usr/lib/jvm/java-7-oracle/  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Install tomcat7  </span></span><br><span class="line">RUN <span class="built_in">cd</span> /tmp &amp;&amp; curl -L <span class="string">&#x27;http://archive.apache.org/dist/tomcat/tomcat-7/v7.0.8/bin/apache-tomcat-7.0.8.tar.gz&#x27;</span> | tar -xz  </span><br><span class="line">RUN mv /tmp/apache-tomcat-7.0.8/ /opt/tomcat7/  </span><br><span class="line">  </span><br><span class="line">ENV CATALINA_HOME /opt/tomcat7  </span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:<span class="variable">$CATALINA_HOME</span>/bin  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 复件tomcat7.sh到容器中的目录 </span></span><br><span class="line">ADD tomcat7.sh /etc/init.d/tomcat7  </span><br><span class="line">RUN chmod 755 /etc/init.d/tomcat7  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Expose ports.  指定暴露的端口</span></span><br><span class="line">EXPOSE 8080  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Define default command.  </span></span><br><span class="line">ENTRYPOINT service tomcat7 start &amp;&amp; tail -f /opt/tomcat7/logs/catalina.out</span><br></pre></td></tr></table></figure>

<p><code>tomcat7.sh</code>命令文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-7-oracle/  </span><br><span class="line"><span class="built_in">export</span> TOMCAT_HOME=/opt/tomcat7  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span>  </span><br><span class="line">start)  </span><br><span class="line">  sh <span class="variable">$TOMCAT_HOME</span>/bin/startup.sh  </span><br><span class="line">;;  </span><br><span class="line">stop)  </span><br><span class="line">  sh <span class="variable">$TOMCAT_HOME</span>/bin/shutdown.sh  </span><br><span class="line">;;  </span><br><span class="line">restart)  </span><br><span class="line">  sh <span class="variable">$TOMCAT_HOME</span>/bin/shutdown.sh  </span><br><span class="line">  sh <span class="variable">$TOMCAT_HOME</span>/bin/startup.sh  </span><br><span class="line">;;  </span><br><span class="line"><span class="keyword">esac</span>  </span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<h3 id="Alpine-构建Nginx"><a href="#Alpine-构建Nginx" class="headerlink" title="Alpine 构建Nginx"></a>Alpine 构建Nginx</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">maintainer</span> zhangshijie <span class="string">&quot;2973707860@qq.com&quot;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> repositories /etc/apk/repositories</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk update &amp;&amp; apk add iotop gcc libgcc libc-dev libcurl libc-utils pcre-dev zlib-dev libnfs make pcre pcre2 zip unzip net-tools pstree wget libevent libevent-dev iproute2</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> nginx-1.16.1.tar.gz /opt/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /opt/nginx-1.16.1 &amp;&amp; ./configure --prefix=/apps/nginx &amp;&amp; make &amp;&amp; make install &amp;&amp; ln -sv /apps/nginx/sbin/nginx /usr/bin/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> addgroup -g 2019 -S nginx &amp;&amp; adduser -s /sbin/nologin -S -D -u 2019 -G nginx nginx</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> nginx.conf /apps/nginx/conf/nginx.conf</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> static.tar.gz /data/nginx/html</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chown nginx.nginx /data/nginx/ /apps/nginx/ -R</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span> <span class="number">443</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;nginx&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># error_log  /var/log/nginx/error.log warn; </span></span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;    </span><br><span class="line"><span class="attribute">daemon</span> <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;                         </span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;                                                  </span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># access_log  /var/log/nginx/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   /data/nginx/html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># include /etc/nginx/conf.d/*.conf;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构建镜像小脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">TAG=<span class="variable">$1</span></span><br><span class="line">docker build -t harbor.magedu.com/n56/nginx-alpine:<span class="variable">$TAG</span> .</span><br></pre></td></tr></table></figure>

<p>repositories</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://mirrors.tuna.tsinghua.edu.cn/alpine/v3.14/main</span><br><span class="line">https://mirrors.tuna.tsinghua.edu.cn/alpine/v3.14/community</span><br></pre></td></tr></table></figure>





<h3 id="原则与建议"><a href="#原则与建议" class="headerlink" title="原则与建议"></a>原则与建议</h3><ul>
<li>容器轻量化。从镜像中产生的容器应该尽量轻量化，能在足够短的时间内停止、销毁、重新生成并替换原来的容器。</li>
<li>使用 <code>.gitignore</code>。在大部分情况下，Dockerfile 会和构建所需的文件放在同一个目录中，为了提高构建的性能，应该使用 <code>.gitignore</code> 来过滤掉不需要的文件和目录。</li>
<li>为了减少镜像的大小，减少依赖，仅安装需要的软件包。</li>
<li>一个容器只做一件事。解耦复杂的应用，分成多个容器，而不是所有东西都放在一个容器内运行。如一个 Python Web 应用，可能需要 Server、DB、Cache、MQ、Log 等几个容器。一个更加极端的说法：One process per container。</li>
<li>减少镜像的图层。不要多个 Label、ENV 等标签。</li>
<li>对续行的参数按照字母表排序，特别是使用<code>apt-get install -y</code>安装包的时候。</li>
<li>使用构建缓存。如果不想使用缓存，可以在构建的时候使用参数<code>--no-cache=true</code>来强制重新生成中间镜像。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Go-02-基础入门</title>
    <url>/posts/52365.html</url>
    <content><![CDATA[<p>Go基础入门</p>
<a id="more"></a>



<h2 id="1-输出"><a href="#1-输出" class="headerlink" title="1. 输出"></a>1. 输出</h2><p>输出，在运行代码时将内容在终端输出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;叫爸爸&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上一节的代码中使用了<code>fmt.Println</code>方法进行了输出。</p>
<p>在Go中提供了多种输出的方式，接下来我们就来详细聊聊。</p>
<h3 id="1-1-内置函数"><a href="#1-1-内置函数" class="headerlink" title="1.1 内置函数"></a>1.1 内置函数</h3><p>在Go的内置函数中提供了 <code>Print</code> 和 <code>Println</code>两个函数用于做输出。</p>
<ul>
<li>print，输出</li>
<li>println，输出并在最后位置添加换行符</li>
</ul>
<p>示例1：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;好吃不过饺子&quot;</span>)    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;好玩不过嫂子&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt; 最终输出：好吃不过饺子好玩不过嫂子</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;好吃不过饺子&quot;</span>)    </span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;好玩不过嫂子&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt;最终输出：好吃不过饺子好玩不过嫂子</span><br></pre></td></tr></table></figure>

<p>上述函数虽然可以实现输出的功能，但在实际开发中不建议使用，原因有两点：1.官方不保证会一直在Go中保留此功能，在之后的版本可能会被移除；2.这两个函数是用于做标准错误输出而非标准输出。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; The print built-in function formats its arguments in an</span><br><span class="line">&#x2F;&#x2F; implementation-specific way and writes the result to standard error.</span><br><span class="line">&#x2F;&#x2F; Print is useful for bootstrapping and debugging; it is not guaranteed</span><br><span class="line">&#x2F;&#x2F; to stay in the language.</span><br><span class="line">func print(args ...Type)</span><br><span class="line">&#x2F;&#x2F; The println built-in function formats its arguments in an</span><br><span class="line">&#x2F;&#x2F; implementation-specific way and writes the result to standard error.</span><br><span class="line">&#x2F;&#x2F; Spaces are always added between arguments and a newline is appended.</span><br><span class="line">&#x2F;&#x2F; Println is useful for bootstrapping and debugging; it is not guaranteed</span><br><span class="line">&#x2F;&#x2F; to stay in the language.</span><br><span class="line">func println(args ...Type)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>扩展：关于标准错误和标准输出，每个进程都各有一个 stdin，stdout 和 stderr 文件描述符。使用的标准方法是 stdout 作为进程输出，stderr 作为进程错误输出。</p>
<h3 id="1-2-fmt标准库（推荐）"><a href="#1-2-fmt标准库（推荐）" class="headerlink" title="1.2 fmt标准库（推荐）"></a>1.2 fmt标准库（推荐）</h3><p><a href="https://www.choudalao.com/article/185">https://www.choudalao.com/article/185</a></p>
<p>fmt是Go标准库中提供了用于进行输入、输出的模块（本节只聊输出，后面章节会讲解输入相关）。</p>
<p>fmt模块中常见的输出相关函数有：</p>
<ul>
<li><code>fmt.Print</code>，输出。</li>
<li><code>fmt.Println</code>，输出并在末尾添加换行符。</li>
<li><code>fmt.Printf</code>，格式化的输出，第一个参数是含占位符的字符串，后续参数则用于格式化字符串。</li>
</ul>
<p><strong>示例1：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Print(<span class="string">&quot;南通州北通州&quot;</span>)</span><br><span class="line">    fmt.Print(<span class="string">&quot;南北通州通南北&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt; 输出：</span><br><span class="line">南通州北通州南北通州通南北</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;男学生女学生&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;男女学生生男女&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt; 输出：</span><br><span class="line">男学生女学生</span><br><span class="line">男女学生生男女</span><br></pre></td></tr></table></figure>

<p><strong>示例3：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// %s，占位符用于格式化字符串</span></span><br><span class="line">      <span class="comment">// %d，占位符用于格式化整型(十进制)</span></span><br><span class="line">       %+d 表示对正整数带+符号</span><br><span class="line">             %nd 表示最小占位 n 个宽度且右对齐</span><br><span class="line">             %-nd 表示最小占位 n 个宽度且左对齐</span><br><span class="line">             %<span class="number">0</span>nd 表示最小占位 n 个宽度且右对齐，空字符使用 <span class="number">0</span> 填充             </span><br><span class="line">    <span class="comment">// %f，十进制小数</span></span><br><span class="line">    <span class="comment">// %.2f，保留小数点后两位（四舍五入）</span></span><br><span class="line">    <span class="comment">// %T  数据类型</span></span><br><span class="line">    <span class="comment">// %#v  占位符 优雅方式打印数值</span></span><br><span class="line">    <span class="comment">// %b  占位符打印二进制</span></span><br><span class="line">    <span class="comment">//  // 浮点数与复数</span></span><br><span class="line">        %b 无小数部分、二进制指数的科学计数法，如<span class="number">-123456</span>p<span class="number">-78</span>；  </span><br><span class="line">    <span class="comment">// %o  占位符打印十进制</span></span><br><span class="line">    <span class="comment">// %x  占位符打印16进制</span></span><br><span class="line">    <span class="comment">// %U  占位符打印Unicode码点</span></span><br><span class="line">    <span class="comment">// %c  占位符打印byte字节类型字符</span></span><br><span class="line">    <span class="comment">// %q  带单引号的字符</span></span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">&quot;老汉开着%s，去接alex这个%d货。\n&quot;</span>, <span class="string">&quot;兰博基尼&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;您的账户余额为：%f，仅保留小数点后两位的话为：%.2f&quot;</span>, <span class="number">1999.213</span>, <span class="number">1999.216</span>)</span><br><span class="line">      fmt.Printf(<span class="string">&quot;%d %b %o %x %U %c %c&quot;</span>, achar, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="string">&#x27;中&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">65</span>)</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt; 输出：</span><br><span class="line">老汉开着兰博基尼，去接alex这个<span class="number">2</span>货。</span><br><span class="line"><span class="number">97</span> <span class="number">1111</span> <span class="number">17</span> f  U+<span class="number">4E2</span>D a A</span><br></pre></td></tr></table></figure>

<p>格式化字符串的占位符有很多，现在没必要全部记住，目前仅需了解上述三个占位符即可。</p>
<p>更多占位符和文档说明可在Go源码 <code>Go编译器安装目录/src/fmt/doc.go</code> 中查看：</p>
<blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">General:</span><br><span class="line">  %v the value in a <span class="keyword">default</span> format</span><br><span class="line">     when printing structs, the plus flag (%+v) adds field names</span><br><span class="line">  %#v    a Go-syntax representation of the value</span><br><span class="line">  %T a Go-syntax representation of the <span class="keyword">type</span> of the value</span><br><span class="line">  %% a literal percent sign; consumes no value</span><br><span class="line">Boolean:</span><br><span class="line">  %t the word <span class="literal">true</span> or <span class="literal">false</span></span><br><span class="line">Integer:</span><br><span class="line">  %b base <span class="number">2</span></span><br><span class="line">  %c the character represented by the corresponding Unicode code point</span><br><span class="line">  %d base <span class="number">10</span></span><br><span class="line">  %o base <span class="number">8</span></span><br><span class="line">  %O base <span class="number">8</span> with <span class="number">0</span>o prefix</span><br><span class="line">  %q a single-quoted character literal safely escaped with Go syntax.</span><br><span class="line">  %x base <span class="number">16</span>, with lower-<span class="keyword">case</span> letters <span class="keyword">for</span> a-f</span><br><span class="line">  %X base <span class="number">16</span>, with upper-<span class="keyword">case</span> letters <span class="keyword">for</span> A-F</span><br><span class="line">  %U Unicode format: U+<span class="number">1234</span>; same as <span class="string">&quot;U+%04X&quot;</span></span><br><span class="line">Floating-point and <span class="built_in">complex</span> constituents:</span><br><span class="line">  %b decimalless scientific notation with exponent a power of two,</span><br><span class="line">     in the manner of strconv.FormatFloat with the <span class="string">&#x27;b&#x27;</span> format,</span><br><span class="line">     e.g. <span class="number">-123456</span>p<span class="number">-78</span></span><br><span class="line">  %e scientific notation, e.g. <span class="number">-1.234456e+78</span></span><br><span class="line">  %E scientific notation, e.g. <span class="number">-1.234456E+78</span></span><br><span class="line">  %f decimal point but no exponent, e.g. <span class="number">123.456</span></span><br><span class="line">  %F synonym <span class="keyword">for</span> %f</span><br><span class="line">  %g %e <span class="keyword">for</span> large exponents, %f otherwise. Precision is discussed below.</span><br><span class="line">  %G %E <span class="keyword">for</span> large exponents, %F otherwise</span><br><span class="line">  %x hexadecimal notation (with decimal power of two exponent), e.g. <span class="number">-0x1</span><span class="number">.23</span>abcp+<span class="number">20</span></span><br><span class="line">  %X upper-<span class="keyword">case</span> hexadecimal notation, e.g. <span class="number">-0X1</span><span class="number">.23</span>ABCP+<span class="number">20</span></span><br><span class="line">String and slice of bytes (treated equivalently with these verbs):</span><br><span class="line">  %s the uninterpreted bytes of the <span class="keyword">string</span> or slice</span><br><span class="line">  %q a double-quoted <span class="keyword">string</span> safely escaped with Go syntax</span><br><span class="line">  %x base <span class="number">16</span>, lower-<span class="keyword">case</span>, two characters per <span class="keyword">byte</span></span><br><span class="line">  %X base <span class="number">16</span>, upper-<span class="keyword">case</span>, two characters per <span class="keyword">byte</span></span><br><span class="line">Slice:</span><br><span class="line">  %p address of <span class="number">0</span>th element in base <span class="number">16</span> notation, with leading <span class="number">0</span>x</span><br><span class="line">Pointer:</span><br><span class="line">  %p base <span class="number">16</span> notation, with leading <span class="number">0</span>x</span><br><span class="line">  The %b, %d, %o, %x and %X verbs also work with pointers,</span><br><span class="line">  formatting the value exactly as <span class="keyword">if</span> it were an integer.</span><br><span class="line">The <span class="keyword">default</span> format <span class="keyword">for</span> %v is:</span><br><span class="line">  <span class="keyword">bool</span>:                    %t</span><br><span class="line">  <span class="keyword">int</span>, <span class="keyword">int8</span> etc.:          %d</span><br><span class="line">  <span class="keyword">uint</span>, <span class="keyword">uint8</span> etc.:        %d, %#x <span class="keyword">if</span> printed with %#v</span><br><span class="line">  <span class="keyword">float32</span>, <span class="keyword">complex64</span>, etc: %g</span><br><span class="line">  <span class="keyword">string</span>:                  %s</span><br><span class="line">  <span class="keyword">chan</span>:                    %p</span><br><span class="line">  pointer:                 %p</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="2-注释"><a href="#2-注释" class="headerlink" title="2.注释"></a>2.注释</h2><ul>
<li>单行注释， <code>//</code></li>
<li>多行注释， <code>/* */</code></li>
</ul>
<p>快捷键：选中代码 然后点击键盘的 【contrl + ?】</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 单行注释</span></span><br><span class="line">    <span class="comment">/*  多行注释</span></span><br><span class="line"><span class="comment">    fmt.Println(666)</span></span><br><span class="line"><span class="comment">    fmt.Println(6 + 9)</span></span><br><span class="line"><span class="comment">    fmt.Println(6 - 9)</span></span><br><span class="line"><span class="comment">    fmt.Println(6 * 9)</span></span><br><span class="line"><span class="comment">    fmt.Println(16 / 9) // 商</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    fmt.Println(<span class="number">16</span> % <span class="number">9</span>) <span class="comment">// 余数</span></span><br></pre></td></tr></table></figure>

<h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3. 变量"></a>3. 变量</h2><p>变量，其实就相当于给某个值设置一个<code>昵称</code>，此<code>昵称</code>代指当前值。</p>
<p>在Go中变量声明的基本格式为：<code>var 变量名 类型 = 值</code> ，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个字符串类型的变量name，值为 &quot;武沛齐&quot;</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">&quot;武沛齐&quot;</span></span><br><span class="line"><span class="comment">// 声明一个整型类型的变量age，值为 18</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span> = <span class="number">18</span></span><br></pre></td></tr></table></figure>

<h3 id="3-1-变量简写"><a href="#3-1-变量简写" class="headerlink" title="3.1 变量简写"></a>3.1 变量简写</h3><p>为了能让变量的声明更方便，Go还提供了一些声明变量的简化方式。</p>
<ul>
<li><p>省略类型，格式为：<code>var 变量名 = 值</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;武沛齐&quot;</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line"><span class="comment">// 在给变量赋值时已知值的类型，所以Go编译器自动可以自动检测到类型，故可简化编写。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>省略var关键字，格式为：<code>变量名 := 值</code> （推荐）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">name := <span class="string">&quot;武沛齐&quot;</span></span><br><span class="line">age := <span class="number">18</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>上述两种简化编写的方式必须是直接赋值操作，即：直接将值赋值给变量，否则无法简化。例如：先声明再赋值时候就不能使用简化方式编写了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明变量</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="comment">// 给变量赋值</span></span><br><span class="line">name = <span class="string">&quot;武沛齐&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意：如果变量只声明不赋值，Go内部其实会给变量默认设置值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil 。</p>
<h3 id="3-2-变量名要求"><a href="#3-2-变量名要求" class="headerlink" title="3.2 变量名要求"></a>3.2 变量名要求</h3><p>对于变量名有以下要求和建议：</p>
<ul>
<li><p>要求（必须遵守，否则报错）</p>
<ul>
<li><p>变量名由字母、数字、下划线组成，且首个字符不能为数字。</p>
</li>
<li><p>不能使用Go内置的25个关键字</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">break</span>、default、func、interface、select、<span class="keyword">case</span>、defer、go、map、struct、chan、<span class="keyword">else</span>、goto、package、switch、const、fallthrough、<span class="keyword">if</span>、range、<span class="built_in">type</span>、<span class="built_in">continue</span>、<span class="keyword">for</span>、import、<span class="built_in">return</span>、var</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>建议</p>
<ul>
<li>变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：<code>numShips</code> 和 <code>startDate</code>。</li>
<li>见名知意，通过变量名就可以知道变量所代指的值，例如：<code>name</code>、<code>email</code>。</li>
</ul>
</li>
</ul>
<h3 id="3-3-全局和局部变量"><a href="#3-3-全局和局部变量" class="headerlink" title="3.3 全局和局部变量"></a>3.3 全局和局部变量</h3><p>根据变量所在位置不同，变量有全局和局部之分。</p>
<h4 id="3-3-1-全局变量"><a href="#3-3-1-全局变量" class="headerlink" title="3.3.1 全局变量"></a>3.3.1 全局变量</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// 声明全局变量</span></span><br><span class="line"><span class="keyword">var</span> country <span class="keyword">string</span> = <span class="string">&quot;中国&quot;</span> </span><br><span class="line"><span class="comment">// 或可使用 var country = &quot;中国&quot;</span></span><br><span class="line"><span class="comment">// 不可使用 country := &quot;中国&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(country)</span><br><span class="line">    country = <span class="string">&quot;China&quot;</span></span><br><span class="line">    fmt.Println(country)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别提醒：Go中的全局变量比较特殊，如果全局变量名首字母小写，则只能被当前包中的go文件使用，外部无法使用；如果首字母大写，则任意文件都使用全局变量。</p>
<p>可简单理解为：首字母大写表写公有，首字母小写表示私有（当前包的go文件所有）。</p>
<h4 id="3-3-2-局部变量"><a href="#3-3-2-局部变量" class="headerlink" title="3.3.2 局部变量"></a>3.3.2 局部变量</h4><p>Go中的变量有作用域之分，每个大括号就是一个作用域，每个作用域中都可定义相关的局部变量。</p>
<p><code>从下到上引用可以，从上不能引用下面 </code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 声明局部变量，在当前函数可用</span></span><br><span class="line">   <span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">&quot;武沛齐&quot;</span></span><br><span class="line">   fmt.Println(name)</span><br><span class="line">   <span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">      <span class="comment">//  生命局部变量，在当前if中可用</span></span><br><span class="line">      <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line">      fmt.Println(age)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 报错，age在if括号的作用域中</span></span><br><span class="line">   <span class="comment">// fmt.Println(age)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//  括号限定了变量的使用范围</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包级别</span></span><br><span class="line"><span class="keyword">var</span> packageVar <span class="keyword">string</span> = <span class="string">&quot;package var&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 函数级别变量</span></span><br><span class="line">    <span class="keyword">var</span> funcVar <span class="keyword">string</span> = <span class="string">&quot;func var&quot;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//    块级别</span></span><br><span class="line">        <span class="keyword">var</span> blockVar <span class="keyword">string</span> = <span class="string">&quot;block Var&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  括号限定了变量的使用范围</span></span><br><span class="line">            <span class="comment">//    子块级别</span></span><br><span class="line">            <span class="keyword">var</span> innerBlockVar <span class="keyword">string</span> = <span class="string">&quot;inner block var&quot;</span></span><br><span class="line">            fmt.Println(packageVar, funcVar, blockVar, innerBlockVar)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fmt.Println(packageVar, funcVar, blockVar, innerBlockVar)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(packageVar)</span><br><span class="line">    fmt.Println(funcVar)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="3-4-因式分解"><a href="#3-4-因式分解" class="headerlink" title="3.4 因式分解"></a>3.4 因式分解</h2><p>在定义多个变量时候，可以通过因式分解的方式进行简化代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">var name = &quot;武沛齐&quot;</span></span><br><span class="line"><span class="comment">var age = 18</span></span><br><span class="line"><span class="comment">var gender  string</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 在全局使用</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    name   = <span class="string">&quot;武沛齐&quot;</span></span><br><span class="line">    age    = <span class="number">18</span></span><br><span class="line">    gender <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(name)</span><br><span class="line">    fmt.Println(age)</span><br><span class="line">    gender = <span class="string">&quot;男&quot;</span></span><br><span class="line">    fmt.Println(gender)</span><br><span class="line">    <span class="comment">// 在局部使用</span></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        x1 = <span class="number">123</span></span><br><span class="line">        x2 = <span class="number">456</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(x1)</span><br><span class="line">    fmt.Println(x2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-常量"><a href="#4-常量" class="headerlink" title="4.常量"></a>4.常量</h2><p>不可被修改的变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义变量</span></span><br><span class="line">    <span class="comment">//var name string = &quot;武沛齐&quot;</span></span><br><span class="line">    <span class="comment">//var name = &quot;武沛齐&quot;</span></span><br><span class="line">    name := <span class="string">&quot;武沛齐&quot;</span></span><br><span class="line">    name = <span class="string">&quot;alex&quot;</span></span><br><span class="line">    fmt.Println(name)</span><br><span class="line">    <span class="comment">// 定义常量</span></span><br><span class="line">    <span class="comment">//const age int = 98</span></span><br><span class="line">    <span class="keyword">const</span> age = <span class="number">98</span></span><br><span class="line">    fmt.Println(age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-1-因式分解"><a href="#4-1-因式分解" class="headerlink" title="4.1 因式分解"></a>4.1 因式分解</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义变量</span></span><br><span class="line">    <span class="comment">//var name string = &quot;武沛齐&quot;</span></span><br><span class="line">    <span class="comment">//var name = &quot;武沛齐&quot;</span></span><br><span class="line">    name := <span class="string">&quot;武沛齐&quot;</span></span><br><span class="line">    name = <span class="string">&quot;alex&quot;</span></span><br><span class="line">    fmt.Println(name)</span><br><span class="line">    <span class="comment">// 定义常量</span></span><br><span class="line">    <span class="comment">//const age int = 98</span></span><br><span class="line">    <span class="keyword">const</span> age = <span class="number">98</span></span><br><span class="line">    fmt.Println(age)</span><br><span class="line">    <span class="comment">// 常量因式分解</span></span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">        v1 = <span class="number">123</span></span><br><span class="line">        v2 = <span class="number">456</span></span><br><span class="line">        pi = <span class="number">9.9</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(v1, v2, pi, gender)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-全局"><a href="#4-2-全局" class="headerlink" title="4.2 全局"></a>4.2 全局</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">const</span> Data = <span class="number">999</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    pi     = <span class="number">3.1415926</span></span><br><span class="line">    gender = <span class="string">&quot;男&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义变量</span></span><br><span class="line">    <span class="comment">//var name string = &quot;武沛齐&quot;</span></span><br><span class="line">    <span class="comment">//var name = &quot;武沛齐&quot;</span></span><br><span class="line">    name := <span class="string">&quot;武沛齐&quot;</span></span><br><span class="line">    name = <span class="string">&quot;alex&quot;</span></span><br><span class="line">    fmt.Println(name)</span><br><span class="line">    <span class="comment">// 定义常量</span></span><br><span class="line">    <span class="comment">//const age int = 98</span></span><br><span class="line">    <span class="keyword">const</span> age = <span class="number">98</span></span><br><span class="line">    fmt.Println(age)</span><br><span class="line">    <span class="comment">// 常量因式分解</span></span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">        v1 = <span class="number">123</span></span><br><span class="line">        v2 = <span class="number">456</span></span><br><span class="line">        <span class="comment">//pi = 9.9</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(v1, v2, pi, gender)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-iota"><a href="#4-3-iota" class="headerlink" title="4.3 iota"></a>4.3 iota</h3><p>可有可无，当做一个在声明常量时的一个计数器。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    monday = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">    tuesday</span><br><span class="line">    wednesday</span><br><span class="line">    thursday</span><br><span class="line">    friday</span><br><span class="line">    saturday</span><br><span class="line">    sunday</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    n1 = <span class="literal">iota</span></span><br><span class="line">    n2</span><br><span class="line">    n3</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// iota</span></span><br><span class="line">    <span class="comment">// 示例1</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        const (</span></span><br><span class="line"><span class="comment">            v1 = 1</span></span><br><span class="line"><span class="comment">            v2 = 2</span></span><br><span class="line"><span class="comment">            v3 = 3</span></span><br><span class="line"><span class="comment">            v4 = 4</span></span><br><span class="line"><span class="comment">            v5 = 5</span></span><br><span class="line"><span class="comment">        )</span></span><br><span class="line"><span class="comment">        fmt.Println(v1, v2, v3, v4, v5)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 示例2</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        const (</span></span><br><span class="line"><span class="comment">            v1 = iota</span></span><br><span class="line"><span class="comment">            v2</span></span><br><span class="line"><span class="comment">            v3</span></span><br><span class="line"><span class="comment">            v4</span></span><br><span class="line"><span class="comment">            v5</span></span><br><span class="line"><span class="comment">        )</span></span><br><span class="line"><span class="comment">        fmt.Println(v1, v2, v3, v4, v5)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 示例3</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        const (</span></span><br><span class="line"><span class="comment">            v1 = iota + 2</span></span><br><span class="line"><span class="comment">            v2</span></span><br><span class="line"><span class="comment">            v3</span></span><br><span class="line"><span class="comment">            v4</span></span><br><span class="line"><span class="comment">            v5</span></span><br><span class="line"><span class="comment">        )</span></span><br><span class="line"><span class="comment">        fmt.Println(v1, v2, v3, v4, v5)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 示例4：</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        const (</span></span><br><span class="line"><span class="comment">            v1 = iota + 2</span></span><br><span class="line"><span class="comment">            _</span></span><br><span class="line"><span class="comment">            v2</span></span><br><span class="line"><span class="comment">            v3</span></span><br><span class="line"><span class="comment">            v4</span></span><br><span class="line"><span class="comment">            v5</span></span><br><span class="line"><span class="comment">        )</span></span><br><span class="line"><span class="comment">        fmt.Println(v1, v2, v3, v4, v5)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-输入"><a href="#5-输入" class="headerlink" title="5.输入"></a>5.输入</h2><p>让用户输入数据，完成项目交互。</p>
<ul>
<li>fmt.Scan</li>
<li>fmt.Scanln</li>
<li>fmt.Scanf</li>
</ul>
<p>示例1：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 示例1：fmt.Scan</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        var name string</span></span><br><span class="line"><span class="comment">        fmt.Println(&quot;请输入用户名：&quot;)</span></span><br><span class="line"><span class="comment">        fmt.Scan(&amp;name)</span></span><br><span class="line"><span class="comment">        fmt.Printf(name)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 示例2：fmt.Scan</span></span><br><span class="line">    <span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line">    <span class="comment">// 当使用Scan时，会提示用户输入</span></span><br><span class="line">    <span class="comment">// 用户输入完成之后，会得到两个值：count,用户输入了几个值；err，用输入错误则是错误信息</span></span><br><span class="line">    _, err := fmt.Scan(&amp;name, &amp;age)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(name, age)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;用户输入数据错误&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 特别说明：fmt.Scan 要求输入两个值，必须输入两个，否则他会一直等待。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 示例1：fmt.Scanln</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        var name string</span></span><br><span class="line"><span class="comment">        fmt.Print(&quot;请输入用户名：&quot;)</span></span><br><span class="line"><span class="comment">        fmt.Scanln(&amp;name)</span></span><br><span class="line"><span class="comment">        fmt.Printf(name)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 示例2：fmt.Scanln</span></span><br><span class="line">    <span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line">    fmt.Print(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line">    <span class="comment">// 当使用Scanln时，会提示用户输入</span></span><br><span class="line">    <span class="comment">// 用户输入完成之后，会得到两个值：count,用户输入了几个值；err，用输入错误则是错误信息</span></span><br><span class="line">    count, err := fmt.Scanln(&amp;name, &amp;age)</span><br><span class="line">    fmt.Println(count, err)</span><br><span class="line">    fmt.Println(name, age)</span><br><span class="line">    <span class="comment">// 特别说明：fmt.Scanln 等待回车。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例3：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line">    fmt.Print(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line">    _, _ = fmt.Scanf(<span class="string">&quot;我叫%s 今年%d 岁&quot;</span>, &amp;name, &amp;age)</span><br><span class="line">    fmt.Println(name, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题：读取一整行"><a href="#问题：读取一整行" class="headerlink" title="问题：读取一整行"></a>问题：读取一整行</h3><p>当使用ftm.Scan等功能时，如果输入一整行且期间存在空格，则无法获取整行。<br>想要读取一行数据，这个功能可以基于标准输入来进行实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    reader := bufio.NewReader(os.Stdin)</span><br><span class="line">    <span class="comment">// line，从stdin中读取一行的数据（字节集合 -&gt; 转化成为字符串）</span></span><br><span class="line">    <span class="comment">// reader默认一次能4096个字节（4096/3)</span></span><br><span class="line">    <span class="comment">//    1. 一次性读完，isPrefix=false</span></span><br><span class="line">    <span class="comment">//       2. 先读一部分，isPrefix=true，再去读取isPrefix=false</span></span><br><span class="line">    line, _, _ := reader.ReadLine()</span><br><span class="line">    data := <span class="keyword">string</span>(line)</span><br><span class="line">    fmt.Println(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-条件语句"><a href="#6-条件语句" class="headerlink" title="6.条件语句"></a>6.条件语句</h2><h3 id="6-1-最基本"><a href="#6-1-最基本" class="headerlink" title="6.1 最基本"></a>6.1 最基本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if 条件 &#123;</span><br><span class="line">    成立后，此代码块执行</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    不成立，此代码块执行</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if 条件 &#123;</span><br><span class="line">    成立后，此代码块执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if true &#123;</span></span><br><span class="line"><span class="comment">            fmt.Println(&quot;666&quot;)</span></span><br><span class="line"><span class="comment">        &#125;else&#123;</span></span><br><span class="line"><span class="comment">            fmt.Println(&quot;999&quot;)</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if 1 &gt; 2 &#123;</span></span><br><span class="line"><span class="comment">            fmt.Println(&quot;666&quot;)</span></span><br><span class="line"><span class="comment">        &#125; else &#123;</span></span><br><span class="line"><span class="comment">            fmt.Println(&quot;999&quot;)</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        flag := false</span></span><br><span class="line"><span class="comment">        if flag &#123;</span></span><br><span class="line"><span class="comment">            fmt.Println(&quot;条件成立&quot;)</span></span><br><span class="line"><span class="comment">        &#125;else&#123;</span></span><br><span class="line"><span class="comment">            fmt.Println(&quot;条件不成立&quot;)</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 练习题1:用户输入姓名，判断是否正确</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        var name string</span></span><br><span class="line"><span class="comment">        fmt.Print(&quot;请输入姓名：&quot;)</span></span><br><span class="line"><span class="comment">        fmt.Scanln(&amp;name)</span></span><br><span class="line"><span class="comment">        if name == &quot;alex&quot; &#123;</span></span><br><span class="line"><span class="comment">            fmt.Println(&quot;用户名输入正确&quot;)</span></span><br><span class="line"><span class="comment">        &#125; else &#123;</span></span><br><span class="line"><span class="comment">            fmt.Println(&quot;用户名输入错误&quot;)</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 练习题2:用户输入数字，判断奇数、偶数</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        var number int</span></span><br><span class="line"><span class="comment">        fmt.Print(&quot;请输入数字：&quot;)</span></span><br><span class="line"><span class="comment">        fmt.Scanln(&amp;number)</span></span><br><span class="line"><span class="comment">        if number % 2 == 0&#123;</span></span><br><span class="line"><span class="comment">            fmt.Println(&quot;您输入的是偶数&quot;)</span></span><br><span class="line"><span class="comment">        &#125;else&#123;</span></span><br><span class="line"><span class="comment">            fmt.Println(&quot;您输入的是奇数&quot;)</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 练习题3:用户和密码，判断用户名密码是否正确。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        var username, password string</span></span><br><span class="line"><span class="comment">        fmt.Print(&quot;请输入用户名：&quot;)</span></span><br><span class="line"><span class="comment">        fmt.Scanln(&amp;username)</span></span><br><span class="line"><span class="comment">        fmt.Print(&quot;请输入密码：&quot;)</span></span><br><span class="line"><span class="comment">        fmt.Scanln(&amp;password)</span></span><br><span class="line"><span class="comment">        if username == &quot;alex&quot; &amp;&amp; password == &quot;sb&quot; &#123;</span></span><br><span class="line"><span class="comment">            fmt.Println(&quot;欢迎登录pornhub&quot;)</span></span><br><span class="line"><span class="comment">        &#125; else &#123;</span></span><br><span class="line"><span class="comment">            fmt.Println(&quot;用户名或密码错误&quot;)</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 练习题4:请输入用户名校验是否是VIP</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        var username string</span></span><br><span class="line"><span class="comment">        fmt.Print(&quot;请输入用户名：&quot;)</span></span><br><span class="line"><span class="comment">        fmt.Scanln(&amp;username)</span></span><br><span class="line"><span class="comment">        if username == &quot;alex&quot; || username == &quot;eric&quot; &#123;</span></span><br><span class="line"><span class="comment">            fmt.Println(&quot;天上人间大VIP&quot;)</span></span><br><span class="line"><span class="comment">        &#125; else &#123;</span></span><br><span class="line"><span class="comment">            fmt.Println(&quot;屌丝&quot;)</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-多条件判断"><a href="#6-2-多条件判断" class="headerlink" title="6.2 多条件判断"></a>6.2 多条件判断</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件A&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> 条件B&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> 条件C&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> length <span class="keyword">int</span></span><br><span class="line">    fmt.Print(<span class="string">&quot;请输入你的长度：&quot;</span>)</span><br><span class="line">    fmt.Scanln(&amp;length)</span><br><span class="line">    <span class="keyword">if</span> length &lt; <span class="number">1</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;没用的东西，还特么是坑&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> length &lt; <span class="number">6</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;刚刚能用&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> length &lt; <span class="number">18</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;生活和谐&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;太特么大了&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-嵌套"><a href="#6-3-嵌套" class="headerlink" title="6.3 嵌套"></a>6.3 嵌套</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;欢迎致电10086，1.话费相关；2.业务办理；3.人工服务。&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> number <span class="keyword">int</span></span><br><span class="line">    fmt.Scanln(&amp;number)</span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">1</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;话费服务，1.交话费；2.查询。&quot;</span>)</span><br><span class="line">        <span class="keyword">var</span> n1 <span class="keyword">int</span></span><br><span class="line">        fmt.Scanln(&amp;n1)</span><br><span class="line">        <span class="keyword">if</span> n1 == <span class="number">1</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;缴话费啦&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> n1 == <span class="number">2</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;查话费了&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;输入错误&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number == <span class="number">2</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;业务办理&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number == <span class="number">3</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;人工服务&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;输入错误&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建议：条件的嵌套不要太多</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="今日作业"><a href="#今日作业" class="headerlink" title="今日作业"></a>今日作业</h2><ol>
<li><p>提⽰⽤户输入⿇花藤. 判断⽤户输入的对不对。如果对, 提⽰真聪明, 如果不对, 提⽰你 是傻逼么。</p>
</li>
<li><p>提示用户输入两个数字，计算两个数的和并输出。</p>
</li>
<li><p>提示用户输入姓名、位置、行为三个值，然后做字符串的拼接 并输出，例如：xx 在 xx 做 xx 。</p>
</li>
<li><p>设定一个理想数字比如：66，让用户输入数字，如果比66大，则显示猜测的结果大了；如果比66小，则显示猜测的结果小了;只有等于66，显示猜测结果正确。</p>
</li>
<li><p>写程序，输出成绩等级。成绩有ABCDE5个等级，与分数的对应关系如下.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A    90-100B    80-89C    60-79D    40-59E    0-39</span><br></pre></td></tr></table></figure>

<p>要求用户输入0-100的数字后，正确输出他的对应成绩等级。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go-03-变量</title>
    <url>/posts/23007.html</url>
    <content><![CDATA[<p>变量</p>
<a id="more"></a>

<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p><strong>函数内定义的变量必须使用，否则报错</strong></p>
<p>变量，其实就相当于给某个值设置一个<code>昵称</code>，此<code>昵称</code>代指当前值。</p>
<p>在Go中变量声明的基本格式为：<code>var 变量名 类型 = 值</code> ，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个字符串类型的变量name，值为 &quot;武沛齐&quot;</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">&quot;武沛齐&quot;</span></span><br><span class="line"><span class="comment">// 生命一个整型类型的变量age，值为 18</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span> = <span class="number">18</span></span><br></pre></td></tr></table></figure>

<h2 id="1-变量简写"><a href="#1-变量简写" class="headerlink" title="1. 变量简写"></a>1. 变量简写</h2><p>为了能让变量的声明更方便，Go还提供了一些声明变量的简化方式。</p>
<ul>
<li><p>省略类型，格式为：<code>var 变量名 = 值</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;武沛齐&quot;</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line"><span class="comment">// 在给变量赋值时已知值的类型，所以Go编译器自动可以自动检测到类型，故可简化编写。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>省略var关键字，格式为：<code>变量名 := 值</code> （推荐）</p>
<ul>
<li>注意: <strong>(必须在函数内包含函数内子块使用）</strong>，不能在包级别使用</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">name := <span class="string">&quot;武沛齐&quot;</span></span><br><span class="line">age := <span class="number">18</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>上述两种简化编写的方式必须是直接赋值操作，即：直接将值赋值给变量，否则无法简化。例如：先声明再赋值时候就不能使用简化方式编写了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明变量</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="comment">// 给变量赋值</span></span><br><span class="line">name = <span class="string">&quot;武沛齐&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意：如果变量只声明不赋值，Go内部其实会给变量默认设置值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil 。</p>
<p>容器</p>
<h2 id="2-变量名要求"><a href="#2-变量名要求" class="headerlink" title="2.变量名要求"></a>2.变量名要求</h2><p>对于变量名有以下要求和建议：</p>
<ul>
<li><p>要求（必须遵守，否则报错）</p>
<ul>
<li><p>变量名由字母、数字、下划线组成，且首个字符不能为数字。</p>
</li>
<li><p>不能使用Go内置的25个关键字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">break、default、func、interface、select、case、defer、go、map、struct、chan、else、goto、package、switch、const、fallthrough、if、range、type、continue、for、import、return、var</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>建议</p>
<ul>
<li>变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：<code>numShips</code> 和 <code>startDate</code>。</li>
<li>见名知意，通过变量名就可以知道变量所代指的值，例如：<code>name</code>、<code>email</code>。</li>
</ul>
</li>
</ul>
<h2 id="3-全局和局部变量"><a href="#3-全局和局部变量" class="headerlink" title="3.全局和局部变量"></a>3.全局和局部变量</h2><p>根据变量所在位置不同，变量有全局和局部之分。</p>
<h3 id="3-1-全局变量"><a href="#3-1-全局变量" class="headerlink" title="3.1 全局变量"></a>3.1 全局变量</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// 声明全局变量</span></span><br><span class="line"><span class="keyword">var</span> country <span class="keyword">string</span> = <span class="string">&quot;中国&quot;</span> </span><br><span class="line"><span class="comment">// 或可使用 var country = &quot;中国&quot;</span></span><br><span class="line"><span class="comment">// 不可使用 country := &quot;中国&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(country)</span><br><span class="line">    country = <span class="string">&quot;China&quot;</span></span><br><span class="line">    fmt.Println(country)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别提醒：Go中的全局变量比较特殊，如果全局变量名首字母小写，则只能被当前包中的go文件使用，外部无法使用；如果首字母大写，则任意文件都使用全局变量。</p>
<p>可简单理解为：首字母大写表写公有，首字母小写表示私有（当前包的go文件所有）。</p>
<h3 id="3-2-局部变量"><a href="#3-2-局部变量" class="headerlink" title="3.2 局部变量"></a>3.2 局部变量</h3><p>Go中的变量有作用域之分，每个大括号就是一个作用域，每个作用域中都可定义相关的局部变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 声明局部变量，在当前函数可用</span></span><br><span class="line">   <span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">&quot;武沛齐&quot;</span></span><br><span class="line">   fmt.Println(name)</span><br><span class="line">   <span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">      <span class="comment">//  生命局部变量，在当前if中可用</span></span><br><span class="line">      <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line">      fmt.Println(age)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 报错，age在if括号的作用域中</span></span><br><span class="line">   <span class="comment">// fmt.Println(age)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-因式分解"><a href="#4-因式分解" class="headerlink" title="4.因式分解"></a>4.因式分解</h2><p>在定义多个变量时候，可以通过因式分解的方式进行简化代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">var name = &quot;武沛齐&quot;</span></span><br><span class="line"><span class="comment">var age = 18</span></span><br><span class="line"><span class="comment">var gender  string</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 在全局使用</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    name   = <span class="string">&quot;武沛齐&quot;</span></span><br><span class="line">    age    = <span class="number">18</span></span><br><span class="line">    gender <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(name)</span><br><span class="line">    fmt.Println(age)</span><br><span class="line">    gender = <span class="string">&quot;男&quot;</span></span><br><span class="line">    fmt.Println(gender)</span><br><span class="line">    <span class="comment">// 在局部使用</span></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        x1 = <span class="number">123</span></span><br><span class="line">        x2 = <span class="number">456</span></span><br><span class="line">    )</span><br><span class="line">      x, y := <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span></span><br><span class="line">    fmt.Println(x1)</span><br><span class="line">    fmt.Println(x2)</span><br><span class="line">      fmt.Println(x,y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-使用步骤"><a href="#5-使用步骤" class="headerlink" title="5.使用步骤"></a>5.使用步骤</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.声明变量，定义变量</span><br><span class="line">2.给与变量赋值</span><br><span class="line">3.使用变量</span><br></pre></td></tr></table></figure>

<p>我们经常看到这样的语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var username string &#x3D; &quot;username&quot;</span><br></pre></td></tr></table></figure>

<p>我们来解读一下该语句:</p>
<ul>
<li>var 关键字 用于声明变量</li>
<li>username 标识符, 给变量取的名字</li>
<li>string 表示该变量只能存储字符串类型的值</li>
<li>= 赋值运算符, 表示给一个变量赋</li>
<li>“username” 字面量(值), 这个是一个username的字符串</li>
</ul>
<h2 id="字面量-值"><a href="#字面量-值" class="headerlink" title="字面量(值)"></a>字面量(值)</h2><p>字面量是值的表示方法，常用与对变量/常量进行初始化，主要分为：</p>
<ul>
<li>标识基础数据类型值的字面量，例如：0, 1.1, true, 3 + 4i, ‘a’, “我爱中国”</li>
<li>构造自定义的复合数据类型的类型字面量，例如：type Interval int</li>
<li>用于表示符合数据类型值的复合字面量，用来构造 array、slice、map、struct 的值， 例如：{1, 2, 3}</li>
</ul>
<h2 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h2><p>变量是指对一块存储空间定义名称，通过名称对存储空间的内容进行访问或修改</p>
<p>由于Go是强类型语言, 变量需要先声明后使用</p>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>声明变量的一般形式是使用 var 关键字:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var identifier type</span><br></pre></td></tr></table></figure>

<p>我们也可以一次声明多个变量, 比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var identifier1, identifier2 type</span><br></pre></td></tr></table></figure>

<p>如果我们一次声明的变量过多，比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var identifier1 type1</span><br><span class="line">var identifier2 type2</span><br><span class="line">var identifier3 type3</span><br></pre></td></tr></table></figure>

<p>我们可以使用() 进行批量申请</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var (</span><br><span class="line">    identifier1 type1</span><br><span class="line">    identifier2 type2</span><br><span class="line">    identifier3 type3    </span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>变量声明过后如果没有赋值，默认是该类型的初始值</p>
<ul>
<li>整形(int uint)： 0</li>
<li>浮点型(float32 float64): 0</li>
<li>布尔: false</li>
<li>字符串: “”</li>
<li>字符: ‘’</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var a float64</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量赋值的语法为: var1 = value1, 如下是一个声明和赋值的过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a string  &#x2F;&#x2F; 变量声明</span><br><span class="line">a &#x3D; &quot;test&quot;    &#x2F;&#x2F; 变量赋值</span><br></pre></td></tr></table></figure>

<p>如果我有多个变量需要赋值语法为: var1, var2 = value1, value2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var (</span><br><span class="line">    a string</span><br><span class="line">    b int</span><br><span class="line">)</span><br><span class="line">a, b &#x3D; &quot;string&quot;, 10</span><br></pre></td></tr></table></figure>

<p><code>注意:</code> 由于Go是强类型语言, 因此我们在进行赋值时，只能赋变量声明类型的值，比如下面方式就是错误的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a string</span><br><span class="line">a &#x3D; 10</span><br></pre></td></tr></table></figure>

<h3 id="声明变量并赋值"><a href="#声明变量并赋值" class="headerlink" title="声明变量并赋值"></a>声明变量并赋值</h3><p>语法格式为: var identifier type = value</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a string &#x3D; &quot;one line&quot;</span><br></pre></td></tr></table></figure>

<p>同样我们已适合批量声明赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var (</span><br><span class="line">    a string  &#x3D; &quot;value1&quot;</span><br><span class="line">    b int     &#x3D; 10</span><br><span class="line">    c float32 &#x3D; 0.01</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="简短声明"><a href="#简短声明" class="headerlink" title="简短声明"></a>简短声明</h3><p>变量的类型使用值类型进行推导，因此我们可以省略类型的定义, 语法格式: a := b</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a, b, c :&#x3D; &quot;value1&quot;, 10, 0.01</span><br></pre></td></tr></table></figure>

<p><code>注意：</code> 简单声明只能用于函数内部, 不用用于全局声明</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量是一个简单值的标识符，在程序运行时，不会被修改的量。用于定义不可被修改的的值，需要在编译过程中进行计算，只能为基础的数据类型布尔、 数值、字符串，使用 const 进行常量定义</p>
<h3 id="显式类型定义"><a href="#显式类型定义" class="headerlink" title="显式类型定义"></a>显式类型定义</h3><p>一般情况下，我们再定义常量的时候 需要制定常量的类型与值 声明语法如下: const identifier type = value</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const PI float32 &#x3D; 3.14</span><br></pre></td></tr></table></figure>

<p>通变量一样， 常量也支持批量定义:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 单行的批量定义 只支持同一种类型</span><br><span class="line">const c1, c2 string &#x3D; &quot;c1&quot;, &quot;c2&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 多行的批量定义支持不同类型</span><br><span class="line">const (</span><br><span class="line">    PI     float32 &#x3D; 3.14</span><br><span class="line">    PILong float64 &#x3D; 3.14159</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="隐式类型定义"><a href="#隐式类型定义" class="headerlink" title="隐式类型定义"></a>隐式类型定义</h3><p>得益于Golang的类型推导, 常量也是可以省略类型的 隐式类型定义语法如下: const identifier = value</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const PI &#x3D; 3.14</span><br></pre></td></tr></table></figure>

<p>批量语法如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    PI     &#x3D; 3.141</span><br><span class="line">    PILong &#x3D; 3.141592</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="值不可修改"><a href="#值不可修改" class="headerlink" title="值不可修改"></a>值不可修改</h3><p>定义多个变量并进行初始化，批量复制中变量类型可省略，并且除了第一个常量值外其他常量可同时省略类型和值，表示使用前一个常量的初始化表达式</p>
<p>常量之间的运算，类型转换，以及对常量调用函数 len、cap、real、imag、complex、unsafe.Sizeof 得到的结果依然为常量</p>
<p>由于常量不能修改，像下面这个就会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    a &#x3D; &quot;sdf&quot;</span><br><span class="line">)</span><br><span class="line">a &#x3D; &quot;bbb&quot;</span><br></pre></td></tr></table></figure>

<h3 id="用作枚举"><a href="#用作枚举" class="headerlink" title="用作枚举"></a>用作枚举</h3><p>比如 我们定义一个性别的枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    UNKNOWN &#x3D; 0 &#x2F;&#x2F; 保密</span><br><span class="line">    FEMALE &#x3D; 1  &#x2F;&#x2F; 女</span><br><span class="line">    MALE &#x3D; 2      &#x2F;&#x2F; 男</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><p>iota是一种特殊常量，可以认为是一个可以被编译器修改的常量</p>
<p>iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    UNKNOWN &#x3D; iota   &#x2F;&#x2F; UNKNOWN 0 </span><br><span class="line">    FEMALE           &#x2F;&#x2F; FEMALE +1</span><br><span class="line">    MALE             &#x2F;&#x2F; MALE   +1</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果你不想从0开始计数 你也可以这样写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    UNKNOWN &#x3D; iota + 5  &#x2F;&#x2F; UNKNOWN 5</span><br><span class="line">    FEMALE              &#x2F;&#x2F; FEMALE +1</span><br><span class="line">    MALE                &#x2F;&#x2F; MALE   +1</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>进程内存结构:</p>
<p><img src="https://gitee.com/waylon1006/go-course/raw/master/image/mem_struct.png" alt="mem_struct"></p>
<ul>
<li>栈：存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中（new 出来的对象）</li>
<li>堆: 存放用new产生的数据</li>
</ul>
<p>值类型和引用类型 是什么?</p>
<ul>
<li>值类型: 这段内存里面存储的是基本类型的数据, 比如 “a”, 10, 0.01</li>
<li>引用类型: 这段内存里面存储的是一个地址, 比如 0xc00011e370 0xc00011e380</li>
</ul>
<h3 id="修改值"><a href="#修改值" class="headerlink" title="修改值"></a>修改值</h3><p>比如 下面这段代码中 a, b 10 存在在哪儿? 当执行赋值操作时 都发生了什么?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a int </span><br><span class="line">a &#x3D; 10</span><br><span class="line"></span><br><span class="line">var b int </span><br><span class="line">b &#x3D; 10</span><br><span class="line"></span><br><span class="line">a &#x3D; 20</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/waylon1006/go-course/raw/master/image/var_ref.png" alt="var_ref"></p>
<ul>
<li>编译器先处理 <code>var a int</code>, 首先它会在栈中创建一个变量为a的引用</li>
<li>a = 10，查找栈中是否有10这个值, 没找到，就将10存放进来, 然后让a指向10</li>
<li>var b int, 创建一个变量为b的引用</li>
<li>b = 10, 查找栈中是否有10这个值, 找到10, 让b指向10</li>
<li>a = 20, 查找栈中是否有20这个值, 为找到, 将20放进去, 然后让a指向20</li>
</ul>
<h3 id="修改引用"><a href="#修改引用" class="headerlink" title="修改引用"></a>修改引用</h3><p>看看下面这段代码, 修改了j的值，为啥没修改i的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i :&#x3D; &quot;this is i&quot;</span><br><span class="line">j :&#x3D; i</span><br><span class="line">j :&#x3D; &quot;this is j&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/waylon1006/go-course/raw/master/image/value_ref.png" alt="value_ref"></p>
<p>下面我们修改了j的值, 为啥i的值也被修改了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i :&#x3D; &quot;this is a&quot;</span><br><span class="line">j :&#x3D; &amp;i</span><br><span class="line">*j &#x3D; &quot;this is j&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/ref_edit.png" alt="ref_edit"></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/posts/2.html</url>
    <content><![CDATA[<p>title: Go-04-数据类型<br>date: 2021-06-18 19:23:47<br>tags:<br>    - Go<br>categories: Go</p>
<p>变量/常量, iota/浮点型/字符型/布尔型</p>
<a id="more"></a>

<p>Go变量</p>
<p>变量是对内存中数据存储空间的表示，如同门牌号对应着房间，同样的，变量名字对应变量的值。</p>
<p>变量使用步骤</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>声明变量，定义变量</span><br><span class="line"><span class="number">2.</span>给与变量赋值</span><br><span class="line"><span class="number">3.</span>使用变量</span><br></pre></td></tr></table></figure>

<p>实际案例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name <span class="keyword">string</span>               <span class="comment">//声明变量名 name</span></span><br><span class="line">    name = <span class="string">&quot;超哥&quot;</span>                   <span class="comment">//给与变量赋值</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;name的值是：&quot;</span>, name) <span class="comment">//使用变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name的值是： 超哥</span><br></pre></td></tr></table></figure>

<p>变量使用过程</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">代码读取</span><br><span class="line">变量加载到内存  name 指向 内存地址的值</span><br><span class="line"><span class="number">1</span>）变量含有名字，变量类型</span><br></pre></td></tr></table></figure>

<h1 id="变量定义方式"><a href="#变量定义方式" class="headerlink" title="变量定义方式"></a>变量定义方式</h1><p>1）定义变量与类型，不赋值，含有默认值</p>
<p>语法：<code>var 语句定义变量的列表，类型在后面</code>，可以定义局部变量也可以，也可全局变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<p>声明多个变量</p>
<p><code>var num,num2 int</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;age的值是：&quot;</span>, age)</span><br><span class="line">    <span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;name的值是：&quot;</span>, name)</span><br><span class="line">    <span class="keyword">var</span> salary <span class="keyword">float64</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;salary的值是：&quot;</span>, salary)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">age的值是： <span class="number">0</span></span><br><span class="line">name的值是： </span><br><span class="line">salary的值是： <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>2）编译器类型推导，自行判断变量类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var num &#x3D; 10.1</span><br></pre></td></tr></table></figure>

<p>一次性定义多个变量 </p>
<p><code>var age,age2 = 10,11</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num, num1 = <span class="number">10</span>, <span class="number">11</span></span><br><span class="line">    fmt.Println(num, num1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）短声明，省略var，<strong>只能用在函数内部</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;超哥&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;name的值是：&quot;</span>, name)</span><br><span class="line">    <span class="comment">//上述段声明等于如下方式</span></span><br><span class="line">    <span class="keyword">var</span> name2 <span class="keyword">string</span></span><br><span class="line">    name2 = <span class="string">&quot;超哥&quot;</span></span><br><span class="line">    fmt.Println(name2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）多变量声明</p>
<p>golang支持一次性声明多个变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">多个局部变量</span><br></pre></td></tr></table></figure>

<p>作用域只在函数体内，参数和返回值也是局部变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//一次性声明多个变量，int默认值</span></span><br><span class="line">    <span class="keyword">var</span> n1, n2, n3 <span class="keyword">int</span></span><br><span class="line">    fmt.Println(n1, n2, n3)</span><br><span class="line">    <span class="comment">//声明多个变量，且赋值</span></span><br><span class="line">    <span class="keyword">var</span> c1, c2, c3 = <span class="string">&quot;chaoge&quot;</span>, <span class="number">18</span>, <span class="number">99.99</span></span><br><span class="line">    fmt.Println(c1, c2, c3)</span><br><span class="line">    <span class="comment">//短声明多个变量</span></span><br><span class="line">    a1, a2, a3 := <span class="string">&quot;yu&quot;</span>, <span class="number">17</span>, <span class="number">100.0</span></span><br><span class="line">    fmt.Println(a1, a2, a3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5）<code>一次性声明多个全局变量</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//声明全局变量方式1</span></span><br><span class="line"><span class="keyword">var</span> n1 = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> n2 = <span class="number">200</span></span><br><span class="line"><span class="keyword">var</span> n3 = <span class="number">300</span></span><br><span class="line"><span class="comment">//声明全局变量方式2</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    d1, d2, d3 = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//声明全局变量方式3</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    c1 = <span class="number">100</span></span><br><span class="line">    c2 = <span class="number">200</span></span><br><span class="line">    c3 = <span class="number">300</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;这里是函数体内&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6）特殊变量，占位符 “_”</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Person</span><span class="params">(a1 <span class="keyword">int</span>, n1 <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a1, n1</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _, name := Person(<span class="number">18</span>, <span class="string">&quot;好嗨哦&quot;</span>)</span><br><span class="line">    fmt.Println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7）常见数据类型变量默认值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 只声明变量，不赋值，只有默认值</span></span><br><span class="line">    <span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> gender <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">var</span> salary <span class="keyword">float64</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;age默认值 :&quot;</span>, age)</span><br><span class="line">    fmt.Println(<span class="string">&quot;name默认值 :&quot;</span>, name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;gender默认值 :&quot;</span>, gender)</span><br><span class="line">    fmt.Println(<span class="string">&quot;salary默认值 :&quot;</span>, salary)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">age默认值 : <span class="number">0</span></span><br><span class="line">name默认值 : </span><br><span class="line">gender默认值 : <span class="literal">false</span></span><br><span class="line">salary默认值 : <span class="number">0</span></span><br></pre></td></tr></table></figure>



<p>注意变量赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">    var name string &#x3D; &quot;kk&quot;</span><br><span class="line">    fmt.Println(name)</span><br><span class="line"></span><br><span class="line">    name &#x3D; &quot;silence&quot; &#x2F;&#x2F; 更新变量值</span><br><span class="line">    fmt.Println(name)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 不是定义，是赋值；修改的是外面的值</span><br><span class="line">        name &#x3D; &quot;aaaaaa&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">kk</span><br><span class="line">silence</span><br><span class="line">aaaaaa</span><br></pre></td></tr></table></figure>



<h1 id="Go常量"><a href="#Go常量" class="headerlink" title="Go常量"></a>Go常量</h1><p>常量代表只读的，不可修改的值，用const关键字定义。</p>
<p>如同用常量定义 “π”之类的常数。</p>
<p>常量如同变量一样，可以批量声明，或者一组相关的常量。</p>
<p>常量的计算都在编译期间完成，并非运行期间！减少运行时的工作。</p>
<p>未使用的常量不会引发编译错误。(这点和变量不一样哦~)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//常量定义且赋值</span></span><br><span class="line"><span class="keyword">const</span> World <span class="keyword">string</span> = <span class="string">&quot;世界&quot;</span></span><br><span class="line"><span class="comment">//多常量初始化</span></span><br><span class="line"><span class="keyword">const</span> x, y <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="comment">//常量类型推断，字符串类型</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="string">&quot;Hello golang&quot;</span></span><br><span class="line"><span class="comment">//常量组</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    e       = <span class="number">2.71828182845904523536028747135266249775724709369995957496696763</span></span><br><span class="line">    pi      = <span class="number">3.14159265358979323846264338327950288419716939937510582097494459</span></span><br><span class="line">    b  <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//常量组，可以除了第一个外其他的常量右边的初始化表达式可以省略</span></span><br><span class="line"><span class="comment">//如果省略初始化表达式，默认使用前面常量的表达式</span></span><br><span class="line"><span class="comment">//与上一个常量相同</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    c1=<span class="number">1</span></span><br><span class="line">    c2</span><br><span class="line">    c3</span><br><span class="line">    c4=<span class="string">&quot;c44444&quot;</span></span><br><span class="line">    c5</span><br><span class="line">)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">c44444</span></span><br><span class="line"><span class="comment">c44444</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//常量也可以定义函数的返回值</span></span><br><span class="line"> <span class="keyword">const</span> (</span><br><span class="line">     f1=<span class="string">&quot;abc&quot;</span>  <span class="comment">//长度为3的字符串类型</span></span><br><span class="line">     f2=<span class="built_in">len</span>(f1)<span class="comment">//返回长度的函数结果</span></span><br><span class="line">     f3=unsafe.Sizeof(f2)<span class="comment">//返回f2所占用的内存大小</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 输出结果</span></span><br><span class="line"><span class="comment"> abc</span></span><br><span class="line"><span class="comment"> 3</span></span><br><span class="line"><span class="comment"> 8</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(f1)</span><br><span class="line">    fmt.Println(f2)</span><br><span class="line">    fmt.Println(f3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Go常量之iota常量生成器（枚举类型）"><a href="#Go常量之iota常量生成器（枚举类型）" class="headerlink" title="Go常量之iota常量生成器（枚举类型）"></a>Go常量之iota常量生成器（枚举类型）</h1><p>iota用于生成一组相似规则初始化的常量，在const常量声明的语句中，第一个常量所在行，iota为0，之后每一个常量声明加一。</p>
<p>例如time包的例子，一周7天，每天可以定义为常量，1~6，周日为0，这种类型也称为枚举</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Sunday = <span class="literal">iota</span></span><br><span class="line">    Monday <span class="comment">//通常省略后续行表达式</span></span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果iota表达式被打断，需要显示恢复</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    A = <span class="literal">iota</span> <span class="comment">//初始0</span></span><br><span class="line">    B        <span class="comment">// +1</span></span><br><span class="line">    C = <span class="string">&quot;c&quot;</span>  <span class="comment">//iota枚举被打断 ，为  c</span></span><br><span class="line">    D        <span class="comment">// c，与上  相同。</span></span><br><span class="line">    E = <span class="literal">iota</span> <span class="comment">// 4，显式恢复。注意计数包含了 C、D 两个，此时为4 。</span></span><br><span class="line">    F        <span class="comment">// 恢复iota 加一，此时为5</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(A, B, C, D, E, F)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 1 c c 4 5</span><br></pre></td></tr></table></figure>

<p>Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。</p>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64</p>
<p>其中，<code>uint8</code>就是我们熟知的<code>byte</code>型，<code>int16</code>对应C语言中的<code>short</code>型，<code>int64</code>对应C语言中的<code>long</code>型。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">uint8</td>
<td align="center">1字节 无符号 8位整型 (0 到 255)</td>
</tr>
<tr>
<td align="center">uint16</td>
<td align="center">2字节 无符号 16位整型 (0 到 65535)</td>
</tr>
<tr>
<td align="center">uint32</td>
<td align="center">4字节 无符号 32位整型 (0 到 4294967295)</td>
</tr>
<tr>
<td align="center">uint64</td>
<td align="center">8字节 无符号 64位整型 (0 到 18446744073709551615)</td>
</tr>
<tr>
<td align="center">int8</td>
<td align="center">1字节 有符号 8位整型 (-128 到 127)</td>
</tr>
<tr>
<td align="center">int16</td>
<td align="center">2字节 有符号 16位整型 (-32768 到 32767)</td>
</tr>
<tr>
<td align="center">int32</td>
<td align="center">4字节 有符号 32位整型 (-2147483648 到 2147483647)</td>
</tr>
<tr>
<td align="center">int64</td>
<td align="center">8字节 有符号 64位整型 (-9223372036854775808 到 9223372036854775807)</td>
</tr>
</tbody></table>
<h3 id="特殊整型"><a href="#特殊整型" class="headerlink" title="特殊整型"></a>特殊整型</h3><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">uint</td>
<td align="center">32位操作系统上就是<code>uint32</code>，64位操作系统上就是<code>uint64</code></td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32位操作系统上就是<code>int32</code>，64位操作系统上就是<code>int64</code></td>
</tr>
<tr>
<td align="center">uintptr</td>
<td align="center">无符号整型，用于存放一个指针</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 在使用<code>int</code>和 <code>uint</code>类型时，不能假定它是32位或64位的整型，而是考虑<code>int</code>和<code>uint</code>可能在不同平台上的差异。</p>
<p><strong>注意事项</strong> 获取对象的长度的内建<code>len()</code>函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用<code>int</code>来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用<code>int</code>和 <code>uint</code>。</p>
<h3 id="数字字面量语法（Number-literals-syntax）"><a href="#数字字面量语法（Number-literals-syntax）" class="headerlink" title="数字字面量语法（Number literals syntax）"></a>数字字面量语法（Number literals syntax）</h3><p>Go1.13版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如：</p>
<p><code>v := 0b00101101</code>， 代表二进制的 101101，相当于十进制的 45。 <code>v := 0o377</code>，代表八进制的 377，相当于十进制的 255。 <code>v := 0x1p-2</code>，代表十六进制的 1 除以 2²，也就是 0.25。</p>
<p>而且还允许我们用 <code>_</code> 来分隔数字，比如说： <code>v := 123_456</code> 表示 v 的值等于 123456。</p>
<p>我们可以借助fmt函数来将一个整数以不同进制形式展示。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 十进制</span></span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d \n&quot;</span>, a)  <span class="comment">// 10</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%b \n&quot;</span>, a)  <span class="comment">// 1010  占位符%b表示二进制</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 八进制  以0开头</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">077</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%o \n&quot;</span>, b)  <span class="comment">// 77</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 十六进制  以0x开头</span></span><br><span class="line">    <span class="keyword">var</span> c <span class="keyword">int</span> = <span class="number">0xff</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%x \n&quot;</span>, c)  <span class="comment">// ff</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%X \n&quot;</span>, c)  <span class="comment">// FF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>（一般不做&gt;= &lt;= ==判断，因为不精确；所以如果想要判断 ==  !=  判断差值在一定取件范围内）</p>
<p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code>，编译器默认声明为float64。这两种浮点型数据格式遵循<code>IEEE 754</code>标准： <code>float32</code> 的浮点数的最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。 <code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Waylonwhynot/whatyouneed_blog_pic@main/pic/p3-20210619110956002.png" alt="img"></p>
<p>打印浮点数时，可以使用<code>fmt</code>包配合动词<code>%f</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> price <span class="keyword">float32</span> = <span class="number">11.22</span> <span class="comment">//正数符号</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;price=&quot;</span>, price)</span><br><span class="line">    <span class="keyword">var</span> num1 <span class="keyword">float32</span> = <span class="number">-3.4</span> <span class="comment">//负数符号</span></span><br><span class="line">    <span class="keyword">var</span> num2 <span class="keyword">float64</span> = <span class="number">-8.23</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;num1=&quot;</span>, num1, <span class="string">&quot;num2=&quot;</span>, num2)</span><br><span class="line">    <span class="comment">//尾数可能丢失，精度缺损</span></span><br><span class="line">    <span class="keyword">var</span> num3 <span class="keyword">float32</span> = <span class="number">-123.11111111105</span><span class="comment">//精度丢失了    </span></span><br><span class="line">    <span class="keyword">var</span> num4 <span class="keyword">float64</span> = <span class="number">-123.11111111105</span><span class="comment">//float64的精度高于float32</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;num3=&quot;</span>, num3, <span class="string">&quot;num4=&quot;</span>, num4)</span><br><span class="line">    <span class="comment">//输出结果</span></span><br><span class="line">    <span class="comment">//num3= -123.111115 num4= -123.11111111105</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>complex64和complex128</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 <span class="keyword">complex64</span></span><br><span class="line">c1 = <span class="number">1</span> + <span class="number">2i</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="keyword">complex128</span></span><br><span class="line">c2 = <span class="number">2</span> + <span class="number">3i</span></span><br><span class="line">fmt.Println(c1)</span><br><span class="line">fmt.Println(c2)</span><br></pre></td></tr></table></figure>

<p>复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。</p>
<h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>Go语言中以<code>bool</code>类型进行声明布尔型数据，布尔型数据只有<code>true（真）</code>和<code>false（假）</code>两个值。</p>
<p><strong>注意：</strong></p>
<ol>
<li>布尔类型变量的默认值为<code>false</code>。</li>
<li>Go 语言中不允许将整型强制转换为布尔型.</li>
<li>布尔型无法参与数值运算，也无法与其他类型进行转换。</li>
</ol>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的<strong>内部实现使用<code>UTF-8</code>编码</strong>。 字符串的值为<code>双引号(&quot;)</code>中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := <span class="string">&quot;hello&quot;</span></span><br><span class="line">s2 := <span class="string">&quot;你好&quot;</span></span><br><span class="line">也可以直接定义原生的字符串，不会进行解析</span><br><span class="line">msgRaw = <span class="string">`我的名\n字是kk`</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h3><p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。</p>
<table>
<thead>
<tr>
<th align="center">转义符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>\r</code></td>
<td align="center">回车符（返回行首）</td>
</tr>
<tr>
<td align="center"><code>\n</code></td>
<td align="center">换行符（直接跳到下一行的同列位置）</td>
</tr>
<tr>
<td align="center"><code>\t</code></td>
<td align="center">制表符</td>
</tr>
<tr>
<td align="center"><code>\&#39;</code></td>
<td align="center">单引号</td>
</tr>
<tr>
<td align="center"><code>\&quot;</code></td>
<td align="center">双引号</td>
</tr>
<tr>
<td align="center"><code>\\</code></td>
<td align="center">反斜杠</td>
</tr>
</tbody></table>
<p>举个例子，我们要打印一个Windows平台下的一个文件路径：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;str := \&quot;c:\\Code\\lesson1\\go.exe\&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><p>Go语言中要定义一个多行字符串时，就必须使用<code>反引号</code>字符：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := <span class="string">`第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">fmt.Println(s1)</span><br></pre></td></tr></table></figure>

<p>反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p>
<h3 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h3><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">len(str)</td>
<td align="center">求长度</td>
</tr>
<tr>
<td align="center">+或fmt.Sprintf</td>
<td align="center">拼接字符串</td>
</tr>
<tr>
<td align="center">strings.Split</td>
<td align="center">分割</td>
</tr>
<tr>
<td align="center">strings.contains</td>
<td align="center">判断是否包含</td>
</tr>
<tr>
<td align="center">strings.HasPrefix,strings.HasSuffix</td>
<td align="center">前缀/后缀判断</td>
</tr>
<tr>
<td align="center">strings.Index(),strings.LastIndex()</td>
<td align="center">子串出现的位置</td>
</tr>
<tr>
<td align="center">strings.Join(a[]string, sep string)</td>
<td align="center">join操作</td>
</tr>
</tbody></table>
<h3 id="byte和rune类型-字符类型（字节和码点）"><a href="#byte和rune类型-字符类型（字节和码点）" class="headerlink" title="byte和rune类型 字符类型（字节和码点）"></a>byte和rune类型 字符类型（字节和码点）</h3><blockquote>
<p>单引号引起来的就是字符</p>
</blockquote>
<p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;中&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;x&#x27;</span></span><br></pre></td></tr></table></figure>

<p>Go 语言的字符有以下两种：</p>
<ol>
<li><code>uint8</code>类型（<strong>整数类型</strong>），或者叫 byte 型，代表了<code>ASCII码</code>的一个字符。</li>
<li><code>rune</code>类型（<strong>整数类型</strong>），代表一个 <code>UTF-8字符</code>。可以表是一个中文字符</li>
</ol>
<p>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型。<code>rune</code>类型实际是一个<code>uint32</code>。</p>
<p>Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traversalString</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;hello沙河&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123; <span class="comment">//byte</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v(%c) &quot;</span>, s[i], s[i])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123; <span class="comment">//rune</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v(%c) &quot;</span>, r, r)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 230(æ) 178(²) 153() 230(æ) 178(²) 179(³) </span><br><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 27801(沙) 27827(河) </span><br></pre></td></tr></table></figure>

<p>因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。</p>
<p>字符串底层是一个byte数组，所以可以和<code>[]byte</code>类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以<strong>字符串的长度是byte字节的长度</strong>。 rune类型用来表示utf8字符，<strong>一个rune字符由一个或多个byte组成</strong>。</p>
<h3 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h3><p>要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeString</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := <span class="string">&quot;big&quot;</span></span><br><span class="line">    <span class="comment">// 强制类型转换</span></span><br><span class="line">    byteS1 := []<span class="keyword">byte</span>(s1)</span><br><span class="line">    byteS1[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span></span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(byteS1))</span><br><span class="line"></span><br><span class="line">    s2 := <span class="string">&quot;白萝卜&quot;</span></span><br><span class="line">    runeS2 := []<span class="keyword">rune</span>(s2)</span><br><span class="line">    runeS2[<span class="number">0</span>] = <span class="string">&#x27;红&#x27;</span></span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(runeS2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>在 go 语言中使用 type 声明一种新的类型，语法格式为： type TypeName Formatter</p>
<p>比如我们可以定义自己</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Gender <span class="keyword">string</span></span><br><span class="line"><span class="keyword">type</span> add <span class="function"><span class="keyword">func</span><span class="params">(a, b init)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>



<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。</p>
<p>强制类型转换的基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">T(表达式)</span><br></pre></td></tr></table></figure>

<p>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.</p>
<p>比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrtDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">    <span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// math.Sqrt()接收的参数是float64类型，需要强制转换</span></span><br><span class="line">    c = <span class="keyword">int</span>(math.Sqrt(<span class="keyword">float64</span>(a*a + b*b)))</span><br><span class="line">    fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h2><table>
<thead>
<tr>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>array</td>
<td></td>
<td>值类型</td>
</tr>
<tr>
<td>struct</td>
<td></td>
<td>值类型</td>
</tr>
<tr>
<td>string</td>
<td>“”</td>
<td>UTF-8字符串</td>
</tr>
<tr>
<td>slice</td>
<td>nil</td>
<td>引用类型</td>
</tr>
<tr>
<td>map</td>
<td>nil</td>
<td>引用类型</td>
</tr>
<tr>
<td>channel</td>
<td>nil</td>
<td>引用类型</td>
</tr>
<tr>
<td>interface</td>
<td>nil</td>
<td>接口</td>
</tr>
<tr>
<td>function</td>
<td>nil</td>
<td>函数</td>
</tr>
</tbody></table>
<p>在 Go 语言中，值类型和引用类型是两种不同的数据类型，它们的主要区别在于变量赋值或传递时的行为。</p>
<p>值类型<br>值类型在赋值或传递时，会拷贝整个值，即创建一个副本，修改副本不会影响原始值。<br>常见的值类型：<br>基本数据类型：int、float、bool、string 等<br>数组：[N]T<br>结构体：struct<br>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    b := a <span class="comment">// 值拷贝</span></span><br><span class="line">    b = <span class="number">20</span></span><br><span class="line">    fmt.Println(a, b) <span class="comment">// 输出：10 20，修改 b 不影响 a</span></span><br><span class="line"></span><br><span class="line">    arr1 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    arr2 := arr1 <span class="comment">// 值拷贝</span></span><br><span class="line">    arr2[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">    fmt.Println(arr1, arr2) <span class="comment">// 输出：[1 2 3] [100 2 3]，修改 arr2 不影响 arr1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用类型<br>引用类型在赋值或传递时，会拷贝引用，即多个变量指向同一块内存，修改其中一个会影响其他引用。<br>常见的引用类型：<br>切片：[]T<br>映射：map<br>通道：chan<br>接口：interface<br>指针：*T<br>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    s2 := s1 <span class="comment">// 引用拷贝</span></span><br><span class="line">    s2[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">    fmt.Println(s1, s2) <span class="comment">// 输出：[100 2 3] [100 2 3]，修改 s2 会影响 s1</span></span><br><span class="line"></span><br><span class="line">    m1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">    m2 := m1 <span class="comment">// 引用拷贝</span></span><br><span class="line">    m2[<span class="string">&quot;a&quot;</span>] = <span class="number">100</span></span><br><span class="line">    fmt.Println(m1, m2) <span class="comment">// 输出：map[a:100] map[a:100]，修改 m2 会影响 m1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结<br>值类型：赋值或传递时拷贝值，互不影响。<br>引用类型：赋值或传递时拷贝引用，指向同一块内存，互相影响。</p>
]]></content>
  </entry>
  <entry>
    <title>Go-05-运算符</title>
    <url>/posts/25552.html</url>
    <content><![CDATA[<p>运算符</p>
<a id="more"></a>



<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>Go 语言内置的运算符有：</p>
<ol>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
</ol>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">相加</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">相减</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">相乘</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center">相除</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">求余</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> <code>++</code>（自增）和<code>--</code>（自减）在Go语言中是单独的语句，并不是运算符。</p>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">==</td>
<td align="center">检查两个值是否相等，如果相等返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="center">!=</td>
<td align="center">检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="center">&gt;=</td>
<td align="center">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="center">&lt;=</td>
<td align="center">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>
</tbody></table>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;&amp;</td>
<td align="center">逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td>
</tr>
<tr>
<td align="center">||</td>
<td align="center">逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td>
</tr>
<tr>
<td align="center">!</td>
<td align="center">逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td>
</tr>
</tbody></table>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符对整数在内存中的二进制位进行操作。</p>
<p>在需要极致优化的场景中，位运算可以替代部分算术运算，大幅提升效率：</p>
<ul>
<li><strong>快速乘除</strong>：<code>a &lt;&lt; 3</code> 代替 <code>a * 8</code>。</li>
<li><strong>位掩码（Bitmask）</strong>：用单个整数存储多个布尔值，节省内存。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用位掩码管理文件权限（读、写、执行）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ   0b001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WRITE  0b010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXECUTE 0b100</span></span><br><span class="line"><span class="keyword">int</span> permissions = READ | WRITE;  <span class="comment">// 0b011</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>位集合（Bitset）</strong>：压缩存储大量布尔值。</p>
</li>
<li><p><strong>哈希算法</strong>：通过异或操作混合哈希值。</p>
</li>
<li><p><strong>位操作技巧</strong>：如判断奇偶（<code>x &amp; 1</code>）、交换变量（<code>a ^= b; b ^= a; a ^= b;</code>）。</p>
<ul>
<li><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li><p><strong>二进制视角</strong>：任何整数的二进制形式最后一位决定了奇偶性：</p>
<ul>
<li><strong>最后一位为 1</strong> → 奇数（如 <code>5 = 0b101</code>）</li>
<li><strong>最后一位为 0</strong> → 偶数（如 <code>4 = 0b100</code>）</li>
</ul>
</li>
<li><p><strong>按位与（&amp;）操作</strong>：<code>x &amp; 1</code> 会保留最后一位，其他位清零：</p>
<p>python</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 &amp; 1 → 0b101 &amp; 0b001 &#x3D; 0b001 → 1（奇数）</span><br><span class="line">    4 &amp; 1 → 0b100 &amp; 0b001 &#x3D; 0b000 → 0（偶数）</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="对比传统方法"><a href="#对比传统方法" class="headerlink" title="对比传统方法"></a>对比传统方法</h4><ul>
<li><strong>常规方法</strong>：<code>x % 2 == 0</code>（求余判断）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>位运算优势</strong>：硬件直接支持位操作，速度更快（避免除法运算）。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;</td>
<td align="center">参与运算的两数各对应的二进位相与。 （两位均为1才为1）</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1）</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td align="center">左移n位就是乘以2的n次方。 “a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td align="center">右移n位就是除以2的n次方。 “a&gt;&gt;b”是把a的各二进位全部右移b位。</td>
</tr>
<tr>
<td align="center">&amp;^</td>
<td align="center">and not: 右边的位是1，左边的就变成0； 7=&gt; 0111  2=&gt;0010 ———-&gt; 所以7 &amp;^ 2 =&gt;0101 =5</td>
</tr>
</tbody></table>
<p>原码补码反码：<a href="https://www.eefocus.com/fpga/480691">https://www.eefocus.com/fpga/480691</a></p>
<p>对于有符号数而言：</p>
<p>   (1)二进制的最高位是符号位：0表示正数，1表示负数</p>
<p>   (2)正数的原码、反码、补码都一样；</p>
<p>   (3)负数的反码 = 它的原码符号位不变，其他位取反（0 -&gt;1 ; 1-&gt;0 ）；</p>
<p>   (4)负数的补码 = 它的反码 +1；</p>
<p>   (5)0的反码、补码都是0；</p>
<p>   (6)在计算机运算的时候，都是以补码的方式来运算的；</p>
<h3 id="三、典型应用场景"><a href="#三、典型应用场景" class="headerlink" title="三、典型应用场景"></a>三、典型应用场景</h3><ol>
<li><p><strong>权限系统</strong><br>用位掩码表示用户权限，节省存储空间并快速验证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">READ &#x3D; 1 &lt;&lt; 0  # 1 (0b0001)</span><br><span class="line">WRITE &#x3D; 1 &lt;&lt; 1 # 2 (0b0010)</span><br><span class="line">EXECUTE &#x3D; 1 &lt;&lt; 2 # 4 (0b0100)</span><br><span class="line">user_permission &#x3D; READ | WRITE</span><br><span class="line">if user_permission &amp; WRI