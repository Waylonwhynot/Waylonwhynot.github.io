<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>py_day01</title>
    <url>/2020/08/09/py-day01/</url>
    <content><![CDATA[<p>python基础<br>变量·字符串·常用操作</p>
<a id="more"></a>
<h5 id="1-编译型语言和解释型语言的区别"><a href="#1-编译型语言和解释型语言的区别" class="headerlink" title="1. 编译型语言和解释型语言的区别"></a>1. 编译型语言和解释型语言的区别</h5><p>编译型语言(强类型语言) :  一次编译，到处运行 例：c, c++, java等<br>解释型语言(弱类型语言)：不需要编译，直接调用解释器执行 例：php，python， shell</p>
<p>解释型语言修改完后，不需要编译，执行流程是从上到下依次解释执行。shell</p>
<h6 id="1-1-python的优势和劣势"><a href="#1-1-python的优势和劣势" class="headerlink" title="1.1 python的优势和劣势"></a>1.1 python的优势和劣势</h6><p>优势：</p>
<ul>
<li>简单易上手</li>
<li>大量的第三方的安装包  jekins, k8s api包  胶水语言</li>
</ul>
<p>劣势：</p>
<ul>
<li>速度慢 和c, c++, java比</li>
</ul>
<h5 id="2-演示python的安装和pycharm安装"><a href="#2-演示python的安装和pycharm安装" class="headerlink" title="2. 演示python的安装和pycharm安装"></a>2. 演示python的安装和pycharm安装</h5><h5 id="3-python的入门程序"><a href="#3-python的入门程序" class="headerlink" title="3. python的入门程序"></a>3. python的入门程序</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;hellowrold!&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>执行原理：</p>
<blockquote>
<p>右键执行的时候，会自动调用python解释器从上到下依次执行python代码。类比 shell。</p>
</blockquote>
<p>ps: 交互式命令行的执行方式  python3  —-》 ipython</p>
<p>编辑器和命令行式的写法的区别和应用场景：</p>
<blockquote>
<p>编辑器适用于大型的项目，命令行适用于小的测试</p>
</blockquote>
<h5 id="4-python的变量"><a href="#4-python的变量" class="headerlink" title="4. python的变量"></a>4. python的变量</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>+<span class="number">4</span>+<span class="number">5</span>  </span><br><span class="line">y = x*<span class="number">5</span> + <span class="number">6</span></span><br><span class="line">z = y*<span class="number">7</span></span><br><span class="line">print(z)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>变量就是将中间的结果暂存到内存,以便后续程序调用</p>
</blockquote>
<p>类比shell， 和shell中的变量的定义是一致的。<br>但是和shell中不一样的地方的是：shell的等号两边不允许有空格，但是python等号两边也可以没有空格。那为啥必须要有空格？</p>
<ul>
<li>从视觉上会好看一些，调试代码比较舒服</li>
<li>写代码，需要遵循 PEP8 规范  <ul>
<li>变量的等号两边必须是有空格的，各大公司code review</li>
<li><strong>变量名必须要有意义</strong> shell</li>
<li>变量名只能是 字母、数字或下划线的任意组合</li>
<li>变量名建议不使用拼音和中文</li>
<li>变量的要具有意义</li>
<li>变量名不要过长</li>
</ul>
</li>
</ul>
<p><strong>编程语言的三种风格</strong></p>
<ul>
<li><p>大驼峰法    单词的首字母一定是大写的。</p>
<blockquote>
<p>UserName,   GetInfo, 等</p>
</blockquote>
</li>
<li><p>小驼峰法   单词的首字母小写，其余大写 </p>
<blockquote>
<p>userName </p>
</blockquote>
</li>
<li><p>下划线法  单词和单词之间使用下划线拼接</p>
<blockquote>
<p>user_name</p>
</blockquote>
</li>
</ul>
<p>在代码 code review (代码评审) , 我们要求三种风格你可以随便选择一种你喜欢的风格，但是大家在选择完成之后，一定要主要的是，千万别中途换风格。</p>
<h5 id="4-1-中午分享"><a href="#4-1-中午分享" class="headerlink" title="4.1 中午分享"></a>4.1 中午分享</h5><ul>
<li>基础都会，就是让你自己写的时候，写不出来？<blockquote>
<p>前提要多练，应该带着项目练。练完一两个项目之后，自然就熟悉了。如果说，你们公司正在建设自动化运维平台，希望大家勇敢点，去做一些核心的模块。</p>
</blockquote>
</li>
</ul>
<h5 id="5-python的基础数据类型"><a href="#5-python的基础数据类型" class="headerlink" title="5. python的基础数据类型"></a>5. python的基础数据类型</h5><ul>
<li><p>整型</p>
<blockquote>
<p>表示一个整数的</p>
</blockquote>
</li>
<li><p>字符串</p>
<blockquote>
<p> 字符串会嵌套<br>name = “dj’sa’b”  ## 外层双引号，内层要求是单引号<br>name2 = ‘ds”ad”sa’ ## 外层单引号，内层要求是双引号<br>hhh = “dvshavhhhhhhhhhhhhhhh” \</p>
<pre><code>&quot;dsadsadsadsa&quot;</code></pre>
<p>使用三引号<br>kkk = ‘’’<br>dnsajndsandjansdnas<br>曾老师<br>boduo老师<br>‘’’<br>print(kkk, type(kkk))</p>
</blockquote>
</li>
<li><p>布尔</p>
</li>
</ul>
<h6 id="5-1-注释"><a href="#5-1-注释" class="headerlink" title="5.1 注释"></a>5.1 注释</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### : python 注释，unix的注释方式</span><br><span class="line">&#x2F;&#x2F;  : java， c, c++ 的注释方式</span><br><span class="line">&#39;&#39;&#39;&#39;&#39;&#39;&#39;: python多行注释</span><br><span class="line">&#x2F;*</span><br><span class="line">这是多行注释</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="6-输入"><a href="#6-输入" class="headerlink" title="6. 输入"></a>6. 输入</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">###交互程序</span></span><br><span class="line"><span class="comment"># name = input(&quot;请输入名字：&quot;) ### 输入的值的类型是字符串类型的，input程序交互获取到的内容是字符串</span></span><br><span class="line"></span><br><span class="line">num = input(<span class="string">&#x27;请输入数字:&#x27;</span>)</span><br><span class="line">print(type(num)) <span class="comment">### &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">print(int(num) + <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>int(‘12’) : 会将字符串类型的整肃转换成整型</p>
<h4 id="7-流程控制"><a href="#7-流程控制" class="headerlink" title="7. 流程控制"></a>7. 流程控制</h4><h5 id="7-1-分支"><a href="#7-1-分支" class="headerlink" title="7. 1 分支"></a>7. 1 分支</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式:</span><br><span class="line">    开始写逻辑代码  <span class="comment">### 必须要4个空格</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">234</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num == <span class="number">123</span>:</span><br><span class="line">    print(<span class="string">&#x27;dsadsa&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;kkkkkk&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意： if.. else的语句只能执行一个</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#### if elif else   只要满足一个条件，那就会立即执行相应的代码，执行完毕之后立即退出</span></span><br><span class="line"></span><br><span class="line">num = input(<span class="string">&#x27;请输入要比较的数字:&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> int(num) &gt;= <span class="number">22</span>:</span><br><span class="line">    print(<span class="string">&#x27;可以扯证了&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> int(num) &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">&#x27;成年了,可以干一些成年的事了&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> int(num) &lt; <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">&#x27;还是小屁孩&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>只要满足一个条件，那就会立即执行相应的代码，执行完毕之后立即退出</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = input(<span class="string">&#x27;请输入名字:&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&#x27;meet&#x27;</span>:</span><br><span class="line">    age = input(<span class="string">&#x27;请输入年龄:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> int(age) == <span class="number">18</span>:</span><br><span class="line">        print(<span class="string">&#x27;输入全部正确&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> int(age) &gt;= <span class="number">22</span>:</span><br><span class="line">        print(<span class="string">&#x27;xxxxxxxx&#x27;</span>)   </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;年龄输入错误!&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;名字输入错误!&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>if else 我们只能写一个，而elif可以写多个条件表达</strong></p>
<h5 id="7-2-循环控制"><a href="#7-2-循环控制" class="headerlink" title="7.2 循环控制"></a>7.2 循环控制</h5><ul>
<li>while 循环</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 基本款</span></span><br><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">    <span class="comment"># 循环体</span></span><br><span class="line">    <span class="comment"># 如果条件为真，那么循环则执行</span></span><br><span class="line">    <span class="comment"># 如果条件为假，那么循环不执行</span></span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">num = int(input(<span class="string">&#x27;请输入数字:&#x27;</span>))  <span class="comment">## 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> num &gt; <span class="number">0</span>: <span class="comment">### 每次循环num和0会进行比较，没如果为True,则执行代码块中的内容</span></span><br><span class="line">    print(<span class="string">&#x27;dsadsadasdsasa&#x27;</span>)</span><br><span class="line">    num = num - <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:   <span class="comment">#### 循环退出之后，都会执行else中的代码</span></span><br><span class="line">    print(<span class="string">&#x27;last line.....&#x27;</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>两大关键字：<br>break 和 continue：</p>
<ul>
<li>break：    退出整个循环，循环已经退出</li>
<li>continue:  跳出本次循环， 循环并没有退出</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#### break ： 当警察抓到犯人的时候，后面即便有人，也不会做任何操作，直接退出</span></span><br><span class="line"><span class="comment"># num = int(input(&#x27;请输入数字:&#x27;))  ## 12</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># while num &gt; 0: ### 每次循环num和0会进行比较，没如果为True,则执行代码块中的内容</span></span><br><span class="line"><span class="comment">#     num = num - 1  ## 第一次：num=11 第二次：num=10 第三次：num=9，，当num=5</span></span><br><span class="line"><span class="comment">#     if num == 5:</span></span><br><span class="line"><span class="comment">#         break   ### 退出整个循环</span></span><br><span class="line"><span class="comment">#     print(&#x27;后续代码...&#x27;) ## 第一次打印，第二次打印，第三次打印，。。。。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### continue ： 警察查身份证，</span></span><br><span class="line">num = int(input(<span class="string">&#x27;请输入数字:&#x27;</span>))  <span class="comment">## 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> num &gt; <span class="number">0</span>:  <span class="comment">### 每次循环num和0会进行比较，没如果为True,则执行代码块中的内容</span></span><br><span class="line">    num = num - <span class="number">1</span>  <span class="comment">## 第一次：num=11 第二次：num=10 第三次：num=9，，当num=5</span></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">continue</span>  <span class="comment">### 跳出当前循环， 循环并没与退出</span></span><br><span class="line">    print(<span class="string">&#x27;后续代码...&#x27;</span>)  <span class="comment">## 第一次打印，第二次打印，第三次打印，。。。。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>for 循环<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### kkk 代表的是每一次循环的时候，目标对象s中的每一个元素</span></span><br><span class="line"><span class="comment">### 当循环到最后一个元素的时候，会自动退出</span></span><br><span class="line">s = <span class="string">&#x27;pounds&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> kkk <span class="keyword">in</span> s:</span><br><span class="line">    print(kkk)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>总结：任何语言无外乎三大流程控制结构</strong></p>
<ul>
<li>顺序</li>
<li>分支</li>
<li>循环</li>
</ul>
<p>是 姚期智 提出的</p>
<p>能够触类旁通，意思就是python学完之后， 在学go的时候，应该是没没任何压力的。<br>前年，参加校招。西安交大，西安大学<br>java， c++， 但是他们的数据结构和算法的功底非常的深厚</p>
<hr>
<h5 id="8-格式化输出"><a href="#8-格式化输出" class="headerlink" title="8. 格式化输出"></a>8. 格式化输出</h5><p>% , format</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 第一种写法：字符串使用+ 不断的进行拼接</span></span><br><span class="line"><span class="comment"># name = input(&#x27;请输入姓名:&#x27;)</span></span><br><span class="line"><span class="comment"># age = input(&#x27;请输入年龄:&#x27;)</span></span><br><span class="line"><span class="comment"># job = input(&#x27;请输入职业:&#x27;)</span></span><br><span class="line"><span class="comment"># hobby = input(&#x27;请输入爱好:&#x27;)</span></span><br><span class="line"><span class="comment"># a = &#x27;------------ info of 51devops ----------&#x27;</span></span><br><span class="line"><span class="comment"># b = &#x27;Name:&#x27;</span></span><br><span class="line"><span class="comment"># c = &#x27;Age:&#x27;</span></span><br><span class="line"><span class="comment"># d = &#x27;Job:&#x27;</span></span><br><span class="line"><span class="comment"># e = &#x27;Hobby:&#x27;</span></span><br><span class="line"><span class="comment"># f = &#x27;------------- end ----------------&#x27;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># print(a+&#x27;\n&#x27;+b+name+&#x27;\n&#x27;+c+age+&#x27;\n&#x27;+d+job+&#x27;\n&#x27;+e+hobby+&#x27;\n&#x27;+f)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 第二种方法, 也有人用，用的还挺多。但是要求格式化传入的值和占位符的值需要一一对应</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># name = input(&#x27;请输入姓名:&#x27;)</span></span><br><span class="line"><span class="comment"># age = input(&#x27;请输入年龄:&#x27;)</span></span><br><span class="line"><span class="comment"># job = input(&#x27;请输入职业:&#x27;)</span></span><br><span class="line"><span class="comment"># hobby = input(&#x27;请输入爱好:&#x27;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># msg = &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># ------------ info of 51devops ----------</span></span><br><span class="line"><span class="comment"># Name  : %s</span></span><br><span class="line"><span class="comment"># Age   : %s</span></span><br><span class="line"><span class="comment"># job   : %s</span></span><br><span class="line"><span class="comment"># Hobbie: %s</span></span><br><span class="line"><span class="comment"># ------------- end ----------------</span></span><br><span class="line"><span class="comment"># &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># ### % 格式化的  而msg中的%s叫字符串占位符，</span></span><br><span class="line"><span class="comment"># print(msg % (age, name, job, hobby))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 第三种方法， 使用format函数来进行格式化</span></span><br><span class="line">name = input(<span class="string">&#x27;请输入姓名:&#x27;</span>)</span><br><span class="line">age = input(<span class="string">&#x27;请输入年龄:&#x27;</span>)</span><br><span class="line">job = input(<span class="string">&#x27;请输入职业:&#x27;</span>)</span><br><span class="line">hobby = input(<span class="string">&#x27;请输入爱好:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">msg = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">------------ info of 51devops ----------</span></span><br><span class="line"><span class="string">Name  : &#123;name1&#125;</span></span><br><span class="line"><span class="string">Age   : &#123;age1&#125;</span></span><br><span class="line"><span class="string">job   : &#123;job1&#125;</span></span><br><span class="line"><span class="string">Hobbie: &#123;hobby1&#125;</span></span><br><span class="line"><span class="string">------------- end ----------------</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">print(msg.format(age1=age, name1=name, job1=job, hobby1=hobby))</span><br></pre></td></tr></table></figure>

<h5 id="9-运算符"><a href="#9-运算符" class="headerlink" title="9. 运算符"></a>9. 运算符</h5><ul>
<li>算数运算</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">% ： 取余数</span><br><span class="line">// : 取整数</span><br></pre></td></tr></table></figure>

<ul>
<li>赋值运算</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">a = a - <span class="number">1</span></span><br><span class="line">a = a / <span class="number">2</span></span><br><span class="line">a = a * <span class="number">2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>逻辑运算</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">and</span> : 与的意思 ， 要求<span class="keyword">and</span>的左右两边的表达式的值都是<span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h5 id="10-索引"><a href="#10-索引" class="headerlink" title="10. 索引"></a>10. 索引</h5><p>提到索引，立马想到的一个概念是：索引都是从 0 开始计数的的</p>
<p>10.1索引的取值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">print(name[<span class="number">0</span>])  <span class="comment">### h</span></span><br><span class="line"><span class="comment"># print(name[6])  ### 报错</span></span><br><span class="line">print(name[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>

<p>10.2 切片 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># name = &#x27;h e l l o w o r l d&#x27;</span></span><br><span class="line"><span class="comment">#         0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">name = <span class="string">&#x27;helloworld&#x27;</span></span><br><span class="line">print(name[<span class="number">4</span>:<span class="number">7</span>]) <span class="comment">### 前包后不包， 或者叫 左闭右开</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># name = &#x27;h e l l o w o r l d&#x27;</span></span><br><span class="line"><span class="string">#         0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="string">                       -3 -2 -1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">name = <span class="string">&#x27;helloworld&#x27;</span></span><br><span class="line"><span class="comment"># print(name[4:7]) ### 前包后不包， 或者叫 左闭右开</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(name[:]) ### 从头切到尾</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(name[:5])  ### hello  从开始切刀5</span></span><br><span class="line"><span class="comment"># print(name[2:])  ### 从2开始切刀最后</span></span><br><span class="line"></span><br><span class="line">print(name[<span class="number">2</span>:<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>字典</li>
<li>列表</li>
<li>集合</li>
</ul>
<p>给数据结构和算法<br><a href="https://www.bilibili.com/video/BV1HA411b7ik">https://www.bilibili.com/video/BV1HA411b7ik</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>py_day02_exercise</title>
    <url>/2020/08/09/py-day02-exercise/</url>
    <content><![CDATA[<p>温故知新</p>
<a id="more"></a>
<h3 id="1-根据需求写代码"><a href="#1-根据需求写代码" class="headerlink" title="1.根据需求写代码"></a>1.根据需求写代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;<span class="string">&#x27;k1&#x27;</span>: <span class="string">&quot;v1&quot;</span>, <span class="string">&quot;k2&quot;</span>: <span class="string">&quot;v2&quot;</span>, <span class="string">&quot;k3&quot;</span>: [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请在字典中添加一个键值对，&quot;k4&quot;: &quot;v4&quot;，输出添加后的字典</span></span><br><span class="line">dic[<span class="string">&#x27;k4&#x27;</span>] = <span class="string">&#x27;v4&#x27;</span></span><br><span class="line">print(dic)</span><br><span class="line"><span class="comment"># 请在修改字典中 &quot;k1&quot; 对应的值为 &quot;alex&quot;，输出修改后的字典</span></span><br><span class="line">dic[<span class="string">&#x27;k1&#x27;</span>] = <span class="string">&#x27;alex&#x27;</span></span><br><span class="line">print(dic)</span><br><span class="line"><span class="comment"># 请在k3对应的值中追加一个元素 44，输出修改后的字典</span></span><br><span class="line">dic[<span class="string">&#x27;k3&#x27;</span>].append(<span class="number">44</span>)</span><br><span class="line">print(dic)</span><br><span class="line"><span class="comment"># 请在k3对应的值的第 1 个位置插入个元素 18，输出修改后的字典</span></span><br><span class="line">dic[<span class="string">&#x27;k3&#x27;</span>].insert(<span class="number">0</span>,<span class="number">18</span>)</span><br><span class="line">print(dic)</span><br></pre></td></tr></table></figure>

<h3 id="2-根据需求写代码"><a href="#2-根据需求写代码" class="headerlink" title="2.根据需求写代码"></a>2.根据需求写代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic1 = &#123;</span><br><span class="line"> <span class="string">&#x27;name&#x27;</span>:[<span class="string">&#x27;pounds&#x27;</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>],</span><br><span class="line"> <span class="string">&#x27;job&#x27;</span>:<span class="string">&#x27;teacher&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;51devops&#x27;</span>:&#123;<span class="string">&#x27;szk&#x27;</span>:[<span class="string">&#x27;python1&#x27;</span>,<span class="string">&#x27;python2&#x27;</span>,<span class="number">100</span>]&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1，将name对应的列表追加⼀个元素’xxx’。</span></span><br><span class="line">dic1[<span class="string">&#x27;name&#x27;</span>].append(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">print(dic1)</span><br><span class="line"><span class="comment"># 2，将name对应的列表中的 pounds ⾸字⺟⼤写。</span></span><br><span class="line">(<span class="number">1</span>)转成大写后upadte</span><br><span class="line">new_words = dic1[<span class="string">&#x27;name&#x27;</span>][<span class="number">0</span>].capitalize()</span><br><span class="line">dic1.update(&#123;<span class="string">&#x27;name&#x27;</span>:[new_words,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]&#125;)</span><br><span class="line">(<span class="number">2</span>)直接赋值更改</span><br><span class="line">dic1[<span class="string">&#x27;name&#x27;</span>][<span class="number">0</span>] = <span class="string">&#x27;Pounds&#x27;</span></span><br><span class="line">print(dic1)</span><br><span class="line"><span class="comment"># 3，51devops 对应的字典加⼀个键值对 ’haoda’,’linux’。</span></span><br><span class="line">dic1[<span class="string">&#x27;51devops&#x27;</span>][<span class="string">&#x27;haoda&#x27;</span>] = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">print(dic1)</span><br><span class="line"><span class="comment"># 4，将51devops对应的字典中的szk对应的列表中的python2删除</span></span><br><span class="line">dic1[<span class="string">&#x27;51devops&#x27;</span>][<span class="string">&#x27;szk&#x27;</span>].remove(<span class="string">&#x27;python2&#x27;</span>)</span><br><span class="line">print(dic1)</span><br></pre></td></tr></table></figure>

<h3 id="3-判断以下值那个能做字典的key-？那个能做集合的元素？"><a href="#3-判断以下值那个能做字典的key-？那个能做集合的元素？" class="headerlink" title="3.判断以下值那个能做字典的key ？那个能做集合的元素？"></a>3.判断以下值那个能做字典的key ？那个能做集合的元素？</h3><ul>
<li>1       ✅</li>
<li>-1      ✅</li>
<li>“”      ✅</li>
<li>None    ✅</li>
<li>[1,2]   ❌</li>
<li>(1,)    ✅</li>
<li>{11,22,33,4} ❌</li>
<li>{‘name’:’szk’,’age’:18} ❌</li>
</ul>
<h3 id="4-将字典的键和值分别追加到-key-list-和-value-list-两个列表中，如："><a href="#4-将字典的键和值分别追加到-key-list-和-value-list-两个列表中，如：" class="headerlink" title="4.将字典的键和值分别追加到 key_list 和 value_list 两个列表中，如："></a>4.将字典的键和值分别追加到 key_list 和 value_list 两个列表中，如：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">key_list = []</span><br><span class="line">value_list = []</span><br><span class="line">info = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="string">&#x27;v1&#x27;</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="string">&#x27;v2&#x27;</span>,<span class="string">&#x27;k3&#x27;</span>:<span class="string">&#x27;v3&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> info.items():</span><br><span class="line">    key_list.append(k)</span><br><span class="line">    value_list.append(v)</span><br><span class="line">print(key_list)</span><br><span class="line">print(value_list)</span><br></pre></td></tr></table></figure>

<h3 id="5-字典dic-‘k1’-“v1”-“k2”-“v2”-“k3”-11-22-33"><a href="#5-字典dic-‘k1’-“v1”-“k2”-“v2”-“k3”-11-22-33" class="headerlink" title="5.字典dic = {‘k1’: “v1”, “k2”: “v2”, “k3”: [11,22,33]}"></a>5.字典dic = {‘k1’: “v1”, “k2”: “v2”, “k3”: [11,22,33]}</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;<span class="string">&#x27;k1&#x27;</span>: <span class="string">&quot;v1&quot;</span>, <span class="string">&quot;k2&quot;</span>: <span class="string">&quot;v2&quot;</span>, <span class="string">&quot;k3&quot;</span>: [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>]&#125;</span><br><span class="line"><span class="comment"># a. 请循环输出所有的key</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> dic.keys():</span><br><span class="line">    print(k)</span><br><span class="line"><span class="comment"># b. 请循环输出所有的value</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> dic.values():</span><br><span class="line">    print(v)</span><br><span class="line"><span class="comment"># c. 请循环输出所有的key和value</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> dic.items():</span><br><span class="line">    print(k,v)</span><br><span class="line"><span class="comment"># d. 请在字典中添加一个键值对，&quot;k4&quot;: &quot;v4&quot;，输出添加后的字典</span></span><br><span class="line">dic[<span class="string">&#x27;k4&#x27;</span>] = <span class="string">&#x27;v4&#x27;</span></span><br><span class="line">print(dic)</span><br><span class="line"><span class="comment"># e. 请在修改字典中 &quot;k1&quot; 对应的值为 &quot;szk&quot;，输出修改后的字典</span></span><br><span class="line">dic[<span class="string">&#x27;k1&#x27;</span>] = <span class="string">&#x27;szk&#x27;</span></span><br><span class="line">print(dic)</span><br><span class="line"><span class="comment"># f. 请在k3对应的值中追加一个元素 44，输出修改后的字典</span></span><br><span class="line">dic[<span class="string">&#x27;k3&#x27;</span>].append(<span class="number">44</span>)</span><br><span class="line">print(dic)</span><br><span class="line"><span class="comment"># g. 请在k3对应的值的第 1 个位置插入个元素 18，输出修改后的字典</span></span><br><span class="line">dic[<span class="string">&#x27;k3&#x27;</span>].insert(<span class="number">0</span>,<span class="number">18</span>)</span><br><span class="line">print(dic)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-请循环打印k2对应的值中的每个元素。"><a href="#6-请循环打印k2对应的值中的每个元素。" class="headerlink" title="6.请循环打印k2对应的值中的每个元素。"></a>6.请循环打印k2对应的值中的每个元素。</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info = &#123;</span><br><span class="line">    <span class="string">&#x27;k1&#x27;</span>:<span class="string">&#x27;v1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;k2&#x27;</span>:[(<span class="string">&#x27;pounds&#x27;</span>),(<span class="string">&#x27;szk&#x27;</span>),(<span class="string">&#x27;51devops&#x27;</span>)],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> values <span class="keyword">in</span> info[<span class="string">&#x27;k2&#x27;</span>]:</span><br><span class="line">    print(values)</span><br></pre></td></tr></table></figure>

<h3 id="7-输出商品列表，用户输入序号，显示用户选中的商品"><a href="#7-输出商品列表，用户输入序号，显示用户选中的商品" class="headerlink" title="7.输出商品列表，用户输入序号，显示用户选中的商品"></a>7.输出商品列表，用户输入序号，显示用户选中的商品</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tag = <span class="literal">True</span></span><br><span class="line"><span class="comment">#购物车</span></span><br><span class="line">bag = []</span><br><span class="line"><span class="comment">#购物车商品总价格</span></span><br><span class="line">bag_price = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> tag:</span><br><span class="line">    <span class="keyword">for</span> inx,value <span class="keyword">in</span> enumerate(goods):</span><br><span class="line">          print(inx,value[<span class="string">&#x27;name&#x27;</span>],value[<span class="string">&#x27;price&#x27;</span>])</span><br><span class="line">    choice = input(<span class="string">&quot;请输入商品编号(退出输入Q/q):&quot;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> choice == <span class="string">&#x27;q&#x27;</span> <span class="keyword">or</span> choice == <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">        print(<span class="string">&quot;您购买的商品列表:%s,一共消费:%s&quot;</span> %(bag,bag_price))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span>  choice.isdigit():</span><br><span class="line">        choice = int(choice)</span><br><span class="line">        <span class="keyword">if</span> choice &gt;= <span class="number">0</span> <span class="keyword">and</span> choice &lt; len(goods):</span><br><span class="line">            print(<span class="string">&#x27;商品:%s  价格:%s&#x27;</span> % (goods[choice][<span class="string">&#x27;name&#x27;</span>], goods[choice][<span class="string">&#x27;price&#x27;</span>]))</span><br><span class="line">            bag.append(goods[choice][<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line">            bag_price += goods[choice][<span class="string">&#x27;price&#x27;</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;输入的编号不存在，请重新输入&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;请输入正确的产品编号&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>python_exercise</category>
      </categories>
      <tags>
        <tag>python_exercise</tag>
      </tags>
  </entry>
  <entry>
    <title>py-day02</title>
    <url>/2020/08/16/py-day02/</url>
    <content><![CDATA[<p>python基础<br>列表 字典 集合 函数(位置参数， 关键字参数， 默认参数) 对文件操作</p>
<a id="more"></a>

<ul>
<li><p>python的基础数据结构</p>
<ul>
<li>整型     1，2，3，</li>
<li>字符串  <ul>
<li>单引号  ‘hello’</li>
<li>双引号  “hello”</li>
<li>三引号  “”””””</li>
</ul>
</li>
<li>布尔类型<ul>
<li>True  </li>
<li>False  注意的是：js true false</li>
</ul>
</li>
</ul>
</li>
<li><p>python的变量</p>
<ul>
<li>变量的作用：保存中间结果    num = 1+2+3    </li>
<li>变量的命名规范：<ul>
<li>PEP8规范</li>
<li>等于号的左右两边是要有空格的</li>
<li><strong>变量名一定要有意义</strong>  name = “szk”</li>
<li>变量的几种风格  ： 大驼峰，小驼峰，下划线</li>
<li>变量命名规范：不能使用关键字命名，不能以数字开头</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串的用法</p>
<ul>
<li>split(‘:’) :   name = “szk_age”  name.split(‘_’)   非常重要的一个字符串用法</li>
<li>字符串的格式化： <ul>
<li>%  例子： “曾老师是一个 %s” % （‘大萨达撒‘）</li>
<li>format 例子： “今天天气不错， 看电影 {}”.format(‘xxxxx’)</li>
<li>format 例子： “曾老师性别{sex}, 年龄 {age}”.format(sex=’男’, age=73)</li>
</ul>
</li>
<li>索引：任何语言中的索引，都是从0开始的  name = ‘szk’</li>
<li>切片：就是从一整个元素中切出想要的元素 name = ‘51aiops’ , 可以根据索引来进行切割 <ul>
<li>name[2:6]  索引的原则：前包后不包 </li>
</ul>
</li>
</ul>
</li>
<li><p>流程控制</p>
<ul>
<li>顺序<ul>
<li>代码从上到下依次执行</li>
</ul>
</li>
<li>分支<ul>
<li>if elif else</li>
<li>elif 可以写多个，而if和else只能写一次</li>
<li><strong>如果有多个分支条件的话，当命中一个条件之后，就会退出整个分支语句</strong></li>
</ul>
</li>
<li>循环<ul>
<li>while  条件: 项目中，用的比较少，算法的时候比较多</li>
<li>for  项目中用的比较多<ul>
<li>for i in ’abcd‘</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>input</li>
<li>条件语句和运算符</li>
<li>赋值运算符 ： <ul>
<li>a = 10   a = a - 1 a += 1   a += 1 ===&gt; a = a - 1</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a><div id="title">今日内容</div></h4><h5 id="1-python基础数据类型之列表和元组"><a href="#1-python基础数据类型之列表和元组" class="headerlink" title="1. python基础数据类型之列表和元组"></a>1. python基础数据类型之列表和元组</h5><ul>
<li><p>列表   其他语言叫数组</p>
<ul>
<li><p>定义：用来存储比较复杂的数据 </p>
</li>
<li><p>用法：name_list = [‘老陈’, ‘老赵’,  ‘文亮’] </p>
</li>
<li><p>定义2： name_list = list() </p>
</li>
<li><p>增删改查  常用的方法： remove， pop， append，for循环 改索引</p>
<p>pop, remove，和del的区别：</p>
</li>
<li><p>pop弹出，弹出之后的元素是可以赋值给其他变量用的</p>
</li>
<li><p>remove和del, 直接删除元素</p>
</li>
<li><p>remove就是通过值删除这个元素</p>
</li>
<li><p>del 通过索引来删除值</p>
<p>pop 是弹出，后面可以引用，remove，del好像是直接删除    </p>
</li>
</ul>
</li>
<li><p>列表的切片：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">user_list = [<span class="string">&quot;王宝强&quot;</span>,<span class="string">&quot;陈羽凡&quot;</span>,<span class="string">&quot;贾乃亮&quot;</span>, <span class="string">&#x27;xxxx&#x27;</span>, <span class="string">&#x27;波多老师&#x27;</span>]</span><br><span class="line">                <span class="comment"># 0      1       2        3       4</span></span><br><span class="line">                <span class="comment"># -5    -4       -3      -2       -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 通过索引下标来获取子列表</span></span><br><span class="line"><span class="comment">### 符合前包后不包的原则</span></span><br><span class="line">users = user_list[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">print(users)</span><br><span class="line">users = user_list[:]  <span class="comment">### 表示的是 从头切到尾</span></span><br><span class="line">users = user_list[<span class="number">2</span>:] <span class="comment">### 表示的是 从2 开始切到结尾</span></span><br><span class="line">users = user_list[:<span class="number">4</span>] <span class="comment">## 从头开始切</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>列表的循环</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">### for循环打印</span></span><br><span class="line">user_list = [<span class="string">&quot;范德彪&quot;</span>,<span class="string">&quot;刘华强&quot;</span>,<span class="string">&#x27;尼古拉斯赵四&#x27;</span>,<span class="string">&quot;宋小宝&quot;</span>,<span class="string">&quot;刘能&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> user_list:</span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(user_list):</span><br><span class="line">    print(i, v)</span><br></pre></td></tr></table></figure>
<p><strong>只需要元素，则使用第一种循环， 若需要索引下标，则使用第二种循环</strong></p>
<ul>
<li>列表和字符串的互相转换<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 1.字符串转列表</span></span><br><span class="line">name = <span class="string">&quot;hello_world&quot;</span></span><br><span class="line">names = name.split(<span class="string">&#x27;_&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(names)<span class="comment">#### [&#x27;hello&#x27;, &#x27;world&#x27;]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 2. 列表转字符串</span></span><br><span class="line">names_list = [<span class="string">&quot;范德彪&quot;</span>,<span class="string">&quot;刘华强&quot;</span>,<span class="string">&#x27;尼古拉斯赵四&#x27;</span>,<span class="string">&quot;宋小宝&quot;</span>,<span class="string">&quot;刘能&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">### 将上述元素通过下划线拼接成字符串</span></span><br><span class="line">res = <span class="string">&#x27;_&#x27;</span>.join(names_list)</span><br><span class="line">print(res, type(res))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>列表的增删改查，下去复习列表的基本操作的时候，遵循这个增删改查的原则</strong></p>
<h5 id="2-python的基础数据类型之字典和集合"><a href="#2-python的基础数据类型之字典和集合" class="headerlink" title="2. python的基础数据类型之字典和集合"></a>2. python的基础数据类型之字典和集合</h5><p><strong>字典和列表一样的重要</strong></p>
<p>python里叫字典，而其他语言java： 哈希table   hashtable</p>
<p>定义方式：</p>
<p>最长用的两种</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第一种：</span><br><span class="line"><span class="comment"># info = &#123;</span></span><br><span class="line"><span class="comment">#     &quot;name&quot;: &#x27;szk&#x27;,</span></span><br><span class="line"><span class="comment">#     &quot;age&quot; : 18,</span></span><br><span class="line"><span class="comment">#     &quot;height&quot;: 180</span></span><br><span class="line"><span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line">第二种</span><br><span class="line">user_info = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;陈顺阳&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span>:<span class="number">30</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;杜峰&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span>:<span class="number">32</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;pounds&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span>:<span class="number">32</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>字典的增删改查（crud）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">info = &#123;<span class="string">&quot;age&quot;</span>:<span class="number">12</span>, <span class="string">&quot;status&quot;</span>:<span class="literal">True</span>, <span class="string">&quot;name&quot;</span>:<span class="string">&quot;szk&quot;</span>,<span class="string">&quot;email&quot;</span>:<span class="string">&quot;xx@live.com&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">### 1.获取字典的键</span></span><br><span class="line"><span class="comment"># keys = info.keys()</span></span><br><span class="line"><span class="comment"># for k in keys:</span></span><br><span class="line"><span class="comment">#     print(k)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ### 2. 获取字典的所有值</span></span><br><span class="line"><span class="comment"># values = info.values()</span></span><br><span class="line"><span class="comment"># for v in values:</span></span><br><span class="line"><span class="comment">#     print(v)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 3.要获取字典的值又要获取字典的key, 非常重要的方法</span></span><br><span class="line"><span class="comment"># for k, v in info.items():</span></span><br><span class="line"><span class="comment">#     print(k, v)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 根据键来获取值  重要</span></span><br><span class="line"><span class="comment"># print(info[&#x27;height&#x27;])</span></span><br><span class="line">data = info.get(<span class="string">&quot;height&quot;</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment"># 根据name为键去info字典中获取对应的值，如果不存在则返回None，存在则返回值。</span></span><br><span class="line">print(data) <span class="comment"># 输出：None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 4.更新键值对</span></span><br><span class="line"><span class="comment"># info2 = &#123;&quot;age&quot;:12, &quot;status&quot;:True&#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># # info2.update(age=14, name=&#x27;szk&#x27;) ### 如果key存在的话，就会更新原有的值，若不存在，将这个name值加入info2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 5.增加</span></span><br><span class="line"><span class="comment"># info2[&#x27;name&#x27;] = &#x27;szk&#x27; ###向字典中添加一个元素</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># print(info2)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 6.删除</span></span><br><span class="line">info2 = &#123;<span class="string">&quot;age&quot;</span>:<span class="number">12</span>, <span class="string">&quot;status&quot;</span>:<span class="literal">True</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;szk&quot;</span>&#125;</span><br><span class="line"><span class="comment"># data = info2.pop(&quot;age&quot;) ### 根据键来删除元素</span></span><br><span class="line"><span class="comment"># print(info2) # &#123;&#x27;status&#x27;: True, &#x27;name&#x27;: &#x27;szk&#x27;&#125;</span></span><br><span class="line"><span class="comment"># print(data) # 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> info2[<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line">print(info2)</span><br></pre></td></tr></table></figure>

<ul>
<li>集合的特性<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 2.交集</span></span><br><span class="line">s1 = &#123;<span class="string">&quot;刘能&quot;</span>, <span class="string">&quot;赵四&quot;</span>, <span class="string">&quot;⽪⻓⼭&quot;</span>&#125;</span><br><span class="line">s2 = &#123;<span class="string">&quot;刘科⻓&quot;</span>, <span class="string">&quot;冯乡⻓&quot;</span>, <span class="string">&quot;⽪⻓⼭&quot;</span>&#125;</span><br><span class="line">s3 = s1 &amp; s2                 <span class="comment"># 方式一：取两个集合的交集</span></span><br><span class="line">s4 = s1.intersection(s2) <span class="comment"># 方</span></span><br><span class="line"></span><br><span class="line">print(s3, s4)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 3.并集</span></span><br><span class="line">s1 = &#123;<span class="string">&quot;刘能&quot;</span>, <span class="string">&quot;赵四&quot;</span>, <span class="string">&quot;⽪⻓⼭&quot;</span>&#125;</span><br><span class="line">s2 = &#123;<span class="string">&quot;刘科⻓&quot;</span>, <span class="string">&quot;冯乡⻓&quot;</span>, <span class="string">&quot;⽪⻓⼭&quot;</span>&#125;</span><br><span class="line">s3 = s1 | s2               <span class="comment"># 方式一：取两个集合的并集</span></span><br><span class="line">s4 = s1.union(s2)</span><br><span class="line"></span><br><span class="line">print(s3, s4)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 4.差集</span></span><br><span class="line">s1 = &#123;<span class="string">&quot;刘能&quot;</span>, <span class="string">&quot;赵四&quot;</span>, <span class="string">&quot;⽪⻓⼭&quot;</span>&#125;</span><br><span class="line">s2 = &#123;<span class="string">&quot;刘科⻓&quot;</span>, <span class="string">&quot;冯乡⻓&quot;</span>, <span class="string">&quot;⽪⻓⼭&quot;</span>&#125;</span><br><span class="line">s3 = s1 - s2                       <span class="comment"># 方式一：差集，s1中有且s2中没有的值</span></span><br><span class="line">s4 = s1.difference(s2)         <span class="comment"># 方式二：差集，s1中有且s2中没有的值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>列表和集合的转换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v1 = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">99</span>,<span class="number">22</span>]</span><br><span class="line">s1 = set(v1)</span><br><span class="line">l1 = list(s1)</span><br><span class="line">print(l1)</span><br></pre></td></tr></table></figure>

<h5 id="3-python对文件的操作"><a href="#3-python对文件的操作" class="headerlink" title="3. python对文件的操作"></a>3. python对文件的操作</h5><blockquote>
<p>主要学习就是文件打开的几种模式，，项目中涉及到就是文件上传和下载</p>
</blockquote>
<p>主要的文件打开方式：</p>
<p>模式： w, r, r+<br>方法： open, close, read, write<br>上下文管理器：推崇的方式</p>
<p>#####4. python的函数 基础入门</p>
<blockquote>
<p>重点：函数的参数</p>
</blockquote>
<p>函数的定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shell:</span><br><span class="line">    func test()&#123;</span><br><span class="line">        函数体</span><br><span class="line">    &#125;</span><br><span class="line">    test() <span class="comment">### 函数的调用</span></span><br><span class="line">python:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">        函数体</span><br><span class="line">    test() <span class="comment">### 函数调用</span></span><br></pre></td></tr></table></figure>
<h5 id="4-函数的参数"><a href="#4-函数的参数" class="headerlink" title="4.函数的参数"></a>4.函数的参数</h5><ul>
<li>参数的分类<ul>
<li>位置参数</li>
<li>关键字参数</li>
<li>动态接收参数</li>
</ul>
</li>
</ul>
<p>参数组合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">第一种：</span><br><span class="line">位置参数， 关键字参数， 默认参数</span><br><span class="line">test(a, b, c=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">第二种：</span><br><span class="line">动态接收位置参数， 动态接收关键字参数配合起来使用</span><br><span class="line">test(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">dic = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">    print(kwargs)</span><br><span class="line">func(**dic)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结:位置参数 &gt; args(动态位置参数) &gt; 默认值参数 &gt; *kwargs(动态默认参数)，这四种参数可以任意的使用</p>
</blockquote>
<p>如果想接收所有的参数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">    print(args,kwargs)</span><br><span class="line">func(<span class="number">1</span>,<span class="number">23</span>,<span class="number">5</span>,a=<span class="number">1</span>,b=<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>动态参数还可以这样传参:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>]</span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">*args</span>):</span></span><br><span class="line">    print(args)</span><br><span class="line">func(lst[<span class="number">0</span>],lst[<span class="number">1</span>],lst[<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">*args</span>):</span></span><br><span class="line">    print(args)</span><br><span class="line">func(*lst)  </span><br><span class="line"><span class="comment"># 在实参的位置上用*将lst(可迭代对象)按照顺序打散</span></span><br><span class="line"><span class="comment"># 在形参的位置上用*把收到的参数组合成一个元祖</span></span><br></pre></td></tr></table></figure>
<p>字典也可以进行打散,不过需要**</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">    print(kwargs)</span><br><span class="line">func(**dic)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>py-day04</title>
    <url>/2020/08/29/py-day04/</url>
    <content><![CDATA[<p>python基础<br>函数高级操作(生成器、迭代器、装饰器)+模块(request json)</p>
<a id="more"></a>

<h4 id="复习"><a href="#复习" class="headerlink" title="复习"></a><div id="title">复习</div></h4><p>函数部分：</p>
<p>0.函数嵌套</p>
<ul>
<li>一个函数中可以调用另一个函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;fuc1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">    func1()</span><br><span class="line">    print(<span class="string">&#x27;func2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">func2()</span><br></pre></td></tr></table></figure>

<ul>
<li>只要遇见了()就是函数的调用. 如果没有()就不是函数的调用</li>
<li>函数的执行顺序</li>
</ul>
<p>1.内置函数</p>
<ul>
<li>数学计算<ul>
<li>sum</li>
<li>abs</li>
<li>divmod</li>
<li>round</li>
<li>pow</li>
<li>min， max</li>
</ul>
</li>
<li>数据结构相关<ul>
<li>list() 将一个可迭代对象转换成列表</li>
<li>tuple() 将一个可迭代对象转换成元组</li>
<li><strong>bytes() 把字符串类型转换成bytes类型</strong> 重要</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python2中经常使用的编码方式</span><br><span class="line">s = <span class="string">&#x27;你好武大&#x27;</span></span><br><span class="line">bs = s.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">print(bs)</span><br><span class="line">结果:<span class="string">b&#x27;\xe4\xbd\xa0\xe5\xa5\xbd\xe6\xad\xa6\xe5\xa4\xa7&#x27;</span></span><br><span class="line">s1 = bs.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">print(s1)</span><br><span class="line">结果: 你好武大</span><br><span class="line"></span><br><span class="line">python3中使用如下方式</span><br><span class="line">s = <span class="string">&#x27;你好&#x27;</span></span><br><span class="line">bs = bytes(s,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">print(bs)</span><br><span class="line"><span class="comment"># 将字符串转换成字节</span></span><br><span class="line">bs1 = str(bs,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">print(bs1)</span><br></pre></td></tr></table></figure>

<ul>
<li>enumerate  对列表的高级操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;lisi&#x27;</span>,<span class="string">&#x27;wangwu&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i,k <span class="keyword">in</span> enumerate(lst):</span><br><span class="line">    print(<span class="string">&#x27;这是序号&#x27;</span>,i)</span><br><span class="line">    print(<span class="string">&#x27;这是元素&#x27;</span>,k)</span><br></pre></td></tr></table></figure>

<p>2.匿名函数 lambada  面试问的较多 (<strong>和sorted函数配合使用</strong>)</p>
<blockquote>
<p>没有名字的函数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">在项目中单独使用lambada的情况，不是很多。</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">和 sorted 一起使用的时候，比较多。</span><br><span class="line">项目中有很多需要对数据进行排序的需求</span><br><span class="line"></span><br><span class="line">salaries = &#123;</span><br><span class="line">  <span class="string">&#x27;szk&#x27;</span>:<span class="number">30000</span>,</span><br><span class="line">  <span class="string">&#x27;zhangsan&#x27;</span>:<span class="number">888888888</span>,</span><br><span class="line">  <span class="string">&#x27;nick&#x27;</span>:<span class="number">2000</span>,</span><br><span class="line">  <span class="string">&#x27;pounds&#x27;</span>:<span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line">sorted(salaries, key=<span class="keyword">lambda</span> name:salaries[name])</span><br></pre></td></tr></table></figure>


<p>3.迭代器 和for循环机制 <strong>面试中的重点</strong></p>
<blockquote>
<p>如果一个变量中， 包含有<code>__iter__</code>方法的话，那代表这个就是一个迭代器，可以使用<code>__next__</code>来获取其中的每一个元素<br>使用<code>dir()</code>来进行查看，该方法会将这个元素中所有的方法和属性全部列出来</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(a)</span><br><span class="line">[<span class="string">&#x27;__add__&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__contains__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__getitem__&#x27;</span>, <span class="string">&#x27;__getnewargs__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__iter__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__len__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__mod__&#x27;</span>, <span class="string">&#x27;__mul__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__rmod__&#x27;</span>, <span class="string">&#x27;__rmul__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;capitalize&#x27;</span>, <span class="string">&#x27;casefold&#x27;</span>, <span class="string">&#x27;center&#x27;</span>, <span class="string">&#x27;count&#x27;</span>, <span class="string">&#x27;encode&#x27;</span>, <span class="string">&#x27;endswith&#x27;</span>, <span class="string">&#x27;expandtabs&#x27;</span>, <span class="string">&#x27;find&#x27;</span>, <span class="string">&#x27;format&#x27;</span>, <span class="string">&#x27;format_map&#x27;</span>, <span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;isalnum&#x27;</span>, <span class="string">&#x27;isalpha&#x27;</span>, <span class="string">&#x27;isascii&#x27;</span>, <span class="string">&#x27;isdecimal&#x27;</span>, <span class="string">&#x27;isdigit&#x27;</span>, <span class="string">&#x27;isidentifier&#x27;</span>, <span class="string">&#x27;islower&#x27;</span>, <span class="string">&#x27;isnumeric&#x27;</span>, <span class="string">&#x27;isprintable&#x27;</span>, <span class="string">&#x27;isspace&#x27;</span>, <span class="string">&#x27;istitle&#x27;</span>, <span class="string">&#x27;isupper&#x27;</span>, <span class="string">&#x27;join&#x27;</span>, <span class="string">&#x27;ljust&#x27;</span>, <span class="string">&#x27;lower&#x27;</span>, <span class="string">&#x27;lstrip&#x27;</span>, <span class="string">&#x27;maketrans&#x27;</span>, <span class="string">&#x27;partition&#x27;</span>, <span class="string">&#x27;replace&#x27;</span>, <span class="string">&#x27;rfind&#x27;</span>, <span class="string">&#x27;rindex&#x27;</span>, <span class="string">&#x27;rjust&#x27;</span>, <span class="string">&#x27;rpartition&#x27;</span>, <span class="string">&#x27;rsplit&#x27;</span>, <span class="string">&#x27;rstrip&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;splitlines&#x27;</span>, <span class="string">&#x27;startswith&#x27;</span>, <span class="string">&#x27;strip&#x27;</span>, <span class="string">&#x27;swapcase&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;translate&#x27;</span>, <span class="string">&#x27;upper&#x27;</span>, <span class="string">&#x27;zfill&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = a.__iter__()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&lt;str_iterator object at <span class="number">0x10b4447f0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.__next__()</span><br><span class="line"><span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.__next__()</span><br><span class="line"><span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.__next__()</span><br><span class="line"><span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>

<p>面试考察时，考察点就是：如何判断一个元素是否是迭代器？<br>答： 包含有<code>__iter__</code>方法的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">print(dir(a))  <span class="comment"># dir查看对象的方法和函数</span></span><br><span class="line"><span class="comment"># 在打印结果中寻找__iter__ 如果存在就表示当前的这个类型是个可迭代对象</span></span><br></pre></td></tr></table></figure>

<p>4.生成器  <strong>面试中的重点</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 生成器定义</span></span><br><span class="line"><span class="comment">### 生成器的本质就是迭代器，因此我们可以使用迭代器中的__next__方法来获取元素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    print(<span class="number">11</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">22</span>  <span class="comment">### 将return换成yield关键字即可</span></span><br><span class="line"></span><br><span class="line">ret = func()</span><br><span class="line"><span class="comment"># print(ret.__next__())</span></span><br><span class="line"><span class="comment"># print(ret)  ### &lt;generator object func at 0x103cc80b0&gt; 生成器的对象</span></span><br></pre></td></tr></table></figure>

<p>总结：生成器一定是迭代器，但是迭代器就不一定是生成器</p>
<p>5.列表生成式和字典生成式 []  <strong>项目中的重点</strong></p>
<blockquote>
<p>写法比较pythonic的风格</p>
</blockquote>
<ul>
<li>列表生成式</li>
</ul>
<blockquote>
<p>目的是把一些复杂的代码，写的简单化</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">**传统的写法**</span><br><span class="line">l = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    l.append(i)</span><br><span class="line"></span><br><span class="line">**pythonnic的写法**</span><br><span class="line">格式：[结果 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 可迭代对象]</span><br><span class="line"></span><br><span class="line">l = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**高级的写法**</span><br><span class="line">格式：[结果 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 可迭代对象 <span class="keyword">if</span> 条件]</span><br><span class="line">l = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> i &gt; <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>字典生成式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># **传统方式构造字典**</span></span><br><span class="line">keys=[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;sex&#x27;</span>]</span><br><span class="line">vals=[<span class="string">&#x27;szk&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;male&#x27;</span>]</span><br><span class="line">dic=&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,k <span class="keyword">in</span> enumerate(keys):</span><br><span class="line">    <span class="comment"># print(i,k)</span></span><br><span class="line">    dic[k]=vals[i] <span class="comment">## dic[&#x27;name&#x27;] = vals[0] = &#x27;szk&#x27;</span></span><br><span class="line">print(dic)</span><br><span class="line"></span><br><span class="line"><span class="comment">### **pythonnic方式**</span></span><br><span class="line"></span><br><span class="line">dic = &#123;k:vals[i] <span class="keyword">for</span> i,k <span class="keyword">in</span> enumerate(keys) <span class="keyword">if</span> 条件判断&#125;</span><br></pre></td></tr></table></figure>

<p>总结：笔试和项目中比较常见的问题。推荐大家，代码比较简单的话，使用上面两种方式，而如果代码比较复杂的话，不建议大家使用</p>
<p>5.5 递归函数  <strong>面试中常见问题</strong></p>
<blockquote>
<p>函数自己调用自己</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;hello, f1&#x27;</span>)</span><br><span class="line">    f1()</span><br><span class="line"></span><br><span class="line">f1()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码会报错误，因为，无限制的递归下去，会导致操作系统不断的在内存中开辟栈空间，因此会将内存撑爆，程序死掉。所以，为了防止这种情况出现，python设置了一个最大的递归深度，默认1000。如果想要设置这个递归的深度的话，需要改变一下递归的深度设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.getrecursionlimit())  <span class="comment"># 查看最大递归深度 1000</span></span><br><span class="line">sys.setrecursionlimit(<span class="number">2000</span>)  <span class="comment"># 修改最大递归深度</span></span><br></pre></td></tr></table></figure>

<p>所以，如果以后想使用递归的时候，<strong>需要在程序中加入一个终止条件</strong>。</p>
<p>举个例子：</p>
<p>求1到n=5的和？</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">想要获取<span class="number">1</span>到<span class="number">5</span>的和， 只需要知道，<span class="number">1</span>到<span class="number">4</span>的和， 然后加上<span class="number">5</span>，<span class="number">5</span> + sum(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> + sum(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> + sum(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> + sum(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> + sum(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum1</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> sum1(n<span class="number">-1</span>) + n</span><br><span class="line">        </span><br><span class="line">sum1(5) ===&gt; sum1(4) + 5 </span><br><span class="line">sum1(4) ===&gt; sum1(3) + 4</span><br><span class="line">sum1(3) ===&gt; sum1(2) + 3</span><br><span class="line">sum1(2) ===&gt; sum1(1) + 2</span><br><span class="line">sum1(1) ===&gt; 1</span><br></pre></td></tr></table></figure>

<p>求n的阶乘？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>! = <span class="number">5</span> * <span class="number">4</span> * <span class="number">3</span> * <span class="number">2</span> * <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>! = <span class="number">5</span> * <span class="number">4</span>!</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>! = <span class="number">4</span> * <span class="number">3</span>!</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>! = <span class="number">3</span> * <span class="number">2</span>!</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>! = <span class="number">2</span> * <span class="number">1</span>!</span><br><span class="line"></span><br><span class="line">n! = n * (n<span class="number">-1</span>)!</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum1</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> sum1(n<span class="number">-1</span>) * n</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>求斐波那契数列</p>
<blockquote>
<p>0, 1, 1, 2, 3, 5, 8,13,21…… </p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">斐波那契数学规律</span><br><span class="line"></span><br><span class="line">当n=<span class="number">0</span>或者n=<span class="number">1</span>, <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">当n&gt;2, f(3) = f(1) + f(2) = 1 + 1 = 2  ==&gt; f(n) = f(n-1) + f(n-2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span> <span class="keyword">or</span> n==<span class="number">1</span> :</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line">fib(4) ==&gt; fib(3) + fib(2)</span><br></pre></td></tr></table></figure>

<p>总结：递归比较难理解，因为自己调用自己，如果没有终止条件的话，很可能造成整个程序崩掉。在项目中用的比较少。递归使用最多的场景，是在算法，尤其是树的相关算法中，用的最多。所以面试考察递归的时候，除了，用上面这几个简单的例子外，最多考察的是遍历树之类的问题</p>
<p>有兴趣的话，可以刷一下，算法题中的树</p>
<p>6.函数名的作用以及闭包函数   <strong>面试和项目中的重点</strong></p>
<ul>
<li>函数名的作用</li>
</ul>
<blockquote>
<p>函数名本身就是一个内存地址, 是可以当做参数进行传递的,并且还可以赋值给别的变量</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;f1&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">f1</span>):</span></span><br><span class="line">    f1()    </span><br><span class="line">    print(<span class="string">&quot;呵呵&quot;</span>)</span><br><span class="line">    print(func)</span><br><span class="line">    </span><br><span class="line">a = func    <span class="comment"># 把函数当成一个值赋值给另一个变量</span></span><br><span class="line">a()     <span class="comment"># 函数调用 func()</span></span><br></pre></td></tr></table></figure>

<ul>
<li>闭包函数</li>
</ul>
<blockquote>
<p>外层函数中嵌套一个内层函数，然后，外层函数的返回值是这个内层函数。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outter</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">        name = <span class="string">&#x27;szk&#x27;</span></span><br><span class="line">        print(name)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">outter()  <span class="comment">### wrapper()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>并且，函数执行完之后，内部的变量不会随着外面变量的改变而改变。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    name = <span class="string">&#x27;szk&#x27;</span></span><br><span class="line">    print(name)</span><br><span class="line"></span><br><span class="line">f1()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outter</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">        name = <span class="string">&#x27;szk&#x27;</span></span><br><span class="line">        print(name)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">f1 = outter()</span><br><span class="line"></span><br><span class="line">name = <span class="string">&#x27;kkk&#x27;</span></span><br><span class="line">f1()  <span class="comment">### szk</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：函数的变量名和闭包函数的使用主要是为装饰器打的基础。这两个知识点，面试中比较常问。而以闭包函数问的最多。</p>
<p>7.**装饰器 面试和项目中的重中之重 **</p>
<p>最简单的装饰器的写法和使用：</p>
<blockquote>
<p>计算时间的装饰器</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 装饰器的写法：</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_time</span>(<span class="params">fuc</span>):</span>  <span class="comment">### 参数是需要计算的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warpper</span>(<span class="params">*args, **kwargs</span>):</span> <span class="comment">### 需要计算的函数的参数</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        fuc(*args, **kwargs)  <span class="comment">### 需要计算时间的函数</span></span><br><span class="line">        end = time.time()</span><br><span class="line">        print(end - start)</span><br><span class="line">    <span class="keyword">return</span> warpper</span><br><span class="line"></span><br><span class="line"><span class="comment">### 装饰器的使用：</span></span><br><span class="line"><span class="meta">@count_time   ### python提供的语法糖写法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;xxx&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>带参数的装饰器</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span>(<span class="params">engine</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">outter</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>)</span></span><br><span class="line"><span class="function">            ....</span></span><br><span class="line"><span class="function">        <span class="title">return</span> <span class="title">wrapper</span></span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">outter</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">@<span class="title">count_time</span>(<span class="params">engine=<span class="string">&#x27;file&#x27;</span></span>)  ### <span class="title">python</span>提供的语法糖写法</span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">f1</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">wrapper(*args,**kwargs) 这个参数的功能是给原始函数用的；outter(func)，用来装被修饰的函数，auth(engine) 传给内层需要的函数。三层足够使用，最外层可以无限的延伸参数。</span><br></pre></td></tr></table></figure>

<p>总结：装饰器在面试和项目中用的最多。甚至在面试的时候，会当场让你写装饰器。在项目中多用来判断用户是否登录以及记录日志等功能。</p>
<p>函数部分的总结：</p>
<ul>
<li>函数的写法和定义以及基础的参数，位置参数，关键字参数，动态获取参数 </li>
<li>部分内置函数</li>
<li>迭代器和生成器</li>
<li>列表生成式和字典生成式</li>
<li>递归</li>
<li>闭包函数</li>
<li>装饰器</li>
</ul>
<h4 id="模块部分："><a href="#模块部分：" class="headerlink" title="模块部分："></a>模块部分：</h4><blockquote>
<p>python 之所以强大，很大一部分原因是python有非常丰富的内置模块和第三方模块和包</p>
</blockquote>
<p>0.模块的定义</p>
<blockquote>
<p>模块的本质就是一系列的python程序。</p>
</blockquote>
<p>1.模块的使用</p>
<blockquote>
<p>import 模块名</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> md  <span class="comment">### 直接导入模块文件名即可</span></span><br><span class="line">print(md.read())  <span class="comment">### 调用模块中常见的方法和属性，使用.的方式来获取和使用</span></span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>使用.的方式获取所有的函数或者属性</li>
<li>引入的方法不会和当前运行文件中的函数或者属性冲突</li>
</ul>
<blockquote>
<p>from 模块 import 引入的函数或者属性</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> md <span class="keyword">import</span> read</span><br><span class="line">read()</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>使用啥就导入啥，提高程序的执行效率</li>
</ul>
<p>2.模块的导入查找方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">模块的查询顺序</span><br><span class="line">    <span class="number">1.</span>先从内存中找可能已经加载了的</span><br><span class="line">    <span class="number">2.</span>python 内置模块  </span><br><span class="line">    <span class="number">3.</span>sys.path列表里面每一个路径下去找, 需要知道sys.path列表中第一个路径就是当前被执行文件所在的文件夹</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">如何解决上述找不到的路径的问题：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###两种方式</span></span><br><span class="line"><span class="comment">#### 1.将该模块的绝对路径加入到sys.path中</span></span><br><span class="line"><span class="comment"># sys.path.append(&#x27;/Users/shangzekai/PycharmProjects/day04/md1/&#x27;)</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># import md  ###</span></span><br><span class="line"><span class="comment"># print(md.read1())</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 2.从根路径下面的模块开始导入</span></span><br><span class="line"><span class="keyword">from</span> md1 <span class="keyword">import</span> md</span><br><span class="line"><span class="keyword">from</span> md1.md <span class="keyword">import</span> read, read1</span><br></pre></td></tr></table></figure>

<p>3.模块的分类</p>
<ul>
<li>自定义模块</li>
<li>内置模块</li>
<li>第三方模块 </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  <span class="comment"># 当文件被直接执行时</span></span><br></pre></td></tr></table></figure>

<p>4.常见的内置模块</p>
<ul>
<li><p>sys ： </p>
<ul>
<li>sys.path           返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值<br>-os:</li>
<li>os.path.abspath(path)       返回path规范化的绝对路径</li>
<li>os.path.split(path)         将path分割成目录和文件名二元组返回</li>
<li>os.path.dirname(path)       返回path的目录。其实就是os.path.split(path)的第一个元素</li>
<li>os.path.basename(path)      返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素</li>
<li>os.path.exists(path)        如果path存在，返回True；如果path不存在，返回False</li>
<li>os.path.isfile(path)        如果path是一个存在的文件，返回True。否则返回False</li>
<li>os.path.isdir(path)         如果path是一个存在的目录，则返回True。否则返回False</li>
</ul>
</li>
<li><p>random : 生成随机字符串，验证码</p>
<ul>
<li>random.randint(1,2)</li>
</ul>
</li>
<li><p>json 使用的场景非常多，常见于不同的语言和python进行数据交互使用</p>
<ul>
<li>dumps：序列化</li>
<li>loads: 反序列化</li>
<li>dump</li>
<li>load   </li>
</ul>
</li>
<li><p>hashlib  编码</p>
<ul>
<li>md5</li>
<li>sha1</li>
<li>sha256</li>
</ul>
</li>
</ul>
<h4 id="本周内容："><a href="#本周内容：" class="headerlink" title="本周内容："></a>本周内容：</h4><p>0.内置的模块</p>
<ul>
<li>时间模块 （time）<ul>
<li>import time   time.time() </li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 各种时间的转换</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 如果别人给你传了一个2016-05-22，转换成时间戳</span></span><br><span class="line"></span><br><span class="line">string_to_struct = time.strptime(<span class="string">&quot;2016-05-22&quot;</span>,<span class="string">&quot;%Y-%m-%d&quot;</span>) <span class="comment">#将 日期字符串 转成 struct时间对象格式</span></span><br><span class="line"><span class="comment"># print(string_to_struct)</span></span><br><span class="line">struct_to_stamp = time.mktime(string_to_struct) <span class="comment">#将struct时间对象转成时间戳</span></span><br><span class="line">print(struct_to_stamp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 时间戳转换成字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#时间戳 转为 日期字符串</span></span><br><span class="line">print(time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,time.gmtime()) )</span><br></pre></td></tr></table></figure>

<p>总结：时间的转换以及时间的加减</p>
<p>1.第三方模块  requests， pymysql， jenkins，gitlab</p>
<p>pip工具，下载安装第三方模块。和yum类似</p>
<p>pip工具安装的包一定是和python的解释器相对应的</p>
<blockquote>
<p>pip3 install 安装的包<br>pip3 uninstall 安装的包<br>pip3 list<br>换源：</p>
</blockquote>
<p>临时换源：</p>
<blockquote>
<p>pip install 包名 -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
</blockquote>
<p>永久性换源<br>修改 ~/.pip/pip.conf (没有就创建一个)， 内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">global</span>]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>2.requests模块</p>
<blockquote>
<p>爬虫中非常重要的一个模块<br>通过这个模块可以发起http请求，get， post， put， delete方法</p>
</blockquote>
<p>3.pymysql模块</p>
<blockquote>
<p>pip3 install  pymysql</p>
</blockquote>
<p>总结: sql语句的写法是不变。需要关注操作的函数即可。execute</p>
<p>4.redis模块</p>
<blockquote>
<p><a href="https://www.cnblogs.com/john-xiong/p/12089103.html">https://www.cnblogs.com/john-xiong/p/12089103.html</a></p>
</blockquote>
<p>5.gitlab模块</p>
<p>生成token： settings ===&gt; accesstoken ===&gt; create 生成</p>
<blockquote>
<p><a href="https://pypi.org/project/python-gitlab/">https://pypi.org/project/python-gitlab/</a></p>
</blockquote>
<ul>
<li>ATM作业</li>
<li>python操作 docker， k8s， saltstack， ansible</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>py-day05</title>
    <url>/2020/09/06/py-day05/</url>
    <content><![CDATA[<p>python基础<br>class(封装、多态、继承)</p>
<a id="more"></a>

<h4 id="内容回顾："><a href="#内容回顾：" class="headerlink" title="内容回顾："></a>内容回顾：</h4><p>0.内置的模块</p>
<ul>
<li>时间模块 （time）<ul>
<li>import time   time.time() </li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 各种时间的转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 如果别人给你传了一个2016-05-22，转换成时间戳</span></span><br><span class="line"></span><br><span class="line">string_to_struct = time.strptime(<span class="string">&quot;2016-05-22&quot;</span>,<span class="string">&quot;%Y-%m-%d&quot;</span>) <span class="comment">#将 日期字符串 转成 struct时间对象格式</span></span><br><span class="line"><span class="comment"># print(string_to_struct)</span></span><br><span class="line">struct_to_stamp = time.mktime(string_to_struct) <span class="comment">#将struct时间对象转成时间戳</span></span><br><span class="line">print(struct_to_stamp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 时间戳转换成字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#时间戳 转为 日期字符串</span></span><br><span class="line">print(time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,time.gmtime()) )</span><br></pre></td></tr></table></figure>

<p>总结：时间的转换以及时间的加减</p>
<p>1.第三方模块  requests， pymysql， jenkins，gitlab</p>
<p>pip工具，下载安装第三方模块。和yum类似</p>
<p>pip工具安装的包一定是和python的解释器相对应的</p>
<blockquote>
<p>pip3 install 安装的包<br>pip3 uninstall 安装的包<br>pip3 list<br>换源：</p>
</blockquote>
<ul>
<li>临时换源：</li>
</ul>
<blockquote>
<p>pip install 包名 -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
</blockquote>
<ul>
<li>永久性换源<br>修改 ~/.pip/pip.conf (没有就创建一个)， 内容如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">global</span>]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>2.requests模块</p>
<blockquote>
<p>pip3 install requests</p>
</blockquote>
<blockquote>
<p>linux curl<br>爬虫中非常重要的一个模块<br>通过这个模块可以发起http请求，get， post， put， delete方法</p>
</blockquote>
<blockquote>
<p>后续，请求第三放的api获取数据的时候，都是要用到的</p>
</blockquote>
<p>3.pymysql模块<br>如果以后有些老的项目，使用python2.7写的，使用python操作mysql的模块是：MySQL-Python</p>
<p>在python3中的使用方法：</p>
<blockquote>
<p>pip3 install  pymysql</p>
</blockquote>
<p>总结: sql语句的写法是不变。需要关注操作的函数即可。execute</p>
<p>4.redis模块</p>
<blockquote>
<p><a href="https://www.cnblogs.com/john-xiong/p/12089103.html">https://www.cnblogs.com/john-xiong/p/12089103.html</a></p>
</blockquote>
<p>5.gitlab模块</p>
<p>生成token： settings ===&gt; accesstoken ===&gt; create 生成</p>
<blockquote>
<p><a href="https://pypi.org/project/python-gitlab/">https://pypi.org/project/python-gitlab/</a></p>
</blockquote>
<h4 id="本周内容"><a href="#本周内容" class="headerlink" title="本周内容"></a>本周内容</h4><p>1.模块的收尾</p>
<ul>
<li>操作docker</li>
<li>操作paramiko  堡垒机、ansible、saltstack</li>
</ul>
<blockquote>
<p>总结：python之所以强大，是因为他有很强大的第三方模块。以后我们在使用python解决问题的时候，我们可以首先先考虑一下有没有现成的第三方的模块(轮子)，有的话直接拿来用就好了。找第三方模块的方法：首先考虑到github找。</p>
</blockquote>
<p>2.面向对象编程的学习</p>
<ul>
<li>面向过程编程思想<ul>
<li>在我们学习函数之前，写的所有的程序代码，都是面向过程式的编程</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    total += <span class="number">1</span></span><br><span class="line">print(total)</span><br></pre></td></tr></table></figure>

<ul>
<li>面向过程编程有点像高中的时候解题：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">答：第一步：</span><br><span class="line">   第二步：</span><br><span class="line">   第三步：</span><br></pre></td></tr></table></figure>

<ul>
<li>面向函数编程思想</li>
</ul>
<blockquote>
<p>学完函数之后，我们写的代码，发生了一些改变。我们会把一些功能相同的代码写到一个函数中去，而后，那块需要用到这个功能，我们直接调用这个函数即可</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;鉴权逻辑&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;登录逻辑&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>减少代码的冗余</li>
<li>增加了代码的灵活度</li>
</ul>
<blockquote>
<p>shell编程中，是没有面向对象的思想的。shell编程是面向函数式的编程。处理一些简单的任务，所以面向函数编程，已经足够满足我们的日常需求了。但是如果写一些大的项目话，shell就力不从心了。因此，引入了面向对象的编程，来满足大型项目的开发需要    </p>
</blockquote>
<blockquote>
<p>面向函数式编程和面向对象编程，是没有好坏之分的，需要看你的应用场景来决定。面向对象编程他的封装性和扩展性比其他的编程思想要好很多。</p>
</blockquote>
<p>面向对象的概念</p>
<p><strong>什么是类?什么又是对象?</strong></p>
<blockquote>
<p>类：就是具有相同属性（特征）和功能(技能)的一类事物， 比如说：人类，鸡类，狗类</p>
</blockquote>
<blockquote>
<p>对象：就是类的具体表现形式, 比如说，张三，李四等</p>
</blockquote>
<p><strong>所谓的类，就是一个模板，对象就是模板的具体生产出来的实例</strong></p>
<ul>
<li>面向对象中类和对象的基本使用</li>
</ul>
<blockquote>
<p>现在基本上所有的高级语言(c++, java, php, python,C#)中，都有面向对象的</p>
</blockquote>
<h5 id="从类的角度研究基本使用方法"><a href="#从类的角度研究基本使用方法" class="headerlink" title="从类的角度研究基本使用方法"></a>从类的角度研究基本使用方法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    mind = <span class="string">&quot;有思想&quot;</span></span><br><span class="line">    leg = <span class="number">2</span></span><br><span class="line">    eye = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;eating...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;sleeping...&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>‘’’<br>注意：<br>    1. class是定义类的关键字，Person是类名，建议大家首字母大写<br>    2. 冒号后面是这个类的具体内容<br>‘’’</p>
<blockquote>
<p>print(Person.<strong>dict</strong>) ### 获取类中所有的属性和方法<br>print(Person.<strong>dict</strong>.get(‘leg’)) ### 获取某一个属性的方式</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在类定义阶段就会立刻执行类体代码，会产生类的名称空间，用于将类体代码执行过程中产生的名字都存放与类的名称空间中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OldboyStudent</span>:</span></span><br><span class="line">    school = <span class="string">&#x27;Oldboy&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_course</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;is choosing course&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;====&gt;&#x27;</span>)</span><br><span class="line"><span class="comment"># 定义执行后就会输出====&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="推荐大家使用如下方式"><a href="#推荐大家使用如下方式" class="headerlink" title="推荐大家使用如下方式"></a>推荐大家使用如下方式</h3><h4 id="使用类的方式来获取类中的属性和类的方法"><a href="#使用类的方式来获取类中的属性和类的方法" class="headerlink" title="使用类的方式来获取类中的属性和类的方法"></a>使用类的方式来获取类中的属性和类的方法</h4><h3 id="直接使用-的方式来获取，万能的点"><a href="#直接使用-的方式来获取，万能的点" class="headerlink" title="直接使用 . 的方式来获取，万能的点"></a>直接使用 . 的方式来获取，万能的点</h3><p>print(Person.leg)<br>Person.eat(123)  ####</p>
<p>Person.mind = ‘无脑’  # 改<br>print(Person.mind)</p>
<p>del Person.mind  # 删<br>print(Person.mind)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">##### 从对象的角度来研究</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">class Person:</span><br><span class="line">    mind &#x3D; &quot;有思想&quot;</span><br><span class="line">    leg &#x3D; 2</span><br><span class="line">    eye &#x3D; 2</span><br><span class="line"></span><br><span class="line">    ### 当实例化一个对象的时候，会自动的触发该__init__函数</span><br><span class="line">    ### 此时self指代的就是当前实例化的对象，也就是 self &#x3D; p1</span><br><span class="line">    def __init__(self, name, age, height):</span><br><span class="line">        # print(self) ### &lt;__main__.Person object at 0x10ee29760&gt;</span><br><span class="line">        self.name &#x3D; name ### p1.name &#x3D; &#39;wenliang&#39;  p2.name &#x3D; &#39;nick&#39;</span><br><span class="line">        self.age &#x3D; age   ### p1.age &#x3D; 73   p2.age &#x3D; 84</span><br><span class="line">        self.height &#x3D; height ### p1.height &#x3D; 168 p2.height&#x3D;178</span><br><span class="line"></span><br><span class="line">    def eat(self):</span><br><span class="line">        ### self &#x3D; p1</span><br><span class="line">        print(&#39;%s eating...&#39; % self.name)</span><br><span class="line"></span><br><span class="line">    def sleep(self):</span><br><span class="line">        print(&#39;sleeping...&#39;)</span><br><span class="line"></span><br><span class="line"># p1 &#x3D; Person()  ### 实例化Person类，产生一个对象</span><br><span class="line"># p2 &#x3D; Person()  ### 实例化Person类，产生一个对象</span><br><span class="line"># p3 &#x3D; Person()  ### 实例化Person类，产生一个对象</span><br><span class="line"># print(id(p1)) ### 产生对象的内存地址是不同的</span><br><span class="line"># print(id(p2))</span><br><span class="line"># print(id(p3))</span><br><span class="line"></span><br><span class="line">p1 &#x3D; Person(name&#x3D;&#39;wenliang&#39;, age&#x3D;73, height&#x3D;168)</span><br><span class="line">p2 &#x3D; Person(name&#x3D;&#39;nick&#39;, age&#x3D;84, height&#x3D;170)</span><br><span class="line"></span><br><span class="line"># print(p1.__dict__)</span><br><span class="line"># print(p2.__dict__)</span><br><span class="line"></span><br><span class="line">### 对象操作属性</span><br><span class="line"># print(p1.mind)</span><br><span class="line"># print(p1.name)</span><br><span class="line">#</span><br><span class="line"># print(p2.mind)</span><br><span class="line"># print(p2.name)</span><br><span class="line"></span><br><span class="line"># print(p1.mind)</span><br><span class="line"># print(p2.mind)</span><br><span class="line"># print(p3.mind)</span><br><span class="line"></span><br><span class="line"># print(p1.__dict__)</span><br><span class="line"></span><br><span class="line">### 对象操作方法</span><br><span class="line"># Person.eat(1)</span><br><span class="line">p1.eat()  ### 会默认将当前的对象p1,传给方法中的self</span><br><span class="line">p2.eat()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：<br>1.后续项目中大部分都是使用对象来操作类中相关的属性和方法的<br>2.self 指代的就是当前的对象<br>3.<code>__init__()</code>初始化方法</p>
</blockquote>
<ul>
<li><p>面向对象的三大特性</p>
<ul>
<li><p>python 中一切皆对象    linux一切皆文件</p>
</li>
<li><p><strong>封装</strong></p>
<ul>
<li>封装的总共有两个特点：<br>1.将内容封装到某个地方，以后再去调用被封装在某处的内容。<br>2.一些私有的不想被外部访问的变量，也可以封装起来</li>
</ul>
</li>
<li><p><strong>继承</strong></p>
<ul>
<li>分类：<ul>
<li>单继承</li>
<li>多继承   C++， python有，但是php和java没有， </li>
</ul>
</li>
</ul>
</li>
<li><p>多态</p>
</li>
</ul>
</li>
<li><p>面向的对象中的装饰器</p>
<ul>
<li>property</li>
<li>classmethod</li>
<li>staticmethod</li>
</ul>
</li>
<li><p><strong>反射</strong> </p>
<ul>
<li>只有在Python中有</li>
</ul>
</li>
<li><p>面向对象中的双下划线方法</p>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>发布方式对比</title>
    <url>/2020/08/13/%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>灰度、蓝绿、ABtest发布等部署方案对比</p>
<a id="more"></a>
<h2 id="蓝绿发布（Blue-Green-Deployment）"><a href="#蓝绿发布（Blue-Green-Deployment）" class="headerlink" title="蓝绿发布（Blue/Green Deployment）"></a>蓝绿发布（Blue/Green Deployment）</h2><ol>
<li>定义</li>
</ol>
<p>蓝绿部署是不停老版本，部署新版本然后进行测试。确认OK后将流量切到新版本，然后老版本同时也升级到新版本。</p>
<ol start="2">
<li>特点</li>
</ol>
<p>蓝绿部署无需停机，并且风险较小。</p>
<ol start="3">
<li>部署过程</li>
</ol>
<p>部署版本 1 的应用（初始的状态）<br>所有外部请求的流量都打到这个版本上。<br>部署版本 2 的应用<br>版本 2 的代码与版本 1 不同(新功能、Bug修复等)。</p>
<p>将流量从版本 1 切换到版本 2。<br>如版本 2 测试正常，就删除版本 1 正在使用的资源（例如实例），从此正式用版本 2。<br>4. 小结</p>
<p>从过程不难发现，在部署的过程中，我们的应用始终在线。并且新版本上线的过程中，并没有修改老版本的任何内容，在部署期间，老版本的状态不受影响，这样风险很小。并且只要老版本的资源不被删除，理论上，我们可以在任何时间回滚到老版本。</p>
<ol start="5">
<li>蓝绿发布的注意事项</li>
</ol>
<p>当你切换到蓝色环境时，需要妥当处理未完成的业务和新的业务。如果你的数据库后端无法处理，会是一个比较麻烦的问题。</p>
<p>可能会出现需要同时处理微服务架构应用和传统架构应用的情况，如果在蓝绿部署中协调不好这两者，还是有可能会导致服务停止。<br>需要提前考虑数据库与应用部署同步迁移/回滚的问题。<br>蓝绿部署需要有基础设施支持。<br>在非隔离基础架构（ VM 、 Docker 等）上执行蓝绿部署，蓝色环境和绿色环境有被摧毁的风险。<br>6. 优势和不足</p>
<p>优势<br>升级切换和回退速度非常快。</p>
<p>不足<br>切换是全量的，如果 V2 版本有问题，则对用户体验有直接影响。</p>
<p>需要两倍机器资源。</p>
<ol start="7">
<li>适用场合</li>
</ol>
<p>对用户体验有一定容忍度的场景。<br>机器资源有富余或者可以按需分配（AWS 云，或自建容器云）。</p>
<h2 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h2><ol>
<li>定义</li>
</ol>
<p>灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。AB Test 就是一种灰度发布方式，让一部分用户继续用 A，一部分用户开始用 B，如果用户对 B 没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到 B 上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。</p>
<ol start="2">
<li><p>A/B Testing<br>A/B 测试是用来测试应用功能表现的方法，例如可用性、受欢迎程度、可见性等等。 A/B 测试通常用在应用的前端上，不过当然需要后端来支持。<br>A/B 测试与蓝绿部署的区别在于， A/B 测试目的在于通过科学的实验设计、采样样本代表性、流量分割与小流量测试等方式来获得具有代表性的实验结论，并确信该结论在推广到全部流量可信；蓝绿部署的目的是安全稳定地发布新版本应用，并在必要时回滚。</p>
</li>
<li><p>金丝雀发布</p>
</li>
</ol>
<p>我们平常所说的金丝雀部署也是灰度发布的一种方式，在原有版本可用的情况下，同时部署一个新版本应用作为「金丝雀」服务器来测试新版本的性能和表现，以保障整体系统稳定的情况下，尽早发现、调整问题。</p>
<blockquote>
<p>矿井中的金丝雀：17 世纪，英国矿井工人发现，金丝雀对瓦斯这种气体十分敏感。空气中哪怕有极其微量的瓦斯，金丝雀也会停止歌唱；当瓦斯含量超过一定限度时，虽然鲁钝的人类毫无察觉，金丝雀却早已毒发身亡。当时在采矿设备相对简陋的条件下，工人们每次下井都会带上一只金丝雀作为瓦斯检测指标，以便在危险状况下紧急撤离。</p>
</blockquote>
<p>灰度发布／金丝雀发布由以下几个步骤组成：</p>
<p>准备好部署各个阶段的工件，包括：构建工件，测试脚本，配置文件和部署清单文件。<br>从负载均衡列表中移除掉「金丝雀」服务器。<br>升级「金丝雀」应用（排掉原有流量并进行部署）。<br>对应用进行自动化测试。<br>将「金丝雀」服务器重新添加到负载均衡列表中（连通性和健康检查）。<br>如果「金丝雀」在线使用测试成功，升级剩余的其他服务器（否则就回滚）。<br>除此之外灰度发布还可以设置路由权重，动态调整不同的权重来进行新老版本的验证。</p>
<ol start="4">
<li>优势和不足</li>
</ol>
<p>优势<br>用户体验影响小，灰度发布过程出现问题只影响少量用户。</p>
<p>不足<br>发布自动化程度不够，发布期间可引发服务中断。</p>
<h2 id="滚动发布（Rolling-Update-Deployment）"><a href="#滚动发布（Rolling-Update-Deployment）" class="headerlink" title="滚动发布（Rolling Update Deployment）"></a>滚动发布（Rolling Update Deployment）</h2><p>在金丝雀发布基础上的进一步优化改进，是一种自动化程度较高的发布方式，用户体验比较平滑，是目前成熟型技术组织所采用的主流发布方式。</p>
<ol>
<li>定义</li>
</ol>
<p>滚动发布：一般是取出一个或者多个服务器停止服务，执行更新，并重新将其投入使用。周而复始，直到集群中所有的实例都更新成新版本。</p>
<ol start="2">
<li>特点</li>
</ol>
<p>这种部署方式相对于蓝绿部署，更加节约资源——它不需要运行两个集群、两倍的实例数。我们可以部分部署，例如每次只取出集群的 20% 进行升级。</p>
<ol start="3">
<li>部署过程</li>
</ol>
<p>滚动式发布一般先发 1 台，或者一个小比例，如 2% 服务器，主要做流量验证用，类似金丝雀 (Canary) 测试。<br>滚动式发布需要比较复杂的发布工具和智能 LB，支持平滑的版本替换和流量拉入拉出。<br>每次发布时，先将老版本 V1 流量从 LB 上摘除，然后清除老版本，发新版本 V2，再将 LB 流量接入新版本。这样可以尽量保证用户体验不受影响。<br>一次滚动式发布一般由若干个发布批次组成，每批的数量一般是可以配置的（可以通过发布模板定义）。例如第一批 1 台（金丝雀），第二批 10%，第三批 50%，第四批 100%。每个批次之间留观察间隔，通过手工验证或监控反馈确保没有问题再发下一批次，所以总体上滚动式发布过程是比较缓慢的 (其中金丝雀的时间一般会比后续批次更长，比如金丝雀 10 分钟，后续间隔 2 分钟)。<br>回退是发布的逆过程，将新版本流量从 LB 上摘除，清除新版本，发老版本，再将 LB 流量接入老版本。和发布过程一样，回退过程一般也比较慢的。<br>4. 优势和不足</p>
<p>优势<br>用户体验影响小，体验较平滑。</p>
<p>不足<br>发布和回退时间比较缓慢。</p>
<p>发布工具比较复杂，LB 需要平滑的流量摘除和拉入能力。</p>
<h2 id="其它发布方式"><a href="#其它发布方式" class="headerlink" title="其它发布方式"></a>其它发布方式</h2><p>上述都是偏传统的发布方式，能覆盖大部分应用发布场景。针对一些关键新功能的上线发布，或者一些特定的场景，还有一些特殊的发布方式。</p>
<p>功能开关发布</p>
<p>利用代码中的功能开关（Feature Flag/Toggle/Switch）来控制发布逻辑，一般不需要复杂的发布工具和智能 LB 配合，是一种相对比较低成本和简单的发布方式。这种方式也是支持现代 DevOps 理念，研发人员可以灵活定制和自助完成的发布方式。功能开关的原理如下图所示：</p>
<ol>
<li>部署过程</li>
</ol>
<p>功能开关发布需要一个配置中心或者开关中心这样的服务支持，例如携程的 Apollo 配置中心或者开源的 FF4J，这些都支持开关发布。业界还有专门的功能开关 SaaS 服务，例如 LaunchDarkly。通过配置中心，运维或研发人员可以在运行期动态配置功能开关的值。当然，功能开关发布只是配置中心的一种使用场景，配置中心还能支持其它很多动态配置场景。<br>功能开关服务一般提供客户端 SDK，方便开发人员集成。在运行期，客户端 SDK 会同步最新的开关值，技术实现有推方式 (push)，也有拉方式 (pull)，或者推拉结合方式。<br>新功能（V2 new feature）和老功能（V1 old feature）住在同一套代码中，新功能隐藏在开关后面，如果开关没有打开，则走老代码逻辑，如果开关打开，则走新代码逻辑。技术实现上可以理解为一个简单的 if/else 逻辑。<br>应用上线后，开关先不打开，然后运维或研发人员通过开关中心打开新功能，经过流量验证新功能没有问题，则发布完成；如果有问题，则随时可以通过开关中心切回老功能逻辑。<br>2. 优势和不足</p>
<p>优势<br>升级切换和回退速度非常快。</p>
<p>相对于复杂的发布工具，实施比较简单，成本相对低廉。</p>
<p>研发能够灵活定制发布逻辑，支持 DevOps 自助发布。</p>
<p>不足<br>切换是全量的，如果 V2 版本有问题，则对用户体验有直接影响。</p>
<p>对代码有侵入，代码逻辑会变复杂，需要定期清理老版本逻辑，维护成本变高。</p>
]]></content>
      <categories>
        <category>ops</category>
      </categories>
      <tags>
        <tag>deploy</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes网络通信原理</title>
    <url>/2020/08/11/kubernetes%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>了解通信原理</p>
<a id="more"></a>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>1、网络的命名空间：Linux在网络栈中引入网络命名空间，将独立的网络协议栈隔离到不同的命令空间中，彼此间无法通信；docker利用这一特性，实现不容器间的网络隔离。</p>
<p>2、Veth设备对：也叫虚拟网络接口对。Veth设备对的引入是为了实现在不同网络命名空间的通信。</p>
<p>3、Iptables/Netfilter：Netfilter负责在内核中执行各种挂接的规则(过滤、修改、丢弃等)，运行在内核 模式中；Iptables模式是在用户模式下运行的进程，负责协助维护内核中Netfilter的各种规则表；通过二者的配合来实现整个Linux网络协议栈中灵活的数据包处理机制。</p>
<p>4、网桥：网桥是一个二层网络设备,通过网桥可以将linux支持的不同的端口连接起来,并实现类似交换机那样的多对多的通信。</p>
<p>5、路由：Linux系统包含一个完整的路由功能，当IP层在处理数据发送或转发的时候，会使用路由表来决定发往哪里。</p>
<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p>Kubernetes对集群内部的网络进行了重新抽象，以实现整个集群网络扁平化。我们可以理解网络模型时，可以完全抽离物理节点去理解，我们用图说话，先有基本印象。</p>
<img src="/2020/08/11/kubernetes%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/kubernetes-proxy-model.jpg" class title="kubernetes网络通信原理">

<h3 id="一个Service"><a href="#一个Service" class="headerlink" title="一个Service"></a>一个Service</h3><p>Service是Kubernetes为为屏蔽这些后端实例（Pod）的动态变化和对多实例的负载均衡而引入的资源对象。Service通常与deployment绑定，定义了服务的访问入口地址，应用(Pod)可以通过这个入口地址访问其背后的一组由Pod副本组成的集群实例。Service与其后端Pod副本集群之间则是通过Label Selector来实现映射。</p>
<p>Service的类型(Type)决定了Service如何对外提供服务，根据类型不同，服务可以只在Kubernetes cluster中可见，也可以暴露到集群外部。Service有三种类型，ClusterIP，NodePort和LoadBalancer。具体的使用场景会在下文中进行阐述。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl get svc --selector app&#x3D;nginx</span><br><span class="line">NAME   TYPE     CLUSTER-IP  EXTERNAL-IP PORT(S) AGE</span><br><span class="line">nginx ClusterIP 172.19.0.166   &lt;none&gt;    80&#x2F;TCP  1m</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">describe</span> <span class="string">svc</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">Name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">Namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">Labels:</span> <span class="string">app=nginx</span></span><br><span class="line"><span class="attr">Annotations:</span> <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="attr">Selector:</span> <span class="string">app=nginx</span></span><br><span class="line"><span class="attr">Type:</span> <span class="string">ClusterIP</span></span><br><span class="line"><span class="attr">IP:</span> <span class="number">172.19</span><span class="number">.0</span><span class="number">.166</span></span><br><span class="line"><span class="attr">Port:</span> <span class="string">&lt;unset&gt;</span> <span class="number">80</span><span class="string">/TCP</span></span><br><span class="line"><span class="attr">TargetPort:</span> <span class="number">80</span><span class="string">/TCP</span></span><br><span class="line"><span class="attr">Endpoints:</span> <span class="number">172.16</span><span class="number">.2</span><span class="number">.125</span><span class="string">:80,172.16.2.229:80</span></span><br><span class="line"><span class="attr">Session Affinity:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">Events:</span> <span class="string">&lt;none&gt;</span></span><br></pre></td></tr></table></figure>
<p>该svc后端代理了2个Pod实例:172.16.2.125:80,172.16.2.229:80</p>
<h3 id="三个IP"><a href="#三个IP" class="headerlink" title="三个IP"></a>三个IP</h3><p>Kubernetes为描述其网络模型的IP对象，抽象出Cluster IP和Pod IP的概念。</p>
<p>PodIP是Kubernetes集群中每个Pod的IP地址。它是Docker Engine 根据docker0网桥的IP地址段进行分配的，是一个虚拟的二层网络。Kubernetes中Pod间能够彼此直接通讯，Pod里的容器访问另外一个Pod里的容器，是通过Pod IP所在进行通信。</p>
<p>Cluster IP仅作用于Service，其没有实体对象所对应，因此Cluster IP无法被ping通。它的作用是为Service后端的实例提供统一的访问入口。当访问ClusterIP时，请求将被转发到后端的实例上，默认是轮询方式。Cluster IP和Service一样由kube-proxy组件维护，其实现方式主要有两种，<strong>iptables</strong>和<strong>IPVS</strong>。在<strong>1.8版本后kubeproxy开始支持IPVS方式</strong>。在上例中，SVC的信息中包含了Cluster IP。</p>
<p>这里未列出nodeip概念，由于其本身是物理机的网卡IP。因此可理解为nodeip就是物理机IP。</p>
<h3 id="三个Port"><a href="#三个Port" class="headerlink" title="三个Port"></a>三个Port</h3><p>在Kubernetes中，涉及容器，Pod，Service，集群各等多个层级的对象间的通信，为在网络模型中区分各层级的通信端口，这里对Port进行了抽象。</p>
<h4 id="Port"><a href="#Port" class="headerlink" title="Port"></a>Port</h4><p>该Port非一般意义上的TCP/IP中的Port概念，它是特指Kubernetes中Service的port，是Service间的访问端口，例如Mysql的Service默认3306端口。它仅对进群内容器提供访问权限，而无法从集群外部通过该端口访问服务。</p>
<h4 id="nodePort"><a href="#nodePort" class="headerlink" title="nodePort"></a>nodePort</h4><p>nodePort为外部机器提供了访问集群内服务的方式。比如一个Web应用需要被其他用户访问，那么需要配置type=NodePort，而且配置nodePort=30001，那么其他机器就可以通过浏览器访问scheme://node:30001访问到该服务，例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;node:30001</span><br></pre></td></tr></table></figure>
<h4 id="targetPort"><a href="#targetPort" class="headerlink" title="targetPort"></a>targetPort</h4><p>targetPort是容器的端口（最根本的端口入口），与制作容器时暴露的端口一致（DockerFile中EXPOSE），例如<a href="http://docker.io官方的nginx暴露的是80端口./">http://docker.io官方的nginx暴露的是80端口。</a></p>
<p>eg:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mallh5-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">abcdocker</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">  <span class="attr">app:</span> <span class="string">mallh5web</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line"> <span class="attr">ports:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">     <span class="attr">port:</span> <span class="number">3017</span></span><br><span class="line">     <span class="attr">targetPort:</span> <span class="number">5003</span></span><br><span class="line">     <span class="attr">nodePort:</span> <span class="number">31122</span></span><br></pre></td></tr></table></figure>
<p>举出了一个service的yaml，其部署在abcdocker的namespace中。这里配置了nodePort，因此其类型Type就是NodePort，注意大小写。若没有配置nodePort，那这里需要填写ClusterIP，即表示只支持集群内部服务访问。</p>
<h2 id="集群内部通信"><a href="#集群内部通信" class="headerlink" title="集群内部通信"></a>集群内部通信</h2><h3 id="单节点通信"><a href="#单节点通信" class="headerlink" title="单节点通信"></a>单节点通信</h3><p>集群单节点内的通信，主要包括两种情况，同一个pod内的多容器间通信以及同一节点不同pod间的通信。由于不涉及跨节点访问，因此流量不会经过物理网卡进行转发。</p>
<p>查看路由表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@node-1:&#x2F;opt&#x2F;bin# route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination Gateway Genmask Flags Metric Ref Use Iface</span><br><span class="line">0.0.0.0 172.23.100.1 0.0.0.0 UG 0 0 0 eth0</span><br><span class="line">10.1.0.0 0.0.0.0 255.255.0.0 U 0 0 0 flannel.1 #flannel 网络内跨节点的通信会交给 flannel.1 处理</span><br><span class="line">10.1.1.0 0.0.0.0 255.255.255.0 U 0 0 0 docker0 #flannel 网络内节点内的通信会走 docker0</span><br></pre></td></tr></table></figure>

<h3 id="1-Pod内通信"><a href="#1-Pod内通信" class="headerlink" title="1 Pod内通信"></a>1 Pod内通信</h3><img src="/2020/08/11/kubernetes%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/pod%E5%86%85%E9%80%9A%E4%BF%A1.jpg" class title="kubernetes网络通信原理">
<p>同一个pod内共享网络命名空间，容器之间通过访问127.0.0.1:（端口）即可。图中的veth<em>即指veth对的一端（另一端未标注，但实际上是成对出现），该veth对是由Docker Daemon挂载在docker0网桥上，另一端添加到容器所属的网络命名空间，图上显示是容器中的eth0。<br>图中演示了bridge模式下的容器间通信。docker1向docker2发送请求，docker1，docker2均与docker0建立了veth对进行通讯。<br>当请求经过docker0时，由于容器和docker0同属于一个子网，因此请求经过docker2与docker0的veth</em>对，转发到docker2，该过程并未跨节点，因此不经过eth0。</p>
<p>总结：同一个pod内的多个容器间的通信，通过lo即可实现；</p>
<h3 id="Pod间通信"><a href="#Pod间通信" class="headerlink" title="Pod间通信"></a>Pod间通信</h3><p>同节点pod间通信<br>由于Pod内共享网络命名空间（由pause容器创建），所以本质上也是同节点容器间的通信。同时，同一Node中Pod的默认路由都是docker0的地址，由于它们关联在同一个docker0网桥上，地址网段相同，所有它们之间应当是能直接通信的。来看看实际上这一过程如何实现。如上图，Pod1中容器1和容器2共享网络命名空间，因此对pod外的请求通过pod1和Docker0网桥的veth对（图中挂在eth0和ethx上）实现。</p>
<p>总结：<br>同一Node中Pod的默认路由都是docker0的地址<br>pod ip &lt;—&gt; pod ip，pod和pod之间要不经过任何转换即可通信；</p>
<img src="/2020/08/11/kubernetes%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/%E5%90%8C%E8%8A%82%E7%82%B9pod%E9%97%B4%E9%80%9A%E4%BF%A1.jpg" class title="kubernetes网络通信原理">

<h3 id="pod和service通信"><a href="#pod和service通信" class="headerlink" title="pod和service通信"></a>pod和service通信</h3><p>pod ip &lt;—-&gt; cluster ip（即service ip）&lt;—-&gt;pod ip，他们通过iptables或ipvs实现通信，另外大家要注意ipvs取代不了iptables，因为ipvs只能做负载均衡，而做不了nat转换；</p>
<h3 id="跨节点通信"><a href="#跨节点通信" class="headerlink" title="跨节点通信"></a>跨节点通信</h3><h4 id="CNI：容器网络接口"><a href="#CNI：容器网络接口" class="headerlink" title="CNI：容器网络接口"></a>CNI：容器网络接口</h4><p>CNI 是一种标准，它旨在为容器平台提供网络的标准化。不同的容器平台（比如目前的 kubernetes、mesos 和 rkt）能够通过相同的接口调用不同的网络组件。</p>
<p>目前kubernetes支持的CNI组件种类很多，例如：flannel，callco，canel，kube-router。</p>
<p>flanel只支持网络通讯，但是不支持网络策略。<br>callco网络通讯和网络策略都支持。<br>canel：flanel+callco合起来的功能。</p>
<p>主流的跨主机通信方案主要有一下几种：<br>1）基于隧道的overlay网络：按隧道类型来说，不同的公司或者组织有不同的实现方案。docker原生的overlay网络就是基于vxlan隧道实现的。ovn则需要通过geneve或者stt隧道来实现的。flannel最新版本也开始默认基于vxlan实现overlay网络。</p>
<p>2）基于包封装的overlay网络：基于UDP封装等数据包包装方式，在docker集群上实现跨主机网络。典型实现方案有weave、flannel的早期版本。</p>
<p>3）基于三层实现SDN网络：基于三层协议和路由，直接在三层上实现跨主机网络，并且通过iptables实现网络的安全隔离。典型的方案为Project Calico。同时对不支持三层路由的环境，Project Calico还提供了基于IPIP封装的跨主机网络实现</p>
<p>总结：<br>    1）虚拟网桥，虚拟网卡，多个容器共用一个虚拟网卡进行通信；<br>    2）多路复用：MacVLAN，多个容器共用一个物理网卡进行通信；<br>    3）硬件交换：SR-LOV，一个物理网卡可以虚拟出多个接口，这个性能最好。</p>
<h4 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h4><img src="/2020/08/11/kubernetes%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/flannel1.jpg" class title="kubernetes网络通信原理">
<p>集群内跨节点通信涉及到不同的子网间通信，仅靠docker0无法实现，这里需要借助CNI网络插件来实现。图中展示了使用flannel实现跨节点通信的方式。</p>
<p>简单说来，flannel的用户态进程flanneld会为每个node节点创建一个flannel.1的网桥，根据etcd或apiserver的全局统一的集群信息为每个node分配全局唯一的网段，避免地址冲突。同时会为docker0和flannel.1创建veth对，docker0将报文丢给flannel.1,。</p>
<p>Flanneld维护了一份全局node的网络表，通过flannel.1接收到请求后，根据node表，将请求二次封装为UDP包，扔给eth0，由eth0出口进入物理网路发送给目的node。</p>
<p>在另一端以相反的流程。Flanneld解包并发往docker0，进而发往目的Pod中的容器</p>
<p>两个节点上的pod可以借助flannel隧道进行通信。默认使用的VxLAN协议，因为它有额外开销，所以性能有点低。</p>
<p>flannel第二种协议叫host-gw(host gateway)，即Node节点把自己的网络接口当做pod的网关使用，从而使不同节点上的node进行通信，这个性能比VxLAN高，因为它没有额外开销。不过他有个缺点， 就是各node节点必须在同一个网段中 。</p>
<p>另外，如果两个pod所在节点在同一个网段中 ，可以让VxLAN也支持host-gw的功能， 即直接通过物理网卡的网关路由转发，而不用隧道flannel叠加，从而提高了VxLAN的性能，这种flannel的功能叫directrouting。<br>flannel支持多种后端：<br>    1.Vxlan<br>        1.1 vxlan<br>        1.2 Dirextrouting<br>    2.host-gw：Host Gateway  #不推荐，只能在二层网络中，不支持跨网络，如果有成千上万的Pod，容易产生广播风暴<br>    3.UDP：性能差</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># kubectl get pods -o wide</span></span><br><span class="line">NAME                             READY     STATUS             RESTARTS   AGE       IP             NODE</span><br><span class="line">myapp-deploy-69b47bc96d-79fqh    1/1       Running            4          7d        10.244.1.97    node1</span><br><span class="line">myapp-deploy-69b47bc96d-tc54k    1/1       Running            4          7d        10.244.2.88    node2</span><br><span class="line">[root@master ~]<span class="comment"># kubectl exec -it myapp-deploy-69b47bc96d-79fqh -- /bin/sh</span></span><br><span class="line">/ <span class="comment"># ping 10.244.2.88 #ping对方Node上容器的ip</span></span><br><span class="line">PING 10.244.2.88 (10.244.2.88): 56 data bytes</span><br><span class="line">64 bytes from 10.244.2.88: seq=0 ttl=62 time=0.459 ms</span><br><span class="line">64 bytes from 10.244.2.88: seq=0 ttl=62 time=0.377 ms</span><br><span class="line">64 bytes from 10.244.2.88: seq=1 ttl=62 time=0.252 ms</span><br><span class="line">64 bytes from 10.244.2.88: seq=2 ttl=62 time=0.261 ms</span><br></pre></td></tr></table></figure>
<p>在其他节点上抓包，发现根本就在ens192上抓不到包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># tcpdump -i ens192 -nn icmp</span></span><br><span class="line">[root@master ~]<span class="comment"># yum install bridge-utils -y</span></span><br><span class="line">[root@master ~]<span class="comment"># brctl show docker0</span></span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">docker08000.024283f8b8ffno</span><br><span class="line">[root@master ~]<span class="comment"># brctl show cni0</span></span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">cni08000.0a580af40001noveth6ec94aab</span><br><span class="line">vethf703483a</span><br><span class="line">vethff579703</span><br></pre></td></tr></table></figure>
<p> 可以看到veth这些接口都是桥接到cni0上的。</p>
<pre><code>brctl show表示查看已有网桥。</code></pre>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;[root@node1 ~]<span class="comment">#  tcpdump -i cni0 -nn icmp</span></span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on cni0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">23:40:11.370754 IP 10.244.1.97 &gt; 10.244.2.88: ICMP <span class="built_in">echo</span> request, id 4864, seq 96, length 64</span><br><span class="line">23:40:11.370988 IP 10.244.2.88 &gt; 10.244.1.97: ICMP <span class="built_in">echo</span> reply, id 4864, seq 96, length 64</span><br><span class="line">23:40:12.370888 IP 10.244.1.97 &gt; 10.244.2.88: ICMP <span class="built_in">echo</span> request, id 4864, seq 97, length 64</span><br><span class="line">23:40:12.371090 IP 10.244.2.88 &gt; 10.244.1.97: ICMP <span class="built_in">echo</span> reply, id 4864, seq 97, length 64</span><br><span class="line">^X23:40:13.371015 IP 10.244.1.97 &gt; 10.244.2.88: ICMP <span class="built_in">echo</span> request, id 4864, seq 98, length 64</span><br><span class="line">23:40:13.371239 IP 10.244.2.88 &gt; 10.244.1.97: ICMP <span class="built_in">echo</span> reply, id 4864, seq 98, length 64</span><br><span class="line">23:40:14.371128 IP 10.244.1.97 &gt; 10.244.2.88: ICMP <span class="built_in">echo</span> request, id 4864, seq 99, length 64</span><br></pre></td></tr></table></figure>
<p>可以看到，在node节点，可以在cni0端口上抓到容器里面的Ping时的包。</p>
<pre><code>其实，上面ping时的数据流是先从cni0进来，然后从flannel.1出去，最后借助物理网卡ens32发出去。所以，我们在flannel.1上也能抓到包：</code></pre>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment">#  tcpdump -i flannel.1 -nn icmp</span></span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on flannel.1, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">03:12:36.823315 IP 10.244.1.97 &gt; 10.244.2.88: ICMP <span class="built_in">echo</span> request, id 4864, seq 12840, length 64</span><br><span class="line">03:12:36.823496 IP 10.244.2.88 &gt; 10.244.1.97: ICMP <span class="built_in">echo</span> reply, id 4864, seq 12840, length 64</span><br><span class="line">03:12:37.823490 IP 10.244.1.97 &gt; 10.244.2.88: ICMP <span class="built_in">echo</span> request, id 4864, seq 12841, length 64</span><br><span class="line">03:12:37.823634 IP 10.244.2.88 &gt; 10.244.1.97: ICMP <span class="built_in">echo</span> reply, id 4864, seq 12841, length 64</span><br></pre></td></tr></table></figure>
<p>同样，在ens192物理网卡上也能抓到包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># tcpdump -i ens192 -nn host 172.16.1.102  #172.16.1.102是node2的物理ip</span></span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on ens192, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">10:59:24.234174 IP 172.16.1.101.60617 &gt; 172.16.1.102.8472: OTV, flags [I] (0x08), overlay 0, instance 1</span><br><span class="line">IP 10.244.1.97 &gt; 10.244.2.88: ICMP <span class="built_in">echo</span> request, id 7168, seq 0, length 64</span><br><span class="line">10:59:24.234434 IP 172.16.1.102.54894 &gt; 172.16.1.101.8472: OTV, flags [I] (0x08), overlay 0, instance 1</span><br><span class="line">IP 10.244.2.88 &gt; 10.244.1.97: ICMP <span class="built_in">echo</span> reply, id 7168, seq 0, length 64</span><br><span class="line">10:59:25.234301 IP 172.16.1.101.60617 &gt; 172.16.1.102.8472: OTV, flags [I] (0x08), overlay 0, instance 1</span><br><span class="line">IP 10.244.1.97 &gt; 10.244.2.88: ICMP <span class="built_in">echo</span> request, id 7168, seq 1, length 64</span><br><span class="line">10:59:25.234469 IP 172.16.1.102.54894 &gt; 172.16.1.101.8472: OTV, flags [I] (0x08), overlay 0, instance 1</span><br><span class="line">IP 10.244.2.88 &gt; 10.244.1.97: ICMP <span class="built_in">echo</span> reply, id 7168, seq 1, length 64</span><br><span class="line">10:59:26.234415 IP 172.16.1.101.60617 &gt; 172.16.1.102.8472: OTV, flags [I] (0x08), overlay 0, instance 1</span><br><span class="line">IP 10.244.1.97 &gt; 10.244.2.88: ICMP <span class="built_in">echo</span> request, id 7168, seq 2, length 64</span><br><span class="line">10:59:26.234592 IP 172.16.1.102.54894 &gt; 172.16.1.101.8472: OTV, flags [I] (0x08), overlay 0, instance 1</span><br><span class="line">IP 10.244.2.88 &gt; 10.244.1.97: ICMP <span class="built_in">echo</span> reply, id 7168, seq 2, length 64</span><br><span class="line">10:59:27.234528 IP 172.16.1.101.60617 &gt; 172.16.1.102.8472: OTV, flags [I] (0x08), overlay 0, instance 1</span><br><span class="line">IP 10.244.1.97 &gt; 10.244.2.88: ICMP <span class="built_in">echo</span> request, id 7168, seq 3, length 64</span><br></pre></td></tr></table></figure>
<pre><code>下面我们把flannel的通信模式改成directrouting的方式</code></pre>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master flannel]<span class="comment"># cd /root/manifests/flannel</span></span><br><span class="line">[root@master flannel]<span class="comment"># kubectl edit configmap kube-flannel-cfg -n kube-system</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="string">&quot;Network&quot;</span>: <span class="string">&quot;10.244.0.0/16&quot;</span>,</span><br><span class="line">      <span class="string">&quot;Backend&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;vxlan&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Directrouting&quot;</span>: <span class="literal">true</span> <span class="comment">#加一行这个</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">[root@master flannel]<span class="comment"># ip route show</span></span><br><span class="line">default via 172.16.1.254 dev ens192 proto static metric 100 </span><br><span class="line">10.244.0.0/24 dev cni0 proto kernel scope link src 10.244.0.1 <span class="comment">#访问10.244.0.0/24要通过10.244.0.1</span></span><br><span class="line">10.244.1.0/24 via 10.244.1.0 dev flannel.1 onlink <span class="comment">#10.244.1.0是配置在flannel上的地址，表示访问10.244.1.0/24通过本机flannel.1上的10.244.1.0送出去，下同</span></span><br><span class="line">10.244.2.0/24 via 10.244.2.0 dev flannel.1 onlink  <span class="comment">#10.244.2.0是配置在flannel上的地址</span></span><br><span class="line">172.16.1.0/24 dev ens192 proto kernel scope link src 172.16.1.100 metric 100</span><br><span class="line"></span><br><span class="line">[root@master flannel]<span class="comment"># kubectl get configmap kube-flannel-cfg -o json -n kube-system</span></span><br><span class="line">　　　　　　<span class="string">&quot;net-conf.json&quot;</span>: <span class="string">&quot;&#123;\n \&quot;Network\&quot;: \&quot;10.244.0.0/16\&quot;,\n \&quot;Backend\&quot;: &#123;\n \&quot;Type\&quot;: \&quot;vxlan\&quot;,\n \&quot;Directrouting\&quot;: true\n &#125;\n&#125;\n&quot;</span></span><br></pre></td></tr></table></figure>
<p>看到有Directrouting，说明生效了。</p>
<pre><code>重启整个k8s，然后再看：</code></pre>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># ip route show</span></span><br><span class="line">default via 172.16.1.254 dev ens192 proto static metric 100 </span><br><span class="line">10.244.0.0/24 dev cni0 proto kernel scope link src 10.244.0.1 <span class="comment">#访问本机直接在本机直接转发，而不需要其他接口，这就是directrouting</span></span><br><span class="line">10.244.1.0/24 via 172.16.1.101 dev ens192 <span class="comment">#看到现在访问10.244.1.0，通过本地物理网卡ens192上的172.16.1.101送出去，即通过物理网卡通信了，而不再通过隧道flannel通信。</span></span><br><span class="line">10.244.2.0/24 via 172.16.1.102 dev ens192 </span><br><span class="line">172.16.1.0/24 dev ens192 proto kernel scope link src 172.16.1.100 metric 100 </span><br><span class="line">172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1</span><br><span class="line">继续登录到一个pod中进行ping测试：</span><br><span class="line"></span><br><span class="line">[root@master ~]<span class="comment"># kubectl get pods -o wide</span></span><br><span class="line">NAME                             READY     STATUS             RESTARTS   AGE       IP             NODE</span><br><span class="line">myapp-deploy-69b47bc96d-75g2b    1/1       Running            0          12m       10.244.1.124   node1</span><br><span class="line">myapp-deploy-69b47bc96d-jwgwm    1/1       Running            0          3s        10.244.2.100   node2</span><br><span class="line">[root@master ~]<span class="comment"># kubectl exec  -it myapp-deploy-69b47bc96d-75g2b -- /bin/sh</span></span><br><span class="line">/ <span class="comment"># ping 10.244.2.100</span></span><br><span class="line">PING 10.244.2.100 (10.244.2.100): 56 data bytes</span><br><span class="line">64 bytes from 10.244.2.100: seq=0 ttl=62 time=0.536 ms</span><br><span class="line">64 bytes from 10.244.2.100: seq=1 ttl=62 time=0.206 ms</span><br><span class="line">64 bytes from 10.244.2.100: seq=2 ttl=62 time=0.206 ms</span><br><span class="line">64 bytes from 10.244.2.100: seq=3 ttl=62 time=0.203 ms</span><br><span class="line">64 bytes from 10.244.2.100: seq=4 ttl=62 time=0.210 ms</span><br><span class="line">[root@node1 ~]<span class="comment"># tcpdump -i ens192 -nn icmp</span></span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on ens192, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">12:31:10.899403 IP 10.244.1.124 &gt; 10.244.2.100: ICMP <span class="built_in">echo</span> request, id 8960, seq 24, length 64</span><br><span class="line">12:31:10.899546 IP 10.244.2.100 &gt; 10.244.1.124: ICMP <span class="built_in">echo</span> reply, id 8960, seq 24, length 64</span><br><span class="line">12:31:11.899505 IP 10.244.1.124 &gt; 10.244.2.100: ICMP <span class="built_in">echo</span> request, id 8960, seq 25, length 64</span><br><span class="line">12:31:11.899639 IP 10.244.2.100 &gt; 10.244.1.124: ICMP <span class="built_in">echo</span> reply, id 8960, seq 25, length 64</span><br><span class="line">通过抓包可以看到，现在在pod中进行互ping，是从物理网卡ens192进出的，这就是directrouting，这种性能比默认vxlan高。</span><br></pre></td></tr></table></figure>
<h2 id="外部访问集群"><a href="#外部访问集群" class="headerlink" title="外部访问集群"></a>外部访问集群</h2><p>从集群外访问集群有多种方式，比如loadbalancer，Ingress，nodeport，nodeport和loadbalancer是service的两个基本类型，是将service直接对外暴露的方式，ingress则是提供了七层负载均衡，其基本原理将外部流量转发到内部的service，再转发到后端endpoints，在平时的使用中，我们可以依据具体的业务需求选用不同的方式。这里主要介绍nodeport和ingress方式。</p>
<h3 id="Nodeport"><a href="#Nodeport" class="headerlink" title="Nodeport"></a>Nodeport</h3><p>通过将Service的类型设置为NodePort，就可以在Cluster中的主机上通过一个指定端口暴露服务。注意通过Cluster中每台主机上的该指定端口都可以访问到该服务，发送到该主机端口的请求会被kubernetes路由到提供服务的Pod上。采用这种服务类型，可以在kubernetes cluster网络外通过主机IP：端口的方式访问到服务。</p>
<img src="/2020/08/11/kubernetes%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/nodeport.jpg" class title="kubernetes网络通信原理">
<p>这里给出一个influxdb的例子，我们也可以针对这个模板去修改成其他的类型：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">influxdb</span></span><br><span class="line">  <span class="attr">spec:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8086</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">31112</span></span><br><span class="line">      <span class="attr">selector:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">influxdb</span></span><br></pre></td></tr></table></figure>

<h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><img src="/2020/08/11/kubernetes%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/ingress.jpg" class title="kubernetes网络通信原理">
<p>Ingress是推荐在生产环境使用的方式，它起到了七层负载均衡器和Http方向代理的作用，可以根据不同的url把入口流量分发到不同的后端Service。外部客户端只看到<a href="http://foo.bar.com这个服务器,屏蔽了内部多个service的实现方式.采用这种方式,简化了客户端的访问,并增加了后端实现和部署的灵活性,可以在不影响客户端的情况下对后端的服务部署进行调整./">http://foo.bar.com这个服务器，屏蔽了内部多个Service的实现方式。采用这种方式，简化了客户端的访问，并增加了后端实现和部署的灵活性，可以在不影响客户端的情况下对后端的服务部署进行调整。</a></p>
<p>其部署的yaml可以参考如下模板：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line"> <span class="attr">annotations:</span></span><br><span class="line"> <span class="attr">ingress.kubernetes.io/rewrite-target:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">rules:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">test.name.com</span></span><br><span class="line"> <span class="attr">http:</span></span><br><span class="line"> <span class="attr">paths:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/test</span></span><br><span class="line"> <span class="attr">backend:</span></span><br><span class="line"> <span class="attr">serviceName:</span> <span class="string">service-1</span></span><br><span class="line"> <span class="attr">servicePort:</span> <span class="number">8118</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/name</span></span><br><span class="line"> <span class="attr">backend:</span></span><br><span class="line"> <span class="attr">serviceName:</span> <span class="string">service-2</span></span><br><span class="line"> <span class="attr">servicePort:</span> <span class="number">8228</span></span><br></pre></td></tr></table></figure>
<p>这里我们定义了一个ingress模板，定义通过<a href="http://test.name.com来访问服务,在虚拟主机http//test.name.com%E4%B8%8B%E9%9D%A2%E5%AE%9A%E4%B9%89%E4%BA%86%E4%B8%A4%E4%B8%AAPath%EF%BC%8C%E5%85%B6%E4%B8%AD/test%E8%A2%AB%E5%88%86%E5%8F%91%E5%88%B0%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1s1%EF%BC%8C/name%E8%A2%AB%E5%88%86%E5%8F%91%E5%88%B0%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1s2%E3%80%82">http://test.name.com来访问服务，在虚拟主机http://test.name.com下面定义了两个Path，其中/test被分发到后端服务s1，/name被分发到后端服务s2。</a><br>集群中可以定义多个ingress，来完成不同服务的转发，这里需要一个ingress controller来管理集群中的Ingress规则。Ingress Contronler 通过与 Kubernetes API 交互，动态的去感知集群中 Ingress 规则变化，然后读取它，按照自定义的规则，规则就是写明了哪个域名对应哪个service，生成一段 Nginx 配置，再写到 Nginx-ingress-control的 Pod 里，这个 Ingress Contronler 的pod里面运行着一个nginx服务，控制器会把生成的nginx配置写入/etc/nginx.conf文件中，然后 reload使用配置生效。</p>
<p>Kubernetes提供的Ingress Controller模板如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line"> <span class="attr">annotations:</span></span><br><span class="line"> <span class="attr">ingress.kubernetes.io/rewrite-target:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">rules:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">foo.bar.com</span></span><br><span class="line"> <span class="attr">http:</span></span><br><span class="line"> <span class="attr">paths:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/foo</span></span><br><span class="line"> <span class="attr">backend:</span></span><br><span class="line"> <span class="attr">serviceName:</span> <span class="string">s1</span></span><br><span class="line"> <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/bar</span></span><br><span class="line"> <span class="attr">backend:</span></span><br><span class="line"> <span class="attr">serviceName:</span> <span class="string">s2</span></span><br><span class="line"> <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>



<p><a href="https://blog.51cto.com/liuzhengwei521/2427495">https://blog.51cto.com/liuzhengwei521/2427495</a></p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>py_day01_exercise</title>
    <url>/2020/08/09/py-day01-exercise/</url>
    <content><![CDATA[<p>温故知新</p>
<a id="more"></a>

<h3 id="1-列举你了解的编码及他们之间的区别？"><a href="#1-列举你了解的编码及他们之间的区别？" class="headerlink" title="1.列举你了解的编码及他们之间的区别？"></a>1.列举你了解的编码及他们之间的区别？</h3><ul>
<li>ASCII: python2默认的编码，一个字母是8位</li>
<li>Unicode(万国码)：一个字母是32位</li>
<li>UTF - 8：万国码的压缩码，最少用一个字节，最多用4个字节，一个中文是三个字节，24<br>位</li>
<li>GBK: 专门用作汉文的编码，其中一个中文用两个字节<blockquote>
<p>注意：用什么格式编写保存文件，就用什么格式打开</p>
</blockquote>
</li>
</ul>
<h3 id="2-Python2和Python3的区别？"><a href="#2-Python2和Python3的区别？" class="headerlink" title="2.Python2和Python3的区别？"></a>2.Python2和Python3的区别？</h3><ul>
<li>编码<ul>
<li>python2默认的编码是ACSII</li>
<li>python3默认的编码是UTF-8,所以开发过程中最好加一句：  # -<em>- coding:utf-8 -</em>-</li>
</ul>
</li>
<li>输入<ul>
<li>python2: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = raw_input(<span class="string">&quot;请输入姓名：&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li>python3 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = input(<span class="string">&quot;请输入姓名：&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>print<ul>
<li>python2: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>python3 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&quot;123456&quot;</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="3-python都有那些数据类型？"><a href="#3-python都有那些数据类型？" class="headerlink" title="3.python都有那些数据类型？"></a>3.python都有那些数据类型？</h3><p>Python基本数据类型一般分为：数字、字符串、列表、元组、字典、集合</p>
<h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a><strong>数字</strong></h4><p>数字类型是不可更改的对象。对变量改变数字值就是生成/创建新的对象。<br>Python支持多种数字类型：<br>整型(标准整型和长整型(Python2.7及之前的有这种类型))、布尔型、双精度浮点型、十进制浮点型、复数。</p>
<h4 id="标准整型"><a href="#标准整型" class="headerlink" title="标准整型"></a><strong>标准整型</strong></h4><p>int，标准整型，在大多数32位机器上标准整型取值范围是-2^31到2^31-1，也就是-2147483648~2147483647，如果在64位机器使用64位编译器，那么这个系统的标准整型将是64位。</p>
<h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a><strong>布尔型</strong></h4><p>bool，从Python2.3开始Python中添加了布尔类型。布尔类型有两种True和False。对于没有__nozero__方法的对象默认是True。</p>
<p>对于值为0的数字、空集（空列表、空元组、空字典等）在Python中的布尔类型中都是False。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="number">1</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="number">0</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a><strong>浮点型</strong></h4><p>float，每个浮点型占8个字节（64位），完全遵守IEEE754号规范（52M/11E/1S）,其中52个位用于表示底，11个位用于表示指数（可表示的范围大约是±10**308.25），剩下的一个位表示符号。这看上去相当完美，然而，实际精度依赖于机器架构和创建Python解释器的编译器。</p>
<p>浮点型值通常都有一个小数点和一个可选的后缀e（大写或小写，表示科学计数法）。在e和指数之间可以用正（+）或负（-）表示指数的正负（正数的话可以省略符号）。更多内容，请点击python学习网。</p>
<p>以上是Python核心编程的对浮点型(双精度浮点型)的说明。经过Python实测浮点型默认长度是24字节如果超出这个范围会自动</p>
<p>复数类型</p>
<p>complex，在复数中虚数不能单独存在，它们总是和一个值为0.0的实数部分一起来构成一个复数。<br>复数由实数部分和虚数部分构成。<br>表示虚数的语法：real+imagj。<br>实数部分和虚数部分都是浮点型。<br>虚数部分必须有后缀j或J。</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h4><p>字符串(string)是不可变类型，就是说改变一个字符串的元素需要新建一个新的字符串。字符串是由独立的字符组成的，并且这些字符可以通过切片操作顺序地访问。Python里面通过在引号间包含字符的方式创建字符串，单引号和双引号的作用是相同的。</p>
<p>Python用“原始字符串”操作符来创建直接量字符串，所以再做区分就没什么意义了。其他的语言，比如C语言里面用单引号来标示字符，双引号标示字符串，而在Python里面没有字符这个类型。这可能是双引号和单引号在Python里面被视作一样的另一个原因。</p>
<p>Python实际上有三类字符串。通常意义的字符串（str） 和Unicode字符串（unicode） 实际上都是抽象类basestring的子类。这个basestring是不能实例化的。</p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a><strong>列表</strong></h4><p>列表(list)像字符串类型一样，列表类型也是序列式的数据类型。字符串只能由字符组成，而且是不可变的（不能单独改变它的某个值），而列表则是能保留任意数目的Python对象的灵活的容器。</p>
<p>列表不仅可以包含Python的标准类型，而且可以用用户定义的对象作为自己的元素。列表可以包含不同类型的对象，而且要比C或者Python自己的数组类型（包含在array扩展包中）都要灵活，因为数组类型所有的元素只能是一种类型。列表可以执行pop,sort、reverse等操作。列表也可以添加或者减少元素，还可以跟其他的列表结合或者把一个列表分成几个。可以对单独一个元素或者多个元素执行insert、update或remove操作。</p>
<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a><strong>元组</strong></h4><p>元组类型在很多操作上都跟列表一样，许多用在列表上的例子在元组上照样能跑，我们有一节内容专门讲解元组类型。它们的主要不同在于元组是不可变的，或者说是只读的，所以那些用于更新列表的操作，比如用切片操作来更新一部分元素的操作，就不能用于元组类型。</p>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a><strong>字典</strong></h4><p>字典是Python语言中唯一的映射类型。映射类型对象里哈希值（键，key） 和指向的对象（值。value） 是一对多的关系。一个字典对象是可变的，它是一个容器类型，能存储任意个数的Python对象，其中也包括其他容器类型。字典类型和序列类型容器类（列表、元组） 的区别是存储和访问数据的方式不同。序列类型只用数字类型的键（从序列的开始起按数值顺序索引） 。映射类型可以用其他对象类型做键，一般最常见的是用字符串做键。和序列类型的键不同，映像类型的键直接或间接地和存储的数据值相关联。但因为在映射类型中，我们不再用“序列化排序”的键，所以映像类型中的数据是无序排列的映射类型不要求用数字值做索引以从一个容器中获取对应的数据项。你可以用键直接“映射”到值，这就是为什么叫映射类型（“mappingtype”） 的原因。映射类型通常被称做哈希表，是因为字典对象就是哈希类型的。字典是Python中最强大的数据类型之一。</p>
<p>字典常见的操作有：字典创建、字典赋值、字典中值的访问、字典更新、字典元素删除等操作。</p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a><strong>集合</strong></h4><p>集合最早出现在Python2.3版本中，通过集合模块来创建，并通过ImmutableSet类和Set类进行访问。</p>
<p>集合有两种不同的类型，可变集合（set）和不可变集合（frozenset）。可变集合，你可以添加和删除元素，对不可变集合则不允许这样做。请注意，可变集合不是可哈希的，因此既不能用做字典的键也不能做其他集合中的元素。不可变集合则正好相反，即，他们有哈希值，能被用做字典的键或是作为集合中的一个成员。集合对象是一组无序排列的可哈希的值。</p>
<p>集合支持用in和not in操作符检查成员，由len()内建函数得到集合的基数（大小） ，用for循环迭代集合的成员。但是因为集合本身是无序的，你不可以为集合创建索引或执行切片（slice） 操作，也没有键可用来获取集合中元素的值。</p>
<h3 id="4-补充代码，实现以下功能"><a href="#4-补充代码，实现以下功能" class="headerlink" title="4.补充代码，实现以下功能"></a>4.补充代码，实现以下功能</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value = <span class="string">&#x27;51devops&quot;niubi&#x27;</span></span><br><span class="line">print(value)</span><br></pre></td></tr></table></figure>
<h3 id="5-用print打印出下面内容："><a href="#5-用print打印出下面内容：" class="headerlink" title="5.用print打印出下面内容："></a>5.用print打印出下面内容：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">⽂能提笔安天下,</span></span><br><span class="line"><span class="string">武能上⻢定乾坤.</span></span><br><span class="line"><span class="string">⼼存谋略何⼈胜,</span></span><br><span class="line"><span class="string">古今英雄唯是君。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="6-变量名的命名规范和建议？"><a href="#6-变量名的命名规范和建议？" class="headerlink" title="6.变量名的命名规范和建议？"></a>6.变量名的命名规范和建议？</h3><blockquote>
<ol>
<li>变量名只能是 字母、数字或下划线的任意组合</li>
<li>变量名的第一个字符不能是数字</li>
<li>关键字不能声明为变量名[‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘exec’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘not’, ‘or’, ‘pass’, ‘print’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’]</li>
</ol>
</blockquote>
<h3 id="7-如下那个变量名是正确的？"><a href="#7-如下那个变量名是正确的？" class="headerlink" title="7.如下那个变量名是正确的？"></a>7.如下那个变量名是正确的？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name &#x3D; &#39;51devops&#39;  ✔️</span><br><span class="line">_ &#x3D; &#39;echo&#39;         ✔️</span><br><span class="line">_9 &#x3D; &quot;zhangsan&quot;    ✔️</span><br><span class="line">9name &#x3D; &quot;xxx&quot;      ×</span><br><span class="line">devops(edu &#x3D; 666   ×</span><br></pre></td></tr></table></figure>

<h3 id="8-简述你了解if条件语句的基本结构。"><a href="#8-简述你了解if条件语句的基本结构。" class="headerlink" title="8.简述你了解if条件语句的基本结构。"></a>8.简述你了解if条件语句的基本结构。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1)</span><br><span class="line">if 条件:</span><br><span class="line">    代码块</span><br><span class="line">else:</span><br><span class="line">    代码块</span><br><span class="line">(2)</span><br><span class="line">if 条件:</span><br><span class="line">    代码块</span><br><span class="line">elif 条件:</span><br><span class="line">    代码块</span><br><span class="line">else:</span><br><span class="line">    代码块</span><br><span class="line">(3)</span><br><span class="line">if 条件:</span><br><span class="line">    代码块</span><br><span class="line">if 条件:</span><br><span class="line">    代码块</span><br><span class="line">else:</span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure>

<h3 id="9-设定一个理想数字比如：66，让用户输入数字，如果比66大，则显示猜测的结果大了；如果比66小，则显示猜测的结果小了-只有等于66，显示猜测结果正确。"><a href="#9-设定一个理想数字比如：66，让用户输入数字，如果比66大，则显示猜测的结果大了；如果比66小，则显示猜测的结果小了-只有等于66，显示猜测结果正确。" class="headerlink" title="9.设定一个理想数字比如：66，让用户输入数字，如果比66大，则显示猜测的结果大了；如果比66小，则显示猜测的结果小了;只有等于66，显示猜测结果正确。"></a>9.设定一个理想数字比如：66，让用户输入数字，如果比66大，则显示猜测的结果大了；如果比66小，则显示猜测的结果小了;只有等于66，显示猜测结果正确。</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">right_num = <span class="number">66</span></span><br><span class="line"></span><br><span class="line">num = int(input(<span class="string">&quot;请输入一个数字:&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num &gt; right_num:</span><br><span class="line">    print(<span class="string">&#x27;猜测的结果大了&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> num &lt; right_num:</span><br><span class="line">    print(<span class="string">&#x27;猜测的结果小了&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;猜对了&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="10-写程序，成绩有ABCDE5个等级，与分数的对应关系如下"><a href="#10-写程序，成绩有ABCDE5个等级，与分数的对应关系如下" class="headerlink" title="10.写程序，成绩有ABCDE5个等级，与分数的对应关系如下."></a>10.写程序，成绩有ABCDE5个等级，与分数的对应关系如下.</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">grade = int(input(<span class="string">&quot;请输入分数:&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> grade &gt;= <span class="number">100</span> <span class="keyword">or</span> grade &lt; <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">&#x27;请输入正确分数:0-100&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">90</span> &lt;= grade &lt;= <span class="number">100</span>:</span><br><span class="line">    print(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">80</span> &lt;= grade &lt; <span class="number">90</span>:</span><br><span class="line">    print(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">60</span> &lt;= grade &lt; <span class="number">80</span>:</span><br><span class="line">    print(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">40</span> &lt;= grade &lt; <span class="number">60</span>:</span><br><span class="line">    print(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;E&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="11-模拟10086客服电话（条件语句的嵌套）"><a href="#11-模拟10086客服电话（条件语句的嵌套）" class="headerlink" title="11.模拟10086客服电话（条件语句的嵌套）"></a>11.模拟10086客服电话（条件语句的嵌套）</h3><hr>
<h3 id="1-猜数字，设定一个理想数字比如：66，让用户输入数字，如果比66大，则显示猜测的结果大了；如果比66小，则显示猜测的结果小了-只有等于66，显示猜测结果正确，然后退出循环。"><a href="#1-猜数字，设定一个理想数字比如：66，让用户输入数字，如果比66大，则显示猜测的结果大了；如果比66小，则显示猜测的结果小了-只有等于66，显示猜测结果正确，然后退出循环。" class="headerlink" title="1.猜数字，设定一个理想数字比如：66，让用户输入数字，如果比66大，则显示猜测的结果大了；如果比66小，则显示猜测的结果小了;只有等于66，显示猜测结果正确，然后退出循环。"></a>1.猜数字，设定一个理想数字比如：66，让用户输入数字，如果比66大，则显示猜测的结果大了；如果比66小，则显示猜测的结果小了;只有等于66，显示猜测结果正确，然后退出循环。</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">right_num = <span class="number">66</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    num = int(input(<span class="string">&quot;请输入一个数字:&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> num &gt; right_num:</span><br><span class="line">        print(<span class="string">&#x27;猜测的结果大了&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> num &lt; right_num:</span><br><span class="line">        print(<span class="string">&#x27;猜测的结果小了&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;猜对了&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h3 id="2-在上一题的基础，设置：给用户三次猜测机会，如果三次之内猜测对了，则显示猜测正确，退出循环，如果三次之内没有猜测正确，则自动退出循环，并显示‘大笨蛋’。"><a href="#2-在上一题的基础，设置：给用户三次猜测机会，如果三次之内猜测对了，则显示猜测正确，退出循环，如果三次之内没有猜测正确，则自动退出循环，并显示‘大笨蛋’。" class="headerlink" title="2.在上一题的基础，设置：给用户三次猜测机会，如果三次之内猜测对了，则显示猜测正确，退出循环，如果三次之内没有猜测正确，则自动退出循环，并显示‘大笨蛋’。"></a>2.在上一题的基础，设置：给用户三次猜测机会，如果三次之内猜测对了，则显示猜测正确，退出循环，如果三次之内没有猜测正确，则自动退出循环，并显示‘大笨蛋’。</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">right_num = <span class="number">66</span></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">    num = int(input(<span class="string">&quot;请输入一个数字:&quot;</span>))</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> num &gt; right_num:</span><br><span class="line">        print(<span class="string">&#x27;猜测的结果大了&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> num &lt; right_num:</span><br><span class="line">        print(<span class="string">&#x27;猜测的结果小了&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;猜对了&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;太笨了&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-使用两种方法实现输出-1-2-3-4-5-6-8-9-10"><a href="#3-使用两种方法实现输出-1-2-3-4-5-6-8-9-10" class="headerlink" title="3.使用两种方法实现输出 1 2 3 4 5 6 8 9 10"></a>3.使用两种方法实现输出 1 2 3 4 5 6 8 9 10</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">10</span>:</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(n)</span><br><span class="line"></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> n &lt;= <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">if</span> n != <span class="number">7</span>:</span><br><span class="line">        print(n)</span><br><span class="line">    n += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="4-求1-100的所有数的和"><a href="#4-求1-100的所有数的和" class="headerlink" title="4.求1-100的所有数的和"></a>4.求1-100的所有数的和</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n &lt;= <span class="number">100</span>:</span><br><span class="line">    res += n</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<h3 id="5-输出-1-100-内的所有奇数"><a href="#5-输出-1-100-内的所有奇数" class="headerlink" title="5.输出 1-100 内的所有奇数"></a>5.输出 1-100 内的所有奇数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> n &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">        print(n)</span><br><span class="line">    n += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="6-输出-1-100-内的所有偶数"><a href="#6-输出-1-100-内的所有偶数" class="headerlink" title="6.输出 1-100 内的所有偶数"></a>6.输出 1-100 内的所有偶数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> n &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        print(n)</span><br><span class="line">    n += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="7-求1-2-3-4-5-…-99的所有数的和"><a href="#7-求1-2-3-4-5-…-99的所有数的和" class="headerlink" title="7.求1-2+3-4+5 … 99的所有数的和"></a>7.求1-2+3-4+5 … 99的所有数的和</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        res += n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res -= n</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>

<h3 id="8-⽤户登陆（三次输错机会）且每次输错误时显示剩余错误次数（提示：使⽤字符串格式化）"><a href="#8-⽤户登陆（三次输错机会）且每次输错误时显示剩余错误次数（提示：使⽤字符串格式化）" class="headerlink" title="8.⽤户登陆（三次输错机会）且每次输错误时显示剩余错误次数（提示：使⽤字符串格式化）"></a>8.⽤户登陆（三次输错机会）且每次输错误时显示剩余错误次数（提示：使⽤字符串格式化）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">user = <span class="string">&#x27;test&#x27;</span></span><br><span class="line">passwd = <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">count = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> count &gt; <span class="number">0</span>:</span><br><span class="line">    count -= <span class="number">1</span></span><br><span class="line">    valid_user = input(<span class="string">&#x27;请输入用户名:&#x27;</span>)</span><br><span class="line">    valid_passwd = input(<span class="string">&#x27;请输入密码:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> valid_user == user <span class="keyword">and</span> valid_passwd == passwd:</span><br><span class="line">        print(<span class="string">&#x27;登录成功&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;用户名或密码错误(剩余尝试次数: %s次)&quot;</span> %(count))</span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">0</span>:</span><br></pre></td></tr></table></figure>

<h3 id="9-猜年龄游戏"><a href="#9-猜年龄游戏" class="headerlink" title="9.猜年龄游戏"></a>9.猜年龄游戏</h3><p>要求：允许用户最多尝试3次，3次都没猜对的话，就直接退出，如果猜对了，打印恭喜信息并退出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment">#年龄</span></span><br><span class="line">age = random.randint(<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line">print(age)</span><br><span class="line"></span><br><span class="line">count = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> count &gt; <span class="number">0</span>:</span><br><span class="line">    guess_age = int(input(<span class="string">&#x27;猜猜我的年龄:&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> guess_age &gt; age:</span><br><span class="line">        print(<span class="string">&#x27;猜大了&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> guess_age &lt; age:</span><br><span class="line">        print(<span class="string">&#x27;猜小了&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;猜对了&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    count -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="10-猜年龄游戏升级版"><a href="#10-猜年龄游戏升级版" class="headerlink" title="10.猜年龄游戏升级版"></a>10.猜年龄游戏升级版</h3><p>要求：允许用户最多尝试3次，每尝试3次后，如果还没猜对，就问用户是否还想继续玩，如果回答Y，就继续让其猜3次，以此往复，如果回答N，就退出程序，如何猜对了，就直接退出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment">#年龄</span></span><br><span class="line">age = random.randint(<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line">print(age)</span><br><span class="line"></span><br><span class="line">count = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> count &gt; <span class="number">0</span>:</span><br><span class="line">    guess_age = int(input(<span class="string">&#x27;猜猜我的年龄:&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> guess_age &gt; age:</span><br><span class="line">        print(<span class="string">&#x27;猜大了&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> guess_age &lt; age:</span><br><span class="line">        print(<span class="string">&#x27;猜小了&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;猜对了&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    count -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">        chance = input(<span class="string">&#x27;Do you want continue(Y/N):&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> chance == <span class="string">&#x27;Y&#x27;</span> <span class="keyword">or</span> chance == <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">            count = <span class="number">3</span></span><br><span class="line">        <span class="keyword">elif</span> chance == <span class="string">&#x27;N&#x27;</span> <span class="keyword">or</span> chance == <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&#x27;pls input correct choice&#x27;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-写代码，有如下列表，按照要求实现每一个功能。"><a href="#1-写代码，有如下列表，按照要求实现每一个功能。" class="headerlink" title="1.写代码，有如下列表，按照要求实现每一个功能。"></a>1.写代码，有如下列表，按照要求实现每一个功能。</h3><p>li = [“pounds”, “szk”, “haoda”, “barry”, “devops”]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#计算列表的长度并输出</span></span><br><span class="line">print(len(li))</span><br><span class="line"></span><br><span class="line"><span class="comment">#请通过步长获取索引为偶数的所有值，并打印出获取后的列表</span></span><br><span class="line">print(li[::<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#列表中追加元素”seven”,并输出添加后的列表</span></span><br><span class="line">li.append(<span class="string">&quot;seven&quot;</span>)</span><br><span class="line">print(li)</span><br><span class="line"></span><br><span class="line"><span class="comment">#请在列表的第1个位置插入元素”Tony”,并输出添加后的列表</span></span><br><span class="line">li.insert(<span class="number">1</span>,<span class="string">&quot;Tony&quot;</span>)</span><br><span class="line">print(li)</span><br><span class="line"></span><br><span class="line"><span class="comment">#请修改列表第2个位置的元素为”Kelly”,并输出修改后的列表</span></span><br><span class="line">li[<span class="number">2</span>] = <span class="string">&quot;Kelly&quot;</span></span><br><span class="line">print(li)</span><br><span class="line"></span><br><span class="line"><span class="comment">#请删除列表中的元素”haoda”,并输出添加后的列表</span></span><br><span class="line">li.remove(<span class="string">&quot;haoda&quot;</span>)</span><br><span class="line">print(li)</span><br><span class="line"></span><br><span class="line"><span class="comment">#请删除列表中的第2个元素，并输出删除元素后的列表</span></span><br><span class="line">li.pop(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># del li[2]</span></span><br><span class="line">print(li)</span><br><span class="line"></span><br><span class="line"><span class="comment">#请删除列表中的第2至第4个元素，并输出删除元素后的列表</span></span><br><span class="line"><span class="keyword">del</span> li[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure>

<h3 id="2-写代码，有如下列表，利用切片实现每一个功能"><a href="#2-写代码，有如下列表，利用切片实现每一个功能" class="headerlink" title="2.写代码，有如下列表，利用切片实现每一个功能"></a>2.写代码，有如下列表，利用切片实现每一个功能</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">&quot;a&quot;</span>, <span class="number">4</span>, <span class="string">&quot;b&quot;</span>, <span class="number">5</span>,<span class="string">&quot;c&quot;</span>]</span><br><span class="line"><span class="comment"># 通过对li列表的切片形成新的列表 [1,3,2]</span></span><br><span class="line">new_list = li[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">print(new_list)</span><br><span class="line"><span class="comment"># 通过对li列表的切片形成新的列表 [“a”,4,”b”]</span></span><br><span class="line">new_list = li[<span class="number">3</span>:<span class="number">6</span>]</span><br><span class="line">print(new_list)</span><br><span class="line"><span class="comment"># 通过对li列表的切片形成新的列表 [1,2,4,5]</span></span><br><span class="line">new_list = li[::<span class="number">2</span>]</span><br><span class="line">print(new_list)</span><br><span class="line"><span class="comment"># 通过对li列表的切片形成新的列表 [3,”a”,”b”]</span></span><br><span class="line">new_list = li[<span class="number">1</span>:<span class="number">-2</span>:<span class="number">2</span>]</span><br><span class="line">print(new_list)</span><br><span class="line"><span class="comment"># 通过对li列表的切片形成新的列表 [3,”a”,”b”,”c”]</span></span><br><span class="line">new_list = li[<span class="number">1</span>::<span class="number">2</span>]</span><br><span class="line">print(new_list)</span><br><span class="line"><span class="comment"># 通过对li列表的切片形成新的列表 [“c”]</span></span><br><span class="line">new_list = li[<span class="number">-1</span>:]</span><br><span class="line">print(new_list)</span><br><span class="line"><span class="comment"># 通过对li列表的切片形成新的列表 [“b”,”a”,3]</span></span><br><span class="line">new_list = li[<span class="number">-3</span>::<span class="number">-2</span>]</span><br><span class="line">print(new_list)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-写代码，有如下列表，按照要求实现每一个功能。"><a href="#3-写代码，有如下列表，按照要求实现每一个功能。" class="headerlink" title="3.写代码，有如下列表，按照要求实现每一个功能。"></a>3.写代码，有如下列表，按照要求实现每一个功能。</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lis = [<span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;k&quot;</span>, [<span class="string">&quot;qwe&quot;</span>, <span class="number">20</span>, [<span class="string">&quot;k1&quot;</span>, [<span class="string">&quot;tt&quot;</span>, <span class="number">3</span>, <span class="string">&quot;1&quot;</span>]], <span class="number">89</span>], <span class="string">&quot;ab&quot;</span>, <span class="string">&quot;adv&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将列表lis中的”k”变成大写，并打印列表。</span></span><br><span class="line">lis[<span class="number">2</span>] = lis[<span class="number">2</span>].upper()</span><br><span class="line">lis[<span class="number">2</span>] = <span class="string">&quot;K&quot;</span></span><br><span class="line">print(lis)</span><br><span class="line"><span class="comment">#将列表中的数字3变成字符串”100”</span></span><br><span class="line">lis[<span class="number">1</span>] = <span class="string">&quot;100&quot;</span></span><br><span class="line">print(lis)</span><br><span class="line"><span class="comment">#将列表中的字符串”tt”变成数字 101</span></span><br><span class="line">lis[<span class="number">3</span>][<span class="number">2</span>][<span class="number">0</span>] = <span class="number">101</span></span><br><span class="line">print(lis)</span><br><span class="line"><span class="comment">#在 “qwe”前面插入字符串：”火车头”</span></span><br><span class="line">lis[<span class="number">3</span>].insert(<span class="number">0</span>,<span class="string">&quot;火车头&quot;</span>)</span><br><span class="line">print(lis)</span><br></pre></td></tr></table></figure>


<h3 id="4-请用代码实现循环输出元素和值：users-“szk”-”pounds”-”波姐”-，如："><a href="#4-请用代码实现循环输出元素和值：users-“szk”-”pounds”-”波姐”-，如：" class="headerlink" title="4.请用代码实现循环输出元素和值：users = [“szk”,”pounds”,”波姐”] ，如："></a>4.请用代码实现循环输出元素和值：users = [“szk”,”pounds”,”波姐”] ，如：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">users = [<span class="string">&quot;szk&quot;</span>,<span class="string">&quot;pounds&quot;</span>,<span class="string">&quot;波姐&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx,value <span class="keyword">in</span> enumerate(users):</span><br><span class="line">    print(idx,value)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-写代码实现以下功能"><a href="#5-写代码实现以下功能" class="headerlink" title="5.写代码实现以下功能"></a>5.写代码实现以下功能</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如有变量 googs = [‘汽车’,’飞机’,’火箭’] 提示用户可供选择的商品：用户输入索引后，将指定商品的内容拼接打印，如：用户输入0，则打印 您选择的商品是汽车。</span></span><br><span class="line">goods = [<span class="string">&#x27;汽车&#x27;</span>,<span class="string">&#x27;飞机&#x27;</span>,<span class="string">&#x27;火箭&#x27;</span>]</span><br><span class="line">tag = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> tag:</span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(goods):</span><br><span class="line">        print(<span class="string">&quot;编号:%s   商品名称: %s&quot;</span> %(k,v))</span><br><span class="line">    choice = int(input(<span class="string">&quot;输入商品编号:&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> choice &gt;= <span class="number">0</span> <span class="keyword">and</span> choice &lt; <span class="number">3</span>:</span><br><span class="line">        print(goods[choice])</span><br><span class="line">        tag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;商品编号输入错误&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="6-请用代码实现"><a href="#6-请用代码实现" class="headerlink" title="6.请用代码实现"></a>6.请用代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li = <span class="string">&quot;szk&quot;</span></span><br><span class="line"><span class="comment">#转成列表</span></span><br><span class="line">convert_list = list(li)</span><br><span class="line">print(convert_list)</span><br><span class="line"></span><br><span class="line"><span class="comment">#转成字符串</span></span><br><span class="line">convert_str = <span class="string">&quot;_&quot;</span>.join(convert_list)</span><br><span class="line">print(convert_str,type(convert_str))</span><br></pre></td></tr></table></figure>

<h3 id="8-利用for循环和range找出100以内所有的偶数并将这些偶数插入到一个新列表中"><a href="#8-利用for循环和range找出100以内所有的偶数并将这些偶数插入到一个新列表中" class="headerlink" title="8.利用for循环和range找出100以内所有的偶数并将这些偶数插入到一个新列表中"></a>8.利用for循环和range找出100以内所有的偶数并将这些偶数插入到一个新列表中</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">new_list = []</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">101</span>):</span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        new_list.append(num)</span><br><span class="line"></span><br><span class="line">print(new_list)</span><br></pre></td></tr></table></figure>


<h3 id="9-利用for循环和range-找出50以内能被3整除的数，并将这些数插入到一个新列表中"><a href="#9-利用for循环和range-找出50以内能被3整除的数，并将这些数插入到一个新列表中" class="headerlink" title="9.利用for循环和range 找出50以内能被3整除的数，并将这些数插入到一个新列表中"></a>9.利用for循环和range 找出50以内能被3整除的数，并将这些数插入到一个新列表中</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">new_list = []</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">51</span>):</span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        new_list.append(num)</span><br><span class="line"></span><br><span class="line">print(new_list)</span><br></pre></td></tr></table></figure>
<h3 id="10-利用for循环和range从100-1，倒序打印"><a href="#10-利用for循环和range从100-1，倒序打印" class="headerlink" title="10.利用for循环和range从100~1，倒序打印"></a>10.利用for循环和range从100~1，倒序打印</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">num_list = []</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">101</span>):</span><br><span class="line">    num_list.append(num)</span><br><span class="line"></span><br><span class="line"><span class="comment">#倒序</span></span><br><span class="line">num_list.reverse()</span><br><span class="line"></span><br><span class="line">print(num_list)</span><br></pre></td></tr></table></figure>
<h3 id="11-利用for循环和range循环1-30的数字，将能被3整除的添加到一个列表中，将能被4整除的添加到另外一个列表中。"><a href="#11-利用for循环和range循环1-30的数字，将能被3整除的添加到一个列表中，将能被4整除的添加到另外一个列表中。" class="headerlink" title="11.利用for循环和range循环1-30的数字，将能被3整除的添加到一个列表中，将能被4整除的添加到另外一个列表中。"></a>11.利用for循环和range循环1-30的数字，将能被3整除的添加到一个列表中，将能被4整除的添加到另外一个列表中。</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">list_3 = []</span><br><span class="line">list_4 = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">31</span>):</span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        list_3.append(num)</span><br><span class="line">    <span class="keyword">elif</span> num % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">        list_4.append(num)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">print(list_3)</span><br><span class="line">print(list_4)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python_exercise</category>
      </categories>
      <tags>
        <tag>python_exercise</tag>
      </tags>
  </entry>
  <entry>
    <title>py-day03</title>
    <url>/2020/08/23/py-day03/</url>
    <content><![CDATA[<p>python基础<br>函数高级操作(生成器、迭代器、装饰器)</p>
<a id="more"></a>
<h4 id="内容复习"><a href="#内容复习" class="headerlink" title="内容复习 "></a><div id="title">内容复习 </div></h4><p>1.列表：</p>
<ul>
<li>定义：<ul>
<li>li = []</li>
<li>li = list()</li>
</ul>
</li>
<li>增<ul>
<li>append insert</li>
</ul>
</li>
<li>删<ul>
<li>pop  clear</li>
</ul>
</li>
<li>改<ul>
<li>li[3] = ‘newvalue’</li>
</ul>
</li>
<li>查<ul>
<li>for i in li:</li>
<li>for index, value in  enumate(li):</li>
</ul>
</li>
<li>索引<ul>
<li>不管是哪一门语言，只要提到索引，必然起始值从0开始</li>
<li>li[3]</li>
</ul>
</li>
<li>切片<ul>
<li>li = [1,2,3,4,5,6,7,8]</li>
<li>根据索引的下标来去切，并且遵循一个原则，前包后不包 li[2:5]</li>
</ul>
</li>
</ul>
<p>2.字典：</p>
<ul>
<li>定义：<ul>
<li>d = dict() ===&gt; d = dict(name=’szk’, age=13)</li>
<li>d = {}  ===&gt; d = {‘name’:’szk’, ‘age’:13}   推荐</li>
</ul>
</li>
<li>增 或 修改<ul>
<li>d[‘height’] = 178</li>
<li>d.update(height=180)  d.update(xxx=123)</li>
<li>删除<ul>
<li>del d[‘name’]</li>
</ul>
</li>
</ul>
</li>
<li>查：<ul>
<li>遍历所有的键   for k in d.keys()</li>
<li>遍历所有的值   for v in d.values()</li>
<li>遍历所有的键值 for k, v in d.items()  </li>
</ul>
</li>
</ul>
<p>项目中的数据结构：非常重要的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;szk&#x27;</span>, <span class="string">&#x27;age&#x27;</span>:<span class="number">13</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;kkk&#x27;</span>, <span class="string">&#x27;age&#x27;</span>:<span class="number">14</span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>3.元组<br>定义：(1,2,)   tuple()<br>4.集合<br>定义：{}  set()  天生去重</p>
<p>4.函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名():</span></span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">函数名()</span><br></pre></td></tr></table></figure>

<p>函数执行的原理：</p>
<blockquote>
<p>函数定义的时候，会开辟一个栈(先进后出)，然后将函数压入栈中，注意此时我们只能操作栈顶的元素。调用函数的时候 函数名() ,就会将函数出栈，执行</p>
</blockquote>
<ul>
<li>函数的参数<ul>
<li>位置参数</li>
<li>关键字参数</li>
<li>默认参数 </li>
<li>动态接收位置参数</li>
<li>动态接收关键字参数</li>
</ul>
</li>
</ul>
<h3 id="函数部分："><a href="#函数部分：" class="headerlink" title="函数部分："></a>函数部分：</h3><h4 id="0-函数嵌套"><a href="#0-函数嵌套" class="headerlink" title="0.函数嵌套"></a>0.函数嵌套</h4><ol>
<li><p>只要遇见了()就是函数的调用. 如果没有()就不是函数的调用</p>
</li>
<li><p>函数的执行顺序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span>():</span>   </span><br><span class="line">    print(<span class="number">111</span>)  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun2</span>():</span>   </span><br><span class="line">    print(<span class="number">222</span>)   </span><br><span class="line">    fun1()   </span><br><span class="line">fun2()</span><br><span class="line">print(<span class="number">111</span>)</span><br></pre></td></tr></table></figure>
<p>接下来再看一个例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun2</span>():</span>   </span><br><span class="line">    print(<span class="number">222</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun3</span>():</span></span><br><span class="line">        print(<span class="number">666</span>)</span><br><span class="line">    print(<span class="number">444</span>)</span><br><span class="line">    fun3()</span><br><span class="line">    print(<span class="number">888</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="number">33</span>)</span><br><span class="line">fun2()</span><br><span class="line">print(<span class="number">555</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>gloabal<br>首先我们写这样一个代码, 首先在全局声明一个变量, 然后再局部调用这个变量, 并改变这 个变量的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 100</span><br><span class="line">def func():   </span><br><span class="line">    global a    # 加了个global表示不再局部创建这个变量了. 而是直接使用全局的a   </span><br><span class="line">    a &#x3D; 28   </span><br><span class="line">print(a)</span><br><span class="line">func()</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>global表示. 不再使用局部作用域中的内容了. 而改用全局作用域中的变量</p>
</li>
</ol>
<p><strong>变量污染，很少使用</strong></p>
<h5 id="1-内置函数"><a href="#1-内置函数" class="headerlink" title="1.内置函数"></a>1.内置函数</h5><p>就是python给你提供的. 拿来直接用的函数, 比如print., input等等.</p>
<img src="/2020/08/23/py-day03/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0.jpg" class title="内置函数">
<p><strong>迭代器相关</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">range()</span><br><span class="line">next()</span><br><span class="line">迭代器向下执⾏一次, 内部实际使用了next()方法返回迭代器的下一个项目</span><br></pre></td></tr></table></figure>
<p><strong>iter()</strong></p>
<blockquote>
<p>获取迭代器, 内部实际使用的是iter()方法来获取迭代器</p>
</blockquote>
<p><strong>eval()</strong></p>
<blockquote>
<p>字符串类型代码的执行<br>执行部分字符串类型的代码,并返回最终结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(eval(&quot;2+2&quot;))</span><br><span class="line"># 4</span><br><span class="line">n &#x3D; 8</span><br><span class="line">print(eval(&quot;2+n&quot;))</span><br><span class="line"># 10</span><br><span class="line">def func():</span><br><span class="line">    print(666)</span><br><span class="line">eval(&quot;func()&quot;)</span><br><span class="line"># 666</span><br></pre></td></tr></table></figure>
<p><strong>exec()</strong></p>
<blockquote>
<p>执行字符串类型的代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msg &#x3D; &#39;&#39;&#39;</span><br><span class="line">def func():</span><br><span class="line">    print(&#39;有计划没行动等于零&#39;)</span><br><span class="line">func()</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">exec(msg)</span><br></pre></td></tr></table></figure>
<p>以上这两个在公司开发中禁止使用,如果里边出现<strong>del</strong>就会出现很大的问题</p>
<p><strong>输入和输出相关</strong><br><strong>input()</strong></p>
<blockquote>
<p>获取用户输入的内容</p>
</blockquote>
<p><strong>print()</strong></p>
<blockquote>
<p>打印输出</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&#39;你好&#39;,&#39;我好&#39;)    </span><br><span class="line">print(&#39;你好&#39;,&#39;我好&#39;,sep&#x3D;&#39;|&#39;)</span><br><span class="line">结果:</span><br><span class="line">你好 我好</span><br><span class="line">你好|我好</span><br></pre></td></tr></table></figure>
<p><strong>sep</strong>是将多个元素进行修改 默认的是空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&#39;你好&#39;)</span><br><span class="line">print(&#39;我好&#39;)</span><br><span class="line">print(&#39;你好&#39;,end&#x3D;&#39;&#39;)</span><br><span class="line">print(&#39;我好&#39;)</span><br></pre></td></tr></table></figure>

<p><strong>end</strong>默认是\n 这就是我们为什么使用print的时候会出现换行,end的值修改成了空字符串</p>
<p><strong>id()</strong></p>
<blockquote>
<p>获取到对象的内存地址</p>
</blockquote>
<p><strong>调用相关</strong></p>
<p><strong>callable()</strong></p>
<blockquote>
<p>用于检查一个对象是否是可调用的. 如果返回True, object有可能调用失败, 但如果返回False. 那调用绝对不会成功</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(callable(print))</span><br><span class="line">结果:</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p><strong>查看内置属性</strong><br><strong>dir()</strong></p>
<blockquote>
<p>查看对象的内置属性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(dir(list))</span><br><span class="line">结果:</span><br><span class="line">[&#39;__add__&#39;, &#39;__class__&#39;, &#39;__contains__&#39;, &#39;__delattr__&#39;, &#39;__delitem__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getitem__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__iadd__&#39;, &#39;__imul__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__len__&#39;, &#39;__lt__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__reversed__&#39;, &#39;__rmul__&#39;, &#39;__setattr__&#39;, &#39;__setitem__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;append&#39;, &#39;clear&#39;, &#39;copy&#39;, &#39;count&#39;, &#39;extend&#39;, &#39;index&#39;, &#39;insert&#39;, &#39;pop&#39;, &#39;remove&#39;, &#39;reverse&#39;, &#39;sort&#39;]</span><br></pre></td></tr></table></figure>

<p><strong>基础数据类型相关</strong><br>数字相关<br><strong>​- bool()</strong> 将给定的数据转换成bool值. 如果不给值. 返回False<br>​**- int()** 将给定的数据转换成int值. 如果不给值, 返回0<br><strong>​- ﬂoat()</strong> 将给定的数据转换成ﬂoat值. 也就是小数<br>​数学运算<br>​<strong>abs()</strong> 返回绝对值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1:  print(abs(-1))</span><br><span class="line">2:  结果:</span><br><span class="line">3:  1</span><br></pre></td></tr></table></figure>

<p><strong>divmod()</strong> 返回商和余数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(divmod(15,2))</span><br><span class="line">结果:</span><br><span class="line">(7, 1)</span><br></pre></td></tr></table></figure>

<p><strong>​round()</strong> 四舍五入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(round(15.1111,2))  # 保留2位小数</span><br><span class="line">结果:</span><br><span class="line">15.11</span><br></pre></td></tr></table></figure>
<p>​<br><strong>pow(a, b)</strong> 求a的b次幂, 如果有三个参数. 则求完次幂后对第三个数取余</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(pow(15,2,3))</span><br><span class="line">结果:</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><strong>​sum()</strong> 求和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(sum([12,3,4]))  #sum里边的参数是一个可迭代对象</span><br><span class="line">结果:</span><br><span class="line">19</span><br></pre></td></tr></table></figure>

<p><strong>​​min()</strong> 求最小值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(min([12,3,4]))  # 寻找最小的数字</span><br><span class="line">结果:</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>​<strong>max()</strong> 求最大值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(max([12,3,4]))  # 寻找最大的数字</span><br><span class="line">结果:</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p><strong>数据结构相关</strong><br>列表和元组:</p>
<ul>
<li>list() 将一个可迭代对象转换成列表</li>
<li>tuple() 将一个可迭代对象转换成元组</li>
<li>reversed() 将一个序列翻转, 返回翻转序列的迭代器</li>
</ul>
<p><strong>reversed</strong> 示例:<br><code>l = reversed(&#39;你好&#39;)  # l 获取到的是一个生成器 print(list(l))</code></p>
<p><strong>数据结构相关</strong><br>列表和元组:</p>
<ul>
<li>list() 将一个可迭代对象转换成列表</li>
<li>tuple() 将一个可迭代对象转换成元组</li>
<li>reversed() 将一个序列翻转, 返回翻转序列的迭代器</li>
</ul>
<p><strong>reversed</strong> 示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l &#x3D; reversed(&#39;你好&#39;)  # l 获取到的是一个生成器</span><br><span class="line">print(list(l))</span><br></pre></td></tr></table></figure>
<p><strong>bytes()</strong> 把字符串转换成bytes类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 :  s &#x3D; &#39;你好武大&#39;</span><br><span class="line">2 :  bs &#x3D; s.encode(&#39;utf-8&#39;)</span><br><span class="line">3 :  print(bs)</span><br><span class="line">4 :  结果:b&#39;\xe4\xbd\xa0\xe5\xa5\xbd\xe6\xad\xa6\xe5\xa4\xa7&#39;</span><br><span class="line">5 :  s1 &#x3D; bs.decode(&#39;utf-8&#39;)</span><br><span class="line">6 :  print(s1)</span><br><span class="line">7 :  结果: 你好武大</span><br><span class="line">8 :  s &#x3D; &#39;你好&#39;</span><br><span class="line">9 :  bs &#x3D; bytes(s,encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">10:  print(bs)</span><br><span class="line">11:  # 将字符串转换成字节</span><br><span class="line">12:  bs1 &#x3D; str(bs,encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">13:  print(bs1)</span><br><span class="line">14:  # 将字节转换成字符串</span><br></pre></td></tr></table></figure>

<p><strong>数据集合</strong></p>
<ul>
<li>dict() 创建一个字典</li>
<li>set() 创建一个集合</li>
<li>len() 返回一个对象的元素个数</li>
<li>enumerate() 获取枚举对象</li>
</ul>
<p><strong>enumerate()</strong> 举例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lst &#x3D; [&#39;zhangsan&#39;,&#39;lisi&#39;,&#39;wangwu&#39;]</span><br><span class="line">for i,k in enumerate(lst):</span><br><span class="line">    print(&#39;这是序号&#39;,i)</span><br><span class="line">    print(&#39;这是元素&#39;,k)</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">**zip()** 函数用于将可迭代的对象作为参数,将对象中对应的元素打包成一个个元祖,</span><br><span class="line">然后返回由这些元祖组成的内容,如果各个迭代器的元素个数不一致,则按照长度最短的返回</span><br></pre></td></tr></table></figure>
<p>lst1 = [1,2,3]<br>lst2 = [‘a’,’b’,’c’,’d’]<br>lst3 = (11,12,13,14,15)<br>for i in zip(lst1,lst2,lst3):<br>    print(i)<br>结果:<br>(1, ‘a’, 11)<br>(2, ‘b’, 12)<br>(3, ‘c’, 13)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**lambda**</span><br><span class="line">&gt; 匿名函数,为了解决一些简单的需求而设计的一句话函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>def func(n):<br>    return n<strong>n<br>print(func(4))<br>f = lambda x: x</strong>x<br>print(f(4))<br>结果:<br>256<br>256</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**lambda**表示的是匿名函数,不需要用**def**来声明,一句话就可以声明出一个函数</span><br><span class="line">语法:</span><br><span class="line">　　函数名 &#x3D; **lambda** 参数:返回值</span><br><span class="line">注意:</span><br><span class="line">　　1. 函数的参数可以有多个,多个参数之间用逗号隔开</span><br><span class="line">　　2. 匿名函数不管多复杂.只能写一行.且逻辑结束后直接返回数据</span><br><span class="line">　　3. 返回值和正常的函数一样,可以是任意数据类型,返回值的时候只能返回一个不能返回多个匿名函数并不是说一定没有名字,这里前面的变量就是一个函数名,说他是匿名原因是我们通过name查看的时候是没有名字的.统一都叫做lambda.在调用的时候没有什么特别之处,像正常的函数调用既可</span><br><span class="line"></span><br><span class="line">**sorted**</span><br><span class="line">排序函数</span><br><span class="line"></span><br><span class="line">&gt; 语法:sorted(iterable,key&#x3D;None,reverse&#x3D;False)</span><br><span class="line"></span><br><span class="line">**iterable** : 可迭代对象</span><br><span class="line">**key**: 排序规则(排序函数),在**sorted**内部会将可迭代对象中的每一个元素传递给这个函数的参数.根据函数运算的结果进行排序</span><br><span class="line">**reverse** :是否是倒叙,True 倒叙 False 正序</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>lst = [1,3,2,5,4]<br>lst2 = sorted(lst)<br>print(lst)    #原列表不会改变<br>print(lst2)   #返回的新列表是经过排序的<br>lst3 = sorted(lst,reverse=True)<br>print(lst3)   #倒叙<br>结果:<br>[1, 3, 2, 5, 4]<br>[1, 2, 3, 4, 5]<br>[5, 4, 3, 2, 1]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字典使用**sorted**排序</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>dic = {1:’a’,3:’c’,2:’b’}<br>print(sorted(dic))   # 字典排序返回的就是排序后的key<br>结果:<br>[1,2,3]</p>
<p>salaries = {<br>  ‘szk’:30000,<br>  ‘zhangsan’:888888888,<br>  ‘nick’:2000,<br>  ‘pounds’:100<br>}<br>sorted(salaries, key=lambda name:salaries[name])</p>
<h5 id="2-匿名函数-lambada-面试问的较多"><a href="#2-匿名函数-lambada-面试问的较多" class="headerlink" title="2.匿名函数 lambada  面试问的较多"></a>2.匿名函数 lambada  面试问的较多</h5><h4 id="3-迭代器-和for循环机制-面试中的重点"><a href="#3-迭代器-和for循环机制-面试中的重点" class="headerlink" title="3.迭代器 和for循环机制 面试中的重点"></a>3.迭代器 和for循环机制 面试中的重点</h4><p>for循环是不是也可以,并且还不报错啊,其实上边就是for的机制,<br>注意: 迭代器不能反复,只能向下执行,并且是一次性的.获取过了就不能在获取了</p>
<p>总结:</p>
<ul>
<li>Iterator: 迭代器. 内部包含<strong>iter</strong>() 同时包含<strong>next</strong>().</li>
<li>迭代器的特点:</li>
</ul>
<ol>
<li>节省内存.</li>
<li>惰性机制</li>
<li>不能反复, 只能向下执行.<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">print(dir(a))  <span class="comment"># dir查看对象的方法和函数</span></span><br><span class="line"><span class="comment"># 在打印结果中寻找__iter__ 如果存在就表示当前的这个类型是个可迭代对象</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="4-生成器-面试中的重点"><a href="#4-生成器-面试中的重点" class="headerlink" title="4.生成器  面试中的重点"></a>4.生成器  面试中的重点</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 生成器定义</span></span><br><span class="line"><span class="comment">### 生成器的本质就是迭代器，因此我们可以使用迭代器中的__next__方法来获取元素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    print(<span class="number">11</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">22</span>  <span class="comment">### 将return换成yield关键字即可</span></span><br><span class="line"></span><br><span class="line">ret = func()</span><br><span class="line"><span class="comment"># print(ret.__next__())</span></span><br><span class="line"><span class="comment"># print(ret)  ### &lt;generator object func at 0x103cc80b0&gt; 生成器的对象</span></span><br></pre></td></tr></table></figure>
<ul>
<li>return 和 yield 的区别<ul>
<li>yield是分段来执行一个函数,yield可以出现多次</li>
<li>return是直接停止这个函数,return可以出现多次但是只会执行到第一个就结束了</li>
</ul>
</li>
<li>生成器的好处<ul>
<li>节省内存</li>
</ul>
</li>
</ul>
<p>总结：生成器一定是迭代器，但是迭代器就不一定是生成器</p>
<h4 id="5-列表生成式和字典生成式-项目中的重点"><a href="#5-列表生成式和字典生成式-项目中的重点" class="headerlink" title="5.列表生成式和字典生成式 []  项目中的重点"></a>5.列表生成式和字典生成式 []  项目中的重点</h4><ol>
<li>列表推导式的常⽤写法:</li>
</ol>
<blockquote>
<p>[结果 for 变量 in 可迭代对象]</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls &#x3D; [i for i in range(10)]</span><br><span class="line">print(ls)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>筛选模式</p>
<blockquote>
<p>[结果 for 变量 in 可迭代对象 if 条件]</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lst &#x3D; [i for i in range(100) if i %2 &#x3D;&#x3D; 0]</span><br><span class="line">print(lst)</span><br></pre></td></tr></table></figure>
</li>
<li><p>字典生成式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 内置方法初识</span></span><br><span class="line">l=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(l):</span><br><span class="line">    print(i,v)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 构造字典</span></span><br><span class="line">keys=[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;sex&#x27;</span>]</span><br><span class="line">vals=[<span class="string">&#x27;szk&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;male&#x27;</span>]</span><br><span class="line">dic=&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i,k <span class="keyword">in</span> enumerate(keys):</span><br><span class="line">    <span class="comment"># print(i,k)</span></span><br><span class="line">    dic[k]=vals[i]</span><br><span class="line">print(dic)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典生成式</span></span><br><span class="line">dic=&#123;k:vals[i] <span class="keyword">for</span> i,k <span class="keyword">in</span> enumerate(keys)&#125;</span><br><span class="line">print(dic)</span><br><span class="line"><span class="comment"># 也支持if判断</span></span><br><span class="line">dic=&#123;k:vals[i] <span class="keyword">for</span> i,k <span class="keyword">in</span> enumerate(keys) <span class="keyword">if</span> i &gt; <span class="number">0</span>&#125;</span><br><span class="line">print(dic)</span><br></pre></td></tr></table></figure>
</li>
<li><p>三元表达式</p>
<blockquote>
<p>结果 = 条件成立 if 条件 else 条件不成立返回的值</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 求两个数的较大值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max2</span>(<span class="params">x, y</span>):</span></span><br><span class="line">  <span class="keyword">if</span> x &gt; y:</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 三元表达式实现的效果:条件成立的情况下返回一个值，不成立的情况下返回另外一个值</span></span><br><span class="line">name = input(<span class="string">&#x27;please input your name&gt;&gt;&gt;:&#x27;</span>).strip()</span><br><span class="line">res = <span class="string">&#x27;NB&#x27;</span> <span class="keyword">if</span> name = <span class="string">&#x27;szk&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;SB&#x27;</span>  <span class="comment"># 当name值为szk的时候才会是NB其他情况都是SB</span></span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">语法结构</span></span><br><span class="line"><span class="string">结果 = 条件成立 if 条件 else 条件不成立返回的值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">替换上面max2内的代码</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="5-递归函数-面试中常见问题"><a href="#5-递归函数-面试中常见问题" class="headerlink" title="5. 递归函数  面试中常见问题"></a>5. 递归函数  面试中常见问题</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1.什么是函数递归调用？(也可以说成是函数的嵌套调用的一种形式)</span></span><br><span class="line"><span class="string">    在调用一个函数的过程中又直接或者间接的调用该函数本身，称之为函数的递归调用</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 直接调用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">  print(<span class="string">&#x27;from foo&#x27;</span>)</span><br><span class="line">  foo()</span><br><span class="line">foo()</span><br><span class="line"><span class="string">&quot;&quot;&quot;画图诠释递归调用意味着反复的开辟内存空间最后导致内存溢出&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ps:补充知识点 查看及修改最大递归深度的方法(不是绝对的精准)</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.getrecursionlimit())  <span class="comment"># 查看最大递归深度 1000</span></span><br><span class="line">sys.setrecursionlimit(<span class="number">2000</span>)  <span class="comment"># 修改最大递归深度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看具体的递归深度(直接调用自己)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">n</span>):</span></span><br><span class="line">  print(<span class="string">&#x27;from foo&#x27;</span>,n)</span><br><span class="line">  foo(n+<span class="number">1</span>)</span><br><span class="line">foo(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 间接调用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">  print(<span class="string">&#x27;from bar&#x27;</span>)</span><br><span class="line">  func()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">  print(<span class="string">&#x27;from func&#x27;</span>)</span><br><span class="line">  bar()</span><br><span class="line">bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ps:无限的递归没有任何意义的</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>有意义的递归一定是伴随着n规模的减少而减少</p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.从1到100，求个和？</span></span><br><span class="line"><span class="comment">## 常规的做法</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">101</span>):</span><br><span class="line">    sum += i</span><br><span class="line">print(sum)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 递归的做法</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">有意义的递归：</span></span><br><span class="line"><span class="string">    有最终的结束条件</span></span><br><span class="line"><span class="string">    n规模问题的解决得益于n-1问题的规模的解决</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">现在是求1到100的和？</span></span><br><span class="line"><span class="string">1到99的和，然后再加上 100， 即就能够知道1到100的和</span></span><br><span class="line"><span class="string">1到98的和，然后再加上 99，就能够知道1到99的和</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumrecv</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> sumrecv(n<span class="number">-1</span>) + n </span><br></pre></td></tr></table></figure>

<p>#2.求n!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jiecheng</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> jiecheng(n<span class="number">-1</span>) * n</span><br><span class="line"></span><br><span class="line">res = jiecheng(<span class="number">5</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>


<h4 id="6-函数名的作用以及闭包函数-面试和项目中的重点"><a href="#6-函数名的作用以及闭包函数-面试和项目中的重点" class="headerlink" title="6.函数名的作用以及闭包函数   面试和项目中的重点"></a>6.函数名的作用以及闭包函数   面试和项目中的重点</h4><blockquote>
<p>闭包函数：函数嵌套+名称空间与作用域+函数对象</p>
</blockquote>
<ol>
<li>什么是闭包函数<ol>
<li>定义在函数内的函数</li>
<li>该函数体代码包含对该函数外层作用域中名字的引用<ul>
<li>强调：函数外层指的不是全局作用域</li>
</ul>
</li>
</ol>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outter</span>()</span></span><br><span class="line">    x = 1</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        print(x)</span><br><span class="line">    <span class="keyword">return</span> inner <span class="comment">#利用函数对象的概念，将一个内部函数返回并在全剧终拿到并使用，从而打破了函数的层级限制</span></span><br><span class="line"></span><br><span class="line"> f = outter()  返回的是inner的内存地址</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">     x = <span class="number">11111</span></span><br><span class="line">     print(<span class="string">&#x27;from foo&#x27;</span>)</span><br><span class="line">     f()   </span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数的作用域关系在定义阶段就已经固定了，与调用位置无关<br>f = outter() —&gt; 指向inner内存地址<br>闭: 函数一定来自于函数内部<br>包: 此函数外面还包裹了一层东西，无论在哪用inner，都是以外面包裹的这一层东西为准</p>
</blockquote>
<h4 id="7-装饰器-面试和项目中的重中之重"><a href="#7-装饰器-面试和项目中的重中之重" class="headerlink" title="7.**装饰器 面试和项目中的重中之重 **"></a>7.**装饰器 面试和项目中的重中之重 **</h4><h5 id="7-1-闭包函数的应用"><a href="#7-1-闭包函数的应用" class="headerlink" title="7.1. 闭包函数的应用"></a>7.1. 闭包函数的应用</h5><ol>
<li>为函数体传值的方式<br>方式1:以参数的形式为函数体传值<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def foo(x):</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure></li>
<li>方式二:包给函数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outter</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="comment"># x = 1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">        print(x)</span><br><span class="line">    <span class="keyword">return</span> foo</span><br><span class="line">f = outter(<span class="number">10</span>)</span><br><span class="line">f()</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">url</span>):</span></span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        print(response.text)</span><br><span class="line"></span><br><span class="line">每次调用都需要传,且定义全局变量不合适</span><br><span class="line"></span><br><span class="line"><span class="comment"># get(&#x27;https://www.baidu.com&#x27;)</span></span><br><span class="line"><span class="comment"># get(&#x27;https://www.baidu.com&#x27;)</span></span><br><span class="line"><span class="comment"># get(&#x27;https://www.baidu.com&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outter</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># url = &#x27;https://www.baidu.com&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>():</span></span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            print(response.text)</span><br><span class="line">    <span class="keyword">return</span> get</span><br><span class="line"></span><br><span class="line">传一次即可</span><br><span class="line">baidu = outter(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line">baidu()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>装饰器（闭包函数的应用）</li>
</ol>
<ul>
<li><p>1、开放封闭原则<br>  软件一旦上之后就应该开放封闭原则<br>  具体是指对修改是封闭的，但对扩展是开放的</p>
</li>
<li><p>2、什么是装饰器<br>  装饰就是修饰，器指的就是工具<br>  装饰器本身可以是任意可调用的对象<br>  被装饰的对象也可以是任意可调用的对象</p>
<p>  装饰器—&gt;函数<br>  被装饰的对象=&gt;函数</p>
<p>  装饰器是用来为被装饰对象添加新功能的一种工具<br>  必须遵循：</p>
<pre><code>  1、不能修改被装饰对象的源代码
  2、不能修改被装饰对象的调用方式</code></pre>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;from home&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outter</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="comment"># func=index</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">        start_time=time.time()</span><br><span class="line">        func()</span><br><span class="line">        end_time=time.time()</span><br><span class="line">        print(<span class="string">&#x27;run time is %s&#x27;</span> %(end_time - start_time))</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">index=outter(index)</span><br><span class="line"></span><br><span class="line">index()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>3.装饰器修正+装饰器语法糖</p>
<blockquote>
<p>如果有返回值，则在内层函数定义res ，末尾return；<br>内层函数接收参数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timmer</span>(<span class="params">func</span>):</span> <span class="comment">#func用来接收被装饰的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span> <span class="comment">#这个功能是给原始的函数用的</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        <span class="keyword">return</span> func(*args,**kwargs) <span class="comment">#拿到返回值</span></span><br><span class="line">        stop_time=time.time()</span><br><span class="line">        print(<span class="string">&#x27;run time is %s&#x27;</span> %(stop_time - start_time))</span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@timmer # index=timmer(index)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">&#x27;welcome to index&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1234</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@timmer #home=timmer(home)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>(<span class="params">name</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">&#x27;welcome %s to home page&#x27;</span> %name)</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.有参装饰器<br>eg: 引入参数钱的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">current_user = &#123;<span class="string">&#x27;login&#x27;</span>:<span class="literal">False</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outter</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> current_user[<span class="string">&#x27;login&#x27;</span>]:</span><br><span class="line">            <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">        user = input(<span class="string">&#x27;username&gt;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">        passwd = input(<span class="string">&#x27;passwd&gt;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">        <span class="keyword">if</span>  user == <span class="string">&#x27;egon&#x27;</span> <span class="keyword">and</span> passwd == <span class="string">&#x27;123&#x27;</span>:</span><br><span class="line">            current_user[<span class="string">&#x27;login&#x27;</span>] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@outter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">&#x27;welcome to index&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1234</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@outter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>(<span class="params">name</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">&#x27;welcome %s to home page&#x27;</span> %name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">index()</span><br><span class="line">home(<span class="string">&#x27;egon&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>引入参数<br>func 用来接收被装饰的函数<br>wrapper(*args,**kwargs): #这个功能是给原始的函数用的</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">current_user=&#123;<span class="string">&#x27;login&#x27;</span>:<span class="literal">False</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span>(<span class="params">engine</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">outter</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">            <span class="keyword">if</span> current_user[<span class="string">&#x27;login&#x27;</span>]:</span><br><span class="line">                <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line"></span><br><span class="line">            user=input(<span class="string">&#x27;username&gt;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">            pwd=input(<span class="string">&#x27;password&gt;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> engine == <span class="string">&#x27;file&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> user == <span class="string">&#x27;egon&#x27;</span> <span class="keyword">and</span> pwd == <span class="string">&#x27;123&#x27;</span>:</span><br><span class="line">                    current_user[<span class="string">&#x27;login&#x27;</span>]=<span class="literal">True</span></span><br><span class="line">                    <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">            <span class="keyword">elif</span> engine == <span class="string">&#x27;mysql&#x27;</span>:</span><br><span class="line">                print(<span class="string">&#x27;基于mysql数据的认证&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> engine == <span class="string">&#x27;ldap&#x27;</span>:</span><br><span class="line">                print(<span class="string">&#x27;基于ldap的认证方式&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> outter</span><br><span class="line"></span><br><span class="line"><span class="meta">@auth(engine=&#x27;mysql&#x27;) # @outter # index=outter(index) #index=wrapper</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">&#x27;welcome to index&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1234</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@auth(engine=&#x27;ldap&#x27;) # @outter # home=outter(home) #home=wrapper</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>(<span class="params">name</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">&#x27;welcome %s to home page&#x27;</span> %name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">index()</span><br><span class="line">home(<span class="string">&#x27;egon&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>装饰器原理：就是闭包函数的应用。 @auth(engine=’file’)，执行的过程为拿到outter内存地址+engine=’file’; @outter(func) 执行的过程为 把他正下方的函数名当做参数传入，得到的结果重新赋值给index index = @outter(index),index拿到的是outter的调用结果，index = wrapper; wrapper函数内打开就可以看到，要访问一个func，问上一层outter要，enggine没有，再上一层要，auth。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结: wrapper(*args,**kwargs) 这个参数的功能是给原始函数用的；outter(func)，用来装被修饰的函数，auth(engine) 传给内层需要的函数。三层足够使用，最外层可以无限的延伸参数。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span>(<span class="params">engine</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">outter</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>)</span></span><br><span class="line"><span class="function">            ....</span></span><br><span class="line"><span class="function">        <span class="title">return</span> <span class="title">wrapper</span></span></span><br></pre></td></tr></table></figure>


<ol start="5">
<li>叠加装饰器<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def outter1(func1): #func1&#x3D;wrapper2的内存地址</span><br><span class="line">    print(&#39;加载了outter1&#39;)</span><br><span class="line"></span><br><span class="line">    def wrapper1(*args,**kwargs):</span><br><span class="line">        print(&#39;执行了wrapper1&#39;)</span><br><span class="line">        res1&#x3D;func1(*args,**kwargs)</span><br><span class="line">        return res1</span><br><span class="line"></span><br><span class="line">    return wrapper1</span><br><span class="line"></span><br><span class="line">def outter2(func2): #func2&#x3D;wrapper3的内存地址</span><br><span class="line">    print(&#39;加载了outter2&#39;)</span><br><span class="line"></span><br><span class="line">    def wrapper2(*args,**kwargs):</span><br><span class="line">        print(&#39;执行了wrapper2&#39;)</span><br><span class="line">        res2&#x3D;func2(*args,**kwargs)</span><br><span class="line">        return res2</span><br><span class="line">    return wrapper2</span><br><span class="line"></span><br><span class="line">def outter3(func3): # func3&#x3D;最原始的那个index的内存地址</span><br><span class="line">    print(&#39;加载了outter3&#39;)</span><br><span class="line"></span><br><span class="line">    def wrapper3(*args,**kwargs):</span><br><span class="line">        print(&#39;执行了wrapper3&#39;)</span><br><span class="line">        res3&#x3D;func3(*args,**kwargs)</span><br><span class="line">        return res3</span><br><span class="line">    return wrapper3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@outter1 # outter1(wrapper2的内存地址)&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;index&#x3D;wrapper1的内存地址</span><br><span class="line">@outter2 # outter2(wrapper3的内存地址)&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;wrapper2的内存地址</span><br><span class="line">@outter3 # outter3(最原始的那个index的内存地址)&#x3D;&#x3D;&#x3D;&gt;wrapper3的内存地址</span><br><span class="line">def index():</span><br><span class="line">    print(&#39;from index&#39;)</span><br><span class="line">#</span><br><span class="line">print(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)</span><br><span class="line"># index()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结： 叠加多个装饰器</p>
</blockquote>
</li>
<li>加载顺序(outter函数的调用顺序):自下而上</li>
<li>执行顺序(wrapper函数的执行顺序):自上而下</li>
</ol>
<h3 id="模块部分："><a href="#模块部分：" class="headerlink" title="模块部分："></a>模块部分：</h3><p>1.模块的使用</p>
<p>2.自定义模块 </p>
<p>3.内置模块  time os</p>
<p>4.第三方模块  pymysql， jenkins，gitlab</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
</search>
