<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"waylon.whatyouneed.site","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="interview review">
<meta property="og:type" content="article">
<meta property="og:title" content="面试问题复习">
<meta property="og:url" content="https://waylon.whatyouneed.site/2020/09/13/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="YouNeed">
<meta property="og:description" content="interview review">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/waylon1006/blog_pic/raw/master/pic/007S8ZIlly1gjrnmxyuwrj30uz0enab6.jpg">
<meta property="og:image" content="https://gitee.com/waylon1006/blog_pic/raw/master/pic/007S8ZIlly1gjrnn2jht0j30ry0f73zx.jpg">
<meta property="og:image" content="https://gitee.com/waylon1006/blog_pic/raw/master/pic/image-20210507213828564.png">
<meta property="og:image" content="https://gitee.com/waylon1006/blog_pic/raw/master/pic/image-20210711044059299.png">
<meta property="og:image" content="https://gitee.com/waylon1006/blog_pic/raw/master/pic/image-20210721165618801.png">
<meta property="og:image" content="https://gitee.com/waylon1006/blog_pic/raw/master/pic/image-20210721172047037.png">
<meta property="article:published_time" content="2020-09-13T08:53:08.000Z">
<meta property="article:modified_time" content="2021-07-30T11:31:03.104Z">
<meta property="article:author" content="Waylon Yan">
<meta property="article:tag" content="review">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/waylon1006/blog_pic/raw/master/pic/007S8ZIlly1gjrnmxyuwrj30uz0enab6.jpg">

<link rel="canonical" href="https://waylon.whatyouneed.site/2020/09/13/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%A4%8D%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>面试问题复习 | YouNeed</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a target="_blank" rel="noopener" href="https://github.com/Waylonwhynot" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#FD6C6C; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">YouNeed</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">what</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://waylon.whatyouneed.site/2020/09/13/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/timg.jpeg">
      <meta itemprop="name" content="Waylon Yan">
      <meta itemprop="description" content="tech life sharing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YouNeed">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试问题复习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-13 16:53:08" itemprop="dateCreated datePublished" datetime="2020-09-13T16:53:08+08:00">2020-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-30 19:31:03" itemprop="dateModified" datetime="2021-07-30T19:31:03+08:00">2021-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">杂记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>37k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:01</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>interview review</p>
<a id="more"></a>

<h4 id="1-TCP三次握手四次挥手面试题："><a href="#1-TCP三次握手四次挥手面试题：" class="headerlink" title="1.TCP三次握手四次挥手面试题："></a>1.TCP三次握手四次挥手面试题：</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Qing-840/p/9283367.html">https://www.cnblogs.com/Qing-840/p/9283367.html</a></p>
<p><img src="https://gitee.com/waylon1006/blog_pic/raw/master/pic/007S8ZIlly1gjrnmxyuwrj30uz0enab6.jpg" alt="120-TCP三次握手和四次挥手-三次握手静态.jpg?x-oss-process=style/watermark"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一次握手是在建立连接，服务器就进入LISTEN（监听）状态；客户端发送连接请求报文段，把标有SYN的数据包发给服务器端即为接收端。此时TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。</span><br><span class="line">第二次握手是服务器端即接收端收到客户端的SYN的报文段，同时发送标有SYN&#x2F;ACK的数据包。TCP服务器进程进入了SYN-RCVD（同步收到）状态。</span><br><span class="line">第三次握手是客户端收到服务器端的SYN&#x2F;ACK的数据包后，向服务器端发送标有ACK的数据包。TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态.当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/waylon1006/blog_pic/raw/master/pic/007S8ZIlly1gjrnn2jht0j30ry0f73zx.jpg" alt="120-TCP三次握手和四次挥手-四次挥手静态.png?x-oss-process=style/watermark"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">第一次挥手</span><br><span class="line">客户端设置seq和 ACK ,向服务器发送一个 FIN&#x3D;1报文段。此时，（第一次挥手，FIN&#x3D;1，seq&#x3D;u）客户端进入 FIN_WAIT 状态，表示客户端没有数据要发送给服务端了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二次挥手</span><br><span class="line">服务端收到了客户端发送的 FIN 报文段，向客户端回了一个 ACK 报文段。服务端进入CLOSE_WAIT状态，客户端进入FIN-WAIT-1状态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第三次挥手</span><br><span class="line">服务端向客户端发送FIN 报文段，请求关闭连接，同时服务端进入 LAST_ACK 状态。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第四次挥手</span><br><span class="line">客户端收到服务端发送的 FIN 报文段后，向服务端发送 ACK 报文段,然后客户端进入 TIME_WAIT 状态。服务端收到客户端的 ACK 报文段以后，就关闭连接。此时，客户端等待 2MSL（指一个片段在网络中最大的存活时间）后依然没有收到回复，则说明服务端已经正常关闭，这样客户端就可以关闭连接了。</span><br></pre></td></tr></table></figure>



<h5 id="1-1-高并发的情况下会存在大量的timewait，timewait过高会占用大量内存和cpu使用率"><a href="#1-1-高并发的情况下会存在大量的timewait，timewait过高会占用大量内存和cpu使用率" class="headerlink" title="1.1 高并发的情况下会存在大量的timewait，timewait过高会占用大量内存和cpu使用率"></a>1.1 <strong>高并发的情况下会存在大量的timewait，timewait过高会占用大量内存和cpu使用率</strong></h5><ul>
<li>优化timewait方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">发现系统存在大量TIME_WAIT状态的连接，通过调整linux内核参数解决，</span><br><span class="line">vi &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line"></span><br><span class="line">编辑文件，加入以下内容：</span><br><span class="line">net.ipv4.tcp_syncookies &#x3D; 1</span><br><span class="line">net.ipv4.tcp_tw_reuse &#x3D; 1</span><br><span class="line">net.ipv4.tcp_tw_recycle &#x3D; 1</span><br><span class="line">net.ipv4.tcp_fin_timeout &#x3D; 30</span><br><span class="line"></span><br><span class="line">然后执行 &#x2F;sbin&#x2F;sysctl -p 让参数生效。</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_syncookies &#x3D; 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_tw_reuse &#x3D; 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_tw_recycle &#x3D; 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_fin_timeout 修改系統默认的 TIMEOUT 时间</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="1-2-如果机器上存在大量SYN-RCVD状态，证明遭遇泛洪攻击"><a href="#1-2-如果机器上存在大量SYN-RCVD状态，证明遭遇泛洪攻击" class="headerlink" title="1.2 如果机器上存在大量SYN_RCVD状态，证明遭遇泛洪攻击"></a>1.2 <strong>如果机器上存在大量SYN_RCVD状态，证明遭遇泛洪攻击</strong></h5><ul>
<li>优化建议（待补充）</li>
</ul>
<h4 id="2-粘包问题"><a href="#2-粘包问题" class="headerlink" title="2. 粘包问题"></a>2. 粘包问题</h4><p>TCP独有（流式协议）<br>把数据像水流一样发出去；TCP协议nagle算法会把时间间隔较短，数据量较小的数据粘到一起，基于网络发出去。<br>解决方案：收数据的时候收干净就好了</p>
<h4 id="3-mac地址多少位表示"><a href="#3-mac地址多少位表示" class="headerlink" title="3.mac地址多少位表示"></a>3.mac地址多少位表示</h4><p>48位二进制 –&gt; 看到的是16进制表示</p>
<h4 id="4-OSI每一层功能"><a href="#4-OSI每一层功能" class="headerlink" title="4.OSI每一层功能"></a>4.OSI每一层功能</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1. 物理层</span><br><span class="line">网线 光纤</span><br><span class="line">网线 ---&gt; 01010101 电信号 ---&gt; 从网线中传输信号</span><br><span class="line">- 8个比特位一个字节</span><br><span class="line">2. 数据链路层</span><br><span class="line">网卡</span><br><span class="line">  - 数据帧: 一组电信号是一个数据帧, 有头和数据部分</span><br><span class="line">  - 网卡 --&gt; mac地址 --&gt; 全球唯一 --&gt; 烧制在网卡上</span><br><span class="line">  - 48位二进制 --&gt; 看到的是16进制表示</span><br><span class="line">  广播: 局域网内通信，所有人都会接收到，通过mac地址确定给谁的数据报，如果不是自己的就不处理</span><br><span class="line">  -广播风暴</span><br><span class="line">3. 网络层</span><br><span class="line">路由器</span><br><span class="line">   - 跨局域网通信，需要经过网络层</span><br><span class="line">   - IP地址: 0.0.0.0 - 255.255.255.255</span><br><span class="line">   - 子网掩码</span><br><span class="line">   - ARP: ip和mac对照表</span><br><span class="line">4. 传输层</span><br><span class="line">四层路由器</span><br><span class="line">   - 端口: 0-65535 一个应用程序可以监听多个端口，但是一个端口只能属于一个应用程序</span><br><span class="line">   - TCP协议: 可靠传输(可靠传输如何保证)三次挥手四次挥手  绝对多数视频传输也都是用TCP了</span><br><span class="line">   - UDP协议: 不可靠传输</span><br><span class="line">5. 应用层</span><br><span class="line">HTTP,DNS, DHCP,FTP，WebSocket,Telnet，NFS，SMTP,SNMP</span><br><span class="line">   - http(所有http协议都是基于基于TCP封装), 因为网络对现在来说不重要，相比于成本没必要在TCP上再封装。</span><br><span class="line">   补充: Mysql redis这种cs架构软件通信是基于TCP协议封装的</span><br></pre></td></tr></table></figure>

<h4 id="5-常用端口号"><a href="#5-常用端口号" class="headerlink" title="5. 常用端口号"></a>5. 常用端口号</h4><table>
<thead>
<tr>
<th>应用程序</th>
<th>FTP</th>
<th>TFTP</th>
<th>TELNET</th>
<th>SMTP</th>
<th>DNS</th>
<th>HTTP</th>
<th>SSH</th>
<th>MYSQL</th>
</tr>
</thead>
<tbody><tr>
<td>熟知端口</td>
<td>21,20</td>
<td>69</td>
<td>23</td>
<td>25</td>
<td>53</td>
<td>80</td>
<td>22</td>
<td>3306</td>
</tr>
<tr>
<td>传输层协议</td>
<td>TCP</td>
<td>UDP</td>
<td>TCP</td>
<td>TCP</td>
<td>UDP</td>
<td>TCP</td>
<td>TCP</td>
<td><strong>TCP</strong></td>
</tr>
</tbody></table>
<h4 id="6-为什么客户端最后还要等待2MSL？"><a href="#6-为什么客户端最后还要等待2MSL？" class="headerlink" title="6. 为什么客户端最后还要等待2MSL？"></a>6. 为什么客户端最后还要等待2MSL？</h4><p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p>
<p>保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。<br>防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。<br>6.2 为什么建立连接是三次握手，关闭连接确是四次挥手呢？<br>建立连接的时候，服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p>
<p>6.3 如果已经建立了连接，但是客户端突然出现故障了怎么办？<br>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h4 id="7-IO模型（面试）"><a href="#7-IO模型（面试）" class="headerlink" title="7. IO模型（面试）"></a>7. IO模型（面试）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="8-猴子补丁"><a href="#8-猴子补丁" class="headerlink" title="8. 猴子补丁"></a>8. 猴子补丁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">它得益于python灵活的语法、一切皆对象的思想</span><br><span class="line">猴子补丁（monkey patch）的主要功能就是运行时动态改变方法、类的方法。但是只要和“模块运行时替换的功能”对应就行了.其实不管是定义在类外的普通方法、类里面的方法、甚至是模块这些都可以进行“动态替换的操作”</span><br><span class="line"></span><br><span class="line">monkey patch允许在运行期间动态修改一个类或模块（注意python中一切皆对象，包括类、方法、甚至是模块）</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">class A:</span><br><span class="line">    def func(self):</span><br><span class="line">        print(&quot;Hi&quot;)</span><br><span class="line">    def monkey(self):</span><br><span class="line">        print(&quot;Hi, monkey&quot;)</span><br><span class="line"></span><br><span class="line">a &#x3D; A()</span><br><span class="line">a.func()</span><br><span class="line">&#39;&#39;&#39;运行结果</span><br><span class="line">Hi</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上面的结果无可厚非，大家都知道，但是看一下下面的例子：</span><br><span class="line">class A:</span><br><span class="line">    def func(self):</span><br><span class="line">        print(&quot;Hi&quot;)</span><br><span class="line">    def monkey(self):</span><br><span class="line">        print(&quot;Hi, monkey&quot;)</span><br><span class="line">a &#x3D; A()</span><br><span class="line">A.func&#x3D;A.monkey   #在运行的时候，才改变了func</span><br><span class="line">a.func()</span><br><span class="line">&#39;&#39;&#39;运行结果</span><br><span class="line">Hi, monkey</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">还可以这样</span><br><span class="line">class A:</span><br><span class="line">    def func(self):</span><br><span class="line">        print(&quot;Hi&quot;)</span><br><span class="line">    def monkey(self):</span><br><span class="line">        print(&quot;Hi, monkey&quot;)</span><br><span class="line"></span><br><span class="line">def outer_monkey(a):  # a 这个参数是没有用到的，因为func有一个参数，如果这个函数没有参数的话不能这样直接赋值</span><br><span class="line">    print(&quot;Hi,outer monkey&quot;)</span><br><span class="line"></span><br><span class="line">a &#x3D; A()</span><br><span class="line">A.func&#x3D;outer_monkey</span><br><span class="line">a.func()</span><br><span class="line">&#39;&#39;&#39;运行结果</span><br><span class="line">Hi, outer monkey</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="9-MySQL相关问题"><a href="#9-MySQL相关问题" class="headerlink" title="9. MySQL相关问题"></a>9. MySQL相关问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">事务的四大特性：</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">ACID</span><br><span class="line">A: 原子性</span><br><span class="line">   一个事务是一个不可分割的单位，事务中包含了诸多操作，要么同时成功，要么同时失败。</span><br><span class="line">C: 一致性</span><br><span class="line">   事务必须是使数据库从一个一致性的状态变到另外一个一致性的状态。</span><br><span class="line">I: 隔离性</span><br><span class="line">   一个事务的执行不能被其他事务干扰，其一个事务内部的操作及其使用到的数据对并发的其他事务是隔离的，并发执行的事务文件也是互不干扰的。</span><br><span class="line">D: 持久性</span><br><span class="line">    也叫”永久性“。</span><br><span class="line">    一个事务一旦提交成功执行成功，那么它对数据库中数据的修改应该是永久的。</span><br><span class="line">    接下来的其他操作或者故障不应该改对其他有任何的影响。</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>



<h4 id="10-乐观锁悲观锁"><a href="#10-乐观锁悲观锁" class="headerlink" title="10. 乐观锁悲观锁"></a>10. 乐观锁悲观锁</h4><h4 id="11-http协议工作原理，数据格式"><a href="#11-http协议工作原理，数据格式" class="headerlink" title="11. http协议工作原理，数据格式"></a>11. http协议工作原理，数据格式</h4><p><img src="https://gitee.com/waylon1006/blog_pic/raw/master/pic/image-20210507213828564.png" alt="image-20210507213828564"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">超文本传输协议 用来规定服务端和浏览器之间的数据交互的格式。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 四大特性</span></span><br><span class="line"><span class="number">1.</span> 基于请求响应</span><br><span class="line"><span class="number">2.</span> 基于TCP/IP作用于应用层之上的协议</span><br><span class="line"><span class="number">3.</span> 无状态</span><br><span class="line">   不保存用户信息</span><br><span class="line">   eg: 一个人来了<span class="number">1000</span>次，都如初见</span><br><span class="line">      由于是无状态的，所以出现了一些专门用来记录用户状态的而技术</span><br><span class="line">      cookie，session，token</span><br><span class="line"><span class="number">4.</span>无链接，短链接</span><br><span class="line">  请求来一次/响应一次，之后就没有任何关系了。</span><br><span class="line">  补充知识点: 长连接：双方建立连接之后默认不断开  websocket</span><br><span class="line"></span><br><span class="line"><span class="comment">## 请求数据格式</span></span><br><span class="line">   请求首行: 协议和版本，请求方法</span><br><span class="line">   请求头: (kv键值对) host:端口 路径  请求参数(请求类型text/html，压缩，语言，缓存，认证，长连接，UA等)</span><br><span class="line">   空行</span><br><span class="line">   请求体(get没有 / post有；存放的是post的请求提交的敏感数据)</span><br><span class="line"><span class="comment">## 响应数据格式</span></span><br><span class="line">   响应首行: 协议和版本 状态码</span><br><span class="line">   响应头: (kv键值对) 服务器信息，时间，返回内容类型+字符集，Etag缓存，长连接和超时时间，缓存过期时间，压缩方法，命中缓存</span><br><span class="line">   空行</span><br><span class="line">   响应体(返回的数据)</span><br></pre></td></tr></table></figure>

<h4 id="12-WSGI-wsgiref-uwsgi是什么关系？"><a href="#12-WSGI-wsgiref-uwsgi是什么关系？" class="headerlink" title="12.WSGI wsgiref uwsgi是什么关系？"></a>12.WSGI wsgiref uwsgi是什么关系？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WSGI是协议，wsgiref uwsgi是实现该协议的模块。</span><br></pre></td></tr></table></figure>

<h4 id="13-session"><a href="#13-session" class="headerlink" title="13.session"></a>13.session</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Django默认session的过期时间是14天</span><br></pre></td></tr></table></figure>

<h4 id="14-orm设计字段优化"><a href="#14-orm设计字段优化" class="headerlink" title="14.orm设计字段优化"></a>14.orm设计字段优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">有一些字段可以拿到数据，但是需要频繁跨表；可以考虑设置成普通字段，这样在后期获取数据的时候，减少一些跨表的次数。从而提高效率。 </span><br><span class="line">只需要在另外一张表加数据的时候，也同步增加。</span><br></pre></td></tr></table></figure>

<h4 id="15-框架"><a href="#15-框架" class="headerlink" title="15.框架"></a>15.框架</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">a socket服务端</span></span><br><span class="line"><span class="string">b 根据url不同返回不同的内容</span></span><br><span class="line"><span class="string">    url---视图函数</span></span><br><span class="line"><span class="string">c 字符串返回给用户</span></span><br><span class="line"><span class="string">    特殊字符替换</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Web框架种类：</span></span><br><span class="line"><span class="string">a         b   c     Tornado</span></span><br><span class="line"><span class="string">别人的a   b    c     django（a用的wsgiref）</span></span><br><span class="line"><span class="string">别人a     b   别人c   flask（c用的jinja2）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### fastapi 框架</span></span><br><span class="line"><span class="comment">#### sanic   异步框架 （和Flask很像，但是它用了asyncio）</span></span><br></pre></td></tr></table></figure>



<h4 id="15-解释型编译型-强弱类型"><a href="#15-解释型编译型-强弱类型" class="headerlink" title="15.解释型编译型,强弱类型"></a>15.解释型编译型,强弱类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Python：强类型动态语言  （强：指的是不同数据类型之间不能做操作如int+str）</span><br><span class="line">JS: 弱类型动态语言  （可int+str）；ECMAScript + 操作DOM，BOM</span><br><span class="line">NodeJS：ECMAScript扩展出了服务端所需要的一些API，做后端</span><br><span class="line"></span><br><span class="line">C: c代码写完，编译(跨平台运行)</span><br><span class="line">Java: 一处编码，处处运行，半编译半解释。 ---&gt; 把java源代码编译成字节码文件 .class ---&gt; 运行在jvm上</span><br><span class="line"></span><br><span class="line">Go：编译型，可跨平台编译（windows平台可编译出mac平台的可执行文件）</span><br><span class="line">php：web开发</span><br></pre></td></tr></table></figure>

<h4 id="16-数据类型"><a href="#16-数据类型" class="headerlink" title="16. 数据类型"></a>16. 数据类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">python 中一切皆对象</span><br><span class="line"><span class="comment"># type和object的关系</span></span><br><span class="line"><span class="number">1</span> type是所有类的元类；包括它自己(type是type自己的类)</span><br><span class="line"><span class="number">2</span> object是所有类的基类(包括type)</span><br><span class="line"><span class="number">3</span> object也是由type实例化得到的</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一切皆对象的好处</span></span><br><span class="line">不同类型之间的变量直接可以相互赋值</span><br><span class="line">a=<span class="number">100</span></span><br><span class="line">a=<span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> 本质都是 变量指向了一个内存地址</span><br></pre></td></tr></table></figure>

<h4 id="17-可变不可变"><a href="#17-可变不可变" class="headerlink" title="17.可变不可变"></a>17.可变不可变</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可变类型</span></span><br><span class="line">字典 列表 集合</span><br><span class="line"><span class="comment"># 不可变类型</span></span><br><span class="line">数字 字符串 元祖</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典的key必须用不可变类型，可hash  （字典就是hash散列，3.5以前无序）</span></span><br><span class="line">原因: print(hash(<span class="string">&#x27;sdad&#x27;</span>)) hash值相同，就是同一个字符串； hash之后放入内存</span><br><span class="line">     下次再来查的时候，还是用相同的hash函数得到值之后去查</span><br><span class="line"><span class="comment">#### 3.6 开始，字典就是有序的了。   先插A后插B 打印字典keys列表时，B在A前</span></span><br><span class="line">     原因：加入了记录位置的列表</span><br></pre></td></tr></table></figure>

<h4 id="17-1-python中的参数传递是值传递还是引用传递"><a href="#17-1-python中的参数传递是值传递还是引用传递" class="headerlink" title="17.1 python中的参数传递是值传递还是引用传递"></a>17.1 python中的参数传递是值传递还是引用传递</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python 中参数传递都是copy一份传递过去，由于一切皆对象，传过去都是地址，python中区分可变和不可变类型，可变类型在函数中修改会影响原来的；不可变类型，不会影响原来的。</span><br><span class="line"></span><br><span class="line">l = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo2</span>(<span class="params">l</span>):</span></span><br><span class="line">    l.append(<span class="number">6</span>)</span><br><span class="line">    print(l)</span><br><span class="line"></span><br><span class="line">foo2(l)</span><br><span class="line">print(l) 原来l也改变了；</span><br></pre></td></tr></table></figure>



<h4 id="17-如何理解python一切皆对象"><a href="#17-如何理解python一切皆对象" class="headerlink" title="17. 如何理解python一切皆对象"></a>17. 如何理解python一切皆对象</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python中所有的对象都有身份、类型和值</span></span><br><span class="line">https://www.cnblogs.com/wangxin37/p/<span class="number">6598466.</span>html</span><br></pre></td></tr></table></figure>

<h4 id="17-深浅拷贝"><a href="#17-深浅拷贝" class="headerlink" title="17. 深浅拷贝"></a>17. 深浅拷贝</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,a,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">l2 = l 赋值</span><br><span class="line">print(l2 <span class="keyword">is</span> l)   <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> copy</span><br><span class="line">l3 = copy(l)</span><br><span class="line">print(l) 和 print(l3)  一样</span><br><span class="line">print(l <span class="keyword">is</span> l3)  <span class="comment"># False , 指向了不同的内存地址</span></span><br><span class="line">l3[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">l 和 l1 都改变了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">深拷贝，递归拷贝，子子孙孙都拷贝了，耗费资源。</span><br><span class="line">l4 = deepcopy(l)</span><br><span class="line">l4[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">只有l4变了，l未改变</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="18-字符编码"><a href="#18-字符编码" class="headerlink" title="18. 字符编码"></a>18. 字符编码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Unicode 编码统一了 字符和数字的对应关系</span><br><span class="line">UTF<span class="number">-8</span>: 主流编码方式</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符如何对应一个特定数字的标准，这个标准称之为字符编码</span></span><br><span class="line"><span class="number">1.</span> 最早ASCII码 <span class="number">1</span>Bytes=<span class="number">8</span>bit，<span class="number">8</span>bit可以表示<span class="number">0</span><span class="number">-2</span>**<span class="number">8</span><span class="number">-1</span>种变化，即可以表示<span class="number">256</span>个字符</span><br><span class="line">   后GBK GBK:<span class="number">2</span>Bytes代表一个中文字符，<span class="number">1</span>Bytes表示一个英文字符</span><br><span class="line"><span class="number">2.</span> unicode（定长），　统一用<span class="number">2</span>Bytes代表一个字符；虽然<span class="number">2</span>**<span class="number">16</span><span class="number">-1</span>=<span class="number">65535</span>，但unicode却可以存放<span class="number">100</span>w+个字符，因为unicode存放了与其他编码的映射关系</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> UTF<span class="number">-8</span> 英文字符只用<span class="number">1</span>Bytes表示，对中文字符用<span class="number">3</span>Bytes</span><br><span class="line"><span class="comment">#总结：内存中统一采用unicode，浪费空间来换取可以转换成任意编码（不乱码），硬盘可以采用各种编码，如utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> Python2 和 Python3 字符编码区别</span><br><span class="line">（<span class="number">1</span>）解释器默认读文件的编码</span><br><span class="line">    python3： 默认读文件的编码utf<span class="number">-8</span></span><br><span class="line">    python2： ASCII</span><br><span class="line">（<span class="number">2</span>）字符串</span><br><span class="line"><span class="comment"># python2 两种字符串类型 str 和 unicode</span></span><br><span class="line">保证python2 的str类型不乱码；所以python2 一般以u(<span class="string">&#x27;xxx&#x27;</span>) unicode方式存； x = <span class="string">u&#x27;上&#x27;</span>  将字符串存成Unicode</span><br><span class="line"></span><br><span class="line"><span class="comment"># python3 中也有两种字符串类型str和bytes</span></span><br><span class="line">python3 的str类型默认直接存成Unicode格式，无论如何都不会乱码</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结：</span></span><br><span class="line">python2中的str类型就是python3的bytes类型</span><br><span class="line">python2中的Unicode 就是 python3的str类型</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<h4 id="19-闭包函数"><a href="#19-闭包函数" class="headerlink" title="19. 闭包函数"></a>19. 闭包函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 定义在函数内部</span><br><span class="line"><span class="number">2.</span> 对外部作用域引用(就是引用函数外部的变量)</span><br><span class="line"></span><br><span class="line">函数是一等公民如何理解？可以赋值给一个变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器就是闭包函数的典型应用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">      <span class="comment"># 代码</span></span><br><span class="line">      res = func(*args, **kwargs)</span><br><span class="line">      <span class="comment"># 代码</span></span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span>():</span></span><br><span class="line">    print(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line"><span class="comment"># 没有语法糖</span></span><br><span class="line">a = wrapper(a)</span><br><span class="line">a()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有语法糖: 把下面函数名a --&gt; 当做参数传给 上面的函数 --&gt; 再赋值给 a</span></span><br><span class="line"><span class="meta">@wrapper</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span>():</span></span><br><span class="line">    print(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 面向切面编程  AOP</span></span><br><span class="line"><span class="comment"># OOP 面向对象编程</span></span><br></pre></td></tr></table></figure>

<h4 id="20-Django相关"><a href="#20-Django相关" class="headerlink" title="20.Django相关"></a>20.Django相关</h4><h5 id="20-1-APPEND-SLASH问题（实际为中间件控制）"><a href="#20-1-APPEND-SLASH问题（实际为中间件控制）" class="headerlink" title="20.1 APPEND SLASH问题（实际为中间件控制）"></a>20.1 APPEND SLASH问题（实际为中间件控制）</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在配置文件settings.py中有一个参数**APPEND_SLASH**，该参数有两个值<span class="literal">True</span>或<span class="literal">False</span></span><br><span class="line"></span><br><span class="line">这个东西是在中间件里面明确写了的配置<span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="20-2-form表单和ajax提交的重复"><a href="#20-2-form表单和ajax提交的重复" class="headerlink" title="20.2 form表单和ajax提交的重复"></a>20.2 form表单和ajax提交的重复</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">都会触发两次(有ajax的请情况)；</span><br><span class="line">(1)form表单中的input的submmit类型 </span><br><span class="line">(2)button按钮  </span><br><span class="line"></span><br><span class="line">ajax提交一次触发</span><br><span class="line">input 的 button类型不会触发重复提交</span><br></pre></td></tr></table></figure>

<h5 id="20-3-QueryDict-问题"><a href="#20-3-QueryDict-问题" class="headerlink" title="20.3 QueryDict 问题"></a>20.3 QueryDict 问题</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http.request <span class="keyword">import</span> QueryDict</span><br><span class="line">本质就是一个字典，比字典强大，不能够修改值，一改就报错； </span><br><span class="line">为什么不能改？</span><br><span class="line">  其实就重写了setattr 和 setitem 两个方法。</span><br></pre></td></tr></table></figure>

<h5 id="20-4-中间件练习，处理form表单和AJax发过来的数据"><a href="#20-4-中间件练习，处理form表单和AJax发过来的数据" class="headerlink" title="20.4 中间件练习，处理form表单和AJax发过来的数据"></a>20.4 中间件练习，处理form表单和AJax发过来的数据</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 中间件，中间都有一个request.data</span></span><br><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonMiddle</span>(<span class="params">MiddlewareMixin</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">          <span class="comment"># 第一种情况， Json格式数据穿过，load过来</span></span><br><span class="line">          request.data = json.loads(request.body)</span><br><span class="line">          <span class="keyword">print</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">          <span class="comment"># 第二种urlencoded 用request.POST处理</span></span><br><span class="line">          <span class="comment"># 第三种 文件处理和数据，数据部分用request.POST处理</span></span><br><span class="line">            request.data = request.POST</span><br><span class="line"></span><br><span class="line">&lt;form action=<span class="string">&quot;&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    用户名:&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span> id=<span class="string">&quot;name&quot;</span>&gt;</span><br><span class="line">    密码: &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;pwd&quot;</span> id=<span class="string">&quot;id_pwd&quot;</span>&gt;</span><br><span class="line">      <span class="comment"># 提交form表单，3个print都有数据，前两个数据（1为QueryDict，2为b&#x27;name=eee&amp;pwd=eee&#x27;）</span></span><br><span class="line">      <span class="comment"># 原因是数据丛body中封装到request.POST中，所以都有数据；3有数据的原因是因为中间件处理了一下。</span></span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交1&quot;</span> id=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">    <span class="comment"># Ajax指定Json方式  Application/json并序列化字符串提交，request.body中和request.data中有数据；django会将接收到的数据存放于HttpRequest.body，requet.data 为 中间件封装</span></span><br><span class="line">    &lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;提交&quot;</span> id=<span class="string">&quot;id_commit&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $(<span class="string">&#x27;#id_commit&#x27;</span>).click(function ()&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            type: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">            contentType: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">            data: JSON.stringify(&#123;name:$(<span class="string">&#x27;#name&#x27;</span>).val(),password:$(<span class="string">&#x27;#id_pwd&#x27;</span>).val()&#125;),</span><br><span class="line">            &#123;<span class="comment">#data: &#123;name:$(&#x27;#name&#x27;).val(),password:$(&#x27;#id_pwd&#x27;).val()&#125;,#&#125;</span></span><br><span class="line">            success: function (args)&#123;</span><br><span class="line">                alert(args)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;            </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">关注问题：一、</span><br><span class="line">       <span class="number">1.</span> form 表单中重复提交的场景:(<span class="number">1</span>)表单中input的submmit类型  和单&lt;button&gt;按钮  都会触发两次(有ajax的请情况)；</span><br><span class="line">       <span class="number">2.</span> input 的 button类型不会触发重复提交</span><br><span class="line">       二、QueryDict </span><br><span class="line">       <span class="number">1.</span> 本质就是一个字典，比字典强大，不能够修改值，一改就报错</span><br><span class="line"></span><br><span class="line">需要读源码：<span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="21-Python中的魔法方法"><a href="#21-Python中的魔法方法" class="headerlink" title="21. Python中的魔法方法"></a>21. Python中的魔法方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __init__: 类实例化会触发</span></span><br><span class="line"><span class="comment"># __str__: 打印对象会触发</span></span><br><span class="line"><span class="comment"># __call__: 对象() -&gt; 类内的__call__；类也是对象  类()，类实例化过程调用元类的__call__；自定义元类() -&gt; 内置元类的__call__</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># __new__: 在类的实例化会触发，它比__init__早（造出裸体的人，__init__穿衣服）</span></span><br><span class="line"><span class="comment"># __del__: del对象，对象回收的时候触发</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># __setattr__,__getattr__: （.拦截方法）</span></span><br><span class="line">  当对象.属性赋值----&gt; 会调用setattr；  book_obj.publish = &#x27;east&#x27;</span><br><span class="line">  如果是取值 ----&gt; 会调用getattr；         print(book_obj.publish)</span><br><span class="line">     应用：假设有一个Person对象，.name=<span class="number">10</span>，正常直接就设置上了；  重写setattr 不让写数字。</span><br><span class="line">    </span><br><span class="line"><span class="comment"># __getitem__  ，__setitem__ : ([]拦截)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># __enter__ 和 __next__ 上下文管理器</span></span><br></pre></td></tr></table></figure>

<ul>
<li>应用场景:设有一个Person对象，.addr=10，正常直接就设置上了；  重写setattr 不让写数字。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">object</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> key == <span class="string">&#x27;addr&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> isinstance(value, str):</span><br><span class="line">                <span class="comment"># setattr(self, key, value)  # 内部执行了 self.name = value    所以出现了递归报错</span></span><br><span class="line">                self.__dict__[key] = value <span class="comment"># 第一种方法</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">&#x27;你不能放&#x27;</span>)</span><br><span class="line">                <span class="keyword">raise</span> NotStrException(<span class="string">&#x27;不是字符串异常&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.__dict__[key] = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotStrException</span>(<span class="params">BaseException</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, msg</span>):</span></span><br><span class="line">        self.msg = msg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.msg</span><br><span class="line"></span><br><span class="line">person_obj = Person(<span class="string">&#x27;egon&#x27;</span>, <span class="number">99</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    person_obj.addr = <span class="string">&#x27;SH&#x27;</span></span><br><span class="line"><span class="keyword">except</span> NotStrException <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line">print(person_obj.name)</span><br><span class="line">print(person_obj.age)</span><br><span class="line">print(person_obj.addr)</span><br></pre></td></tr></table></figure>

<ul>
<li>应用场景, 重写setitem和getitem，让类可以通过[‘name’] 方式赋值</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        self.__dict__[<span class="string">&#x27;key&#x27;</span>] = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__dict__.get(item)</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&#x27;lqz&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p[<span class="string">&#x27;name&#x27;</span>] = <span class="number">10</span></span><br><span class="line">print(p[<span class="string">&#x27;name&#x27;</span>])</span><br></pre></td></tr></table></figure>

<ul>
<li>重写setattr 和 getattr ，让自定义地点可以通过.取值赋值</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDict</span>(<span class="params">dict</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self, key, value</span>):</span> <span class="comment"># 点拦截</span></span><br><span class="line">        self[key] = value <span class="comment"># 继承父类方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, item</span>):</span>  <span class="comment"># 点拦截；获取值的时候，自身__dict__没有，就去父类找，父类没有，就去基类找。再没有就在getattr找</span></span><br><span class="line">        <span class="keyword">return</span> self[item] <span class="comment"># 继承父类方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dict_obj = MyDict()</span><br><span class="line">dict_obj.name = <span class="string">&#x27;waylon&#x27;</span></span><br><span class="line">dict_obj.age = <span class="number">28</span></span><br><span class="line">print(dict_obj)</span><br><span class="line">print(dict_obj.age)</span><br><span class="line">print(dict_obj.__dict__)</span><br></pre></td></tr></table></figure>

<ul>
<li>enter和exit 实现上下文管理器，执行sql查询后自动关闭链接 %%%% 面试被问的概率高</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mysql</span>(<span class="params">object</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;出现with语句，对象的__enter__被触发，有返回值则赋值给as声明的变量&#x27;</span>)</span><br><span class="line">        self.conn = pymysql.connect(host=<span class="string">&#x27;&#x27;</span>, user=<span class="string">&#x27;&#x27;</span>, password=<span class="string">&#x27;&#x27;</span>, database=<span class="string">&#x27;&#x27;</span>, port=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.conn <span class="comment"># return self.conn的原因是下面要用，如果直接conn 下面找不到</span></span><br><span class="line">                <span class="comment"># 同时return 的值会被with语句中的as拿到</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;退出with代码块时执行此方法&#x27;</span>)</span><br><span class="line">        self.conn.close() </span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Mysql() <span class="keyword">as</span> mysql:</span><br><span class="line">    mysql.cursor()</span><br><span class="line">    print(<span class="string">&#x27;++执行代码块&#x27;</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 执行SQL语句</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>__eq__</code>对象等号比较</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x,y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">        <span class="comment"># 打印比较的第二个对象的x值</span></span><br><span class="line">        print(obj.x)</span><br><span class="line">        <span class="keyword">if</span> self.x + self.y == obj.x + obj.y:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">b = A(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(a == b)  <span class="comment"># 当执行==时，会触发__eq__的执行，并且把b传进去给obj</span></span><br></pre></td></tr></table></figure>

<h4 id="22-cookie，session，token"><a href="#22-cookie，session，token" class="headerlink" title="22.cookie，session，token"></a>22.cookie，session，token</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> HTTP协议：基于请求响应  基于TCP IP应用层协议的应用层协议 ； 无状态，短连接</span><br><span class="line"><span class="number">2.</span> MySQL：C/S架构；底层基于socket，自己封装的协议，MySQL的客户端；</span><br><span class="line"><span class="number">3.</span> redis：c/s架构，底层基于socket，自己封装的协议</span><br><span class="line"><span class="number">4.</span> docker：c/s架构，基于http协议，使用restful规范</span><br><span class="line"><span class="number">5.</span> elasticsearch： c/s架构，基于http协议，使用restful规范</span><br><span class="line"></span><br><span class="line"><span class="comment"># cookie：存在于浏览器的键值对，向服务端发送请求，携带过去（不安全）</span></span><br><span class="line"><span class="comment"># session：存在于服务端的键值对（放在内存，文件，MySQL，Redis都可以） </span></span><br><span class="line">       缺点：用户量过大，存储需要耗费很多资源</span><br><span class="line">  cookie 和 session区别：(<span class="number">1</span>)存储位置；(<span class="number">2</span>)session依赖于cookie；(<span class="number">3</span>) session的好处是浏览器只存session_id随机字符串，不存储个人信息。</span><br><span class="line"><span class="comment"># token：就是个字符串（既安全，又存个人信息）加密字符串</span></span><br><span class="line">      优点：服务端不存储信息</span><br><span class="line"></span><br><span class="line"><span class="comment"># token应用广泛：可以是浏览器，小程序，也可以是移动端</span></span><br><span class="line"><span class="comment"># JWT：json web token</span></span><br></pre></td></tr></table></figure>



<ul>
<li>cookie使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Django设置cookie</span></span><br><span class="line">response.set_cookie(key, values) <span class="comment"># (HttpResponse对象) render redirect JSONResponse都可以</span></span><br><span class="line">加盐处理：obj.set_signed_cookie(key,value,salt=<span class="string">&#x27;盐&#x27;</span>)</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">IE 浏览器识别expire</span><br><span class="line">**都用max_age**</span><br><span class="line">domain=<span class="literal">None</span>, Cookie生效的域名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除cookie</span></span><br><span class="line">rep.delete_cookie(<span class="string">&quot;user&quot;</span>)  <span class="comment"># 删除用户浏览器上之前设置的usercookie值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取cookie</span></span><br><span class="line">request.COOKIES[<span class="string">&#x27;key&#x27;</span>]</span><br><span class="line">request.get_signed_cookie(key, default=RAISE_ERROR, salt=<span class="string">&#x27;&#x27;</span>, max_age=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>session</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**设置session：request.session[<span class="string">&#x27;key&#x27;</span>] = value**</span><br><span class="line">**获取session：request.session.get(<span class="string">&#x27;key&#x27;</span>)**</span><br><span class="line">**设置过期时间：request.session.set_expiry()**</span><br><span class="line">清除session：request.session.delete() <span class="comment"># 删除当前会话所有的session</span></span><br><span class="line">**request.session.flush() <span class="comment"># 浏览器和服务端都清空，一般用这个**</span></span><br></pre></td></tr></table></figure>

<h4 id="23-Django中session底层原理"><a href="#23-Django中session底层原理" class="headerlink" title="23.Django中session底层原理"></a>23.Django中session底层原理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在中间件中，请求走的时候，process_response，取出request.session的modify属性，判断是否是true，如果是true，表示在视图函数中修改过session，数据库同步修改，如果是false，就不修改，返回给前端</span></span><br><span class="line">sessionid ：随机字符串</span><br><span class="line"><span class="comment"># 请求来了，通过sessionid，取出随机字符串--&gt;DB中去查--&gt;把表的数据转成字典，赋值给request.session,后面视图函数中就可以操作它了。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">设置session内部发生的事情：</span><br><span class="line">    <span class="number">1</span>、Django内部自动生成一个随机字符串</span><br><span class="line">    <span class="number">2</span>、Django内部自动将随机字符串和对应的数据存储到django_session表中</span><br><span class="line">       <span class="number">2.1</span>、在内存中产生操作数据的缓存</span><br><span class="line">       <span class="number">2.2</span>、在响应结果Django中间件的时候才真正的操作数据库</span><br><span class="line">    <span class="number">3</span>、将产生的随机字符串返回给客户端浏览器保存</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    return HttpResponse(&#x27;hhh&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def get_session(request):</span></span><br><span class="line"><span class="string">    print(request.session.get(&#x27;hobby&#x27;))</span></span><br><span class="line"><span class="string">    # print(request.session)</span></span><br><span class="line"><span class="string">    # print(request.session.get(&#x27;hobby&#x27;))</span></span><br><span class="line"><span class="string">    # print(request.session.get(&#x27;hobby1&#x27;))</span></span><br><span class="line"><span class="string">    # print(request.session.get(&#x27;hobby2&#x27;))</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    获取session内部发生的事情：</span><br><span class="line">    <span class="number">1</span>、自动从浏览器请求中获取session_id对应的随机字符串（中间件）</span><br><span class="line">    <span class="number">2</span>、用该随机字符串去django_session表中查找对应的数据</span><br><span class="line">    <span class="number">3</span>、如果有匹配的数据，则将对应的数据取出并以字典的形式封装到request.session中，如果没有匹配的数据，则request.session.get()返回none</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>应用场景：使用token实现token功能</li>
</ul>
<h4 id="24-异常处理"><a href="#24-异常处理" class="headerlink" title="24.异常处理"></a>24.异常处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">else</span>:    正常执行没有出异常的时候会走</span><br><span class="line">finnaly: 无论是否有异常，都会走</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  print(<span class="string">&#x27;xxxx&#x27;</span>)</span><br><span class="line"><span class="comment">#  print(1/0)</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">  print(e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  print(<span class="string">&quot;正常执行完成，没有出异常，会走&quot;</span>)</span><br><span class="line">finnally:</span><br><span class="line">  print(<span class="string">&quot;我是finnaly&quot;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="25-pymysql使用"><a href="#25-pymysql使用" class="headerlink" title="25.pymysql使用"></a>25.pymysql使用</h4><p>字符集：utf8mb4 特殊符号不会报错，主流</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">#### 26.Django相关</span><br><span class="line"></span><br><span class="line">- 视图层</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">1. response对象: 三件套+response 本质都是HttpResponse</span><br><span class="line">2. request对象：</span><br><span class="line">request.GET: http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;index&#x2F;123?name&#x3D;lqz&amp;age&#x3D;18  name&#x3D;lqz&amp;age&#x3D;18 会被转成字典至GET</span><br><span class="line">request.POST: urlencoded formdata 两种编码的数据会被放到字典中</span><br><span class="line">request.META: HTTP请求的其他东西放在里面，比如客户端ip地址：REMOTE_ADDR</span><br><span class="line">request.FILES：上传的文件</span><br><span class="line">request.session:用的session是中间件里面的，不是请求里面的。</span><br><span class="line">  </span><br><span class="line">3. 301永久，容易被搜索引擎抓录 302临时  </span><br><span class="line">4. JsonResponse</span><br><span class="line">5. CBV 和 FBV</span><br><span class="line">#  文件上传（form表单中指定编码格式）</span><br><span class="line"></span><br><span class="line">6. 文件上传（form表单中指定编码格式）</span><br><span class="line">def register(request):</span><br><span class="line">    if request.method &#x3D;&#x3D; &#39;GET&#39;:</span><br><span class="line">        return render(request,&#39;register.html&#39;)</span><br><span class="line">    elif request.method &#x3D;&#x3D; &#39;POST&#39;:</span><br><span class="line">        print(request.body)</span><br><span class="line"></span><br><span class="line">        # 从request.POST中获取用户名</span><br><span class="line">        name&#x3D;request.POST.get(&#39;name&#39;) </span><br><span class="line">        # 从request.FILES获取文件对象</span><br><span class="line">        file_obj&#x3D;request.FILES.get(&#39;myfile&#39;) </span><br><span class="line">        name &#x3D; file_obj.name # 获取文件名字</span><br><span class="line">        </span><br><span class="line">        # 上传的文件存放于templates文件夹下</span><br><span class="line">        with open(name,&#39;wb&#39;) as f: </span><br><span class="line">            for chunk in file_obj.chunks():</span><br><span class="line">                f.write(chunk)</span><br><span class="line"></span><br><span class="line">        return HttpResponse(&#39;注册成功&#39;)</span><br></pre></td></tr></table></figure>

<p>ajax发送文件</p>
<p>1、需要借助js内置对象<strong>Formdata</strong>，既可以添加普通键值对，又添加文件对象<br>2、需要指定两个关键性的参数：<strong>contentType:false</strong> 和  <strong>processData:false</strong><br>3、Django后端能直接识别到formdata对象，并且能够将内部的普通键值对自动解析封装到<strong>request.POST</strong>，将文件数据自动封装到<strong>request.FILES中</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Ajax 发送文件</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;username:<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;d1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;p&gt;password:<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;d2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;d3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;btn btn-info&quot;</span> id=<span class="string">&quot;d4&quot;</span>&gt;click me &lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 写一个Ajax请求操作：点击按钮朝后端发送普通键值对和文件数据</span></span><br><span class="line">    $(<span class="string">&#x27;#d4&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 1.先创建一个FormData内置对象：</span></span><br><span class="line">        <span class="keyword">let</span> formDataObj = <span class="keyword">new</span> FormData();</span><br><span class="line">        <span class="comment">// 2.给FormData对象添加普通键值对</span></span><br><span class="line">        formDataObj.append(<span class="string">&#x27;username&#x27;</span>,$(<span class="string">&#x27;#d1&#x27;</span>).val());</span><br><span class="line">        formDataObj.append(<span class="string">&#x27;password&#x27;</span>,$(<span class="string">&#x27;#d2&#x27;</span>).val());</span><br><span class="line">        <span class="comment">// 3.给FormData对象添加文件对象</span></span><br><span class="line">        formDataObj.append(<span class="string">&#x27;myfile&#x27;</span>,$(<span class="string">&#x27;#d3&#x27;</span>)[<span class="number">0</span>].files[<span class="number">0</span>])</span><br><span class="line">        <span class="comment">// 4.将对象基于Ajax发送给后端</span></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            type:<span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">            data:formDataObj,  <span class="comment">// 直接将FormData对象放在data后面即可</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Ajax发送文件必须要指定的两个参数</span></span><br><span class="line">            contentType:<span class="literal">false</span>,  <span class="comment">// 不需要使用任何编码，Django后端能够自动识别formdata对象</span></span><br><span class="line">            processData:<span class="literal">false</span>,  <span class="comment">// 告诉浏览器不要对数据进行任何处理，直接发给后端就行</span></span><br><span class="line">            </span><br><span class="line">            success:<span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>模板层</li>
</ul>
<p>Django是如何处理xss攻击的？</p>
<p>后端在渲染的时候模板语言 将标签替换成特殊字符例如 &lt; 替换为 &amp;lt；mark_safe 就是不替换特殊字符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">一、变量：&#123;&#123; 变量名 &#125;&#125;</span><br><span class="line">    <span class="number">1.1</span> 深度查询：句点符的应用</span><br><span class="line">    <span class="number">1.2</span> 过滤器</span><br><span class="line">二、标签：&#123;% 标签名 %&#125;</span><br><span class="line">三、内置过滤器</span><br><span class="line">   &#123;&#123; obj|filter_name:param &#125;&#125; 变量名字|过滤器名称：变量</span><br><span class="line">  &lt;p&gt;统计长度：&#123;&#123; s|length &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;默认值，意思就是当前面的值的布尔值是True，那么就显示前面的值，如果不是True，那么就显示默认值：&#123;&#123; b|default:&#x27;默认值&#x27; &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;文件大小：&#123;&#123; file_size|filesizeformat &#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment"># django中处理XSS攻击的方式</span></span><br><span class="line">django就是在后端渲染的时候用模板语言 将标签替换成特殊字符例如 &lt; 替换为 &amp;lt； 从而防止了xss攻击</span><br><span class="line"></span><br><span class="line">解除限制:</span><br><span class="line">(<span class="number">1</span>)在前端模板语言中实现，只须用到帮助函数safe</span><br><span class="line">(<span class="number">2</span>)在后端views中实现</span><br><span class="line">   重点：safe     加上safe就是显示html，不加safe就是字符串</span><br><span class="line">   <span class="keyword">from</span> django.utils.safestring <span class="keyword">import</span> mark_safe</span><br><span class="line">   res=mark_safe(<span class="string">&#x27;&lt;h1&gt;你好哇&lt;/h1&gt;&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">三、自定义标签和过滤器</span><br><span class="line">四、模板的导入和继承</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意一点： 模板转Python字典的时候，在后端转成了一个字符串，里面是单引号；渲染到前端之后 var a = ’&#123;dict&#125;‘</span></span><br><span class="line">是无法用JSON.Stringify转，因为里面是单引号，不是json格式的字符串。js对象里面的键是双引号</span><br><span class="line"></span><br><span class="line">Python中字典    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;json&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">23</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">JavaScript的对象（Object）本质上是键值对的集合（Hash结构），但是只能用字符串作为键。</span><br><span class="line"><span class="comment"># 双引号双引号双引号</span></span><br><span class="line"></span><br><span class="line">var a = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;;</span><br><span class="line">console.log(a.name);</span><br><span class="line">console.log(a[<span class="string">&quot;age&quot;</span>]);</span><br><span class="line"></span><br><span class="line">// JSON字符串转换成对象</span><br><span class="line">var obj = JSON.parse(str1); </span><br><span class="line">// 对象转换成JSON字符串</span><br><span class="line">var str = JSON.stringify(obj1);</span><br><span class="line"><span class="string">&quot;&#123;&quot;</span>name<span class="string">&quot;:&quot;</span>json<span class="string">&quot;,&quot;</span>age<span class="string">&quot;:18&#125;&quot;</span>   JSON格式的字符串里面是双引号</span><br></pre></td></tr></table></figure>

<ul>
<li>模型层</li>
</ul>
<h4 id="单表操作"><a href="#单表操作" class="headerlink" title="单表操作"></a>单表操作</h4><h5 id="增"><a href="#增" class="headerlink" title="增"></a>增</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>先生成对象，后save</span><br><span class="line">obj = Employee(name=<span class="string">&quot;Egon&quot;</span>, gender=<span class="number">0</span>, birth=<span class="string">&#x27;1997-01-27&#x27;</span>, department=<span class="string">&quot;财务部&quot;</span>, salary=<span class="number">100.1</span>)</span><br><span class="line">obj.save()</span><br><span class="line"><span class="number">2.</span>create</span><br><span class="line"><span class="comment"># 每个模型表下都有一个objects管理器，用于对该表中的记录进行增删改查操作，其中增加操作如下所示</span></span><br><span class="line">obj = Employee.objects.create(name=<span class="string">&quot;Egon&quot;</span>, gender=<span class="number">0</span>, birth=<span class="string">&#x27;1997-01-27&#x27;</span>, department=<span class="string">&quot;财务部&quot;</span>, salary=<span class="number">100.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回值</span></span><br><span class="line">obj 就是被创建的对象本身</span><br></pre></td></tr></table></figure>

<h5 id="查-除了count外的返回值都是一个模型类的对象"><a href="#查-除了count外的返回值都是一个模型类的对象" class="headerlink" title="查(除了count外的返回值都是一个模型类的对象)"></a>查(除了count外的返回值都是一个模型类的对象)</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="number">1</span>&gt; all():                  查询所有结果</span><br><span class="line">  </span><br><span class="line">&lt;<span class="number">2</span>&gt; filter(**kwargs):       它包含了与所给筛选条件相匹配的对象</span><br><span class="line">  </span><br><span class="line">&lt;<span class="number">3</span>&gt; get(**kwargs):          返回与所给筛选条件相匹配的对象，返回结果有且只有一个，如果符合筛选条件的对象超过一个或者没有都会抛出错误。</span><br><span class="line">  </span><br><span class="line">&lt;<span class="number">4</span>&gt; exclude(**kwargs):      它包含了与所给筛选条件不匹配的对象</span><br><span class="line"> </span><br><span class="line">&lt;<span class="number">5</span>&gt; order_by(*field):       对查询结果排序(<span class="string">&#x27;-id&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">&lt;<span class="number">6</span>&gt; reverse():              对查询结果反向排序</span><br><span class="line">  </span><br><span class="line">&lt;<span class="number">8</span>&gt; count():                返回数据库中匹配查询(QuerySet)的对象数量。</span><br><span class="line">  </span><br><span class="line">&lt;<span class="number">9</span>&gt; first():                返回第一条记录</span><br><span class="line">  </span><br><span class="line">&lt;<span class="number">10</span>&gt; last():                返回最后一条记录</span><br><span class="line">  </span><br><span class="line">&lt;<span class="number">11</span>&gt; exists():              如果QuerySet包含数据，就返回<span class="literal">True</span>，否则返回<span class="literal">False</span></span><br><span class="line"> </span><br><span class="line">&lt;<span class="number">12</span>&gt; values(*field):        返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系列</span><br><span class="line">                            model的实例化对象，而是一个可迭代的字典序列</span><br><span class="line">&lt;<span class="number">13</span>&gt; values_list(*field):   它与values()非常相似，它返回的是一个元组序列，values返回的是一个字典序列</span><br><span class="line"> </span><br><span class="line">&lt;<span class="number">14</span>&gt; distinct():            从返回结果中剔除重复纪录</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">def index(request):</span><br><span class="line">    # 添加表记录++++++++++++++++++++++++++++++++++</span><br><span class="line">    # 方式一</span><br><span class="line">    # book&#x3D;Book(name&#x3D;&#39;红楼梦&#39;,pub_data&#x3D;&#39;2015-10-12&#39;,price&#x3D;88,publish&#x3D;&#39;老男孩出版社&#39;)</span><br><span class="line">    # book.save()</span><br><span class="line">    # 方式二</span><br><span class="line">    # Book.objects.create(name&#x3D;&#39;Python红宝书&#39;,pub_data&#x3D;&#39;2010-10-12&#39;,price&#x3D;100,publish&#x3D;&#39;人民出版社&#39;)</span><br><span class="line">    # 查询表记录++++++++++++++++++++++++++++++++++</span><br><span class="line">    # QUerySet数据类型（类似于一个列表，里面放着一些对象）</span><br><span class="line">    # 1 方法的返回值是什么</span><br><span class="line">    # 2 方法的调用者</span><br><span class="line">    # (1) all方法 返回一个QuerySet对象</span><br><span class="line">    # book_list&#x3D;Book.objects.all()</span><br><span class="line">    # print(book_list[1].name)</span><br><span class="line">    # print(book_list)</span><br><span class="line">    # for obj in book_list:</span><br><span class="line">    #     print(obj.name)</span><br><span class="line">    # (2)first last：调用者是queryset对象，返回值是对象</span><br><span class="line">    # book&#x3D;Book.objects.all().first()</span><br><span class="line">    # book2&#x3D;Book.objects.all().last()</span><br><span class="line">    # print(book)</span><br><span class="line">    # print(book2)</span><br><span class="line">    # (3) filter  返回值是queryset对象(相当于where语句)</span><br><span class="line">    # 可以加多个过滤条件</span><br><span class="line">    # book&#x3D;Book.objects.filter(name&#x3D;&#39;红楼梦&#39;).first()</span><br><span class="line">    # print(book)</span><br><span class="line">    # (4)get方法 有且只有一个查询结果才有意义 返回值是一个对象</span><br><span class="line">    # book&#x3D;Book.objects.get(name&#x3D;&#39;红楼梦&#39;)</span><br><span class="line">    # print(book)</span><br><span class="line">    # 直接报错</span><br><span class="line">    # book &#x3D; Book.objects.get(name&#x3D;&#39;红楼梦eee&#39;)</span><br><span class="line">    # --------------最常用-----------------</span><br><span class="line">    # (5)exclude 除了查询之外的 返回值也是queryset</span><br><span class="line">    # ret&#x3D;Book.objects.exclude(name&#x3D;&#39;红楼梦&#39;)</span><br><span class="line">    # print(ret)</span><br><span class="line">    # （6）order_by(默认升序，加个- 就是降序),可以多个过滤条件调用者是queryset返回值也是queryset</span><br><span class="line">    # book_list&#x3D;Book.objects.all().order_by(&#39;id&#39;)</span><br><span class="line">    # book_list&#x3D;Book.objects.all().order_by(&#39;-id&#39;,&#39;price&#39;)</span><br><span class="line">    # print(book_list)</span><br><span class="line">    # （7）count() 调用者是queryset，返回值是int</span><br><span class="line">    # ret&#x3D;Book.objects.all().count()</span><br><span class="line">    # print(ret)</span><br><span class="line">    # (8)exist()判断是是否有值，不能传参数，</span><br><span class="line">    # ret&#x3D;Book.objects.all().exists()</span><br><span class="line">    # print(ret)</span><br><span class="line">    # （9）values方法</span><br><span class="line">    # 查询所有书籍的名称(里面传的值，前提是表有这个字段)也是queryset但是里面放的是字典</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    values原理</span><br><span class="line">    temp&#x3D;[]</span><br><span class="line">    for obj in Book.objects.all():</span><br><span class="line">        temp.append(&#123;&#39;name&#39;:obj.name&#125;)</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    # ret&#x3D;Book.objects.all().values(&#39;name&#39;)</span><br><span class="line">    # print(ret)</span><br><span class="line">    # 不加.all()也可以,调用是queryset返回值也是queryset</span><br><span class="line">    # ret&#x3D;Book.objects.values(&#39;price&#39;)</span><br><span class="line">    # print(ret)</span><br><span class="line">    # （10）value_list</span><br><span class="line">    # ret&#x3D;Book.objects.all().values_list(&#39;price&#39;,&#39;name&#39;)</span><br><span class="line">    # print(ret)</span><br><span class="line">    # (11) distinct  seletc * 的时候没有意义</span><br><span class="line">    # SELECT DISTINCT name from app01_book;</span><br><span class="line">    # 没有任何意义，不要这样么用</span><br><span class="line">    # Book.objects.all().distinct()</span><br><span class="line">    # ret&#x3D;Book.objects.all().values(&#39;name&#39;).distinct()</span><br><span class="line">    # print(ret)</span><br><span class="line"></span><br><span class="line">    # 双下划线模糊查询-----------------------</span><br><span class="line">    # 查询价格大于100的书</span><br><span class="line">    # ret&#x3D;Book.objects.filter(price__gt&#x3D;100)</span><br><span class="line">    # print(ret)</span><br><span class="line">    # 查询大于50小于100的书</span><br><span class="line">    # ret&#x3D;Book.objects.filter(price__gt&#x3D;50,price__lt&#x3D;100)</span><br><span class="line">    # print(ret)</span><br><span class="line">    # 查询已红楼开头的书</span><br><span class="line">    # ret&#x3D;Book.objects.filter(name__startswith&#x3D;&#39;红楼&#39;)</span><br><span class="line">    # print(ret)</span><br><span class="line">    # 查询包含‘红’的书</span><br><span class="line">    # ret&#x3D; Book.objects.filter(name__contains&#x3D;&#39;红&#39;)</span><br><span class="line">    # print(ret)</span><br><span class="line">    # icontains  不区分大小写</span><br><span class="line">    # 价格在50，88，100 中的</span><br><span class="line">    # ret&#x3D;Book.objects.filter(price__in&#x3D;[50,88,100])</span><br><span class="line">    # print(ret)</span><br><span class="line">    # 出版日期在2018年的</span><br><span class="line">    # ret&#x3D;Book.objects.filter(pub_data__year&#x3D;2015,pub_data__month&#x3D;2)</span><br><span class="line">    # print(ret)</span><br><span class="line">    # 删除，修改------------------------</span><br><span class="line">    # delete：调用者可以是queryset也可以是model对象</span><br><span class="line">    # 删除价格为188的书有返回值 (1, &#123;&#39;app01.Book&#39;: 1&#125;) 删除的个数，那张表，记录数</span><br><span class="line">    # ret&#x3D;Book.objects.filter(price&#x3D;188).delete()</span><br><span class="line">    # print(ret)</span><br><span class="line">    # ret&#x3D;Book.objects.filter(price&#x3D;100).first().delete()</span><br><span class="line">    # print(ret)</span><br><span class="line"></span><br><span class="line">    # 修改 update只能queryset来调用 返回值为int</span><br><span class="line">    # ret&#x3D;Book.objects.filter(name&#x3D;&#39;红楼梦1&#39;).update(name&#x3D;&#39;红楼梦&#39;)</span><br><span class="line">    # print(ret)</span><br><span class="line">    # 报错</span><br><span class="line">    # Book.objects.filter(name&#x3D;&#39;红楼梦&#39;).first().update(name&#x3D;&#39;红楼梦1&#39;)</span><br><span class="line"></span><br><span class="line">    # ret&#x3D;Book.objects.filter(name&#x3D;&#39;红楼梦1&#39;).first()</span><br><span class="line">    # print(ret.delete())</span><br><span class="line">    # aa&#x3D;Publish.objects.filter(name&#x3D;&#39;人民出版社&#39;)</span><br><span class="line">    # print(type(aa))</span><br><span class="line">    # aa.delete()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>基于双下划线的模糊查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Book.objects.filter(price__in&#x3D;[100,200,300])</span><br><span class="line">Book.objects.filter(price__gt&#x3D;100)</span><br><span class="line">Book.objects.filter(price__lt&#x3D;100)</span><br><span class="line">Book.objects.filter(price__gte&#x3D;100)</span><br><span class="line">Book.objects.filter(price__lte&#x3D;100)</span><br><span class="line">Book.objects.filter(price__range&#x3D;[100,200])</span><br><span class="line">Book.objects.filter(title__contains&#x3D;&quot;python&quot;)</span><br><span class="line">Book.objects.filter(title__icontains&#x3D;&quot;python&quot;)</span><br><span class="line">Book.objects.filter(title__startswith&#x3D;&quot;py&quot;)</span><br><span class="line">Book.objects.filter(pub_date__year&#x3D;2012)</span><br></pre></td></tr></table></figure>

<h5 id="删delete"><a href="#删delete" class="headerlink" title="删delete()"></a>删delete()</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.filter(pub_date__year=<span class="number">2005</span>).delete()</span><br><span class="line"><span class="comment"># 在 Django 删除对象时，会模仿 SQL 约束 ON DELETE CASCADE 的行为，换句话说，删除一个对象时也会删除与它相关联的外键对象。</span></span><br><span class="line">b = Blog.objects.get(pk=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># This will delete the Blog and all of its Entry objects.</span></span><br><span class="line">b.delete()</span><br><span class="line"></span><br><span class="line">如果不想级联删除，可以设置为:</span><br><span class="line">pubHouse = models.ForeignKey(to=<span class="string">&#x27;Publisher&#x27;</span>, on_delete=models.SET_NULL, blank=<span class="literal">True</span>, null=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h5 id="更新update"><a href="#更新update" class="headerlink" title="更新update"></a>更新update</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Book.objects.filter(title__startswith=<span class="string">&quot;py&quot;</span>).update(price=<span class="number">120</span>)</span><br><span class="line">此外，update()方法对于任何结果集（QuerySet）均有效，这意味着你可以同时更新多条记录update()方法会返回一个整型数值，表示受影响的记录条数。</span><br></pre></td></tr></table></figure>



<h4 id="多表操作（基于对象的跨表查询）"><a href="#多表操作（基于对象的跨表查询）" class="headerlink" title="多表操作（基于对象的跨表查询）"></a>多表操作（基于对象的跨表查询）</h4><h5 id="增-1"><a href="#增-1" class="headerlink" title="增"></a>增</h5><p>一对多</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方式<span class="number">1</span>: <span class="comment"># 通过 表名=对象 创建</span></span><br><span class="line">   publish_obj=Publish.objects.get(nid=<span class="number">1</span>)</span><br><span class="line">   book_obj=Book.objects.create(title=<span class="string">&quot;&quot;</span>,publishDate=<span class="string">&quot;2012-12-12&quot;</span>,price=<span class="number">100</span>,publish=publish_obj)</span><br><span class="line">  </span><br><span class="line">方式<span class="number">2</span>: <span class="comment"># 通过 id值取创建</span></span><br><span class="line">   book_obj=Book.objects.create(title=<span class="string">&quot;&quot;</span>,publishDate=<span class="string">&quot;2012-12-12&quot;</span>,price=<span class="number">100</span>,publish_id=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>多对多(实际就时候操作第三张表) </p>
<p>add</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前生成的书籍对象</span></span><br><span class="line">  book_obj=Book.objects.create(title=<span class="string">&quot;追风筝的人&quot;</span>,price=<span class="number">200</span>,publishDate=<span class="string">&quot;2012-11-12&quot;</span>,publish_id=<span class="number">1</span>)</span><br><span class="line">  <span class="comment"># 为书籍绑定的做作者对象</span></span><br><span class="line">  yuan=Author.objects.filter(name=<span class="string">&quot;yuan&quot;</span>).first() <span class="comment"># 在Author表中主键为2的纪录</span></span><br><span class="line">  egon=Author.objects.filter(name=<span class="string">&quot;alex&quot;</span>).first() <span class="comment"># 在Author表中主键为1的纪录</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 绑定多对多关系,即向关系表book_authors中添加纪录</span></span><br><span class="line">  book_obj.authors.add(yuan,egon)    <span class="comment">#  将某些特定的 model 对象添加到被关联对象集合中。   =======    book_obj.authors.add(*[])</span></span><br></pre></td></tr></table></figure>

<p>删和更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">book_obj.authors.remove()      # 将某个特定的对象从被关联对象集合中去除。    &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;   book_obj.authors.remove(*[])</span><br><span class="line">book_obj.authors.clear()       #清空被关联对象集合</span><br><span class="line">book_obj.authors.set()         #先清空再设置</span><br></pre></td></tr></table></figure>

<h5 id="查询（基于对象跨表）"><a href="#查询（基于对象跨表）" class="headerlink" title="查询（基于对象跨表）"></a>查询（基于对象跨表）</h5><h6 id="一对多查询-正向查询按字段，反向查询按表名小写-set-多个值就加all"><a href="#一对多查询-正向查询按字段，反向查询按表名小写-set-多个值就加all" class="headerlink" title="一对多查询 (正向查询按字段，反向查询按表名小写+_set,多个值就加all)"></a>一对多查询 <font color="red">(正向查询按字段，反向查询按表名小写+_set,多个值就加all)</font></h6><p>正向查询（按字段：publish）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询主键为1的书籍的出版社所在的城市</span></span><br><span class="line">book_obj=Book.objects.filter(pk=<span class="number">1</span>).first()</span><br><span class="line"><span class="comment"># book_obj.publish 是主键为1的书籍对象关联的出版社对象</span></span><br><span class="line">print(book_obj.publish.city)</span><br></pre></td></tr></table></figure>

<p>反向查询（按表名：book_set）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">publish&#x3D;Publish.objects.get(name&#x3D;&quot;苹果出版社&quot;)</span><br><span class="line">#publish.book_set.all() : 与苹果出版社关联的所有书籍对象集合</span><br><span class="line">book_list&#x3D;publish.book_set.all()    </span><br><span class="line">for book_obj in book_list:</span><br><span class="line">       print(book_obj.title)</span><br></pre></td></tr></table></figure>

<h6 id="一对一查询-正向查询按字段，反向查询表名小写"><a href="#一对一查询-正向查询按字段，反向查询表名小写" class="headerlink" title="一对一查询(正向查询按字段，反向查询表名小写)"></a>一对一查询<font color="red">(正向查询按字段，反向查询表名小写)</font></h6><p>正向查询(按字段：authorDetail)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">egon&#x3D;Author.objects.filter(name&#x3D;&quot;egon&quot;).first()</span><br><span class="line">print(egon.authorDetail.telephone)</span><br></pre></td></tr></table></figure>

<p>反向查询(按表名：author)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查询所有住址在北京的作者的姓名</span><br><span class="line"> </span><br><span class="line">authorDetail_list&#x3D;AuthorDetail.objects.filter(addr&#x3D;&quot;beijing&quot;)</span><br><span class="line">for obj in authorDetail_list:</span><br><span class="line">     print(obj.author.name)</span><br></pre></td></tr></table></figure>

<h6 id="多对多查询-正向查询按字段，反向查询按表名小写-set-多个值就加all"><a href="#多对多查询-正向查询按字段，反向查询按表名小写-set-多个值就加all" class="headerlink" title="多对多查询 (正向查询按字段，反向查询按表名小写+_set,多个值就加all)"></a>多对多查询 <font color="red">(正向查询按字段，反向查询按表名小写+_set,多个值就加all)</font></h6><p>正向查询(按字段：authors)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 眉所有作者的名字以及手机号</span><br><span class="line"> </span><br><span class="line">book_obj&#x3D;Book.objects.filter(title&#x3D;&quot;眉&quot;).first()</span><br><span class="line">authors&#x3D;book_obj.authors.all()</span><br><span class="line">for author_obj in authors:</span><br><span class="line">     print(author_obj.name,author_obj.authorDetail.telephone)</span><br></pre></td></tr></table></figure>

<p>反向查询(按表名：book_set)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查询egon出过的所有书籍的名字</span><br><span class="line">  author_obj&#x3D;Author.objects.get(name&#x3D;&quot;egon&quot;)</span><br><span class="line">  book_list&#x3D;author_obj.book_set.all()        #与egon作者相关的所有书籍</span><br><span class="line">  for book_obj in book_list:</span><br><span class="line">    print(book_obj.title)</span><br></pre></td></tr></table></figure>

<h4 id="多表操作（基于双下划线的跨表查询）"><a href="#多表操作（基于双下划线的跨表查询）" class="headerlink" title="多表操作（基于双下划线的跨表查询）"></a>多表操作（基于双下划线的跨表查询）</h4><p>跨表后 使用两个下划线来链接模型(model)间关联字段的名称</p>
<p>一对多查询<font color="red">(正向查询按字段，反向查询表名小写)</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 练习:  查询苹果出版社出版过的所有书籍的名字与价格(一对多)</span><br><span class="line"></span><br><span class="line"># 正向查询 按字段:publish</span><br><span class="line"></span><br><span class="line">queryResult&#x3D;Book.objects.filter(publish__name&#x3D;&quot;苹果出版社&quot;).values_list(&quot;title&quot;,&quot;price&quot;)</span><br><span class="line"></span><br><span class="line"># 反向查询 按表名:book</span><br><span class="line">queryResult&#x3D;Publish.objects.filter(name&#x3D;&quot;苹果出版社&quot;).values_list(&quot;book__title&quot;,&quot;book__price&quot;)</span><br><span class="line">查询的本质一样，就是select from的表不一样</span><br></pre></td></tr></table></figure>

<p>多对多查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 练习: 查询lqz出过的所有书籍的名字(多对多)</span><br><span class="line"></span><br><span class="line"># 正向查询 按字段:authors:</span><br><span class="line">queryResult&#x3D;Book.objects.filter(authors__name&#x3D;&quot;lqz&quot;).values_list(&quot;title&quot;)</span><br><span class="line"></span><br><span class="line"># 反向查询 按表名:book</span><br><span class="line">queryResult&#x3D;Author.objects.filter(name&#x3D;&quot;lqz&quot;).values_list(&quot;book__title&quot;,&quot;book__price&quot;)</span><br></pre></td></tr></table></figure>

<p>一对一查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查询alex的手机号</span><br><span class="line"></span><br><span class="line"># 正向查询</span><br><span class="line">ret&#x3D;Author.objects.filter(name&#x3D;&quot;lqz&quot;).values(&quot;authordetail__telephone&quot;)</span><br><span class="line"></span><br><span class="line"># 反向查询</span><br><span class="line">ret&#x3D;AuthorDetail.objects.filter(author__name&#x3D;&quot;lqz&quot;).values(&quot;telephone&quot;)</span><br></pre></td></tr></table></figure>

<h5 id="related-name"><a href="#related-name" class="headerlink" title="related_name"></a>related_name</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">publish = ForeignKey(Blog, related_name=<span class="string">&#x27;bookList&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 练习: 查询人民出版社出版过的所有书籍的名字与价格(一对多)</span></span><br><span class="line"><span class="comment"># 反向查询 不再按表名:book,而是related_name:bookList</span></span><br><span class="line">queryResult=Publish.objects.filter(name=<span class="string">&quot;人民出版社&quot;</span>).values_list(<span class="string">&quot;bookList__title&quot;</span>,<span class="string">&quot;bookList__price&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="聚合查询aggregate"><a href="#聚合查询aggregate" class="headerlink" title="聚合查询aggregate"></a>聚合查询aggregate</h4><p><code>aggregate</code>(*args, **kwargs)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Book.objects.aggregate(average_price=Avg(<span class="string">&#x27;price&#x27;</span>))</span><br><span class="line"><span class="comment">#&#123;&#x27;average_price&#x27;: 34.35&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Avg, Max, Min</span><br><span class="line">Book.objects.aggregate(Avg(<span class="string">&#x27;price&#x27;</span>), Max(<span class="string">&#x27;price&#x27;</span>), Min(<span class="string">&#x27;price&#x27;</span>))</span><br><span class="line"><span class="comment">#&#123;&#x27;price__avg&#x27;: 34.35, &#x27;price__max&#x27;: Decimal(&#x27;81.20&#x27;), &#x27;price__min&#x27;: Decimal(&#x27;12.99&#x27;)&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="分组查询annotate"><a href="#分组查询annotate" class="headerlink" title="分组查询annotate"></a>分组查询annotate</h4><p>理解：<strong>values(按什么分组) . annotate(聚合函数统计什么东西) . values（显示字段）</strong> </p>
<p>​         <strong>values(按什么分组) . annotate(聚合函数统计什么东西) .filter(相当于用having判断聚合).values（显示字段）</strong> </p>
<p>最后要用values 或者 values_list ；原因是annotate返回值是queryset，想要某些字段还需要遍历</p>
<p>annotate()为调用的<code>QuerySet</code>中每一个对象都生成一个独立的统计值（统计方法用聚合函数）。</p>
<p>总结 ：跨表(双下划线)分组查询本质就是将关联表join成一张表，再按单表的思路进行分组查询。　</p>
<p>练习：统计每一本书作者个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from django.db.models import Avg, Max, Sum, Min, Max, Count</span><br><span class="line">book_list &#x3D; models.Book.objects.all().annotate(author_num&#x3D;Count(&quot;authors&quot;))</span><br><span class="line">for book in book_list:</span><br><span class="line">     print(book.name)</span><br><span class="line">     print(book.author_num)</span><br><span class="line">book_list &#x3D; models.Book.objects.all().annotate(author_num&#x3D;Count(&quot;authors&quot;)).values(&#39;name&#39;,&#39;author_num&#39;)</span><br><span class="line">print(book_list)</span><br></pre></td></tr></table></figure>

<p>练习：统计每一个出版社的最便宜的书</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">publishList&#x3D;Publish.objects.annotate(MinPrice&#x3D;Min(&quot;book__price&quot;))</span><br><span class="line">for publish_obj in publishList:</span><br><span class="line">    print(publish_obj.name,publish_obj.MinPrice)</span><br></pre></td></tr></table></figure>

<p>annotate的返回值是querySet，如果不想遍历对象，可以用上valuelist：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queryResult&#x3D; Publish.objects.annotate(MinPrice&#x3D;Min(&quot;book__price&quot;)).values_list(&quot;name&quot;,&quot;MinPrice&quot;)</span><br><span class="line">print(queryResult)</span><br></pre></td></tr></table></figure>

<p>练习：统计每一本以py开头的书籍的作者个数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queryResult&#x3D;Book.objects.filter(title__startswith&#x3D;&quot;Py&quot;).annotate(num_authors&#x3D;Count(&#39;authors&#39;))</span><br></pre></td></tr></table></figure>

<p>练习：统计不止一个作者的图书：（作者数量大于一）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret&#x3D;models.Book.objects.annotate(author_num&#x3D;Count(&quot;authors&quot;)).filter(author_num__gt&#x3D;1).values(&#39;name&#39;,&#39;author_num&#39;)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<p>练习：根据一本图书作者数量的多少对查询集 <code>QuerySet</code>进行排序:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Book.objects.annotate(num_authors&#x3D;Count(&#39;authors&#39;)).order_by(&#39;num_authors&#39;)</span><br></pre></td></tr></table></figure>

<p>练习：查询各个作者出的书的总价格:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret&#x3D;models.Author.objects.annotate(sum_price&#x3D;Sum(&quot;book__price&quot;)).values(&quot;name&quot;, &quot;sum_price&quot;)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<p>练习：查询每个出版社的名称和书籍个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret&#x3D;models.Publish.objects.all().annotate(c&#x3D;Count(&#39;book__name&#39;)).values(&#39;name&#39;,&#39;c&#39;)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<h5 id="F查询"><a href="#F查询" class="headerlink" title="F查询"></a>F查询</h5><p>两个字段的值做比较</p>
<p>最字段值进行统一操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 查询评论数大于收藏数的书籍</span><br><span class="line">from django.db.models import F</span><br><span class="line">Book.objects.filter(commnetNum__lt&#x3D;F(&#39;keepNum&#39;))</span><br><span class="line">Django 支持 F() 对象之间以及 F() 对象和常数之间的加减乘除和取模的操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 查询评论数大于收藏数2倍的书籍</span><br><span class="line">Book.objects.filter(commnetNum__lt&#x3D;F(&#39;keepNum&#39;)*2)</span><br><span class="line">修改操作也可以使用F函数,比如将每一本书的价格提高30元：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Book.objects.all().update(price&#x3D;F(&quot;price&quot;)+30)</span><br></pre></td></tr></table></figure>

<h5 id="Q查询"><a href="#Q查询" class="headerlink" title="Q查询"></a>Q查询</h5><p><code>filter()</code> 等方法中的关键字参数查询都是一起进行“AND” 的。 如果你需要执行更复杂的查询（例如<code>OR</code> 语句），你可以使用<code>Q 对象</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from django.db.models import Q</span><br><span class="line">Q(title__startswith&#x3D;&#39;Py&#39;)</span><br></pre></td></tr></table></figure>

<p><code>Q</code> 对象可以使用<code>&amp;</code> 和<code>|</code> 操作符组合起来。当一个操作符在两个<code>Q</code> 对象上使用时，它产生一个新的<code>Q</code> 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bookList&#x3D;Book.objects.filter(Q(authors__name&#x3D;&quot;lqz&quot;)|Q(authors__name&#x3D;&quot;egon&quot;))</span><br></pre></td></tr></table></figure>

<p>等同于下面的SQL <code>WHERE</code> 子句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE name &#x3D;&quot;lqz&quot; OR name &#x3D;&quot;egon&quot;</span><br></pre></td></tr></table></figure>

<h4 id="defer和only"><a href="#defer和only" class="headerlink" title="defer和only"></a>defer和only</h4><p>defer(‘id’,’name’):取出对象，字段除了id和name都有<br>only(‘id’,’name’):取的对象，只有id和name<br>如果点，依然能点出其它列，但是不要点了，因为取没有的列，会再次查询数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ret&#x3D;models.Author.objects.only(&#39;nid&#39;)</span><br><span class="line">for i in ret:</span><br><span class="line">    # 查询不在的字段，会再次查询数据库，造成数据库压力大</span><br><span class="line">    print(i.name)</span><br></pre></td></tr></table></figure>

<h4 id="select-related和prefetch-related"><a href="#select-related和prefetch-related" class="headerlink" title="select_related和prefetch_related"></a>select_related和prefetch_related</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select_related是inner join联表操作，prefetch_related是子查询</span><br><span class="line"><span class="comment"># select_related内部直接先将book表和publish表连起来，然后一次性将大表里面的所有数据全部封装给查询出来的对象</span></span><br><span class="line"></span><br><span class="line">需要看具体情况，看起来比select_related多执行了几句sql语句，但是因为联表操作也有可能很耗时，子查询反而更快。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="defer和only-1"><a href="#defer和only-1" class="headerlink" title="defer和only"></a>defer和only</h4><h4 id="27-中间件"><a href="#27-中间件" class="headerlink" title="27.中间件"></a>27.中间件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">**process_request**：</span><br><span class="line">1、请求来的时候需要经过每一个中间件里面的process_request方法，经过的顺序是按照配置文件中注册的中间件从上往下的顺序一次执行</span><br><span class="line">2、如果中间件里面没有定义，则直接跳过执行下一个</span><br><span class="line">3、如果该方法返回了HTTPResponse对象，那么请求将不再继续往后执行，而是原路返回(类似于校验失败不允许访问)</span><br><span class="line">process_request方法就是用来做全局相关的所有限制功能。</span><br><span class="line"></span><br><span class="line">**process_response***：</span><br><span class="line">1、响应走的时候需要经过每一个中间件里面的process_response方法，该方法有两个额外的参数：request,response</span><br><span class="line">2、该方法必须返回一个HTTPResponse对象(替换浏览器原有的HttpResponse对象)，默认返回的就是形参response</span><br><span class="line">3、顺序按照配置文件中注册了的中间件从下往上依次经过，若没有定义，则跳过;有定义，继续执行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**process_view**：</span><br><span class="line">路由匹配成功之后，执行视图函数之前，会自动执行中间件里面的该方法。</span><br><span class="line">顺序是按照配置文件中注册中间件从上往下的顺序依次执行。</span><br><span class="line"></span><br><span class="line">**process_template_response**:</span><br><span class="line">返回的HttpResponse对象有render属性的时候才会触发。顺序是按照从下往上依次经过。</span><br><span class="line"></span><br><span class="line">**process_exception**：</span><br><span class="line">当视图函数中出现异常情况会触发。</span><br></pre></td></tr></table></figure>

<ul>
<li>csrf</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># form表单</span></span><br><span class="line">&#123;% csrf_token %&#125;</span><br><span class="line"><span class="comment"># ajax</span></span><br><span class="line">data: &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;csrfmiddlewaretoken&#x27;</span>:<span class="string">&#x27;&#123;&#123; csrf_token &#125;&#125;&#x27;</span>&#125;,</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_protect,csrf_exempt</span><br><span class="line"><span class="comment"># FBV: 正常装饰器</span></span><br><span class="line"><span class="meta">@csrf_protect  #需要校验 </span></span><br><span class="line"><span class="meta">@csrf_exempt   #忽略校验</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CBV：三种方式 </span></span><br><span class="line">csrf_protect支持装饰器的三种玩法；</span><br><span class="line">csrf_exempt只能给dispatch方法加才有效果</span><br><span class="line"></span><br><span class="line"><span class="comment">#装饰器方式2,可以针对不同的方法添加不同的装饰器，扩展性强：</span></span><br><span class="line"><span class="comment"># @method_decorator(csrf_protect, name=&#x27;post&#x27;)</span></span><br><span class="line"><span class="comment"># @method_decorator(csrf_exempt, name=&#x27;post&#x27;) # csrf_exempt不行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCsrfToken</span>(<span class="params">View</span>):</span></span><br><span class="line">    <span class="comment"># 装饰器方式3</span></span><br><span class="line">    <span class="comment"># @method_decorator(csrf_protect) # csrf_protect 无影响</span></span><br><span class="line">    <span class="comment"># @method_decorator(csrf_exempt)  # csrf_exempt 无影响</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">return</span> super(MyCsrfToken, self).dispatch(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 装饰器方式1：</span></span><br><span class="line">    <span class="comment"># @method_decorator(csrf_protect)</span></span><br><span class="line"><span class="meta">    @method_decorator(csrf_exempt) # csrf_exempt 不行</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;post&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="28-forms组件"><a href="#28-forms组件" class="headerlink" title="28.forms组件"></a>28.forms组件</h4><p>核心功能: <strong>后端校验字段</strong>；然后可以自己渲染前端标签+错误信息。</p>
<p>前后端分离也可以使用，<strong>前端传过来一个字典，直接可以用。</strong></p>
<p>步骤：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>写一个类，继承Form</span><br><span class="line"><span class="number">2.</span>在类中写字段</span><br><span class="line">+局部钩子（单个字段二次校验）<span class="comment"># def clean_字段</span></span><br><span class="line">当你需要给单个字段增加校验规则的时候可以使用，在后端校验的基础上进行二次校验。</span><br><span class="line">+全局钩子（多个字段二次校验）<span class="comment"># def clean</span></span><br><span class="line">当你需要给多个字段增加校验规则的时候可以使用。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>在视图函数中使用 form=UserForm(校验的字典)</span><br><span class="line"><span class="number">4.</span>form.is_valid() 通过了，就可以起来，不通过，form.errors会有错误信息</span><br><span class="line"><span class="number">5.</span>局部钩子+全局钩子</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserForm</span>(<span class="params">forms.Form</span>):</span></span><br><span class="line">    <span class="comment"># username,password这两个字段最少3位数，最大8位数</span></span><br><span class="line">    username = forms.CharField(min_length=<span class="number">3</span>,max_length=<span class="number">8</span>)</span><br><span class="line">    password = forms.CharField(min_length=<span class="number">3</span>,max_length=<span class="number">8</span>)</span><br><span class="line">    <span class="comment"># email字段必须符合邮箱格式，xx@xx.com</span></span><br><span class="line">    email = forms.EmailField()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 先生成对象，get请求时</span></span><br><span class="line">    form_obj = MyForm()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        <span class="comment"># 获取数据</span></span><br><span class="line">        print(request.POST)</span><br><span class="line">        <span class="comment"># 校验用户数据</span></span><br><span class="line">        form_obj = MyForm(request.POST)</span><br><span class="line">        <span class="keyword">if</span> form_obj.is_valid():</span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;login.html&#x27;</span>, locals())</span><br><span class="line">    <span class="comment"># 局部钩子</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean_username</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 获取用户名</span></span><br><span class="line">        username = self.cleaned_data.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;666&#x27;</span> <span class="keyword">in</span> username:</span><br><span class="line">            <span class="comment"># 提示前端展示错误信息</span></span><br><span class="line">            <span class="comment"># 提示方式1：</span></span><br><span class="line">            self.add_error(<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;用户名不能包含666&#x27;</span>)</span><br><span class="line">            <span class="comment"># 提示方式2(繁琐，一般不用)：</span></span><br><span class="line">            <span class="comment"># raise ValidationError(&#x27;用户名不能包含666.&#x27;)</span></span><br><span class="line">        <span class="comment"># 将钩子函数钩取出来的数据再放回去</span></span><br><span class="line">        <span class="keyword">return</span> username</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 全局钩子</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 获取两个密码字段</span></span><br><span class="line">        password = self.cleaned_data.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        confirm_password = self.cleaned_data.get(<span class="string">&#x27;confirm_password&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> confirm_password == password:</span><br><span class="line">            self.add_error(<span class="string">&#x27;confirm_password&#x27;</span>,<span class="string">&#x27;两次密码不一致&#x27;</span>)</span><br><span class="line">        <span class="comment"># 校验后将全局钩子钩出来的数据再放回去</span></span><br><span class="line">        <span class="keyword">return</span> self.cleaned_data</span><br></pre></td></tr></table></figure>

<ul>
<li>forms组件源码</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">form.is_valid() 去校验数据的时候，内部起了一个for循环，先去校验每个字段的规则，校验完成之后--&gt;再去校验局部钩子函数，一个一个执行完成(校验完)--&gt;全局钩子(clean()) ---&gt; self就会有clean_data和errors</span><br><span class="line">注意：钩子函数必须把校验完成后的数据返回</span><br><span class="line"><span class="keyword">if</span> hasattr(self, <span class="string">&#x27;clean_%s&#x27;</span> % name): <span class="comment"># 利用反射获取局部钩子函数</span></span><br><span class="line">                    value = getattr(self, <span class="string">&#x27;clean_%s&#x27;</span> % name)() <span class="comment"># 局部钩子需要有返回值</span></span><br><span class="line">                    self.cleaned_data[name] = value <span class="comment"># 返回给这里</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="29-auth组件"><a href="#29-auth组件" class="headerlink" title="29.auth组件"></a>29.auth组件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> auth</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、验证用户名密码是否正确：</span><br><span class="line">userobj = auth.authenticate(request,username=username,password=password)</span><br><span class="line"><span class="number">2</span>、保存用户状态：</span><br><span class="line">auth.login(request,userobj)</span><br><span class="line"><span class="number">3</span>、判断当前用户是否登录：</span><br><span class="line">request.user.is_authenticated()</span><br><span class="line"><span class="number">4</span>、获取当前登录用户：</span><br><span class="line">request.user</span><br><span class="line"><span class="number">5</span>、校验用户是否登录的装饰器(局部配置和全局配置)</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.decorators <span class="keyword">import</span> login_required</span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="number">6</span>、校验密码</span><br><span class="line">request.user.check_password(old_password)</span><br><span class="line"><span class="number">7</span>、修改密码</span><br><span class="line">request.user.set_password(new_password)</span><br><span class="line">request.user.save()</span><br></pre></td></tr></table></figure>

<ul>
<li>继承AbstractUser</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">settings配置文件中指定</span><br><span class="line">AUTH_USER_MODEL = <span class="string">&#x27;app01.Userinfo&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User,AbstractUser </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span>(<span class="params">AbstractUser</span>):</span></span><br></pre></td></tr></table></figure>

<p>30.DRF规范口述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.尽量采用https协议</span><br><span class="line">2.接口命名特征表现  https:&#x2F;&#x2F;api.baidu.com</span><br><span class="line">3.多版本共存 v1 v2</span><br><span class="line">4.数据即资源  用名词 books</span><br><span class="line">5.资源操作由请求方式决定  get post patch put delete</span><br><span class="line">6.url上传参的形式传递搜索条件</span><br><span class="line">  https:&#x2F;&#x2F;api.example.com&#x2F;v1&#x2F;zoos?page&#x3D;2&amp;per_page&#x3D;100：指定第几页，以及每页的记录数</span><br><span class="line">7.状态码</span><br><span class="line">8.错误信息</span><br><span class="line">9.返回结果要符合一定规范</span><br><span class="line">POST PUT PATCH 返回资源对象</span><br><span class="line">DELETE 返回空文档</span><br><span class="line">10.需要url请求的资源需要访问资源的请求链接；即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么</span><br></pre></td></tr></table></figure>

<p>31.DRF 视图继承关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">涉及到数据库操作的尽量用GenericAPIView</span><br></pre></td></tr></table></figure>



<p>32.接口幂等性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx</span><br></pre></td></tr></table></figure>



<p>33.解释python鸭子类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">python推崇鸭子类型</span><br><span class="line">优点:方便 ，也可以不继承父类 ，实现相同方法</span><br><span class="line">缺点:多人混合写代码时，容易出问题</span><br><span class="line"></span><br><span class="line">场景: 调一些内部的方法传参数时，传什么参数，类型都不知道，动态语言的弱点。  改进，后面加冒号，规定了参数类型。 </span><br><span class="line">            def auth(user:str) --&gt; int 返回值类型</span><br><span class="line">     编译型语言: 传几个参数，类型都知道。</span><br><span class="line"></span><br><span class="line">可以不继承，有和父类相同的方法，就可以不继承。其他语言必须继承。</span><br><span class="line"></span><br><span class="line">1.人为规范， 学 click speak方法</span><br><span class="line">2.也有强制约束  abc模块 </span><br><span class="line">3.或者父类raise抛异常  ---&gt; 规范子类</span><br></pre></td></tr></table></figure>

<p>34.<code>__new__</code> 和<code>__init__</code> 区别和关系</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__new__ 空对象</span><br><span class="line">__init__ 构造对象</span><br></pre></td></tr></table></figure>



<p>35.assert断言的意思</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">判断接下来的条件是否正常执行，正常，则向下</span><br><span class="line">不正常，报错。</span><br></pre></td></tr></table></figure>

<p>36.http请求头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">背几个常用的请求头</span><br><span class="line">如：</span><br><span class="line">X-ForWarded-For</span><br></pre></td></tr></table></figure>

<p>37.Xss cors csrf</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xss: 跨站脚本攻击(执行js)</span><br><span class="line">csrf: 跨站请求伪造(模拟钓鱼)</span><br><span class="line">cors: 跨域资源共享</span><br><span class="line">  </span><br><span class="line"><span class="number">1.</span>同源策略: 请求的url地址, 必须与浏览器上的url地址处于同域上, 也就是域名, 端口, 协议相同.</span><br><span class="line"><span class="number">2.</span>CORS: 跨域资源共享, 允许不同的域</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/waylon1006/blog_pic/raw/master/pic/image-20210711044059299.png" alt="image-20210711044059299" style="zoom:50%;">



<p>38.架构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MTV</span><br><span class="line">MVVM model view view-model 数据双向绑定 组件化开发 单页面开发</span><br><span class="line">MVC</span><br><span class="line">MVP  Android</span><br></pre></td></tr></table></figure>

<p>39.git 合并分支和扁平化分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">合并分支 :  </span><br><span class="line">扁平化分之合: 变基rebase, 把多个更改合并成一个(master分支线络看起来更清晰)</span><br></pre></td></tr></table></figure>

<p>40.wsgi协议协议干了什么</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wsgi协议规定: 后面是可调用对象（django flask）, 调用这个对象的时候，传两个参数，一个是environ，一个是start_response</span><br><span class="line">environ: 当次的http请求 拆成了字典environ  ---&gt; django 封装了request</span><br><span class="line">start_response: 响应对象   ----&gt;  响应的时候封装了response对象</span><br><span class="line"></span><br><span class="line">django的并发 和web服务器有关  (wsgi)</span><br><span class="line">uwsgi 配置几个线程 几个进程 （<span class="number">4</span>进程 x <span class="number">4</span>线程 = <span class="number">16</span>） <span class="number">16</span>个人干活，但是可以支持并发<span class="number">100</span>个并发，但是实际干活<span class="number">16</span>个人。</span><br><span class="line"></span><br><span class="line"><span class="comment">## 同一个进程下的线程 数据是共享的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上线后: USWGI+Gevent 进程+线程+协程</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/waylon1006/blog_pic/raw/master/pic/image-20210721165618801.png" alt="image-20210721165618801"></p>
<p>41.异步框架</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sanic</span><br><span class="line">fastapi</span><br><span class="line">tornado</span><br><span class="line"></span><br><span class="line">django <span class="number">3.</span>x之前，都是同步框架，</span><br><span class="line">django <span class="number">3.</span>x之后，<span class="number">3.</span>x异步(半残)</span><br><span class="line">   原因是: ORM 是同步框架  , 遇到IO操作 就阻塞在那了</span><br><span class="line">     aiomysql  aioredis  开始是异步, 后面就都用异步。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步就是释放GIL锁，异步就是不释放GIL锁</span></span><br><span class="line">异步的框架就是IO操作没有释放GIL锁</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用异步的关键是  在web服务器上</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 出了新的协议标准 ASGI 异步的协议网关接口</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/waylon1006/blog_pic/raw/master/pic/image-20210721172047037.png" alt="image-20210721172047037"></p>
<p>42.双写一致性问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1 如果mysql数据变化了，轮播图表数据变化了，由于缓存没有更新，就会出现问题</span><br><span class="line">2     -redis+mysql：双写一致性</span><br><span class="line">    -(1) 定期更新或者过期时间（取决于接口）,对数据准确性要求不是特别高的接口</span><br><span class="line">  -(2) 修改了MySQL, 修改缓存</span><br><span class="line">        先改缓存，再改数据库 (很少这样操作，成本比较高。 找缓存，就比较麻烦)</span><br><span class="line">        先改数据库，再改缓存(比较多)</span><br><span class="line">  -(3) 修改了MySQL，删除缓存</span><br><span class="line">       - 先删除缓存，再更新数据库</span><br><span class="line">       - 先更新数据库，再删除缓存（稍微好一些）</span><br><span class="line"></span><br><span class="line">3 首页轮播图接口：缓存更新策略是定时更新</span><br><span class="line">    -celery的定时任务</span><br><span class="line">    -使用celery的定时任务，完成首页轮播图缓存的更新</span><br></pre></td></tr></table></figure>



<h4 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">安全：端口扫描 弱口令扫描 SQL注入 csrf攻击 xss攻击（利用python成为顶级黑客）</span><br><span class="line">网络</span><br><span class="line">物联网：socket用的较多</span><br><span class="line">自动化运维</span><br></pre></td></tr></table></figure>

<p>搜狗面试题：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qiaojushuang/p/7912874.html">https://www.cnblogs.com/qiaojushuang/p/7912874.html</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/review/" rel="tag"><i class="fas fa-cookie-bite"></i> review</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/13/py-day06/" rel="prev" title="py-day06">
      <i class="fa fa-chevron-left"></i> py-day06
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/19/py-day07/" rel="next" title="py-day07">
      py-day07 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A"><span class="nav-number">1.</span> <span class="nav-text">1.TCP三次握手四次挥手面试题：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%A4%A7%E9%87%8F%E7%9A%84timewait%EF%BC%8Ctimewait%E8%BF%87%E9%AB%98%E4%BC%9A%E5%8D%A0%E7%94%A8%E5%A4%A7%E9%87%8F%E5%86%85%E5%AD%98%E5%92%8Ccpu%E4%BD%BF%E7%94%A8%E7%8E%87"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 高并发的情况下会存在大量的timewait，timewait过高会占用大量内存和cpu使用率</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-%E5%A6%82%E6%9E%9C%E6%9C%BA%E5%99%A8%E4%B8%8A%E5%AD%98%E5%9C%A8%E5%A4%A7%E9%87%8FSYN-RCVD%E7%8A%B6%E6%80%81%EF%BC%8C%E8%AF%81%E6%98%8E%E9%81%AD%E9%81%87%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 如果机器上存在大量SYN_RCVD状态，证明遭遇泛洪攻击</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">2. 粘包问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-mac%E5%9C%B0%E5%9D%80%E5%A4%9A%E5%B0%91%E4%BD%8D%E8%A1%A8%E7%A4%BA"><span class="nav-number">3.</span> <span class="nav-text">3.mac地址多少位表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-OSI%E6%AF%8F%E4%B8%80%E5%B1%82%E5%8A%9F%E8%83%BD"><span class="nav-number">4.</span> <span class="nav-text">4.OSI每一层功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="nav-number">5.</span> <span class="nav-text">5. 常用端口号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%80%E5%90%8E%E8%BF%98%E8%A6%81%E7%AD%89%E5%BE%852MSL%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">6. 为什么客户端最后还要等待2MSL？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-IO%E6%A8%A1%E5%9E%8B%EF%BC%88%E9%9D%A2%E8%AF%95%EF%BC%89"><span class="nav-number">7.</span> <span class="nav-text">7. IO模型（面试）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E7%8C%B4%E5%AD%90%E8%A1%A5%E4%B8%81"><span class="nav-number">8.</span> <span class="nav-text">8. 猴子补丁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-MySQL%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="nav-number">9.</span> <span class="nav-text">9. MySQL相关问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-%E4%B9%90%E8%A7%82%E9%94%81%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">10.</span> <span class="nav-text">10. 乐观锁悲观锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-http%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%8C%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="nav-number">11.</span> <span class="nav-text">11. http协议工作原理，数据格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-WSGI-wsgiref-uwsgi%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">12.WSGI wsgiref uwsgi是什么关系？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-session"><span class="nav-number">13.</span> <span class="nav-text">13.session</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-orm%E8%AE%BE%E8%AE%A1%E5%AD%97%E6%AE%B5%E4%BC%98%E5%8C%96"><span class="nav-number">14.</span> <span class="nav-text">14.orm设计字段优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-%E6%A1%86%E6%9E%B6"><span class="nav-number">15.</span> <span class="nav-text">15.框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-%E8%A7%A3%E9%87%8A%E5%9E%8B%E7%BC%96%E8%AF%91%E5%9E%8B-%E5%BC%BA%E5%BC%B1%E7%B1%BB%E5%9E%8B"><span class="nav-number">16.</span> <span class="nav-text">15.解释型编译型,强弱类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">17.</span> <span class="nav-text">16. 数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-%E5%8F%AF%E5%8F%98%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="nav-number">18.</span> <span class="nav-text">17.可变不可变</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-1-python%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="nav-number">19.</span> <span class="nav-text">17.1 python中的参数传递是值传递还是引用传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3python%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1"><span class="nav-number">20.</span> <span class="nav-text">17. 如何理解python一切皆对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">21.</span> <span class="nav-text">17. 深浅拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="nav-number">22.</span> <span class="nav-text">18. 字符编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0"><span class="nav-number">23.</span> <span class="nav-text">19. 闭包函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-Django%E7%9B%B8%E5%85%B3"><span class="nav-number">24.</span> <span class="nav-text">20.Django相关</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#20-1-APPEND-SLASH%E9%97%AE%E9%A2%98%EF%BC%88%E5%AE%9E%E9%99%85%E4%B8%BA%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8E%A7%E5%88%B6%EF%BC%89"><span class="nav-number">24.1.</span> <span class="nav-text">20.1 APPEND SLASH问题（实际为中间件控制）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#20-2-form%E8%A1%A8%E5%8D%95%E5%92%8Cajax%E6%8F%90%E4%BA%A4%E7%9A%84%E9%87%8D%E5%A4%8D"><span class="nav-number">24.2.</span> <span class="nav-text">20.2 form表单和ajax提交的重复</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#20-3-QueryDict-%E9%97%AE%E9%A2%98"><span class="nav-number">24.3.</span> <span class="nav-text">20.3 QueryDict 问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#20-4-%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%BB%83%E4%B9%A0%EF%BC%8C%E5%A4%84%E7%90%86form%E8%A1%A8%E5%8D%95%E5%92%8CAJax%E5%8F%91%E8%BF%87%E6%9D%A5%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">24.4.</span> <span class="nav-text">20.4 中间件练习，处理form表单和AJax发过来的数据</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-Python%E4%B8%AD%E7%9A%84%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95"><span class="nav-number">25.</span> <span class="nav-text">21. Python中的魔法方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-cookie%EF%BC%8Csession%EF%BC%8Ctoken"><span class="nav-number">26.</span> <span class="nav-text">22.cookie，session，token</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-Django%E4%B8%ADsession%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">27.</span> <span class="nav-text">23.Django中session底层原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">28.</span> <span class="nav-text">24.异常处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-pymysql%E4%BD%BF%E7%94%A8"><span class="nav-number">29.</span> <span class="nav-text">25.pymysql使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E8%A1%A8%E6%93%8D%E4%BD%9C"><span class="nav-number">30.</span> <span class="nav-text">单表操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A2%9E"><span class="nav-number">30.1.</span> <span class="nav-text">增</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5-%E9%99%A4%E4%BA%86count%E5%A4%96%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E9%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9E%8B%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">30.2.</span> <span class="nav-text">查(除了count外的返回值都是一个模型类的对象)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0delete"><span class="nav-number">30.3.</span> <span class="nav-text">删delete()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0update"><span class="nav-number">30.4.</span> <span class="nav-text">更新update</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C%EF%BC%88%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B7%A8%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%89"><span class="nav-number">31.</span> <span class="nav-text">多表操作（基于对象的跨表查询）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A2%9E-1"><span class="nav-number">31.1.</span> <span class="nav-text">增</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%EF%BC%88%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E8%B7%A8%E8%A1%A8%EF%BC%89"><span class="nav-number">31.2.</span> <span class="nav-text">查询（基于对象跨表）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%80%E5%AF%B9%E5%A4%9A%E6%9F%A5%E8%AF%A2-%E6%AD%A3%E5%90%91%E6%9F%A5%E8%AF%A2%E6%8C%89%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%8F%8D%E5%90%91%E6%9F%A5%E8%AF%A2%E6%8C%89%E8%A1%A8%E5%90%8D%E5%B0%8F%E5%86%99-set-%E5%A4%9A%E4%B8%AA%E5%80%BC%E5%B0%B1%E5%8A%A0all"><span class="nav-number">31.2.1.</span> <span class="nav-text">一对多查询 (正向查询按字段，反向查询按表名小写+_set,多个值就加all)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80%E6%9F%A5%E8%AF%A2-%E6%AD%A3%E5%90%91%E6%9F%A5%E8%AF%A2%E6%8C%89%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%8F%8D%E5%90%91%E6%9F%A5%E8%AF%A2%E8%A1%A8%E5%90%8D%E5%B0%8F%E5%86%99"><span class="nav-number">31.2.2.</span> <span class="nav-text">一对一查询(正向查询按字段，反向查询表名小写)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%9F%A5%E8%AF%A2-%E6%AD%A3%E5%90%91%E6%9F%A5%E8%AF%A2%E6%8C%89%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%8F%8D%E5%90%91%E6%9F%A5%E8%AF%A2%E6%8C%89%E8%A1%A8%E5%90%8D%E5%B0%8F%E5%86%99-set-%E5%A4%9A%E4%B8%AA%E5%80%BC%E5%B0%B1%E5%8A%A0all"><span class="nav-number">31.2.3.</span> <span class="nav-text">多对多查询 (正向查询按字段，反向查询按表名小写+_set,多个值就加all)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C%EF%BC%88%E5%9F%BA%E4%BA%8E%E5%8F%8C%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%84%E8%B7%A8%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%89"><span class="nav-number">32.</span> <span class="nav-text">多表操作（基于双下划线的跨表查询）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#related-name"><span class="nav-number">32.1.</span> <span class="nav-text">related_name</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2aggregate"><span class="nav-number">33.</span> <span class="nav-text">聚合查询aggregate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2annotate"><span class="nav-number">34.</span> <span class="nav-text">分组查询annotate</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#F%E6%9F%A5%E8%AF%A2"><span class="nav-number">34.1.</span> <span class="nav-text">F查询</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Q%E6%9F%A5%E8%AF%A2"><span class="nav-number">34.2.</span> <span class="nav-text">Q查询</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#defer%E5%92%8Conly"><span class="nav-number">35.</span> <span class="nav-text">defer和only</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#select-related%E5%92%8Cprefetch-related"><span class="nav-number">36.</span> <span class="nav-text">select_related和prefetch_related</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#defer%E5%92%8Conly-1"><span class="nav-number">37.</span> <span class="nav-text">defer和only</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#27-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">38.</span> <span class="nav-text">27.中间件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#28-forms%E7%BB%84%E4%BB%B6"><span class="nav-number">39.</span> <span class="nav-text">28.forms组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#29-auth%E7%BB%84%E4%BB%B6"><span class="nav-number">40.</span> <span class="nav-text">29.auth组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%EF%BC%9A"><span class="nav-number">41.</span> <span class="nav-text">其他：</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Waylon Yan"
      src="/images/timg.jpeg">
  <p class="site-author-name" itemprop="name">Waylon Yan</p>
  <div class="site-description" itemprop="description">tech life sharing</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Waylonwhynot" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Waylonwhynot" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ywl1006@outlook.com" title="E-Mail → mailto:ywl1006@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Waylon Yan</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.6m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">45:29</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div> -->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
